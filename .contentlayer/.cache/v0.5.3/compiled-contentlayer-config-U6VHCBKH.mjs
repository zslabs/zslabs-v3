var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a2, b2) => (typeof require !== "undefined" ? require : a2)[b2]
}) : x2)(function(x2) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x2 + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all4) => {
  for (var name in all4)
    __defProp(target, name, { get: all4[name], enumerable: true });
};
var __copyProps = (to2, from4, except, desc) => {
  if (from4 && typeof from4 === "object" || typeof from4 === "function") {
    for (let key of __getOwnPropNames(from4))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from4[key], enumerable: !(desc = __getOwnPropDesc(from4, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js
var _globalThis;
var init_globalThis = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js"() {
    _globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// node_modules/@opentelemetry/api/build/esm/platform/node/index.js
var init_node = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/node/index.js"() {
    init_globalThis();
  }
});

// node_modules/@opentelemetry/api/build/esm/platform/index.js
var init_platform = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/index.js"() {
    init_node();
  }
});

// node_modules/@opentelemetry/api/build/esm/version.js
var VERSION;
var init_version = __esm({
  "node_modules/@opentelemetry/api/build/esm/version.js"() {
    VERSION = "1.8.0";
  }
});

// node_modules/@opentelemetry/api/build/esm/internal/semver.js
function _makeCompatibilityCheck(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re2);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v2) {
    rejectedVersions.add(v2);
    return false;
  }
  function _accept(v2) {
    acceptedVersions.add(v2);
    return true;
  }
  return function isCompatible2(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re2);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var re2, isCompatible;
var init_semver = __esm({
  "node_modules/@opentelemetry/api/build/esm/internal/semver.js"() {
    init_version();
    re2 = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    isCompatible = _makeCompatibilityCheck(VERSION);
  }
});

// node_modules/@opentelemetry/api/build/esm/internal/global-utils.js
function registerGlobal(type, instance, diag3, allowOverride) {
  var _a12;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a12 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a12 !== void 0 ? _a12 : {
    version: VERSION
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag3.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
    diag3.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag3.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
  return true;
}
function getGlobal(type) {
  var _a12, _b5;
  var globalVersion = (_a12 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a12 === void 0 ? void 0 : _a12.version;
  if (!globalVersion || !isCompatible(globalVersion)) {
    return;
  }
  return (_b5 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b5 === void 0 ? void 0 : _b5[type];
}
function unregisterGlobal(type, diag3) {
  diag3.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
  if (api) {
    delete api[type];
  }
}
var major, GLOBAL_OPENTELEMETRY_API_KEY, _global;
var init_global_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/internal/global-utils.js"() {
    init_platform();
    init_version();
    init_semver();
    major = VERSION.split(".")[0];
    GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
    _global = _globalThis;
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js
function logProxy(funcName, namespace, args) {
  var logger = getGlobal("diag");
  if (!logger) {
    return;
  }
  args.unshift(namespace);
  return logger[funcName].apply(logger, __spreadArray([], __read(args), false));
}
var __read, __spreadArray, DiagComponentLogger;
var init_ComponentLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js"() {
    init_global_utils();
    __read = function(o2, n2) {
      var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
      if (!m2)
        return o2;
      var i2 = m2.call(o2), r2, ar = [], e2;
      try {
        while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
          ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"]))
            m2.call(i2);
        } finally {
          if (e2)
            throw e2.error;
        }
      }
      return ar;
    };
    __spreadArray = function(to2, from4, pack2) {
      if (pack2 || arguments.length === 2)
        for (var i2 = 0, l2 = from4.length, ar; i2 < l2; i2++) {
          if (ar || !(i2 in from4)) {
            if (!ar)
              ar = Array.prototype.slice.call(from4, 0, i2);
            ar[i2] = from4[i2];
          }
        }
      return to2.concat(ar || Array.prototype.slice.call(from4));
    };
    DiagComponentLogger = /** @class */
    function() {
      function DiagComponentLogger2(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      DiagComponentLogger2.prototype.debug = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("debug", this._namespace, args);
      };
      DiagComponentLogger2.prototype.error = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("error", this._namespace, args);
      };
      DiagComponentLogger2.prototype.info = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("info", this._namespace, args);
      };
      DiagComponentLogger2.prototype.warn = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("warn", this._namespace, args);
      };
      DiagComponentLogger2.prototype.verbose = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("verbose", this._namespace, args);
      };
      return DiagComponentLogger2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/types.js
var DiagLogLevel;
var init_types = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/types.js"() {
    (function(DiagLogLevel2) {
      DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
      DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
      DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
      DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
      DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
      DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
      DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
    })(DiagLogLevel || (DiagLogLevel = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js
function createLogLevelDiagLogger(maxLevel, logger) {
  if (maxLevel < DiagLogLevel.NONE) {
    maxLevel = DiagLogLevel.NONE;
  } else if (maxLevel > DiagLogLevel.ALL) {
    maxLevel = DiagLogLevel.ALL;
  }
  logger = logger || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel.ERROR),
    warn: _filterFunc("warn", DiagLogLevel.WARN),
    info: _filterFunc("info", DiagLogLevel.INFO),
    debug: _filterFunc("debug", DiagLogLevel.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
  };
}
var init_logLevelLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js"() {
    init_types();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/diag.js
var __read2, __spreadArray2, API_NAME, DiagAPI;
var init_diag = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/diag.js"() {
    init_ComponentLogger();
    init_logLevelLogger();
    init_types();
    init_global_utils();
    __read2 = function(o2, n2) {
      var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
      if (!m2)
        return o2;
      var i2 = m2.call(o2), r2, ar = [], e2;
      try {
        while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
          ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"]))
            m2.call(i2);
        } finally {
          if (e2)
            throw e2.error;
        }
      }
      return ar;
    };
    __spreadArray2 = function(to2, from4, pack2) {
      if (pack2 || arguments.length === 2)
        for (var i2 = 0, l2 = from4.length, ar; i2 < l2; i2++) {
          if (ar || !(i2 in from4)) {
            if (!ar)
              ar = Array.prototype.slice.call(from4, 0, i2);
            ar[i2] = from4[i2];
          }
        }
      return to2.concat(ar || Array.prototype.slice.call(from4));
    };
    API_NAME = "diag";
    DiagAPI = /** @class */
    function() {
      function DiagAPI2() {
        function _logProxy(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var logger = getGlobal("diag");
            if (!logger)
              return;
            return logger[funcName].apply(logger, __spreadArray2([], __read2(args), false));
          };
        }
        var self = this;
        var setLogger = function(logger, optionsOrLogLevel) {
          var _a12, _b5, _c4;
          if (optionsOrLogLevel === void 0) {
            optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
          }
          if (logger === self) {
            var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            self.error((_a12 = err.stack) !== null && _a12 !== void 0 ? _a12 : err.message);
            return false;
          }
          if (typeof optionsOrLogLevel === "number") {
            optionsOrLogLevel = {
              logLevel: optionsOrLogLevel
            };
          }
          var oldLogger = getGlobal("diag");
          var newLogger = createLogLevelDiagLogger((_b5 = optionsOrLogLevel.logLevel) !== null && _b5 !== void 0 ? _b5 : DiagLogLevel.INFO, logger);
          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
            var stack = (_c4 = new Error().stack) !== null && _c4 !== void 0 ? _c4 : "<failed to generate stacktrace>";
            oldLogger.warn("Current logger will be overwritten from " + stack);
            newLogger.warn("Current logger will overwrite one already registered from " + stack);
          }
          return registerGlobal("diag", newLogger, self, true);
        };
        self.setLogger = setLogger;
        self.disable = function() {
          unregisterGlobal(API_NAME, self);
        };
        self.createComponentLogger = function(options) {
          return new DiagComponentLogger(options);
        };
        self.verbose = _logProxy("verbose");
        self.debug = _logProxy("debug");
        self.info = _logProxy("info");
        self.warn = _logProxy("warn");
        self.error = _logProxy("error");
      }
      DiagAPI2.instance = function() {
        if (!this._instance) {
          this._instance = new DiagAPI2();
        }
        return this._instance;
      };
      return DiagAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js
var __read3, __values, BaggageImpl;
var init_baggage_impl = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js"() {
    __read3 = function(o2, n2) {
      var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
      if (!m2)
        return o2;
      var i2 = m2.call(o2), r2, ar = [], e2;
      try {
        while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
          ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"]))
            m2.call(i2);
        } finally {
          if (e2)
            throw e2.error;
        }
      }
      return ar;
    };
    __values = function(o2) {
      var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
      if (m2)
        return m2.call(o2);
      if (o2 && typeof o2.length === "number")
        return {
          next: function() {
            if (o2 && i2 >= o2.length)
              o2 = void 0;
            return { value: o2 && o2[i2++], done: !o2 };
          }
        };
      throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    BaggageImpl = /** @class */
    function() {
      function BaggageImpl2(entries) {
        this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();
      }
      BaggageImpl2.prototype.getEntry = function(key) {
        var entry = this._entries.get(key);
        if (!entry) {
          return void 0;
        }
        return Object.assign({}, entry);
      };
      BaggageImpl2.prototype.getAllEntries = function() {
        return Array.from(this._entries.entries()).map(function(_a12) {
          var _b5 = __read3(_a12, 2), k2 = _b5[0], v2 = _b5[1];
          return [k2, v2];
        });
      };
      BaggageImpl2.prototype.setEntry = function(key, entry) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntry = function(key) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntries = function() {
        var e_1, _a12;
        var keys4 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          keys4[_i] = arguments[_i];
        }
        var newBaggage = new BaggageImpl2(this._entries);
        try {
          for (var keys_1 = __values(keys4), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            newBaggage._entries.delete(key);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (keys_1_1 && !keys_1_1.done && (_a12 = keys_1.return))
              _a12.call(keys_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return newBaggage;
      };
      BaggageImpl2.prototype.clear = function() {
        return new BaggageImpl2();
      };
      return BaggageImpl2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js
var baggageEntryMetadataSymbol;
var init_symbol = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js"() {
    baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/utils.js
function createBaggage(entries) {
  if (entries === void 0) {
    entries = {};
  }
  return new BaggageImpl(new Map(Object.entries(entries)));
}
function baggageEntryMetadataFromString(str) {
  if (typeof str !== "string") {
    diag.error("Cannot create baggage metadata from unknown type: " + typeof str);
    str = "";
  }
  return {
    __TYPE__: baggageEntryMetadataSymbol,
    toString: function() {
      return str;
    }
  };
}
var diag;
var init_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/utils.js"() {
    init_diag();
    init_baggage_impl();
    init_symbol();
    diag = DiagAPI.instance();
  }
});

// node_modules/@opentelemetry/api/build/esm/context/context.js
function createContextKey(description) {
  return Symbol.for(description);
}
var BaseContext, ROOT_CONTEXT;
var init_context = __esm({
  "node_modules/@opentelemetry/api/build/esm/context/context.js"() {
    BaseContext = /** @class */
    /* @__PURE__ */ function() {
      function BaseContext2(parentContext) {
        var self = this;
        self._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self.getValue = function(key) {
          return self._currentContext.get(key);
        };
        self.setValue = function(key, value) {
          var context3 = new BaseContext2(self._currentContext);
          context3._currentContext.set(key, value);
          return context3;
        };
        self.deleteValue = function(key) {
          var context3 = new BaseContext2(self._currentContext);
          context3._currentContext.delete(key);
          return context3;
        };
      }
      return BaseContext2;
    }();
    ROOT_CONTEXT = new BaseContext();
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js
var consoleMap, DiagConsoleLogger;
var init_consoleLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js"() {
    consoleMap = [
      { n: "error", c: "error" },
      { n: "warn", c: "warn" },
      { n: "info", c: "info" },
      { n: "debug", c: "debug" },
      { n: "verbose", c: "trace" }
    ];
    DiagConsoleLogger = /** @class */
    /* @__PURE__ */ function() {
      function DiagConsoleLogger2() {
        function _consoleFunc(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (console) {
              var theFunc = console[funcName];
              if (typeof theFunc !== "function") {
                theFunc = console.log;
              }
              if (typeof theFunc === "function") {
                return theFunc.apply(console, args);
              }
            }
          };
        }
        for (var i2 = 0; i2 < consoleMap.length; i2++) {
          this[consoleMap[i2].n] = _consoleFunc(consoleMap[i2].c);
        }
      }
      return DiagConsoleLogger2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js
function createNoopMeter() {
  return NOOP_METER;
}
var __extends, NoopMeter, NoopMetric, NoopCounterMetric, NoopUpDownCounterMetric, NoopHistogramMetric, NoopObservableMetric, NoopObservableCounterMetric, NoopObservableGaugeMetric, NoopObservableUpDownCounterMetric, NOOP_METER, NOOP_COUNTER_METRIC, NOOP_HISTOGRAM_METRIC, NOOP_UP_DOWN_COUNTER_METRIC, NOOP_OBSERVABLE_COUNTER_METRIC, NOOP_OBSERVABLE_GAUGE_METRIC, NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
var init_NoopMeter = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js"() {
    __extends = /* @__PURE__ */ function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    NoopMeter = /** @class */
    function() {
      function NoopMeter2() {
      }
      NoopMeter2.prototype.createHistogram = function(_name, _options) {
        return NOOP_HISTOGRAM_METRIC;
      };
      NoopMeter2.prototype.createCounter = function(_name, _options) {
        return NOOP_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createUpDownCounter = function(_name, _options) {
        return NOOP_UP_DOWN_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createObservableGauge = function(_name, _options) {
        return NOOP_OBSERVABLE_GAUGE_METRIC;
      };
      NoopMeter2.prototype.createObservableCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createObservableUpDownCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
      };
      NoopMeter2.prototype.addBatchObservableCallback = function(_callback, _observables) {
      };
      NoopMeter2.prototype.removeBatchObservableCallback = function(_callback) {
      };
      return NoopMeter2;
    }();
    NoopMetric = /** @class */
    /* @__PURE__ */ function() {
      function NoopMetric2() {
      }
      return NoopMetric2;
    }();
    NoopCounterMetric = /** @class */
    function(_super) {
      __extends(NoopCounterMetric2, _super);
      function NoopCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopCounterMetric2.prototype.add = function(_value, _attributes) {
      };
      return NoopCounterMetric2;
    }(NoopMetric);
    NoopUpDownCounterMetric = /** @class */
    function(_super) {
      __extends(NoopUpDownCounterMetric2, _super);
      function NoopUpDownCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopUpDownCounterMetric2.prototype.add = function(_value, _attributes) {
      };
      return NoopUpDownCounterMetric2;
    }(NoopMetric);
    NoopHistogramMetric = /** @class */
    function(_super) {
      __extends(NoopHistogramMetric2, _super);
      function NoopHistogramMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopHistogramMetric2.prototype.record = function(_value, _attributes) {
      };
      return NoopHistogramMetric2;
    }(NoopMetric);
    NoopObservableMetric = /** @class */
    function() {
      function NoopObservableMetric2() {
      }
      NoopObservableMetric2.prototype.addCallback = function(_callback) {
      };
      NoopObservableMetric2.prototype.removeCallback = function(_callback) {
      };
      return NoopObservableMetric2;
    }();
    NoopObservableCounterMetric = /** @class */
    function(_super) {
      __extends(NoopObservableCounterMetric2, _super);
      function NoopObservableCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableCounterMetric2;
    }(NoopObservableMetric);
    NoopObservableGaugeMetric = /** @class */
    function(_super) {
      __extends(NoopObservableGaugeMetric2, _super);
      function NoopObservableGaugeMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableGaugeMetric2;
    }(NoopObservableMetric);
    NoopObservableUpDownCounterMetric = /** @class */
    function(_super) {
      __extends(NoopObservableUpDownCounterMetric2, _super);
      function NoopObservableUpDownCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableUpDownCounterMetric2;
    }(NoopObservableMetric);
    NOOP_METER = new NoopMeter();
    NOOP_COUNTER_METRIC = new NoopCounterMetric();
    NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
    NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
    NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
    NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
    NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics/Metric.js
var ValueType;
var init_Metric = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics/Metric.js"() {
    (function(ValueType2) {
      ValueType2[ValueType2["INT"] = 0] = "INT";
      ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
    })(ValueType || (ValueType = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js
var defaultTextMapGetter, defaultTextMapSetter;
var init_TextMapPropagator = __esm({
  "node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js"() {
    defaultTextMapGetter = {
      get: function(carrier, key) {
        if (carrier == null) {
          return void 0;
        }
        return carrier[key];
      },
      keys: function(carrier) {
        if (carrier == null) {
          return [];
        }
        return Object.keys(carrier);
      }
    };
    defaultTextMapSetter = {
      set: function(carrier, key, value) {
        if (carrier == null) {
          return;
        }
        carrier[key] = value;
      }
    };
  }
});

// node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js
var __read4, __spreadArray3, NoopContextManager;
var init_NoopContextManager = __esm({
  "node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js"() {
    init_context();
    __read4 = function(o2, n2) {
      var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
      if (!m2)
        return o2;
      var i2 = m2.call(o2), r2, ar = [], e2;
      try {
        while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
          ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"]))
            m2.call(i2);
        } finally {
          if (e2)
            throw e2.error;
        }
      }
      return ar;
    };
    __spreadArray3 = function(to2, from4, pack2) {
      if (pack2 || arguments.length === 2)
        for (var i2 = 0, l2 = from4.length, ar; i2 < l2; i2++) {
          if (ar || !(i2 in from4)) {
            if (!ar)
              ar = Array.prototype.slice.call(from4, 0, i2);
            ar[i2] = from4[i2];
          }
        }
      return to2.concat(ar || Array.prototype.slice.call(from4));
    };
    NoopContextManager = /** @class */
    function() {
      function NoopContextManager2() {
      }
      NoopContextManager2.prototype.active = function() {
        return ROOT_CONTEXT;
      };
      NoopContextManager2.prototype.with = function(_context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray3([thisArg], __read4(args), false));
      };
      NoopContextManager2.prototype.bind = function(_context, target) {
        return target;
      };
      NoopContextManager2.prototype.enable = function() {
        return this;
      };
      NoopContextManager2.prototype.disable = function() {
        return this;
      };
      return NoopContextManager2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/context.js
var __read5, __spreadArray4, API_NAME2, NOOP_CONTEXT_MANAGER, ContextAPI;
var init_context2 = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/context.js"() {
    init_NoopContextManager();
    init_global_utils();
    init_diag();
    __read5 = function(o2, n2) {
      var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
      if (!m2)
        return o2;
      var i2 = m2.call(o2), r2, ar = [], e2;
      try {
        while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
          ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"]))
            m2.call(i2);
        } finally {
          if (e2)
            throw e2.error;
        }
      }
      return ar;
    };
    __spreadArray4 = function(to2, from4, pack2) {
      if (pack2 || arguments.length === 2)
        for (var i2 = 0, l2 = from4.length, ar; i2 < l2; i2++) {
          if (ar || !(i2 in from4)) {
            if (!ar)
              ar = Array.prototype.slice.call(from4, 0, i2);
            ar[i2] = from4[i2];
          }
        }
      return to2.concat(ar || Array.prototype.slice.call(from4));
    };
    API_NAME2 = "context";
    NOOP_CONTEXT_MANAGER = new NoopContextManager();
    ContextAPI = /** @class */
    function() {
      function ContextAPI2() {
      }
      ContextAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new ContextAPI2();
        }
        return this._instance;
      };
      ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
        return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
      };
      ContextAPI2.prototype.active = function() {
        return this._getContextManager().active();
      };
      ContextAPI2.prototype.with = function(context3, fn, thisArg) {
        var _a12;
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return (_a12 = this._getContextManager()).with.apply(_a12, __spreadArray4([context3, fn, thisArg], __read5(args), false));
      };
      ContextAPI2.prototype.bind = function(context3, target) {
        return this._getContextManager().bind(context3, target);
      };
      ContextAPI2.prototype._getContextManager = function() {
        return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
      };
      ContextAPI2.prototype.disable = function() {
        this._getContextManager().disable();
        unregisterGlobal(API_NAME2, DiagAPI.instance());
      };
      return ContextAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js
var TraceFlags;
var init_trace_flags = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js"() {
    (function(TraceFlags2) {
      TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
      TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
    })(TraceFlags || (TraceFlags = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js
var INVALID_SPANID, INVALID_TRACEID, INVALID_SPAN_CONTEXT;
var init_invalid_span_constants = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js"() {
    init_trace_flags();
    INVALID_SPANID = "0000000000000000";
    INVALID_TRACEID = "00000000000000000000000000000000";
    INVALID_SPAN_CONTEXT = {
      traceId: INVALID_TRACEID,
      spanId: INVALID_SPANID,
      traceFlags: TraceFlags.NONE
    };
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js
var NonRecordingSpan;
var init_NonRecordingSpan = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js"() {
    init_invalid_span_constants();
    NonRecordingSpan = /** @class */
    function() {
      function NonRecordingSpan2(_spanContext) {
        if (_spanContext === void 0) {
          _spanContext = INVALID_SPAN_CONTEXT;
        }
        this._spanContext = _spanContext;
      }
      NonRecordingSpan2.prototype.spanContext = function() {
        return this._spanContext;
      };
      NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
        return this;
      };
      NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.setStatus = function(_status) {
        return this;
      };
      NonRecordingSpan2.prototype.updateName = function(_name) {
        return this;
      };
      NonRecordingSpan2.prototype.end = function(_endTime) {
      };
      NonRecordingSpan2.prototype.isRecording = function() {
        return false;
      };
      NonRecordingSpan2.prototype.recordException = function(_exception, _time) {
      };
      return NonRecordingSpan2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/context-utils.js
function getSpan(context3) {
  return context3.getValue(SPAN_KEY) || void 0;
}
function getActiveSpan() {
  return getSpan(ContextAPI.getInstance().active());
}
function setSpan(context3, span) {
  return context3.setValue(SPAN_KEY, span);
}
function deleteSpan(context3) {
  return context3.deleteValue(SPAN_KEY);
}
function setSpanContext(context3, spanContext) {
  return setSpan(context3, new NonRecordingSpan(spanContext));
}
function getSpanContext(context3) {
  var _a12;
  return (_a12 = getSpan(context3)) === null || _a12 === void 0 ? void 0 : _a12.spanContext();
}
var SPAN_KEY;
var init_context_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/context-utils.js"() {
    init_context();
    init_NonRecordingSpan();
    init_context2();
    SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js
function isValidTraceId(traceId) {
  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
function isSpanContextValid(spanContext) {
  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
function wrapSpanContext(spanContext) {
  return new NonRecordingSpan(spanContext);
}
var VALID_TRACEID_REGEX, VALID_SPANID_REGEX;
var init_spancontext_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js"() {
    init_invalid_span_constants();
    init_NonRecordingSpan();
    VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
    VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js
function isSpanContext(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var contextApi, NoopTracer;
var init_NoopTracer = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js"() {
    init_context2();
    init_context_utils();
    init_NonRecordingSpan();
    init_spancontext_utils();
    contextApi = ContextAPI.getInstance();
    NoopTracer = /** @class */
    function() {
      function NoopTracer2() {
      }
      NoopTracer2.prototype.startSpan = function(name, options, context3) {
        if (context3 === void 0) {
          context3 = contextApi.active();
        }
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
          return new NonRecordingSpan();
        }
        var parentFromContext = context3 && getSpanContext(context3);
        if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
          return new NonRecordingSpan(parentFromContext);
        } else {
          return new NonRecordingSpan();
        }
      };
      NoopTracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, void 0, span);
      };
      return NoopTracer2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js
var NOOP_TRACER, ProxyTracer;
var init_ProxyTracer = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js"() {
    init_NoopTracer();
    NOOP_TRACER = new NoopTracer();
    ProxyTracer = /** @class */
    function() {
      function ProxyTracer2(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
      }
      ProxyTracer2.prototype.startSpan = function(name, options, context3) {
        return this._getTracer().startSpan(name, options, context3);
      };
      ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
        var tracer2 = this._getTracer();
        return Reflect.apply(tracer2.startActiveSpan, tracer2, arguments);
      };
      ProxyTracer2.prototype._getTracer = function() {
        if (this._delegate) {
          return this._delegate;
        }
        var tracer2 = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer2) {
          return NOOP_TRACER;
        }
        this._delegate = tracer2;
        return this._delegate;
      };
      return ProxyTracer2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js
var NoopTracerProvider;
var init_NoopTracerProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js"() {
    init_NoopTracer();
    NoopTracerProvider = /** @class */
    function() {
      function NoopTracerProvider2() {
      }
      NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
        return new NoopTracer();
      };
      return NoopTracerProvider2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js
var NOOP_TRACER_PROVIDER, ProxyTracerProvider;
var init_ProxyTracerProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js"() {
    init_ProxyTracer();
    init_NoopTracerProvider();
    NOOP_TRACER_PROVIDER = new NoopTracerProvider();
    ProxyTracerProvider = /** @class */
    function() {
      function ProxyTracerProvider2() {
      }
      ProxyTracerProvider2.prototype.getTracer = function(name, version, options) {
        var _a12;
        return (_a12 = this.getDelegateTracer(name, version, options)) !== null && _a12 !== void 0 ? _a12 : new ProxyTracer(this, name, version, options);
      };
      ProxyTracerProvider2.prototype.getDelegate = function() {
        var _a12;
        return (_a12 = this._delegate) !== null && _a12 !== void 0 ? _a12 : NOOP_TRACER_PROVIDER;
      };
      ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
      };
      ProxyTracerProvider2.prototype.getDelegateTracer = function(name, version, options) {
        var _a12;
        return (_a12 = this._delegate) === null || _a12 === void 0 ? void 0 : _a12.getTracer(name, version, options);
      };
      return ProxyTracerProvider2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js
var SamplingDecision;
var init_SamplingResult = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js"() {
    (function(SamplingDecision2) {
      SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
      SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
      SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision || (SamplingDecision = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/span_kind.js
var SpanKind;
var init_span_kind = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/span_kind.js"() {
    (function(SpanKind2) {
      SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
      SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
      SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
      SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
      SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
    })(SpanKind || (SpanKind = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/status.js
var SpanStatusCode;
var init_status = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/status.js"() {
    (function(SpanStatusCode2) {
      SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
      SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
      SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
    })(SpanStatusCode || (SpanStatusCode = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js
function validateKey(key) {
  return VALID_KEY_REGEX.test(key);
}
function validateValue(value) {
  return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
}
var VALID_KEY_CHAR_RANGE, VALID_KEY, VALID_VENDOR_KEY, VALID_KEY_REGEX, VALID_VALUE_BASE_REGEX, INVALID_VALUE_COMMA_EQUAL_REGEX;
var init_tracestate_validators = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js"() {
    VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
    VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
    VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
    VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
    VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
    INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js
var MAX_TRACE_STATE_ITEMS, MAX_TRACE_STATE_LEN, LIST_MEMBERS_SEPARATOR, LIST_MEMBER_KEY_VALUE_SPLITTER, TraceStateImpl;
var init_tracestate_impl = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js"() {
    init_tracestate_validators();
    MAX_TRACE_STATE_ITEMS = 32;
    MAX_TRACE_STATE_LEN = 512;
    LIST_MEMBERS_SEPARATOR = ",";
    LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
    TraceStateImpl = /** @class */
    function() {
      function TraceStateImpl2(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      TraceStateImpl2.prototype.set = function(key, value) {
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      };
      TraceStateImpl2.prototype.unset = function(key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      };
      TraceStateImpl2.prototype.get = function(key) {
        return this._internalState.get(key);
      };
      TraceStateImpl2.prototype.serialize = function() {
        var _this = this;
        return this._keys().reduce(function(agg, key) {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
      };
      TraceStateImpl2.prototype._parse = function(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce(function(agg, part) {
          var listMember = part.trim();
          var i2 = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i2 !== -1) {
            var key = listMember.slice(0, i2);
            var value = listMember.slice(i2 + 1, part.length);
            if (validateKey(key) && validateValue(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
        }
      };
      TraceStateImpl2.prototype._keys = function() {
        return Array.from(this._internalState.keys()).reverse();
      };
      TraceStateImpl2.prototype._clone = function() {
        var traceState = new TraceStateImpl2();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      };
      return TraceStateImpl2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/internal/utils.js
function createTraceState(rawTraceState) {
  return new TraceStateImpl(rawTraceState);
}
var init_utils2 = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/internal/utils.js"() {
    init_tracestate_impl();
  }
});

// node_modules/@opentelemetry/api/build/esm/context-api.js
var context;
var init_context_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/context-api.js"() {
    init_context2();
    context = ContextAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/diag-api.js
var diag2;
var init_diag_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag-api.js"() {
    init_diag();
    diag2 = DiagAPI.instance();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js
var NoopMeterProvider, NOOP_METER_PROVIDER;
var init_NoopMeterProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js"() {
    init_NoopMeter();
    NoopMeterProvider = /** @class */
    function() {
      function NoopMeterProvider2() {
      }
      NoopMeterProvider2.prototype.getMeter = function(_name, _version, _options) {
        return NOOP_METER;
      };
      return NoopMeterProvider2;
    }();
    NOOP_METER_PROVIDER = new NoopMeterProvider();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/metrics.js
var API_NAME3, MetricsAPI;
var init_metrics = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/metrics.js"() {
    init_NoopMeterProvider();
    init_global_utils();
    init_diag();
    API_NAME3 = "metrics";
    MetricsAPI = /** @class */
    function() {
      function MetricsAPI2() {
      }
      MetricsAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new MetricsAPI2();
        }
        return this._instance;
      };
      MetricsAPI2.prototype.setGlobalMeterProvider = function(provider) {
        return registerGlobal(API_NAME3, provider, DiagAPI.instance());
      };
      MetricsAPI2.prototype.getMeterProvider = function() {
        return getGlobal(API_NAME3) || NOOP_METER_PROVIDER;
      };
      MetricsAPI2.prototype.getMeter = function(name, version, options) {
        return this.getMeterProvider().getMeter(name, version, options);
      };
      MetricsAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME3, DiagAPI.instance());
      };
      return MetricsAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics-api.js
var metrics;
var init_metrics_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics-api.js"() {
    init_metrics();
    metrics = MetricsAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js
var NoopTextMapPropagator;
var init_NoopTextMapPropagator = __esm({
  "node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js"() {
    NoopTextMapPropagator = /** @class */
    function() {
      function NoopTextMapPropagator2() {
      }
      NoopTextMapPropagator2.prototype.inject = function(_context, _carrier) {
      };
      NoopTextMapPropagator2.prototype.extract = function(context3, _carrier) {
        return context3;
      };
      NoopTextMapPropagator2.prototype.fields = function() {
        return [];
      };
      return NoopTextMapPropagator2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js
function getBaggage(context3) {
  return context3.getValue(BAGGAGE_KEY) || void 0;
}
function getActiveBaggage() {
  return getBaggage(ContextAPI.getInstance().active());
}
function setBaggage(context3, baggage) {
  return context3.setValue(BAGGAGE_KEY, baggage);
}
function deleteBaggage(context3) {
  return context3.deleteValue(BAGGAGE_KEY);
}
var BAGGAGE_KEY;
var init_context_helpers = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js"() {
    init_context2();
    init_context();
    BAGGAGE_KEY = createContextKey("OpenTelemetry Baggage Key");
  }
});

// node_modules/@opentelemetry/api/build/esm/api/propagation.js
var API_NAME4, NOOP_TEXT_MAP_PROPAGATOR, PropagationAPI;
var init_propagation = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/propagation.js"() {
    init_global_utils();
    init_NoopTextMapPropagator();
    init_TextMapPropagator();
    init_context_helpers();
    init_utils();
    init_diag();
    API_NAME4 = "propagation";
    NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
    PropagationAPI = /** @class */
    function() {
      function PropagationAPI2() {
        this.createBaggage = createBaggage;
        this.getBaggage = getBaggage;
        this.getActiveBaggage = getActiveBaggage;
        this.setBaggage = setBaggage;
        this.deleteBaggage = deleteBaggage;
      }
      PropagationAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new PropagationAPI2();
        }
        return this._instance;
      };
      PropagationAPI2.prototype.setGlobalPropagator = function(propagator) {
        return registerGlobal(API_NAME4, propagator, DiagAPI.instance());
      };
      PropagationAPI2.prototype.inject = function(context3, carrier, setter) {
        if (setter === void 0) {
          setter = defaultTextMapSetter;
        }
        return this._getGlobalPropagator().inject(context3, carrier, setter);
      };
      PropagationAPI2.prototype.extract = function(context3, carrier, getter) {
        if (getter === void 0) {
          getter = defaultTextMapGetter;
        }
        return this._getGlobalPropagator().extract(context3, carrier, getter);
      };
      PropagationAPI2.prototype.fields = function() {
        return this._getGlobalPropagator().fields();
      };
      PropagationAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME4, DiagAPI.instance());
      };
      PropagationAPI2.prototype._getGlobalPropagator = function() {
        return getGlobal(API_NAME4) || NOOP_TEXT_MAP_PROPAGATOR;
      };
      return PropagationAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/propagation-api.js
var propagation;
var init_propagation_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/propagation-api.js"() {
    init_propagation();
    propagation = PropagationAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/trace.js
var API_NAME5, TraceAPI;
var init_trace = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/trace.js"() {
    init_global_utils();
    init_ProxyTracerProvider();
    init_spancontext_utils();
    init_context_utils();
    init_diag();
    API_NAME5 = "trace";
    TraceAPI = /** @class */
    function() {
      function TraceAPI2() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
      }
      TraceAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new TraceAPI2();
        }
        return this._instance;
      };
      TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
        var success = registerGlobal(API_NAME5, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
          this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
      };
      TraceAPI2.prototype.getTracerProvider = function() {
        return getGlobal(API_NAME5) || this._proxyTracerProvider;
      };
      TraceAPI2.prototype.getTracer = function(name, version) {
        return this.getTracerProvider().getTracer(name, version);
      };
      TraceAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME5, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
      };
      return TraceAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace-api.js
var trace;
var init_trace_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace-api.js"() {
    init_trace();
    trace = TraceAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  DiagConsoleLogger: () => DiagConsoleLogger,
  DiagLogLevel: () => DiagLogLevel,
  INVALID_SPANID: () => INVALID_SPANID,
  INVALID_SPAN_CONTEXT: () => INVALID_SPAN_CONTEXT,
  INVALID_TRACEID: () => INVALID_TRACEID,
  ProxyTracer: () => ProxyTracer,
  ProxyTracerProvider: () => ProxyTracerProvider,
  ROOT_CONTEXT: () => ROOT_CONTEXT,
  SamplingDecision: () => SamplingDecision,
  SpanKind: () => SpanKind,
  SpanStatusCode: () => SpanStatusCode,
  TraceFlags: () => TraceFlags,
  ValueType: () => ValueType,
  baggageEntryMetadataFromString: () => baggageEntryMetadataFromString,
  context: () => context,
  createContextKey: () => createContextKey,
  createNoopMeter: () => createNoopMeter,
  createTraceState: () => createTraceState,
  default: () => esm_default,
  defaultTextMapGetter: () => defaultTextMapGetter,
  defaultTextMapSetter: () => defaultTextMapSetter,
  diag: () => diag2,
  isSpanContextValid: () => isSpanContextValid,
  isValidSpanId: () => isValidSpanId,
  isValidTraceId: () => isValidTraceId,
  metrics: () => metrics,
  propagation: () => propagation,
  trace: () => trace
});
var esm_default;
var init_esm = __esm({
  "node_modules/@opentelemetry/api/build/esm/index.js"() {
    init_utils();
    init_context();
    init_consoleLogger();
    init_types();
    init_NoopMeter();
    init_Metric();
    init_TextMapPropagator();
    init_ProxyTracer();
    init_ProxyTracerProvider();
    init_SamplingResult();
    init_span_kind();
    init_status();
    init_trace_flags();
    init_utils2();
    init_spancontext_utils();
    init_invalid_span_constants();
    init_context_api();
    init_diag_api();
    init_metrics_api();
    init_propagation_api();
    init_trace_api();
    esm_default = {
      context,
      diag: diag2,
      metrics,
      propagation,
      trace
    };
  }
});

// node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js
var require_suppress_tracing = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTracingSuppressed = exports.unsuppressTracing = exports.suppressTracing = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var SUPPRESS_TRACING_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
    function suppressTracing(context3) {
      return context3.setValue(SUPPRESS_TRACING_KEY, true);
    }
    exports.suppressTracing = suppressTracing;
    function unsuppressTracing(context3) {
      return context3.deleteValue(SUPPRESS_TRACING_KEY);
    }
    exports.unsuppressTracing = unsuppressTracing;
    function isTracingSuppressed(context3) {
      return context3.getValue(SUPPRESS_TRACING_KEY) === true;
    }
    exports.isTracingSuppressed = isTracingSuppressed;
  }
});

// node_modules/@opentelemetry/core/build/src/baggage/constants.js
var require_constants = __commonJS({
  "node_modules/@opentelemetry/core/build/src/baggage/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BAGGAGE_MAX_TOTAL_LENGTH = exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = exports.BAGGAGE_HEADER = exports.BAGGAGE_ITEMS_SEPARATOR = exports.BAGGAGE_PROPERTIES_SEPARATOR = exports.BAGGAGE_KEY_PAIR_SEPARATOR = void 0;
    exports.BAGGAGE_KEY_PAIR_SEPARATOR = "=";
    exports.BAGGAGE_PROPERTIES_SEPARATOR = ";";
    exports.BAGGAGE_ITEMS_SEPARATOR = ",";
    exports.BAGGAGE_HEADER = "baggage";
    exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
    exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
    exports.BAGGAGE_MAX_TOTAL_LENGTH = 8192;
  }
});

// node_modules/@opentelemetry/core/build/src/baggage/utils.js
var require_utils = __commonJS({
  "node_modules/@opentelemetry/core/build/src/baggage/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseKeyPairsIntoRecord = exports.parsePairKeyValue = exports.getKeyPairs = exports.serializeKeyPairs = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var constants_1 = require_constants();
    function serializeKeyPairs(keyPairs) {
      return keyPairs.reduce((hValue, current) => {
        const value = `${hValue}${hValue !== "" ? constants_1.BAGGAGE_ITEMS_SEPARATOR : ""}${current}`;
        return value.length > constants_1.BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
      }, "");
    }
    exports.serializeKeyPairs = serializeKeyPairs;
    function getKeyPairs(baggage) {
      return baggage.getAllEntries().map(([key, value]) => {
        let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;
        if (value.metadata !== void 0) {
          entry += constants_1.BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
        }
        return entry;
      });
    }
    exports.getKeyPairs = getKeyPairs;
    function parsePairKeyValue(entry) {
      const valueProps = entry.split(constants_1.BAGGAGE_PROPERTIES_SEPARATOR);
      if (valueProps.length <= 0)
        return;
      const keyPairPart = valueProps.shift();
      if (!keyPairPart)
        return;
      const separatorIndex = keyPairPart.indexOf(constants_1.BAGGAGE_KEY_PAIR_SEPARATOR);
      if (separatorIndex <= 0)
        return;
      const key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
      const value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
      let metadata;
      if (valueProps.length > 0) {
        metadata = (0, api_1.baggageEntryMetadataFromString)(valueProps.join(constants_1.BAGGAGE_PROPERTIES_SEPARATOR));
      }
      return { key, value, metadata };
    }
    exports.parsePairKeyValue = parsePairKeyValue;
    function parseKeyPairsIntoRecord(value) {
      if (typeof value !== "string" || value.length === 0)
        return {};
      return value.split(constants_1.BAGGAGE_ITEMS_SEPARATOR).map((entry) => {
        return parsePairKeyValue(entry);
      }).filter((keyPair) => keyPair !== void 0 && keyPair.value.length > 0).reduce((headers, keyPair) => {
        headers[keyPair.key] = keyPair.value;
        return headers;
      }, {});
    }
    exports.parseKeyPairsIntoRecord = parseKeyPairsIntoRecord;
  }
});

// node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js
var require_W3CBaggagePropagator = __commonJS({
  "node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.W3CBaggagePropagator = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing();
    var constants_1 = require_constants();
    var utils_1 = require_utils();
    var W3CBaggagePropagator = class {
      inject(context3, carrier, setter) {
        const baggage = api_1.propagation.getBaggage(context3);
        if (!baggage || (0, suppress_tracing_1.isTracingSuppressed)(context3))
          return;
        const keyPairs = (0, utils_1.getKeyPairs)(baggage).filter((pair) => {
          return pair.length <= constants_1.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
        }).slice(0, constants_1.BAGGAGE_MAX_NAME_VALUE_PAIRS);
        const headerValue = (0, utils_1.serializeKeyPairs)(keyPairs);
        if (headerValue.length > 0) {
          setter.set(carrier, constants_1.BAGGAGE_HEADER, headerValue);
        }
      }
      extract(context3, carrier, getter) {
        const headerValue = getter.get(carrier, constants_1.BAGGAGE_HEADER);
        const baggageString = Array.isArray(headerValue) ? headerValue.join(constants_1.BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString)
          return context3;
        const baggage = {};
        if (baggageString.length === 0) {
          return context3;
        }
        const pairs = baggageString.split(constants_1.BAGGAGE_ITEMS_SEPARATOR);
        pairs.forEach((entry) => {
          const keyPair = (0, utils_1.parsePairKeyValue)(entry);
          if (keyPair) {
            const baggageEntry = { value: keyPair.value };
            if (keyPair.metadata) {
              baggageEntry.metadata = keyPair.metadata;
            }
            baggage[keyPair.key] = baggageEntry;
          }
        });
        if (Object.entries(baggage).length === 0) {
          return context3;
        }
        return api_1.propagation.setBaggage(context3, api_1.propagation.createBaggage(baggage));
      }
      fields() {
        return [constants_1.BAGGAGE_HEADER];
      }
    };
    exports.W3CBaggagePropagator = W3CBaggagePropagator;
  }
});

// node_modules/@opentelemetry/core/build/src/common/anchored-clock.js
var require_anchored_clock = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/anchored-clock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnchoredClock = void 0;
    var AnchoredClock = class {
      /**
       * Create a new AnchoredClock anchored to the current time returned by systemClock.
       *
       * @param systemClock should be a clock that returns the number of milliseconds since January 1 1970 such as Date
       * @param monotonicClock should be a clock that counts milliseconds monotonically such as window.performance or perf_hooks.performance
       */
      constructor(systemClock, monotonicClock) {
        this._monotonicClock = monotonicClock;
        this._epochMillis = systemClock.now();
        this._performanceMillis = monotonicClock.now();
      }
      /**
       * Returns the current time by adding the number of milliseconds since the
       * AnchoredClock was created to the creation epoch time
       */
      now() {
        const delta = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + delta;
      }
    };
    exports.AnchoredClock = AnchoredClock;
  }
});

// node_modules/@opentelemetry/core/build/src/common/attributes.js
var require_attributes = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/attributes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAttributeValue = exports.isAttributeKey = exports.sanitizeAttributes = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    function sanitizeAttributes(attributes) {
      const out = {};
      if (typeof attributes !== "object" || attributes == null) {
        return out;
      }
      for (const [key, val] of Object.entries(attributes)) {
        if (!isAttributeKey(key)) {
          api_1.diag.warn(`Invalid attribute key: ${key}`);
          continue;
        }
        if (!isAttributeValue(val)) {
          api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
          continue;
        }
        if (Array.isArray(val)) {
          out[key] = val.slice();
        } else {
          out[key] = val;
        }
      }
      return out;
    }
    exports.sanitizeAttributes = sanitizeAttributes;
    function isAttributeKey(key) {
      return typeof key === "string" && key.length > 0;
    }
    exports.isAttributeKey = isAttributeKey;
    function isAttributeValue(val) {
      if (val == null) {
        return true;
      }
      if (Array.isArray(val)) {
        return isHomogeneousAttributeValueArray(val);
      }
      return isValidPrimitiveAttributeValue(val);
    }
    exports.isAttributeValue = isAttributeValue;
    function isHomogeneousAttributeValueArray(arr) {
      let type;
      for (const element of arr) {
        if (element == null)
          continue;
        if (!type) {
          if (isValidPrimitiveAttributeValue(element)) {
            type = typeof element;
            continue;
          }
          return false;
        }
        if (typeof element === type) {
          continue;
        }
        return false;
      }
      return true;
    }
    function isValidPrimitiveAttributeValue(val) {
      switch (typeof val) {
        case "number":
        case "boolean":
        case "string":
          return true;
      }
      return false;
    }
  }
});

// node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js
var require_logging_error_handler = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loggingErrorHandler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    function loggingErrorHandler() {
      return (ex) => {
        api_1.diag.error(stringifyException(ex));
      };
    }
    exports.loggingErrorHandler = loggingErrorHandler;
    function stringifyException(ex) {
      if (typeof ex === "string") {
        return ex;
      } else {
        return JSON.stringify(flattenException(ex));
      }
    }
    function flattenException(ex) {
      const result4 = {};
      let current = ex;
      while (current !== null) {
        Object.getOwnPropertyNames(current).forEach((propertyName) => {
          if (result4[propertyName])
            return;
          const value = current[propertyName];
          if (value) {
            result4[propertyName] = String(value);
          }
        });
        current = Object.getPrototypeOf(current);
      }
      return result4;
    }
  }
});

// node_modules/@opentelemetry/core/build/src/common/global-error-handler.js
var require_global_error_handler = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/global-error-handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.globalErrorHandler = exports.setGlobalErrorHandler = void 0;
    var logging_error_handler_1 = require_logging_error_handler();
    var delegateHandler = (0, logging_error_handler_1.loggingErrorHandler)();
    function setGlobalErrorHandler(handler) {
      delegateHandler = handler;
    }
    exports.setGlobalErrorHandler = setGlobalErrorHandler;
    function globalErrorHandler(ex) {
      try {
        delegateHandler(ex);
      } catch (_a12) {
      }
    }
    exports.globalErrorHandler = globalErrorHandler;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/sampling.js
var require_sampling = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/sampling.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TracesSamplerValues = void 0;
    var TracesSamplerValues;
    (function(TracesSamplerValues2) {
      TracesSamplerValues2["AlwaysOff"] = "always_off";
      TracesSamplerValues2["AlwaysOn"] = "always_on";
      TracesSamplerValues2["ParentBasedAlwaysOff"] = "parentbased_always_off";
      TracesSamplerValues2["ParentBasedAlwaysOn"] = "parentbased_always_on";
      TracesSamplerValues2["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
      TracesSamplerValues2["TraceIdRatio"] = "traceidratio";
    })(TracesSamplerValues = exports.TracesSamplerValues || (exports.TracesSamplerValues = {}));
  }
});

// node_modules/@opentelemetry/core/build/src/utils/environment.js
var require_environment = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/environment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseEnvironment = exports.DEFAULT_ENVIRONMENT = exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var sampling_1 = require_sampling();
    var DEFAULT_LIST_SEPARATOR = ",";
    var ENVIRONMENT_BOOLEAN_KEYS = ["OTEL_SDK_DISABLED"];
    function isEnvVarABoolean(key) {
      return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_NUMBERS_KEYS = [
      "OTEL_BSP_EXPORT_TIMEOUT",
      "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BSP_MAX_QUEUE_SIZE",
      "OTEL_BSP_SCHEDULE_DELAY",
      "OTEL_BLRP_EXPORT_TIMEOUT",
      "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BLRP_MAX_QUEUE_SIZE",
      "OTEL_BLRP_SCHEDULE_DELAY",
      "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_LINK_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT",
      "OTEL_EXPORTER_OTLP_TIMEOUT",
      "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
      "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
      "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT",
      "OTEL_EXPORTER_JAEGER_AGENT_PORT"
    ];
    function isEnvVarANumber(key) {
      return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_LISTS_KEYS = [
      "OTEL_NO_PATCH_MODULES",
      "OTEL_PROPAGATORS",
      "OTEL_SEMCONV_STABILITY_OPT_IN"
    ];
    function isEnvVarAList(key) {
      return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
    }
    exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
    exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
    exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
    exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
    exports.DEFAULT_ENVIRONMENT = {
      OTEL_SDK_DISABLED: false,
      CONTAINER_NAME: "",
      ECS_CONTAINER_METADATA_URI_V4: "",
      ECS_CONTAINER_METADATA_URI: "",
      HOSTNAME: "",
      KUBERNETES_SERVICE_HOST: "",
      NAMESPACE: "",
      OTEL_BSP_EXPORT_TIMEOUT: 3e4,
      OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BSP_MAX_QUEUE_SIZE: 2048,
      OTEL_BSP_SCHEDULE_DELAY: 5e3,
      OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
      OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
      OTEL_BLRP_SCHEDULE_DELAY: 5e3,
      OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
      OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
      OTEL_EXPORTER_JAEGER_ENDPOINT: "",
      OTEL_EXPORTER_JAEGER_PASSWORD: "",
      OTEL_EXPORTER_JAEGER_USER: "",
      OTEL_EXPORTER_OTLP_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_HEADERS: "",
      OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
      OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
      OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
      OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
      OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
      OTEL_LOG_LEVEL: api_1.DiagLogLevel.INFO,
      OTEL_NO_PATCH_MODULES: [],
      OTEL_PROPAGATORS: ["tracecontext", "baggage"],
      OTEL_RESOURCE_ATTRIBUTES: "",
      OTEL_SERVICE_NAME: "",
      OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
      OTEL_SPAN_LINK_COUNT_LIMIT: 128,
      OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
      OTEL_TRACES_EXPORTER: "",
      OTEL_TRACES_SAMPLER: sampling_1.TracesSamplerValues.ParentBasedAlwaysOn,
      OTEL_TRACES_SAMPLER_ARG: "",
      OTEL_LOGS_EXPORTER: "",
      OTEL_EXPORTER_OTLP_INSECURE: "",
      OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
      OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
      OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
      OTEL_EXPORTER_OTLP_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative",
      OTEL_SEMCONV_STABILITY_OPT_IN: []
    };
    function parseBoolean(key, environment5, values3) {
      if (typeof values3[key] === "undefined") {
        return;
      }
      const value = String(values3[key]);
      environment5[key] = value.toLowerCase() === "true";
    }
    function parseNumber(name, environment5, values3, min2 = -Infinity, max2 = Infinity) {
      if (typeof values3[name] !== "undefined") {
        const value = Number(values3[name]);
        if (!isNaN(value)) {
          if (value < min2) {
            environment5[name] = min2;
          } else if (value > max2) {
            environment5[name] = max2;
          } else {
            environment5[name] = value;
          }
        }
      }
    }
    function parseStringList(name, output, input, separator = DEFAULT_LIST_SEPARATOR) {
      const givenValue = input[name];
      if (typeof givenValue === "string") {
        output[name] = givenValue.split(separator).map((v2) => v2.trim());
      }
    }
    var logLevelMap = {
      ALL: api_1.DiagLogLevel.ALL,
      VERBOSE: api_1.DiagLogLevel.VERBOSE,
      DEBUG: api_1.DiagLogLevel.DEBUG,
      INFO: api_1.DiagLogLevel.INFO,
      WARN: api_1.DiagLogLevel.WARN,
      ERROR: api_1.DiagLogLevel.ERROR,
      NONE: api_1.DiagLogLevel.NONE
    };
    function setLogLevelFromEnv(key, environment5, values3) {
      const value = values3[key];
      if (typeof value === "string") {
        const theLevel = logLevelMap[value.toUpperCase()];
        if (theLevel != null) {
          environment5[key] = theLevel;
        }
      }
    }
    function parseEnvironment(values3) {
      const environment5 = {};
      for (const env in exports.DEFAULT_ENVIRONMENT) {
        const key = env;
        switch (key) {
          case "OTEL_LOG_LEVEL":
            setLogLevelFromEnv(key, environment5, values3);
            break;
          default:
            if (isEnvVarABoolean(key)) {
              parseBoolean(key, environment5, values3);
            } else if (isEnvVarANumber(key)) {
              parseNumber(key, environment5, values3);
            } else if (isEnvVarAList(key)) {
              parseStringList(key, environment5, values3);
            } else {
              const value = values3[key];
              if (typeof value !== "undefined" && value !== null) {
                environment5[key] = String(value);
              }
            }
        }
      }
      return environment5;
    }
    exports.parseEnvironment = parseEnvironment;
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/environment.js
var require_environment2 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/environment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnvWithoutDefaults = exports.getEnv = void 0;
    var environment_1 = require_environment();
    function getEnv() {
      const processEnv = (0, environment_1.parseEnvironment)(process.env);
      return Object.assign({}, environment_1.DEFAULT_ENVIRONMENT, processEnv);
    }
    exports.getEnv = getEnv;
    function getEnvWithoutDefaults() {
      return (0, environment_1.parseEnvironment)(process.env);
    }
    exports.getEnvWithoutDefaults = getEnvWithoutDefaults;
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js
var require_globalThis = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._globalThis = void 0;
    exports._globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// node_modules/@opentelemetry/core/build/src/common/hex-to-binary.js
var require_hex_to_binary = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/hex-to-binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hexToBinary = void 0;
    function intValue(charCode) {
      if (charCode >= 48 && charCode <= 57) {
        return charCode - 48;
      }
      if (charCode >= 97 && charCode <= 102) {
        return charCode - 87;
      }
      return charCode - 55;
    }
    function hexToBinary(hexStr) {
      const buf = new Uint8Array(hexStr.length / 2);
      let offset = 0;
      for (let i2 = 0; i2 < hexStr.length; i2 += 2) {
        const hi = intValue(hexStr.charCodeAt(i2));
        const lo = intValue(hexStr.charCodeAt(i2 + 1));
        buf[offset++] = hi << 4 | lo;
      }
      return buf;
    }
    exports.hexToBinary = hexToBinary;
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js
var require_hex_to_base64 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hexToBase64 = void 0;
    var hex_to_binary_1 = require_hex_to_binary();
    function hexToBase64(hexStr) {
      return Buffer.from((0, hex_to_binary_1.hexToBinary)(hexStr)).toString("base64");
    }
    exports.hexToBase64 = hexToBase64;
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js
var require_RandomIdGenerator = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RandomIdGenerator = void 0;
    var SPAN_ID_BYTES = 8;
    var TRACE_ID_BYTES = 16;
    var RandomIdGenerator = class {
      constructor() {
        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
        this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
      }
    };
    exports.RandomIdGenerator = RandomIdGenerator;
    var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
    function getIdGenerator(bytes) {
      return function generateId() {
        for (let i2 = 0; i2 < bytes / 4; i2++) {
          SHARED_BUFFER.writeUInt32BE(Math.random() * 2 ** 32 >>> 0, i2 * 4);
        }
        for (let i2 = 0; i2 < bytes; i2++) {
          if (SHARED_BUFFER[i2] > 0) {
            break;
          } else if (i2 === bytes - 1) {
            SHARED_BUFFER[bytes - 1] = 1;
          }
        }
        return SHARED_BUFFER.toString("hex", 0, bytes);
      };
    }
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/performance.js
var require_performance = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/performance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.otperformance = void 0;
    var perf_hooks_1 = __require("perf_hooks");
    exports.otperformance = perf_hooks_1.performance;
  }
});

// node_modules/@opentelemetry/core/build/src/version.js
var require_version = __commonJS({
  "node_modules/@opentelemetry/core/build/src/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VERSION = void 0;
    exports.VERSION = "1.30.1";
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/esm/internal/utils.js
// @__NO_SIDE_EFFECTS__
function createConstMap(values3) {
  var res = {};
  var len = values3.length;
  for (var lp = 0; lp < len; lp++) {
    var val = values3[lp];
    if (val) {
      res[String(val).toUpperCase().replace(/[-.]/g, "_")] = val;
    }
  }
  return res;
}
var init_utils3 = __esm({
  "node_modules/@opentelemetry/semantic-conventions/build/esm/internal/utils.js"() {
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js
var TMP_AWS_LAMBDA_INVOKED_ARN, TMP_DB_SYSTEM, TMP_DB_CONNECTION_STRING, TMP_DB_USER, TMP_DB_JDBC_DRIVER_CLASSNAME, TMP_DB_NAME, TMP_DB_STATEMENT, TMP_DB_OPERATION, TMP_DB_MSSQL_INSTANCE_NAME, TMP_DB_CASSANDRA_KEYSPACE, TMP_DB_CASSANDRA_PAGE_SIZE, TMP_DB_CASSANDRA_CONSISTENCY_LEVEL, TMP_DB_CASSANDRA_TABLE, TMP_DB_CASSANDRA_IDEMPOTENCE, TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT, TMP_DB_CASSANDRA_COORDINATOR_ID, TMP_DB_CASSANDRA_COORDINATOR_DC, TMP_DB_HBASE_NAMESPACE, TMP_DB_REDIS_DATABASE_INDEX, TMP_DB_MONGODB_COLLECTION, TMP_DB_SQL_TABLE, TMP_EXCEPTION_TYPE, TMP_EXCEPTION_MESSAGE, TMP_EXCEPTION_STACKTRACE, TMP_EXCEPTION_ESCAPED, TMP_FAAS_TRIGGER, TMP_FAAS_EXECUTION, TMP_FAAS_DOCUMENT_COLLECTION, TMP_FAAS_DOCUMENT_OPERATION, TMP_FAAS_DOCUMENT_TIME, TMP_FAAS_DOCUMENT_NAME, TMP_FAAS_TIME, TMP_FAAS_CRON, TMP_FAAS_COLDSTART, TMP_FAAS_INVOKED_NAME, TMP_FAAS_INVOKED_PROVIDER, TMP_FAAS_INVOKED_REGION, TMP_NET_TRANSPORT, TMP_NET_PEER_IP, TMP_NET_PEER_PORT, TMP_NET_PEER_NAME, TMP_NET_HOST_IP, TMP_NET_HOST_PORT, TMP_NET_HOST_NAME, TMP_NET_HOST_CONNECTION_TYPE, TMP_NET_HOST_CONNECTION_SUBTYPE, TMP_NET_HOST_CARRIER_NAME, TMP_NET_HOST_CARRIER_MCC, TMP_NET_HOST_CARRIER_MNC, TMP_NET_HOST_CARRIER_ICC, TMP_PEER_SERVICE, TMP_ENDUSER_ID, TMP_ENDUSER_ROLE, TMP_ENDUSER_SCOPE, TMP_THREAD_ID, TMP_THREAD_NAME, TMP_CODE_FUNCTION, TMP_CODE_NAMESPACE, TMP_CODE_FILEPATH, TMP_CODE_LINENO, TMP_HTTP_METHOD, TMP_HTTP_URL, TMP_HTTP_TARGET, TMP_HTTP_HOST, TMP_HTTP_SCHEME, TMP_HTTP_STATUS_CODE, TMP_HTTP_FLAVOR, TMP_HTTP_USER_AGENT, TMP_HTTP_REQUEST_CONTENT_LENGTH, TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED, TMP_HTTP_RESPONSE_CONTENT_LENGTH, TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED, TMP_HTTP_SERVER_NAME, TMP_HTTP_ROUTE, TMP_HTTP_CLIENT_IP, TMP_AWS_DYNAMODB_TABLE_NAMES, TMP_AWS_DYNAMODB_CONSUMED_CAPACITY, TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS, TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY, TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY, TMP_AWS_DYNAMODB_CONSISTENT_READ, TMP_AWS_DYNAMODB_PROJECTION, TMP_AWS_DYNAMODB_LIMIT, TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET, TMP_AWS_DYNAMODB_INDEX_NAME, TMP_AWS_DYNAMODB_SELECT, TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES, TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES, TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE, TMP_AWS_DYNAMODB_TABLE_COUNT, TMP_AWS_DYNAMODB_SCAN_FORWARD, TMP_AWS_DYNAMODB_SEGMENT, TMP_AWS_DYNAMODB_TOTAL_SEGMENTS, TMP_AWS_DYNAMODB_COUNT, TMP_AWS_DYNAMODB_SCANNED_COUNT, TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS, TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES, TMP_MESSAGING_SYSTEM, TMP_MESSAGING_DESTINATION, TMP_MESSAGING_DESTINATION_KIND, TMP_MESSAGING_TEMP_DESTINATION, TMP_MESSAGING_PROTOCOL, TMP_MESSAGING_PROTOCOL_VERSION, TMP_MESSAGING_URL, TMP_MESSAGING_MESSAGE_ID, TMP_MESSAGING_CONVERSATION_ID, TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES, TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES, TMP_MESSAGING_OPERATION, TMP_MESSAGING_CONSUMER_ID, TMP_MESSAGING_RABBITMQ_ROUTING_KEY, TMP_MESSAGING_KAFKA_MESSAGE_KEY, TMP_MESSAGING_KAFKA_CONSUMER_GROUP, TMP_MESSAGING_KAFKA_CLIENT_ID, TMP_MESSAGING_KAFKA_PARTITION, TMP_MESSAGING_KAFKA_TOMBSTONE, TMP_RPC_SYSTEM, TMP_RPC_SERVICE, TMP_RPC_METHOD, TMP_RPC_GRPC_STATUS_CODE, TMP_RPC_JSONRPC_VERSION, TMP_RPC_JSONRPC_REQUEST_ID, TMP_RPC_JSONRPC_ERROR_CODE, TMP_RPC_JSONRPC_ERROR_MESSAGE, TMP_MESSAGE_TYPE, TMP_MESSAGE_ID, TMP_MESSAGE_COMPRESSED_SIZE, TMP_MESSAGE_UNCOMPRESSED_SIZE, SEMATTRS_AWS_LAMBDA_INVOKED_ARN, SEMATTRS_DB_SYSTEM, SEMATTRS_DB_CONNECTION_STRING, SEMATTRS_DB_USER, SEMATTRS_DB_JDBC_DRIVER_CLASSNAME, SEMATTRS_DB_NAME, SEMATTRS_DB_STATEMENT, SEMATTRS_DB_OPERATION, SEMATTRS_DB_MSSQL_INSTANCE_NAME, SEMATTRS_DB_CASSANDRA_KEYSPACE, SEMATTRS_DB_CASSANDRA_PAGE_SIZE, SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL, SEMATTRS_DB_CASSANDRA_TABLE, SEMATTRS_DB_CASSANDRA_IDEMPOTENCE, SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT, SEMATTRS_DB_CASSANDRA_COORDINATOR_ID, SEMATTRS_DB_CASSANDRA_COORDINATOR_DC, SEMATTRS_DB_HBASE_NAMESPACE, SEMATTRS_DB_REDIS_DATABASE_INDEX, SEMATTRS_DB_MONGODB_COLLECTION, SEMATTRS_DB_SQL_TABLE, SEMATTRS_EXCEPTION_TYPE, SEMATTRS_EXCEPTION_MESSAGE, SEMATTRS_EXCEPTION_STACKTRACE, SEMATTRS_EXCEPTION_ESCAPED, SEMATTRS_FAAS_TRIGGER, SEMATTRS_FAAS_EXECUTION, SEMATTRS_FAAS_DOCUMENT_COLLECTION, SEMATTRS_FAAS_DOCUMENT_OPERATION, SEMATTRS_FAAS_DOCUMENT_TIME, SEMATTRS_FAAS_DOCUMENT_NAME, SEMATTRS_FAAS_TIME, SEMATTRS_FAAS_CRON, SEMATTRS_FAAS_COLDSTART, SEMATTRS_FAAS_INVOKED_NAME, SEMATTRS_FAAS_INVOKED_PROVIDER, SEMATTRS_FAAS_INVOKED_REGION, SEMATTRS_NET_TRANSPORT, SEMATTRS_NET_PEER_IP, SEMATTRS_NET_PEER_PORT, SEMATTRS_NET_PEER_NAME, SEMATTRS_NET_HOST_IP, SEMATTRS_NET_HOST_PORT, SEMATTRS_NET_HOST_NAME, SEMATTRS_NET_HOST_CONNECTION_TYPE, SEMATTRS_NET_HOST_CONNECTION_SUBTYPE, SEMATTRS_NET_HOST_CARRIER_NAME, SEMATTRS_NET_HOST_CARRIER_MCC, SEMATTRS_NET_HOST_CARRIER_MNC, SEMATTRS_NET_HOST_CARRIER_ICC, SEMATTRS_PEER_SERVICE, SEMATTRS_ENDUSER_ID, SEMATTRS_ENDUSER_ROLE, SEMATTRS_ENDUSER_SCOPE, SEMATTRS_THREAD_ID, SEMATTRS_THREAD_NAME, SEMATTRS_CODE_FUNCTION, SEMATTRS_CODE_NAMESPACE, SEMATTRS_CODE_FILEPATH, SEMATTRS_CODE_LINENO, SEMATTRS_HTTP_METHOD, SEMATTRS_HTTP_URL, SEMATTRS_HTTP_TARGET, SEMATTRS_HTTP_HOST, SEMATTRS_HTTP_SCHEME, SEMATTRS_HTTP_STATUS_CODE, SEMATTRS_HTTP_FLAVOR, SEMATTRS_HTTP_USER_AGENT, SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH, SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED, SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH, SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED, SEMATTRS_HTTP_SERVER_NAME, SEMATTRS_HTTP_ROUTE, SEMATTRS_HTTP_CLIENT_IP, SEMATTRS_AWS_DYNAMODB_TABLE_NAMES, SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY, SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS, SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY, SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY, SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ, SEMATTRS_AWS_DYNAMODB_PROJECTION, SEMATTRS_AWS_DYNAMODB_LIMIT, SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET, SEMATTRS_AWS_DYNAMODB_INDEX_NAME, SEMATTRS_AWS_DYNAMODB_SELECT, SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES, SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES, SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE, SEMATTRS_AWS_DYNAMODB_TABLE_COUNT, SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD, SEMATTRS_AWS_DYNAMODB_SEGMENT, SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS, SEMATTRS_AWS_DYNAMODB_COUNT, SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT, SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS, SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES, SEMATTRS_MESSAGING_SYSTEM, SEMATTRS_MESSAGING_DESTINATION, SEMATTRS_MESSAGING_DESTINATION_KIND, SEMATTRS_MESSAGING_TEMP_DESTINATION, SEMATTRS_MESSAGING_PROTOCOL, SEMATTRS_MESSAGING_PROTOCOL_VERSION, SEMATTRS_MESSAGING_URL, SEMATTRS_MESSAGING_MESSAGE_ID, SEMATTRS_MESSAGING_CONVERSATION_ID, SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES, SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES, SEMATTRS_MESSAGING_OPERATION, SEMATTRS_MESSAGING_CONSUMER_ID, SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY, SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY, SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP, SEMATTRS_MESSAGING_KAFKA_CLIENT_ID, SEMATTRS_MESSAGING_KAFKA_PARTITION, SEMATTRS_MESSAGING_KAFKA_TOMBSTONE, SEMATTRS_RPC_SYSTEM, SEMATTRS_RPC_SERVICE, SEMATTRS_RPC_METHOD, SEMATTRS_RPC_GRPC_STATUS_CODE, SEMATTRS_RPC_JSONRPC_VERSION, SEMATTRS_RPC_JSONRPC_REQUEST_ID, SEMATTRS_RPC_JSONRPC_ERROR_CODE, SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE, SEMATTRS_MESSAGE_TYPE, SEMATTRS_MESSAGE_ID, SEMATTRS_MESSAGE_COMPRESSED_SIZE, SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE, SemanticAttributes, TMP_DBSYSTEMVALUES_OTHER_SQL, TMP_DBSYSTEMVALUES_MSSQL, TMP_DBSYSTEMVALUES_MYSQL, TMP_DBSYSTEMVALUES_ORACLE, TMP_DBSYSTEMVALUES_DB2, TMP_DBSYSTEMVALUES_POSTGRESQL, TMP_DBSYSTEMVALUES_REDSHIFT, TMP_DBSYSTEMVALUES_HIVE, TMP_DBSYSTEMVALUES_CLOUDSCAPE, TMP_DBSYSTEMVALUES_HSQLDB, TMP_DBSYSTEMVALUES_PROGRESS, TMP_DBSYSTEMVALUES_MAXDB, TMP_DBSYSTEMVALUES_HANADB, TMP_DBSYSTEMVALUES_INGRES, TMP_DBSYSTEMVALUES_FIRSTSQL, TMP_DBSYSTEMVALUES_EDB, TMP_DBSYSTEMVALUES_CACHE, TMP_DBSYSTEMVALUES_ADABAS, TMP_DBSYSTEMVALUES_FIREBIRD, TMP_DBSYSTEMVALUES_DERBY, TMP_DBSYSTEMVALUES_FILEMAKER, TMP_DBSYSTEMVALUES_INFORMIX, TMP_DBSYSTEMVALUES_INSTANTDB, TMP_DBSYSTEMVALUES_INTERBASE, TMP_DBSYSTEMVALUES_MARIADB, TMP_DBSYSTEMVALUES_NETEZZA, TMP_DBSYSTEMVALUES_PERVASIVE, TMP_DBSYSTEMVALUES_POINTBASE, TMP_DBSYSTEMVALUES_SQLITE, TMP_DBSYSTEMVALUES_SYBASE, TMP_DBSYSTEMVALUES_TERADATA, TMP_DBSYSTEMVALUES_VERTICA, TMP_DBSYSTEMVALUES_H2, TMP_DBSYSTEMVALUES_COLDFUSION, TMP_DBSYSTEMVALUES_CASSANDRA, TMP_DBSYSTEMVALUES_HBASE, TMP_DBSYSTEMVALUES_MONGODB, TMP_DBSYSTEMVALUES_REDIS, TMP_DBSYSTEMVALUES_COUCHBASE, TMP_DBSYSTEMVALUES_COUCHDB, TMP_DBSYSTEMVALUES_COSMOSDB, TMP_DBSYSTEMVALUES_DYNAMODB, TMP_DBSYSTEMVALUES_NEO4J, TMP_DBSYSTEMVALUES_GEODE, TMP_DBSYSTEMVALUES_ELASTICSEARCH, TMP_DBSYSTEMVALUES_MEMCACHED, TMP_DBSYSTEMVALUES_COCKROACHDB, DBSYSTEMVALUES_OTHER_SQL, DBSYSTEMVALUES_MSSQL, DBSYSTEMVALUES_MYSQL, DBSYSTEMVALUES_ORACLE, DBSYSTEMVALUES_DB2, DBSYSTEMVALUES_POSTGRESQL, DBSYSTEMVALUES_REDSHIFT, DBSYSTEMVALUES_HIVE, DBSYSTEMVALUES_CLOUDSCAPE, DBSYSTEMVALUES_HSQLDB, DBSYSTEMVALUES_PROGRESS, DBSYSTEMVALUES_MAXDB, DBSYSTEMVALUES_HANADB, DBSYSTEMVALUES_INGRES, DBSYSTEMVALUES_FIRSTSQL, DBSYSTEMVALUES_EDB, DBSYSTEMVALUES_CACHE, DBSYSTEMVALUES_ADABAS, DBSYSTEMVALUES_FIREBIRD, DBSYSTEMVALUES_DERBY, DBSYSTEMVALUES_FILEMAKER, DBSYSTEMVALUES_INFORMIX, DBSYSTEMVALUES_INSTANTDB, DBSYSTEMVALUES_INTERBASE, DBSYSTEMVALUES_MARIADB, DBSYSTEMVALUES_NETEZZA, DBSYSTEMVALUES_PERVASIVE, DBSYSTEMVALUES_POINTBASE, DBSYSTEMVALUES_SQLITE, DBSYSTEMVALUES_SYBASE, DBSYSTEMVALUES_TERADATA, DBSYSTEMVALUES_VERTICA, DBSYSTEMVALUES_H2, DBSYSTEMVALUES_COLDFUSION, DBSYSTEMVALUES_CASSANDRA, DBSYSTEMVALUES_HBASE, DBSYSTEMVALUES_MONGODB, DBSYSTEMVALUES_REDIS, DBSYSTEMVALUES_COUCHBASE, DBSYSTEMVALUES_COUCHDB, DBSYSTEMVALUES_COSMOSDB, DBSYSTEMVALUES_DYNAMODB, DBSYSTEMVALUES_NEO4J, DBSYSTEMVALUES_GEODE, DBSYSTEMVALUES_ELASTICSEARCH, DBSYSTEMVALUES_MEMCACHED, DBSYSTEMVALUES_COCKROACHDB, DbSystemValues, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL, DBCASSANDRACONSISTENCYLEVELVALUES_ALL, DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM, DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM, DBCASSANDRACONSISTENCYLEVELVALUES_ONE, DBCASSANDRACONSISTENCYLEVELVALUES_TWO, DBCASSANDRACONSISTENCYLEVELVALUES_THREE, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE, DBCASSANDRACONSISTENCYLEVELVALUES_ANY, DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL, DbCassandraConsistencyLevelValues, TMP_FAASTRIGGERVALUES_DATASOURCE, TMP_FAASTRIGGERVALUES_HTTP, TMP_FAASTRIGGERVALUES_PUBSUB, TMP_FAASTRIGGERVALUES_TIMER, TMP_FAASTRIGGERVALUES_OTHER, FAASTRIGGERVALUES_DATASOURCE, FAASTRIGGERVALUES_HTTP, FAASTRIGGERVALUES_PUBSUB, FAASTRIGGERVALUES_TIMER, FAASTRIGGERVALUES_OTHER, FaasTriggerValues, TMP_FAASDOCUMENTOPERATIONVALUES_INSERT, TMP_FAASDOCUMENTOPERATIONVALUES_EDIT, TMP_FAASDOCUMENTOPERATIONVALUES_DELETE, FAASDOCUMENTOPERATIONVALUES_INSERT, FAASDOCUMENTOPERATIONVALUES_EDIT, FAASDOCUMENTOPERATIONVALUES_DELETE, FaasDocumentOperationValues, TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD, TMP_FAASINVOKEDPROVIDERVALUES_AWS, TMP_FAASINVOKEDPROVIDERVALUES_AZURE, TMP_FAASINVOKEDPROVIDERVALUES_GCP, FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD, FAASINVOKEDPROVIDERVALUES_AWS, FAASINVOKEDPROVIDERVALUES_AZURE, FAASINVOKEDPROVIDERVALUES_GCP, FaasInvokedProviderValues, TMP_NETTRANSPORTVALUES_IP_TCP, TMP_NETTRANSPORTVALUES_IP_UDP, TMP_NETTRANSPORTVALUES_IP, TMP_NETTRANSPORTVALUES_UNIX, TMP_NETTRANSPORTVALUES_PIPE, TMP_NETTRANSPORTVALUES_INPROC, TMP_NETTRANSPORTVALUES_OTHER, NETTRANSPORTVALUES_IP_TCP, NETTRANSPORTVALUES_IP_UDP, NETTRANSPORTVALUES_IP, NETTRANSPORTVALUES_UNIX, NETTRANSPORTVALUES_PIPE, NETTRANSPORTVALUES_INPROC, NETTRANSPORTVALUES_OTHER, NetTransportValues, TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI, TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED, TMP_NETHOSTCONNECTIONTYPEVALUES_CELL, TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE, TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN, NETHOSTCONNECTIONTYPEVALUES_WIFI, NETHOSTCONNECTIONTYPEVALUES_WIRED, NETHOSTCONNECTIONTYPEVALUES_CELL, NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE, NETHOSTCONNECTIONTYPEVALUES_UNKNOWN, NetHostConnectionTypeValues, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA, NETHOSTCONNECTIONSUBTYPEVALUES_GPRS, NETHOSTCONNECTIONSUBTYPEVALUES_EDGE, NETHOSTCONNECTIONSUBTYPEVALUES_UMTS, NETHOSTCONNECTIONSUBTYPEVALUES_CDMA, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A, NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT, NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA, NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA, NETHOSTCONNECTIONSUBTYPEVALUES_HSPA, NETHOSTCONNECTIONSUBTYPEVALUES_IDEN, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B, NETHOSTCONNECTIONSUBTYPEVALUES_LTE, NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD, NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP, NETHOSTCONNECTIONSUBTYPEVALUES_GSM, NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA, NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN, NETHOSTCONNECTIONSUBTYPEVALUES_NR, NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA, NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA, NetHostConnectionSubtypeValues, TMP_HTTPFLAVORVALUES_HTTP_1_0, TMP_HTTPFLAVORVALUES_HTTP_1_1, TMP_HTTPFLAVORVALUES_HTTP_2_0, TMP_HTTPFLAVORVALUES_SPDY, TMP_HTTPFLAVORVALUES_QUIC, HTTPFLAVORVALUES_HTTP_1_0, HTTPFLAVORVALUES_HTTP_1_1, HTTPFLAVORVALUES_HTTP_2_0, HTTPFLAVORVALUES_SPDY, HTTPFLAVORVALUES_QUIC, HttpFlavorValues, TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE, TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC, MESSAGINGDESTINATIONKINDVALUES_QUEUE, MESSAGINGDESTINATIONKINDVALUES_TOPIC, MessagingDestinationKindValues, TMP_MESSAGINGOPERATIONVALUES_RECEIVE, TMP_MESSAGINGOPERATIONVALUES_PROCESS, MESSAGINGOPERATIONVALUES_RECEIVE, MESSAGINGOPERATIONVALUES_PROCESS, MessagingOperationValues, TMP_RPCGRPCSTATUSCODEVALUES_OK, TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED, TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN, TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT, TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED, TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND, TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS, TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED, TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED, TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION, TMP_RPCGRPCSTATUSCODEVALUES_ABORTED, TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE, TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED, TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL, TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE, TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS, TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED, RPCGRPCSTATUSCODEVALUES_OK, RPCGRPCSTATUSCODEVALUES_CANCELLED, RPCGRPCSTATUSCODEVALUES_UNKNOWN, RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT, RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED, RPCGRPCSTATUSCODEVALUES_NOT_FOUND, RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS, RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED, RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED, RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION, RPCGRPCSTATUSCODEVALUES_ABORTED, RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE, RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED, RPCGRPCSTATUSCODEVALUES_INTERNAL, RPCGRPCSTATUSCODEVALUES_UNAVAILABLE, RPCGRPCSTATUSCODEVALUES_DATA_LOSS, RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED, RpcGrpcStatusCodeValues, TMP_MESSAGETYPEVALUES_SENT, TMP_MESSAGETYPEVALUES_RECEIVED, MESSAGETYPEVALUES_SENT, MESSAGETYPEVALUES_RECEIVED, MessageTypeValues;
var init_SemanticAttributes = __esm({
  "node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js"() {
    init_utils3();
    TMP_AWS_LAMBDA_INVOKED_ARN = "aws.lambda.invoked_arn";
    TMP_DB_SYSTEM = "db.system";
    TMP_DB_CONNECTION_STRING = "db.connection_string";
    TMP_DB_USER = "db.user";
    TMP_DB_JDBC_DRIVER_CLASSNAME = "db.jdbc.driver_classname";
    TMP_DB_NAME = "db.name";
    TMP_DB_STATEMENT = "db.statement";
    TMP_DB_OPERATION = "db.operation";
    TMP_DB_MSSQL_INSTANCE_NAME = "db.mssql.instance_name";
    TMP_DB_CASSANDRA_KEYSPACE = "db.cassandra.keyspace";
    TMP_DB_CASSANDRA_PAGE_SIZE = "db.cassandra.page_size";
    TMP_DB_CASSANDRA_CONSISTENCY_LEVEL = "db.cassandra.consistency_level";
    TMP_DB_CASSANDRA_TABLE = "db.cassandra.table";
    TMP_DB_CASSANDRA_IDEMPOTENCE = "db.cassandra.idempotence";
    TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = "db.cassandra.speculative_execution_count";
    TMP_DB_CASSANDRA_COORDINATOR_ID = "db.cassandra.coordinator.id";
    TMP_DB_CASSANDRA_COORDINATOR_DC = "db.cassandra.coordinator.dc";
    TMP_DB_HBASE_NAMESPACE = "db.hbase.namespace";
    TMP_DB_REDIS_DATABASE_INDEX = "db.redis.database_index";
    TMP_DB_MONGODB_COLLECTION = "db.mongodb.collection";
    TMP_DB_SQL_TABLE = "db.sql.table";
    TMP_EXCEPTION_TYPE = "exception.type";
    TMP_EXCEPTION_MESSAGE = "exception.message";
    TMP_EXCEPTION_STACKTRACE = "exception.stacktrace";
    TMP_EXCEPTION_ESCAPED = "exception.escaped";
    TMP_FAAS_TRIGGER = "faas.trigger";
    TMP_FAAS_EXECUTION = "faas.execution";
    TMP_FAAS_DOCUMENT_COLLECTION = "faas.document.collection";
    TMP_FAAS_DOCUMENT_OPERATION = "faas.document.operation";
    TMP_FAAS_DOCUMENT_TIME = "faas.document.time";
    TMP_FAAS_DOCUMENT_NAME = "faas.document.name";
    TMP_FAAS_TIME = "faas.time";
    TMP_FAAS_CRON = "faas.cron";
    TMP_FAAS_COLDSTART = "faas.coldstart";
    TMP_FAAS_INVOKED_NAME = "faas.invoked_name";
    TMP_FAAS_INVOKED_PROVIDER = "faas.invoked_provider";
    TMP_FAAS_INVOKED_REGION = "faas.invoked_region";
    TMP_NET_TRANSPORT = "net.transport";
    TMP_NET_PEER_IP = "net.peer.ip";
    TMP_NET_PEER_PORT = "net.peer.port";
    TMP_NET_PEER_NAME = "net.peer.name";
    TMP_NET_HOST_IP = "net.host.ip";
    TMP_NET_HOST_PORT = "net.host.port";
    TMP_NET_HOST_NAME = "net.host.name";
    TMP_NET_HOST_CONNECTION_TYPE = "net.host.connection.type";
    TMP_NET_HOST_CONNECTION_SUBTYPE = "net.host.connection.subtype";
    TMP_NET_HOST_CARRIER_NAME = "net.host.carrier.name";
    TMP_NET_HOST_CARRIER_MCC = "net.host.carrier.mcc";
    TMP_NET_HOST_CARRIER_MNC = "net.host.carrier.mnc";
    TMP_NET_HOST_CARRIER_ICC = "net.host.carrier.icc";
    TMP_PEER_SERVICE = "peer.service";
    TMP_ENDUSER_ID = "enduser.id";
    TMP_ENDUSER_ROLE = "enduser.role";
    TMP_ENDUSER_SCOPE = "enduser.scope";
    TMP_THREAD_ID = "thread.id";
    TMP_THREAD_NAME = "thread.name";
    TMP_CODE_FUNCTION = "code.function";
    TMP_CODE_NAMESPACE = "code.namespace";
    TMP_CODE_FILEPATH = "code.filepath";
    TMP_CODE_LINENO = "code.lineno";
    TMP_HTTP_METHOD = "http.method";
    TMP_HTTP_URL = "http.url";
    TMP_HTTP_TARGET = "http.target";
    TMP_HTTP_HOST = "http.host";
    TMP_HTTP_SCHEME = "http.scheme";
    TMP_HTTP_STATUS_CODE = "http.status_code";
    TMP_HTTP_FLAVOR = "http.flavor";
    TMP_HTTP_USER_AGENT = "http.user_agent";
    TMP_HTTP_REQUEST_CONTENT_LENGTH = "http.request_content_length";
    TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = "http.request_content_length_uncompressed";
    TMP_HTTP_RESPONSE_CONTENT_LENGTH = "http.response_content_length";
    TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = "http.response_content_length_uncompressed";
    TMP_HTTP_SERVER_NAME = "http.server_name";
    TMP_HTTP_ROUTE = "http.route";
    TMP_HTTP_CLIENT_IP = "http.client_ip";
    TMP_AWS_DYNAMODB_TABLE_NAMES = "aws.dynamodb.table_names";
    TMP_AWS_DYNAMODB_CONSUMED_CAPACITY = "aws.dynamodb.consumed_capacity";
    TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = "aws.dynamodb.item_collection_metrics";
    TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = "aws.dynamodb.provisioned_read_capacity";
    TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = "aws.dynamodb.provisioned_write_capacity";
    TMP_AWS_DYNAMODB_CONSISTENT_READ = "aws.dynamodb.consistent_read";
    TMP_AWS_DYNAMODB_PROJECTION = "aws.dynamodb.projection";
    TMP_AWS_DYNAMODB_LIMIT = "aws.dynamodb.limit";
    TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET = "aws.dynamodb.attributes_to_get";
    TMP_AWS_DYNAMODB_INDEX_NAME = "aws.dynamodb.index_name";
    TMP_AWS_DYNAMODB_SELECT = "aws.dynamodb.select";
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = "aws.dynamodb.global_secondary_indexes";
    TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = "aws.dynamodb.local_secondary_indexes";
    TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = "aws.dynamodb.exclusive_start_table";
    TMP_AWS_DYNAMODB_TABLE_COUNT = "aws.dynamodb.table_count";
    TMP_AWS_DYNAMODB_SCAN_FORWARD = "aws.dynamodb.scan_forward";
    TMP_AWS_DYNAMODB_SEGMENT = "aws.dynamodb.segment";
    TMP_AWS_DYNAMODB_TOTAL_SEGMENTS = "aws.dynamodb.total_segments";
    TMP_AWS_DYNAMODB_COUNT = "aws.dynamodb.count";
    TMP_AWS_DYNAMODB_SCANNED_COUNT = "aws.dynamodb.scanned_count";
    TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = "aws.dynamodb.attribute_definitions";
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = "aws.dynamodb.global_secondary_index_updates";
    TMP_MESSAGING_SYSTEM = "messaging.system";
    TMP_MESSAGING_DESTINATION = "messaging.destination";
    TMP_MESSAGING_DESTINATION_KIND = "messaging.destination_kind";
    TMP_MESSAGING_TEMP_DESTINATION = "messaging.temp_destination";
    TMP_MESSAGING_PROTOCOL = "messaging.protocol";
    TMP_MESSAGING_PROTOCOL_VERSION = "messaging.protocol_version";
    TMP_MESSAGING_URL = "messaging.url";
    TMP_MESSAGING_MESSAGE_ID = "messaging.message_id";
    TMP_MESSAGING_CONVERSATION_ID = "messaging.conversation_id";
    TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = "messaging.message_payload_size_bytes";
    TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = "messaging.message_payload_compressed_size_bytes";
    TMP_MESSAGING_OPERATION = "messaging.operation";
    TMP_MESSAGING_CONSUMER_ID = "messaging.consumer_id";
    TMP_MESSAGING_RABBITMQ_ROUTING_KEY = "messaging.rabbitmq.routing_key";
    TMP_MESSAGING_KAFKA_MESSAGE_KEY = "messaging.kafka.message_key";
    TMP_MESSAGING_KAFKA_CONSUMER_GROUP = "messaging.kafka.consumer_group";
    TMP_MESSAGING_KAFKA_CLIENT_ID = "messaging.kafka.client_id";
    TMP_MESSAGING_KAFKA_PARTITION = "messaging.kafka.partition";
    TMP_MESSAGING_KAFKA_TOMBSTONE = "messaging.kafka.tombstone";
    TMP_RPC_SYSTEM = "rpc.system";
    TMP_RPC_SERVICE = "rpc.service";
    TMP_RPC_METHOD = "rpc.method";
    TMP_RPC_GRPC_STATUS_CODE = "rpc.grpc.status_code";
    TMP_RPC_JSONRPC_VERSION = "rpc.jsonrpc.version";
    TMP_RPC_JSONRPC_REQUEST_ID = "rpc.jsonrpc.request_id";
    TMP_RPC_JSONRPC_ERROR_CODE = "rpc.jsonrpc.error_code";
    TMP_RPC_JSONRPC_ERROR_MESSAGE = "rpc.jsonrpc.error_message";
    TMP_MESSAGE_TYPE = "message.type";
    TMP_MESSAGE_ID = "message.id";
    TMP_MESSAGE_COMPRESSED_SIZE = "message.compressed_size";
    TMP_MESSAGE_UNCOMPRESSED_SIZE = "message.uncompressed_size";
    SEMATTRS_AWS_LAMBDA_INVOKED_ARN = TMP_AWS_LAMBDA_INVOKED_ARN;
    SEMATTRS_DB_SYSTEM = TMP_DB_SYSTEM;
    SEMATTRS_DB_CONNECTION_STRING = TMP_DB_CONNECTION_STRING;
    SEMATTRS_DB_USER = TMP_DB_USER;
    SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = TMP_DB_JDBC_DRIVER_CLASSNAME;
    SEMATTRS_DB_NAME = TMP_DB_NAME;
    SEMATTRS_DB_STATEMENT = TMP_DB_STATEMENT;
    SEMATTRS_DB_OPERATION = TMP_DB_OPERATION;
    SEMATTRS_DB_MSSQL_INSTANCE_NAME = TMP_DB_MSSQL_INSTANCE_NAME;
    SEMATTRS_DB_CASSANDRA_KEYSPACE = TMP_DB_CASSANDRA_KEYSPACE;
    SEMATTRS_DB_CASSANDRA_PAGE_SIZE = TMP_DB_CASSANDRA_PAGE_SIZE;
    SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL;
    SEMATTRS_DB_CASSANDRA_TABLE = TMP_DB_CASSANDRA_TABLE;
    SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = TMP_DB_CASSANDRA_IDEMPOTENCE;
    SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT;
    SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = TMP_DB_CASSANDRA_COORDINATOR_ID;
    SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = TMP_DB_CASSANDRA_COORDINATOR_DC;
    SEMATTRS_DB_HBASE_NAMESPACE = TMP_DB_HBASE_NAMESPACE;
    SEMATTRS_DB_REDIS_DATABASE_INDEX = TMP_DB_REDIS_DATABASE_INDEX;
    SEMATTRS_DB_MONGODB_COLLECTION = TMP_DB_MONGODB_COLLECTION;
    SEMATTRS_DB_SQL_TABLE = TMP_DB_SQL_TABLE;
    SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE;
    SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE;
    SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE;
    SEMATTRS_EXCEPTION_ESCAPED = TMP_EXCEPTION_ESCAPED;
    SEMATTRS_FAAS_TRIGGER = TMP_FAAS_TRIGGER;
    SEMATTRS_FAAS_EXECUTION = TMP_FAAS_EXECUTION;
    SEMATTRS_FAAS_DOCUMENT_COLLECTION = TMP_FAAS_DOCUMENT_COLLECTION;
    SEMATTRS_FAAS_DOCUMENT_OPERATION = TMP_FAAS_DOCUMENT_OPERATION;
    SEMATTRS_FAAS_DOCUMENT_TIME = TMP_FAAS_DOCUMENT_TIME;
    SEMATTRS_FAAS_DOCUMENT_NAME = TMP_FAAS_DOCUMENT_NAME;
    SEMATTRS_FAAS_TIME = TMP_FAAS_TIME;
    SEMATTRS_FAAS_CRON = TMP_FAAS_CRON;
    SEMATTRS_FAAS_COLDSTART = TMP_FAAS_COLDSTART;
    SEMATTRS_FAAS_INVOKED_NAME = TMP_FAAS_INVOKED_NAME;
    SEMATTRS_FAAS_INVOKED_PROVIDER = TMP_FAAS_INVOKED_PROVIDER;
    SEMATTRS_FAAS_INVOKED_REGION = TMP_FAAS_INVOKED_REGION;
    SEMATTRS_NET_TRANSPORT = TMP_NET_TRANSPORT;
    SEMATTRS_NET_PEER_IP = TMP_NET_PEER_IP;
    SEMATTRS_NET_PEER_PORT = TMP_NET_PEER_PORT;
    SEMATTRS_NET_PEER_NAME = TMP_NET_PEER_NAME;
    SEMATTRS_NET_HOST_IP = TMP_NET_HOST_IP;
    SEMATTRS_NET_HOST_PORT = TMP_NET_HOST_PORT;
    SEMATTRS_NET_HOST_NAME = TMP_NET_HOST_NAME;
    SEMATTRS_NET_HOST_CONNECTION_TYPE = TMP_NET_HOST_CONNECTION_TYPE;
    SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = TMP_NET_HOST_CONNECTION_SUBTYPE;
    SEMATTRS_NET_HOST_CARRIER_NAME = TMP_NET_HOST_CARRIER_NAME;
    SEMATTRS_NET_HOST_CARRIER_MCC = TMP_NET_HOST_CARRIER_MCC;
    SEMATTRS_NET_HOST_CARRIER_MNC = TMP_NET_HOST_CARRIER_MNC;
    SEMATTRS_NET_HOST_CARRIER_ICC = TMP_NET_HOST_CARRIER_ICC;
    SEMATTRS_PEER_SERVICE = TMP_PEER_SERVICE;
    SEMATTRS_ENDUSER_ID = TMP_ENDUSER_ID;
    SEMATTRS_ENDUSER_ROLE = TMP_ENDUSER_ROLE;
    SEMATTRS_ENDUSER_SCOPE = TMP_ENDUSER_SCOPE;
    SEMATTRS_THREAD_ID = TMP_THREAD_ID;
    SEMATTRS_THREAD_NAME = TMP_THREAD_NAME;
    SEMATTRS_CODE_FUNCTION = TMP_CODE_FUNCTION;
    SEMATTRS_CODE_NAMESPACE = TMP_CODE_NAMESPACE;
    SEMATTRS_CODE_FILEPATH = TMP_CODE_FILEPATH;
    SEMATTRS_CODE_LINENO = TMP_CODE_LINENO;
    SEMATTRS_HTTP_METHOD = TMP_HTTP_METHOD;
    SEMATTRS_HTTP_URL = TMP_HTTP_URL;
    SEMATTRS_HTTP_TARGET = TMP_HTTP_TARGET;
    SEMATTRS_HTTP_HOST = TMP_HTTP_HOST;
    SEMATTRS_HTTP_SCHEME = TMP_HTTP_SCHEME;
    SEMATTRS_HTTP_STATUS_CODE = TMP_HTTP_STATUS_CODE;
    SEMATTRS_HTTP_FLAVOR = TMP_HTTP_FLAVOR;
    SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT;
    SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = TMP_HTTP_REQUEST_CONTENT_LENGTH;
    SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED;
    SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = TMP_HTTP_RESPONSE_CONTENT_LENGTH;
    SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED;
    SEMATTRS_HTTP_SERVER_NAME = TMP_HTTP_SERVER_NAME;
    SEMATTRS_HTTP_ROUTE = TMP_HTTP_ROUTE;
    SEMATTRS_HTTP_CLIENT_IP = TMP_HTTP_CLIENT_IP;
    SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = TMP_AWS_DYNAMODB_TABLE_NAMES;
    SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY;
    SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS;
    SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY;
    SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY;
    SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = TMP_AWS_DYNAMODB_CONSISTENT_READ;
    SEMATTRS_AWS_DYNAMODB_PROJECTION = TMP_AWS_DYNAMODB_PROJECTION;
    SEMATTRS_AWS_DYNAMODB_LIMIT = TMP_AWS_DYNAMODB_LIMIT;
    SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET;
    SEMATTRS_AWS_DYNAMODB_INDEX_NAME = TMP_AWS_DYNAMODB_INDEX_NAME;
    SEMATTRS_AWS_DYNAMODB_SELECT = TMP_AWS_DYNAMODB_SELECT;
    SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES;
    SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES;
    SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE;
    SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = TMP_AWS_DYNAMODB_TABLE_COUNT;
    SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = TMP_AWS_DYNAMODB_SCAN_FORWARD;
    SEMATTRS_AWS_DYNAMODB_SEGMENT = TMP_AWS_DYNAMODB_SEGMENT;
    SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS;
    SEMATTRS_AWS_DYNAMODB_COUNT = TMP_AWS_DYNAMODB_COUNT;
    SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = TMP_AWS_DYNAMODB_SCANNED_COUNT;
    SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS;
    SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES;
    SEMATTRS_MESSAGING_SYSTEM = TMP_MESSAGING_SYSTEM;
    SEMATTRS_MESSAGING_DESTINATION = TMP_MESSAGING_DESTINATION;
    SEMATTRS_MESSAGING_DESTINATION_KIND = TMP_MESSAGING_DESTINATION_KIND;
    SEMATTRS_MESSAGING_TEMP_DESTINATION = TMP_MESSAGING_TEMP_DESTINATION;
    SEMATTRS_MESSAGING_PROTOCOL = TMP_MESSAGING_PROTOCOL;
    SEMATTRS_MESSAGING_PROTOCOL_VERSION = TMP_MESSAGING_PROTOCOL_VERSION;
    SEMATTRS_MESSAGING_URL = TMP_MESSAGING_URL;
    SEMATTRS_MESSAGING_MESSAGE_ID = TMP_MESSAGING_MESSAGE_ID;
    SEMATTRS_MESSAGING_CONVERSATION_ID = TMP_MESSAGING_CONVERSATION_ID;
    SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES;
    SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES;
    SEMATTRS_MESSAGING_OPERATION = TMP_MESSAGING_OPERATION;
    SEMATTRS_MESSAGING_CONSUMER_ID = TMP_MESSAGING_CONSUMER_ID;
    SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = TMP_MESSAGING_RABBITMQ_ROUTING_KEY;
    SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = TMP_MESSAGING_KAFKA_MESSAGE_KEY;
    SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = TMP_MESSAGING_KAFKA_CONSUMER_GROUP;
    SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = TMP_MESSAGING_KAFKA_CLIENT_ID;
    SEMATTRS_MESSAGING_KAFKA_PARTITION = TMP_MESSAGING_KAFKA_PARTITION;
    SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = TMP_MESSAGING_KAFKA_TOMBSTONE;
    SEMATTRS_RPC_SYSTEM = TMP_RPC_SYSTEM;
    SEMATTRS_RPC_SERVICE = TMP_RPC_SERVICE;
    SEMATTRS_RPC_METHOD = TMP_RPC_METHOD;
    SEMATTRS_RPC_GRPC_STATUS_CODE = TMP_RPC_GRPC_STATUS_CODE;
    SEMATTRS_RPC_JSONRPC_VERSION = TMP_RPC_JSONRPC_VERSION;
    SEMATTRS_RPC_JSONRPC_REQUEST_ID = TMP_RPC_JSONRPC_REQUEST_ID;
    SEMATTRS_RPC_JSONRPC_ERROR_CODE = TMP_RPC_JSONRPC_ERROR_CODE;
    SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = TMP_RPC_JSONRPC_ERROR_MESSAGE;
    SEMATTRS_MESSAGE_TYPE = TMP_MESSAGE_TYPE;
    SEMATTRS_MESSAGE_ID = TMP_MESSAGE_ID;
    SEMATTRS_MESSAGE_COMPRESSED_SIZE = TMP_MESSAGE_COMPRESSED_SIZE;
    SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = TMP_MESSAGE_UNCOMPRESSED_SIZE;
    SemanticAttributes = /* @__PURE__ */ createConstMap([
      TMP_AWS_LAMBDA_INVOKED_ARN,
      TMP_DB_SYSTEM,
      TMP_DB_CONNECTION_STRING,
      TMP_DB_USER,
      TMP_DB_JDBC_DRIVER_CLASSNAME,
      TMP_DB_NAME,
      TMP_DB_STATEMENT,
      TMP_DB_OPERATION,
      TMP_DB_MSSQL_INSTANCE_NAME,
      TMP_DB_CASSANDRA_KEYSPACE,
      TMP_DB_CASSANDRA_PAGE_SIZE,
      TMP_DB_CASSANDRA_CONSISTENCY_LEVEL,
      TMP_DB_CASSANDRA_TABLE,
      TMP_DB_CASSANDRA_IDEMPOTENCE,
      TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT,
      TMP_DB_CASSANDRA_COORDINATOR_ID,
      TMP_DB_CASSANDRA_COORDINATOR_DC,
      TMP_DB_HBASE_NAMESPACE,
      TMP_DB_REDIS_DATABASE_INDEX,
      TMP_DB_MONGODB_COLLECTION,
      TMP_DB_SQL_TABLE,
      TMP_EXCEPTION_TYPE,
      TMP_EXCEPTION_MESSAGE,
      TMP_EXCEPTION_STACKTRACE,
      TMP_EXCEPTION_ESCAPED,
      TMP_FAAS_TRIGGER,
      TMP_FAAS_EXECUTION,
      TMP_FAAS_DOCUMENT_COLLECTION,
      TMP_FAAS_DOCUMENT_OPERATION,
      TMP_FAAS_DOCUMENT_TIME,
      TMP_FAAS_DOCUMENT_NAME,
      TMP_FAAS_TIME,
      TMP_FAAS_CRON,
      TMP_FAAS_COLDSTART,
      TMP_FAAS_INVOKED_NAME,
      TMP_FAAS_INVOKED_PROVIDER,
      TMP_FAAS_INVOKED_REGION,
      TMP_NET_TRANSPORT,
      TMP_NET_PEER_IP,
      TMP_NET_PEER_PORT,
      TMP_NET_PEER_NAME,
      TMP_NET_HOST_IP,
      TMP_NET_HOST_PORT,
      TMP_NET_HOST_NAME,
      TMP_NET_HOST_CONNECTION_TYPE,
      TMP_NET_HOST_CONNECTION_SUBTYPE,
      TMP_NET_HOST_CARRIER_NAME,
      TMP_NET_HOST_CARRIER_MCC,
      TMP_NET_HOST_CARRIER_MNC,
      TMP_NET_HOST_CARRIER_ICC,
      TMP_PEER_SERVICE,
      TMP_ENDUSER_ID,
      TMP_ENDUSER_ROLE,
      TMP_ENDUSER_SCOPE,
      TMP_THREAD_ID,
      TMP_THREAD_NAME,
      TMP_CODE_FUNCTION,
      TMP_CODE_NAMESPACE,
      TMP_CODE_FILEPATH,
      TMP_CODE_LINENO,
      TMP_HTTP_METHOD,
      TMP_HTTP_URL,
      TMP_HTTP_TARGET,
      TMP_HTTP_HOST,
      TMP_HTTP_SCHEME,
      TMP_HTTP_STATUS_CODE,
      TMP_HTTP_FLAVOR,
      TMP_HTTP_USER_AGENT,
      TMP_HTTP_REQUEST_CONTENT_LENGTH,
      TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,
      TMP_HTTP_SERVER_NAME,
      TMP_HTTP_ROUTE,
      TMP_HTTP_CLIENT_IP,
      TMP_AWS_DYNAMODB_TABLE_NAMES,
      TMP_AWS_DYNAMODB_CONSUMED_CAPACITY,
      TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS,
      TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY,
      TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY,
      TMP_AWS_DYNAMODB_CONSISTENT_READ,
      TMP_AWS_DYNAMODB_PROJECTION,
      TMP_AWS_DYNAMODB_LIMIT,
      TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET,
      TMP_AWS_DYNAMODB_INDEX_NAME,
      TMP_AWS_DYNAMODB_SELECT,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES,
      TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES,
      TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE,
      TMP_AWS_DYNAMODB_TABLE_COUNT,
      TMP_AWS_DYNAMODB_SCAN_FORWARD,
      TMP_AWS_DYNAMODB_SEGMENT,
      TMP_AWS_DYNAMODB_TOTAL_SEGMENTS,
      TMP_AWS_DYNAMODB_COUNT,
      TMP_AWS_DYNAMODB_SCANNED_COUNT,
      TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES,
      TMP_MESSAGING_SYSTEM,
      TMP_MESSAGING_DESTINATION,
      TMP_MESSAGING_DESTINATION_KIND,
      TMP_MESSAGING_TEMP_DESTINATION,
      TMP_MESSAGING_PROTOCOL,
      TMP_MESSAGING_PROTOCOL_VERSION,
      TMP_MESSAGING_URL,
      TMP_MESSAGING_MESSAGE_ID,
      TMP_MESSAGING_CONVERSATION_ID,
      TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES,
      TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES,
      TMP_MESSAGING_OPERATION,
      TMP_MESSAGING_CONSUMER_ID,
      TMP_MESSAGING_RABBITMQ_ROUTING_KEY,
      TMP_MESSAGING_KAFKA_MESSAGE_KEY,
      TMP_MESSAGING_KAFKA_CONSUMER_GROUP,
      TMP_MESSAGING_KAFKA_CLIENT_ID,
      TMP_MESSAGING_KAFKA_PARTITION,
      TMP_MESSAGING_KAFKA_TOMBSTONE,
      TMP_RPC_SYSTEM,
      TMP_RPC_SERVICE,
      TMP_RPC_METHOD,
      TMP_RPC_GRPC_STATUS_CODE,
      TMP_RPC_JSONRPC_VERSION,
      TMP_RPC_JSONRPC_REQUEST_ID,
      TMP_RPC_JSONRPC_ERROR_CODE,
      TMP_RPC_JSONRPC_ERROR_MESSAGE,
      TMP_MESSAGE_TYPE,
      TMP_MESSAGE_ID,
      TMP_MESSAGE_COMPRESSED_SIZE,
      TMP_MESSAGE_UNCOMPRESSED_SIZE
    ]);
    TMP_DBSYSTEMVALUES_OTHER_SQL = "other_sql";
    TMP_DBSYSTEMVALUES_MSSQL = "mssql";
    TMP_DBSYSTEMVALUES_MYSQL = "mysql";
    TMP_DBSYSTEMVALUES_ORACLE = "oracle";
    TMP_DBSYSTEMVALUES_DB2 = "db2";
    TMP_DBSYSTEMVALUES_POSTGRESQL = "postgresql";
    TMP_DBSYSTEMVALUES_REDSHIFT = "redshift";
    TMP_DBSYSTEMVALUES_HIVE = "hive";
    TMP_DBSYSTEMVALUES_CLOUDSCAPE = "cloudscape";
    TMP_DBSYSTEMVALUES_HSQLDB = "hsqldb";
    TMP_DBSYSTEMVALUES_PROGRESS = "progress";
    TMP_DBSYSTEMVALUES_MAXDB = "maxdb";
    TMP_DBSYSTEMVALUES_HANADB = "hanadb";
    TMP_DBSYSTEMVALUES_INGRES = "ingres";
    TMP_DBSYSTEMVALUES_FIRSTSQL = "firstsql";
    TMP_DBSYSTEMVALUES_EDB = "edb";
    TMP_DBSYSTEMVALUES_CACHE = "cache";
    TMP_DBSYSTEMVALUES_ADABAS = "adabas";
    TMP_DBSYSTEMVALUES_FIREBIRD = "firebird";
    TMP_DBSYSTEMVALUES_DERBY = "derby";
    TMP_DBSYSTEMVALUES_FILEMAKER = "filemaker";
    TMP_DBSYSTEMVALUES_INFORMIX = "informix";
    TMP_DBSYSTEMVALUES_INSTANTDB = "instantdb";
    TMP_DBSYSTEMVALUES_INTERBASE = "interbase";
    TMP_DBSYSTEMVALUES_MARIADB = "mariadb";
    TMP_DBSYSTEMVALUES_NETEZZA = "netezza";
    TMP_DBSYSTEMVALUES_PERVASIVE = "pervasive";
    TMP_DBSYSTEMVALUES_POINTBASE = "pointbase";
    TMP_DBSYSTEMVALUES_SQLITE = "sqlite";
    TMP_DBSYSTEMVALUES_SYBASE = "sybase";
    TMP_DBSYSTEMVALUES_TERADATA = "teradata";
    TMP_DBSYSTEMVALUES_VERTICA = "vertica";
    TMP_DBSYSTEMVALUES_H2 = "h2";
    TMP_DBSYSTEMVALUES_COLDFUSION = "coldfusion";
    TMP_DBSYSTEMVALUES_CASSANDRA = "cassandra";
    TMP_DBSYSTEMVALUES_HBASE = "hbase";
    TMP_DBSYSTEMVALUES_MONGODB = "mongodb";
    TMP_DBSYSTEMVALUES_REDIS = "redis";
    TMP_DBSYSTEMVALUES_COUCHBASE = "couchbase";
    TMP_DBSYSTEMVALUES_COUCHDB = "couchdb";
    TMP_DBSYSTEMVALUES_COSMOSDB = "cosmosdb";
    TMP_DBSYSTEMVALUES_DYNAMODB = "dynamodb";
    TMP_DBSYSTEMVALUES_NEO4J = "neo4j";
    TMP_DBSYSTEMVALUES_GEODE = "geode";
    TMP_DBSYSTEMVALUES_ELASTICSEARCH = "elasticsearch";
    TMP_DBSYSTEMVALUES_MEMCACHED = "memcached";
    TMP_DBSYSTEMVALUES_COCKROACHDB = "cockroachdb";
    DBSYSTEMVALUES_OTHER_SQL = TMP_DBSYSTEMVALUES_OTHER_SQL;
    DBSYSTEMVALUES_MSSQL = TMP_DBSYSTEMVALUES_MSSQL;
    DBSYSTEMVALUES_MYSQL = TMP_DBSYSTEMVALUES_MYSQL;
    DBSYSTEMVALUES_ORACLE = TMP_DBSYSTEMVALUES_ORACLE;
    DBSYSTEMVALUES_DB2 = TMP_DBSYSTEMVALUES_DB2;
    DBSYSTEMVALUES_POSTGRESQL = TMP_DBSYSTEMVALUES_POSTGRESQL;
    DBSYSTEMVALUES_REDSHIFT = TMP_DBSYSTEMVALUES_REDSHIFT;
    DBSYSTEMVALUES_HIVE = TMP_DBSYSTEMVALUES_HIVE;
    DBSYSTEMVALUES_CLOUDSCAPE = TMP_DBSYSTEMVALUES_CLOUDSCAPE;
    DBSYSTEMVALUES_HSQLDB = TMP_DBSYSTEMVALUES_HSQLDB;
    DBSYSTEMVALUES_PROGRESS = TMP_DBSYSTEMVALUES_PROGRESS;
    DBSYSTEMVALUES_MAXDB = TMP_DBSYSTEMVALUES_MAXDB;
    DBSYSTEMVALUES_HANADB = TMP_DBSYSTEMVALUES_HANADB;
    DBSYSTEMVALUES_INGRES = TMP_DBSYSTEMVALUES_INGRES;
    DBSYSTEMVALUES_FIRSTSQL = TMP_DBSYSTEMVALUES_FIRSTSQL;
    DBSYSTEMVALUES_EDB = TMP_DBSYSTEMVALUES_EDB;
    DBSYSTEMVALUES_CACHE = TMP_DBSYSTEMVALUES_CACHE;
    DBSYSTEMVALUES_ADABAS = TMP_DBSYSTEMVALUES_ADABAS;
    DBSYSTEMVALUES_FIREBIRD = TMP_DBSYSTEMVALUES_FIREBIRD;
    DBSYSTEMVALUES_DERBY = TMP_DBSYSTEMVALUES_DERBY;
    DBSYSTEMVALUES_FILEMAKER = TMP_DBSYSTEMVALUES_FILEMAKER;
    DBSYSTEMVALUES_INFORMIX = TMP_DBSYSTEMVALUES_INFORMIX;
    DBSYSTEMVALUES_INSTANTDB = TMP_DBSYSTEMVALUES_INSTANTDB;
    DBSYSTEMVALUES_INTERBASE = TMP_DBSYSTEMVALUES_INTERBASE;
    DBSYSTEMVALUES_MARIADB = TMP_DBSYSTEMVALUES_MARIADB;
    DBSYSTEMVALUES_NETEZZA = TMP_DBSYSTEMVALUES_NETEZZA;
    DBSYSTEMVALUES_PERVASIVE = TMP_DBSYSTEMVALUES_PERVASIVE;
    DBSYSTEMVALUES_POINTBASE = TMP_DBSYSTEMVALUES_POINTBASE;
    DBSYSTEMVALUES_SQLITE = TMP_DBSYSTEMVALUES_SQLITE;
    DBSYSTEMVALUES_SYBASE = TMP_DBSYSTEMVALUES_SYBASE;
    DBSYSTEMVALUES_TERADATA = TMP_DBSYSTEMVALUES_TERADATA;
    DBSYSTEMVALUES_VERTICA = TMP_DBSYSTEMVALUES_VERTICA;
    DBSYSTEMVALUES_H2 = TMP_DBSYSTEMVALUES_H2;
    DBSYSTEMVALUES_COLDFUSION = TMP_DBSYSTEMVALUES_COLDFUSION;
    DBSYSTEMVALUES_CASSANDRA = TMP_DBSYSTEMVALUES_CASSANDRA;
    DBSYSTEMVALUES_HBASE = TMP_DBSYSTEMVALUES_HBASE;
    DBSYSTEMVALUES_MONGODB = TMP_DBSYSTEMVALUES_MONGODB;
    DBSYSTEMVALUES_REDIS = TMP_DBSYSTEMVALUES_REDIS;
    DBSYSTEMVALUES_COUCHBASE = TMP_DBSYSTEMVALUES_COUCHBASE;
    DBSYSTEMVALUES_COUCHDB = TMP_DBSYSTEMVALUES_COUCHDB;
    DBSYSTEMVALUES_COSMOSDB = TMP_DBSYSTEMVALUES_COSMOSDB;
    DBSYSTEMVALUES_DYNAMODB = TMP_DBSYSTEMVALUES_DYNAMODB;
    DBSYSTEMVALUES_NEO4J = TMP_DBSYSTEMVALUES_NEO4J;
    DBSYSTEMVALUES_GEODE = TMP_DBSYSTEMVALUES_GEODE;
    DBSYSTEMVALUES_ELASTICSEARCH = TMP_DBSYSTEMVALUES_ELASTICSEARCH;
    DBSYSTEMVALUES_MEMCACHED = TMP_DBSYSTEMVALUES_MEMCACHED;
    DBSYSTEMVALUES_COCKROACHDB = TMP_DBSYSTEMVALUES_COCKROACHDB;
    DbSystemValues = /* @__PURE__ */ createConstMap([
      TMP_DBSYSTEMVALUES_OTHER_SQL,
      TMP_DBSYSTEMVALUES_MSSQL,
      TMP_DBSYSTEMVALUES_MYSQL,
      TMP_DBSYSTEMVALUES_ORACLE,
      TMP_DBSYSTEMVALUES_DB2,
      TMP_DBSYSTEMVALUES_POSTGRESQL,
      TMP_DBSYSTEMVALUES_REDSHIFT,
      TMP_DBSYSTEMVALUES_HIVE,
      TMP_DBSYSTEMVALUES_CLOUDSCAPE,
      TMP_DBSYSTEMVALUES_HSQLDB,
      TMP_DBSYSTEMVALUES_PROGRESS,
      TMP_DBSYSTEMVALUES_MAXDB,
      TMP_DBSYSTEMVALUES_HANADB,
      TMP_DBSYSTEMVALUES_INGRES,
      TMP_DBSYSTEMVALUES_FIRSTSQL,
      TMP_DBSYSTEMVALUES_EDB,
      TMP_DBSYSTEMVALUES_CACHE,
      TMP_DBSYSTEMVALUES_ADABAS,
      TMP_DBSYSTEMVALUES_FIREBIRD,
      TMP_DBSYSTEMVALUES_DERBY,
      TMP_DBSYSTEMVALUES_FILEMAKER,
      TMP_DBSYSTEMVALUES_INFORMIX,
      TMP_DBSYSTEMVALUES_INSTANTDB,
      TMP_DBSYSTEMVALUES_INTERBASE,
      TMP_DBSYSTEMVALUES_MARIADB,
      TMP_DBSYSTEMVALUES_NETEZZA,
      TMP_DBSYSTEMVALUES_PERVASIVE,
      TMP_DBSYSTEMVALUES_POINTBASE,
      TMP_DBSYSTEMVALUES_SQLITE,
      TMP_DBSYSTEMVALUES_SYBASE,
      TMP_DBSYSTEMVALUES_TERADATA,
      TMP_DBSYSTEMVALUES_VERTICA,
      TMP_DBSYSTEMVALUES_H2,
      TMP_DBSYSTEMVALUES_COLDFUSION,
      TMP_DBSYSTEMVALUES_CASSANDRA,
      TMP_DBSYSTEMVALUES_HBASE,
      TMP_DBSYSTEMVALUES_MONGODB,
      TMP_DBSYSTEMVALUES_REDIS,
      TMP_DBSYSTEMVALUES_COUCHBASE,
      TMP_DBSYSTEMVALUES_COUCHDB,
      TMP_DBSYSTEMVALUES_COSMOSDB,
      TMP_DBSYSTEMVALUES_DYNAMODB,
      TMP_DBSYSTEMVALUES_NEO4J,
      TMP_DBSYSTEMVALUES_GEODE,
      TMP_DBSYSTEMVALUES_ELASTICSEARCH,
      TMP_DBSYSTEMVALUES_MEMCACHED,
      TMP_DBSYSTEMVALUES_COCKROACHDB
    ]);
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL = "all";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = "each_quorum";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = "quorum";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = "local_quorum";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE = "one";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO = "two";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE = "three";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = "local_one";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY = "any";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = "serial";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = "local_serial";
    DBCASSANDRACONSISTENCYLEVELVALUES_ALL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL;
    DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM;
    DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM;
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM;
    DBCASSANDRACONSISTENCYLEVELVALUES_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE;
    DBCASSANDRACONSISTENCYLEVELVALUES_TWO = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO;
    DBCASSANDRACONSISTENCYLEVELVALUES_THREE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE;
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE;
    DBCASSANDRACONSISTENCYLEVELVALUES_ANY = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY;
    DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL;
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL;
    DbCassandraConsistencyLevelValues = /* @__PURE__ */ createConstMap([
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL
    ]);
    TMP_FAASTRIGGERVALUES_DATASOURCE = "datasource";
    TMP_FAASTRIGGERVALUES_HTTP = "http";
    TMP_FAASTRIGGERVALUES_PUBSUB = "pubsub";
    TMP_FAASTRIGGERVALUES_TIMER = "timer";
    TMP_FAASTRIGGERVALUES_OTHER = "other";
    FAASTRIGGERVALUES_DATASOURCE = TMP_FAASTRIGGERVALUES_DATASOURCE;
    FAASTRIGGERVALUES_HTTP = TMP_FAASTRIGGERVALUES_HTTP;
    FAASTRIGGERVALUES_PUBSUB = TMP_FAASTRIGGERVALUES_PUBSUB;
    FAASTRIGGERVALUES_TIMER = TMP_FAASTRIGGERVALUES_TIMER;
    FAASTRIGGERVALUES_OTHER = TMP_FAASTRIGGERVALUES_OTHER;
    FaasTriggerValues = /* @__PURE__ */ createConstMap([
      TMP_FAASTRIGGERVALUES_DATASOURCE,
      TMP_FAASTRIGGERVALUES_HTTP,
      TMP_FAASTRIGGERVALUES_PUBSUB,
      TMP_FAASTRIGGERVALUES_TIMER,
      TMP_FAASTRIGGERVALUES_OTHER
    ]);
    TMP_FAASDOCUMENTOPERATIONVALUES_INSERT = "insert";
    TMP_FAASDOCUMENTOPERATIONVALUES_EDIT = "edit";
    TMP_FAASDOCUMENTOPERATIONVALUES_DELETE = "delete";
    FAASDOCUMENTOPERATIONVALUES_INSERT = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT;
    FAASDOCUMENTOPERATIONVALUES_EDIT = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT;
    FAASDOCUMENTOPERATIONVALUES_DELETE = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE;
    FaasDocumentOperationValues = /* @__PURE__ */ createConstMap([
      TMP_FAASDOCUMENTOPERATIONVALUES_INSERT,
      TMP_FAASDOCUMENTOPERATIONVALUES_EDIT,
      TMP_FAASDOCUMENTOPERATIONVALUES_DELETE
    ]);
    TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
    TMP_FAASINVOKEDPROVIDERVALUES_AWS = "aws";
    TMP_FAASINVOKEDPROVIDERVALUES_AZURE = "azure";
    TMP_FAASINVOKEDPROVIDERVALUES_GCP = "gcp";
    FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD;
    FAASINVOKEDPROVIDERVALUES_AWS = TMP_FAASINVOKEDPROVIDERVALUES_AWS;
    FAASINVOKEDPROVIDERVALUES_AZURE = TMP_FAASINVOKEDPROVIDERVALUES_AZURE;
    FAASINVOKEDPROVIDERVALUES_GCP = TMP_FAASINVOKEDPROVIDERVALUES_GCP;
    FaasInvokedProviderValues = /* @__PURE__ */ createConstMap([
      TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD,
      TMP_FAASINVOKEDPROVIDERVALUES_AWS,
      TMP_FAASINVOKEDPROVIDERVALUES_AZURE,
      TMP_FAASINVOKEDPROVIDERVALUES_GCP
    ]);
    TMP_NETTRANSPORTVALUES_IP_TCP = "ip_tcp";
    TMP_NETTRANSPORTVALUES_IP_UDP = "ip_udp";
    TMP_NETTRANSPORTVALUES_IP = "ip";
    TMP_NETTRANSPORTVALUES_UNIX = "unix";
    TMP_NETTRANSPORTVALUES_PIPE = "pipe";
    TMP_NETTRANSPORTVALUES_INPROC = "inproc";
    TMP_NETTRANSPORTVALUES_OTHER = "other";
    NETTRANSPORTVALUES_IP_TCP = TMP_NETTRANSPORTVALUES_IP_TCP;
    NETTRANSPORTVALUES_IP_UDP = TMP_NETTRANSPORTVALUES_IP_UDP;
    NETTRANSPORTVALUES_IP = TMP_NETTRANSPORTVALUES_IP;
    NETTRANSPORTVALUES_UNIX = TMP_NETTRANSPORTVALUES_UNIX;
    NETTRANSPORTVALUES_PIPE = TMP_NETTRANSPORTVALUES_PIPE;
    NETTRANSPORTVALUES_INPROC = TMP_NETTRANSPORTVALUES_INPROC;
    NETTRANSPORTVALUES_OTHER = TMP_NETTRANSPORTVALUES_OTHER;
    NetTransportValues = /* @__PURE__ */ createConstMap([
      TMP_NETTRANSPORTVALUES_IP_TCP,
      TMP_NETTRANSPORTVALUES_IP_UDP,
      TMP_NETTRANSPORTVALUES_IP,
      TMP_NETTRANSPORTVALUES_UNIX,
      TMP_NETTRANSPORTVALUES_PIPE,
      TMP_NETTRANSPORTVALUES_INPROC,
      TMP_NETTRANSPORTVALUES_OTHER
    ]);
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI = "wifi";
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED = "wired";
    TMP_NETHOSTCONNECTIONTYPEVALUES_CELL = "cell";
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = "unavailable";
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = "unknown";
    NETHOSTCONNECTIONTYPEVALUES_WIFI = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI;
    NETHOSTCONNECTIONTYPEVALUES_WIRED = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED;
    NETHOSTCONNECTIONTYPEVALUES_CELL = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL;
    NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE;
    NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN;
    NetHostConnectionTypeValues = /* @__PURE__ */ createConstMap([
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI,
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED,
      TMP_NETHOSTCONNECTIONTYPEVALUES_CELL,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN
    ]);
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = "gprs";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = "edge";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = "umts";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = "cdma";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = "evdo_0";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = "evdo_a";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = "cdma2000_1xrtt";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = "hsdpa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = "hsupa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = "hspa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = "iden";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = "evdo_b";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE = "lte";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = "ehrpd";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = "hspap";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM = "gsm";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = "td_scdma";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = "iwlan";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR = "nr";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = "nrnsa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = "lte_ca";
    NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS;
    NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE;
    NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS;
    NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA;
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0;
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A;
    NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA;
    NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN;
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B;
    NETHOSTCONNECTIONSUBTYPEVALUES_LTE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE;
    NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP;
    NETHOSTCONNECTIONSUBTYPEVALUES_GSM = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM;
    NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA;
    NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN;
    NETHOSTCONNECTIONSUBTYPEVALUES_NR = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR;
    NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA;
    NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA;
    NetHostConnectionSubtypeValues = /* @__PURE__ */ createConstMap([
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA
    ]);
    TMP_HTTPFLAVORVALUES_HTTP_1_0 = "1.0";
    TMP_HTTPFLAVORVALUES_HTTP_1_1 = "1.1";
    TMP_HTTPFLAVORVALUES_HTTP_2_0 = "2.0";
    TMP_HTTPFLAVORVALUES_SPDY = "SPDY";
    TMP_HTTPFLAVORVALUES_QUIC = "QUIC";
    HTTPFLAVORVALUES_HTTP_1_0 = TMP_HTTPFLAVORVALUES_HTTP_1_0;
    HTTPFLAVORVALUES_HTTP_1_1 = TMP_HTTPFLAVORVALUES_HTTP_1_1;
    HTTPFLAVORVALUES_HTTP_2_0 = TMP_HTTPFLAVORVALUES_HTTP_2_0;
    HTTPFLAVORVALUES_SPDY = TMP_HTTPFLAVORVALUES_SPDY;
    HTTPFLAVORVALUES_QUIC = TMP_HTTPFLAVORVALUES_QUIC;
    HttpFlavorValues = {
      HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_0,
      HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_1,
      HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_0,
      SPDY: TMP_HTTPFLAVORVALUES_SPDY,
      QUIC: TMP_HTTPFLAVORVALUES_QUIC
    };
    TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE = "queue";
    TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC = "topic";
    MESSAGINGDESTINATIONKINDVALUES_QUEUE = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE;
    MESSAGINGDESTINATIONKINDVALUES_TOPIC = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC;
    MessagingDestinationKindValues = /* @__PURE__ */ createConstMap([
      TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE,
      TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC
    ]);
    TMP_MESSAGINGOPERATIONVALUES_RECEIVE = "receive";
    TMP_MESSAGINGOPERATIONVALUES_PROCESS = "process";
    MESSAGINGOPERATIONVALUES_RECEIVE = TMP_MESSAGINGOPERATIONVALUES_RECEIVE;
    MESSAGINGOPERATIONVALUES_PROCESS = TMP_MESSAGINGOPERATIONVALUES_PROCESS;
    MessagingOperationValues = /* @__PURE__ */ createConstMap([
      TMP_MESSAGINGOPERATIONVALUES_RECEIVE,
      TMP_MESSAGINGOPERATIONVALUES_PROCESS
    ]);
    TMP_RPCGRPCSTATUSCODEVALUES_OK = 0;
    TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED = 1;
    TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN = 2;
    TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = 3;
    TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = 4;
    TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND = 5;
    TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = 6;
    TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = 7;
    TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = 8;
    TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = 9;
    TMP_RPCGRPCSTATUSCODEVALUES_ABORTED = 10;
    TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = 11;
    TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = 12;
    TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL = 13;
    TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = 14;
    TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS = 15;
    TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = 16;
    RPCGRPCSTATUSCODEVALUES_OK = TMP_RPCGRPCSTATUSCODEVALUES_OK;
    RPCGRPCSTATUSCODEVALUES_CANCELLED = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED;
    RPCGRPCSTATUSCODEVALUES_UNKNOWN = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN;
    RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT;
    RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED;
    RPCGRPCSTATUSCODEVALUES_NOT_FOUND = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND;
    RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS;
    RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED;
    RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED;
    RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION;
    RPCGRPCSTATUSCODEVALUES_ABORTED = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED;
    RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE;
    RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED;
    RPCGRPCSTATUSCODEVALUES_INTERNAL = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL;
    RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE;
    RPCGRPCSTATUSCODEVALUES_DATA_LOSS = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS;
    RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED;
    RpcGrpcStatusCodeValues = {
      OK: TMP_RPCGRPCSTATUSCODEVALUES_OK,
      CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED,
      UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN,
      INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT,
      DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED,
      NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND,
      ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS,
      PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED,
      RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED,
      FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION,
      ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED,
      OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE,
      UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED,
      INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL,
      UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE,
      DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS,
      UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED
    };
    TMP_MESSAGETYPEVALUES_SENT = "SENT";
    TMP_MESSAGETYPEVALUES_RECEIVED = "RECEIVED";
    MESSAGETYPEVALUES_SENT = TMP_MESSAGETYPEVALUES_SENT;
    MESSAGETYPEVALUES_RECEIVED = TMP_MESSAGETYPEVALUES_RECEIVED;
    MessageTypeValues = /* @__PURE__ */ createConstMap([
      TMP_MESSAGETYPEVALUES_SENT,
      TMP_MESSAGETYPEVALUES_RECEIVED
    ]);
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/esm/trace/index.js
var init_trace2 = __esm({
  "node_modules/@opentelemetry/semantic-conventions/build/esm/trace/index.js"() {
    init_SemanticAttributes();
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js
var TMP_CLOUD_PROVIDER, TMP_CLOUD_ACCOUNT_ID, TMP_CLOUD_REGION, TMP_CLOUD_AVAILABILITY_ZONE, TMP_CLOUD_PLATFORM, TMP_AWS_ECS_CONTAINER_ARN, TMP_AWS_ECS_CLUSTER_ARN, TMP_AWS_ECS_LAUNCHTYPE, TMP_AWS_ECS_TASK_ARN, TMP_AWS_ECS_TASK_FAMILY, TMP_AWS_ECS_TASK_REVISION, TMP_AWS_EKS_CLUSTER_ARN, TMP_AWS_LOG_GROUP_NAMES, TMP_AWS_LOG_GROUP_ARNS, TMP_AWS_LOG_STREAM_NAMES, TMP_AWS_LOG_STREAM_ARNS, TMP_CONTAINER_NAME, TMP_CONTAINER_ID, TMP_CONTAINER_RUNTIME, TMP_CONTAINER_IMAGE_NAME, TMP_CONTAINER_IMAGE_TAG, TMP_DEPLOYMENT_ENVIRONMENT, TMP_DEVICE_ID, TMP_DEVICE_MODEL_IDENTIFIER, TMP_DEVICE_MODEL_NAME, TMP_FAAS_NAME, TMP_FAAS_ID, TMP_FAAS_VERSION, TMP_FAAS_INSTANCE, TMP_FAAS_MAX_MEMORY, TMP_HOST_ID, TMP_HOST_NAME, TMP_HOST_TYPE, TMP_HOST_ARCH, TMP_HOST_IMAGE_NAME, TMP_HOST_IMAGE_ID, TMP_HOST_IMAGE_VERSION, TMP_K8S_CLUSTER_NAME, TMP_K8S_NODE_NAME, TMP_K8S_NODE_UID, TMP_K8S_NAMESPACE_NAME, TMP_K8S_POD_UID, TMP_K8S_POD_NAME, TMP_K8S_CONTAINER_NAME, TMP_K8S_REPLICASET_UID, TMP_K8S_REPLICASET_NAME, TMP_K8S_DEPLOYMENT_UID, TMP_K8S_DEPLOYMENT_NAME, TMP_K8S_STATEFULSET_UID, TMP_K8S_STATEFULSET_NAME, TMP_K8S_DAEMONSET_UID, TMP_K8S_DAEMONSET_NAME, TMP_K8S_JOB_UID, TMP_K8S_JOB_NAME, TMP_K8S_CRONJOB_UID, TMP_K8S_CRONJOB_NAME, TMP_OS_TYPE, TMP_OS_DESCRIPTION, TMP_OS_NAME, TMP_OS_VERSION, TMP_PROCESS_PID, TMP_PROCESS_EXECUTABLE_NAME, TMP_PROCESS_EXECUTABLE_PATH, TMP_PROCESS_COMMAND, TMP_PROCESS_COMMAND_LINE, TMP_PROCESS_COMMAND_ARGS, TMP_PROCESS_OWNER, TMP_PROCESS_RUNTIME_NAME, TMP_PROCESS_RUNTIME_VERSION, TMP_PROCESS_RUNTIME_DESCRIPTION, TMP_SERVICE_NAME, TMP_SERVICE_NAMESPACE, TMP_SERVICE_INSTANCE_ID, TMP_SERVICE_VERSION, TMP_TELEMETRY_SDK_NAME, TMP_TELEMETRY_SDK_LANGUAGE, TMP_TELEMETRY_SDK_VERSION, TMP_TELEMETRY_AUTO_VERSION, TMP_WEBENGINE_NAME, TMP_WEBENGINE_VERSION, TMP_WEBENGINE_DESCRIPTION, SEMRESATTRS_CLOUD_PROVIDER, SEMRESATTRS_CLOUD_ACCOUNT_ID, SEMRESATTRS_CLOUD_REGION, SEMRESATTRS_CLOUD_AVAILABILITY_ZONE, SEMRESATTRS_CLOUD_PLATFORM, SEMRESATTRS_AWS_ECS_CONTAINER_ARN, SEMRESATTRS_AWS_ECS_CLUSTER_ARN, SEMRESATTRS_AWS_ECS_LAUNCHTYPE, SEMRESATTRS_AWS_ECS_TASK_ARN, SEMRESATTRS_AWS_ECS_TASK_FAMILY, SEMRESATTRS_AWS_ECS_TASK_REVISION, SEMRESATTRS_AWS_EKS_CLUSTER_ARN, SEMRESATTRS_AWS_LOG_GROUP_NAMES, SEMRESATTRS_AWS_LOG_GROUP_ARNS, SEMRESATTRS_AWS_LOG_STREAM_NAMES, SEMRESATTRS_AWS_LOG_STREAM_ARNS, SEMRESATTRS_CONTAINER_NAME, SEMRESATTRS_CONTAINER_ID, SEMRESATTRS_CONTAINER_RUNTIME, SEMRESATTRS_CONTAINER_IMAGE_NAME, SEMRESATTRS_CONTAINER_IMAGE_TAG, SEMRESATTRS_DEPLOYMENT_ENVIRONMENT, SEMRESATTRS_DEVICE_ID, SEMRESATTRS_DEVICE_MODEL_IDENTIFIER, SEMRESATTRS_DEVICE_MODEL_NAME, SEMRESATTRS_FAAS_NAME, SEMRESATTRS_FAAS_ID, SEMRESATTRS_FAAS_VERSION, SEMRESATTRS_FAAS_INSTANCE, SEMRESATTRS_FAAS_MAX_MEMORY, SEMRESATTRS_HOST_ID, SEMRESATTRS_HOST_NAME, SEMRESATTRS_HOST_TYPE, SEMRESATTRS_HOST_ARCH, SEMRESATTRS_HOST_IMAGE_NAME, SEMRESATTRS_HOST_IMAGE_ID, SEMRESATTRS_HOST_IMAGE_VERSION, SEMRESATTRS_K8S_CLUSTER_NAME, SEMRESATTRS_K8S_NODE_NAME, SEMRESATTRS_K8S_NODE_UID, SEMRESATTRS_K8S_NAMESPACE_NAME, SEMRESATTRS_K8S_POD_UID, SEMRESATTRS_K8S_POD_NAME, SEMRESATTRS_K8S_CONTAINER_NAME, SEMRESATTRS_K8S_REPLICASET_UID, SEMRESATTRS_K8S_REPLICASET_NAME, SEMRESATTRS_K8S_DEPLOYMENT_UID, SEMRESATTRS_K8S_DEPLOYMENT_NAME, SEMRESATTRS_K8S_STATEFULSET_UID, SEMRESATTRS_K8S_STATEFULSET_NAME, SEMRESATTRS_K8S_DAEMONSET_UID, SEMRESATTRS_K8S_DAEMONSET_NAME, SEMRESATTRS_K8S_JOB_UID, SEMRESATTRS_K8S_JOB_NAME, SEMRESATTRS_K8S_CRONJOB_UID, SEMRESATTRS_K8S_CRONJOB_NAME, SEMRESATTRS_OS_TYPE, SEMRESATTRS_OS_DESCRIPTION, SEMRESATTRS_OS_NAME, SEMRESATTRS_OS_VERSION, SEMRESATTRS_PROCESS_PID, SEMRESATTRS_PROCESS_EXECUTABLE_NAME, SEMRESATTRS_PROCESS_EXECUTABLE_PATH, SEMRESATTRS_PROCESS_COMMAND, SEMRESATTRS_PROCESS_COMMAND_LINE, SEMRESATTRS_PROCESS_COMMAND_ARGS, SEMRESATTRS_PROCESS_OWNER, SEMRESATTRS_PROCESS_RUNTIME_NAME, SEMRESATTRS_PROCESS_RUNTIME_VERSION, SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION, SEMRESATTRS_SERVICE_NAME, SEMRESATTRS_SERVICE_NAMESPACE, SEMRESATTRS_SERVICE_INSTANCE_ID, SEMRESATTRS_SERVICE_VERSION, SEMRESATTRS_TELEMETRY_SDK_NAME, SEMRESATTRS_TELEMETRY_SDK_LANGUAGE, SEMRESATTRS_TELEMETRY_SDK_VERSION, SEMRESATTRS_TELEMETRY_AUTO_VERSION, SEMRESATTRS_WEBENGINE_NAME, SEMRESATTRS_WEBENGINE_VERSION, SEMRESATTRS_WEBENGINE_DESCRIPTION, SemanticResourceAttributes, TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD, TMP_CLOUDPROVIDERVALUES_AWS, TMP_CLOUDPROVIDERVALUES_AZURE, TMP_CLOUDPROVIDERVALUES_GCP, CLOUDPROVIDERVALUES_ALIBABA_CLOUD, CLOUDPROVIDERVALUES_AWS, CLOUDPROVIDERVALUES_AZURE, CLOUDPROVIDERVALUES_GCP, CloudProviderValues, TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS, TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC, TMP_CLOUDPLATFORMVALUES_AWS_EC2, TMP_CLOUDPLATFORMVALUES_AWS_ECS, TMP_CLOUDPLATFORMVALUES_AWS_EKS, TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA, TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK, TMP_CLOUDPLATFORMVALUES_AZURE_VM, TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES, TMP_CLOUDPLATFORMVALUES_AZURE_AKS, TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS, TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE, TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE, TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN, TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE, TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS, TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE, CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS, CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC, CLOUDPLATFORMVALUES_AWS_EC2, CLOUDPLATFORMVALUES_AWS_ECS, CLOUDPLATFORMVALUES_AWS_EKS, CLOUDPLATFORMVALUES_AWS_LAMBDA, CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK, CLOUDPLATFORMVALUES_AZURE_VM, CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES, CLOUDPLATFORMVALUES_AZURE_AKS, CLOUDPLATFORMVALUES_AZURE_FUNCTIONS, CLOUDPLATFORMVALUES_AZURE_APP_SERVICE, CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE, CLOUDPLATFORMVALUES_GCP_CLOUD_RUN, CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE, CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS, CLOUDPLATFORMVALUES_GCP_APP_ENGINE, CloudPlatformValues, TMP_AWSECSLAUNCHTYPEVALUES_EC2, TMP_AWSECSLAUNCHTYPEVALUES_FARGATE, AWSECSLAUNCHTYPEVALUES_EC2, AWSECSLAUNCHTYPEVALUES_FARGATE, AwsEcsLaunchtypeValues, TMP_HOSTARCHVALUES_AMD64, TMP_HOSTARCHVALUES_ARM32, TMP_HOSTARCHVALUES_ARM64, TMP_HOSTARCHVALUES_IA64, TMP_HOSTARCHVALUES_PPC32, TMP_HOSTARCHVALUES_PPC64, TMP_HOSTARCHVALUES_X86, HOSTARCHVALUES_AMD64, HOSTARCHVALUES_ARM32, HOSTARCHVALUES_ARM64, HOSTARCHVALUES_IA64, HOSTARCHVALUES_PPC32, HOSTARCHVALUES_PPC64, HOSTARCHVALUES_X86, HostArchValues, TMP_OSTYPEVALUES_WINDOWS, TMP_OSTYPEVALUES_LINUX, TMP_OSTYPEVALUES_DARWIN, TMP_OSTYPEVALUES_FREEBSD, TMP_OSTYPEVALUES_NETBSD, TMP_OSTYPEVALUES_OPENBSD, TMP_OSTYPEVALUES_DRAGONFLYBSD, TMP_OSTYPEVALUES_HPUX, TMP_OSTYPEVALUES_AIX, TMP_OSTYPEVALUES_SOLARIS, TMP_OSTYPEVALUES_Z_OS, OSTYPEVALUES_WINDOWS, OSTYPEVALUES_LINUX, OSTYPEVALUES_DARWIN, OSTYPEVALUES_FREEBSD, OSTYPEVALUES_NETBSD, OSTYPEVALUES_OPENBSD, OSTYPEVALUES_DRAGONFLYBSD, OSTYPEVALUES_HPUX, OSTYPEVALUES_AIX, OSTYPEVALUES_SOLARIS, OSTYPEVALUES_Z_OS, OsTypeValues, TMP_TELEMETRYSDKLANGUAGEVALUES_CPP, TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET, TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG, TMP_TELEMETRYSDKLANGUAGEVALUES_GO, TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA, TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS, TMP_TELEMETRYSDKLANGUAGEVALUES_PHP, TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON, TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY, TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS, TELEMETRYSDKLANGUAGEVALUES_CPP, TELEMETRYSDKLANGUAGEVALUES_DOTNET, TELEMETRYSDKLANGUAGEVALUES_ERLANG, TELEMETRYSDKLANGUAGEVALUES_GO, TELEMETRYSDKLANGUAGEVALUES_JAVA, TELEMETRYSDKLANGUAGEVALUES_NODEJS, TELEMETRYSDKLANGUAGEVALUES_PHP, TELEMETRYSDKLANGUAGEVALUES_PYTHON, TELEMETRYSDKLANGUAGEVALUES_RUBY, TELEMETRYSDKLANGUAGEVALUES_WEBJS, TelemetrySdkLanguageValues;
var init_SemanticResourceAttributes = __esm({
  "node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js"() {
    init_utils3();
    TMP_CLOUD_PROVIDER = "cloud.provider";
    TMP_CLOUD_ACCOUNT_ID = "cloud.account.id";
    TMP_CLOUD_REGION = "cloud.region";
    TMP_CLOUD_AVAILABILITY_ZONE = "cloud.availability_zone";
    TMP_CLOUD_PLATFORM = "cloud.platform";
    TMP_AWS_ECS_CONTAINER_ARN = "aws.ecs.container.arn";
    TMP_AWS_ECS_CLUSTER_ARN = "aws.ecs.cluster.arn";
    TMP_AWS_ECS_LAUNCHTYPE = "aws.ecs.launchtype";
    TMP_AWS_ECS_TASK_ARN = "aws.ecs.task.arn";
    TMP_AWS_ECS_TASK_FAMILY = "aws.ecs.task.family";
    TMP_AWS_ECS_TASK_REVISION = "aws.ecs.task.revision";
    TMP_AWS_EKS_CLUSTER_ARN = "aws.eks.cluster.arn";
    TMP_AWS_LOG_GROUP_NAMES = "aws.log.group.names";
    TMP_AWS_LOG_GROUP_ARNS = "aws.log.group.arns";
    TMP_AWS_LOG_STREAM_NAMES = "aws.log.stream.names";
    TMP_AWS_LOG_STREAM_ARNS = "aws.log.stream.arns";
    TMP_CONTAINER_NAME = "container.name";
    TMP_CONTAINER_ID = "container.id";
    TMP_CONTAINER_RUNTIME = "container.runtime";
    TMP_CONTAINER_IMAGE_NAME = "container.image.name";
    TMP_CONTAINER_IMAGE_TAG = "container.image.tag";
    TMP_DEPLOYMENT_ENVIRONMENT = "deployment.environment";
    TMP_DEVICE_ID = "device.id";
    TMP_DEVICE_MODEL_IDENTIFIER = "device.model.identifier";
    TMP_DEVICE_MODEL_NAME = "device.model.name";
    TMP_FAAS_NAME = "faas.name";
    TMP_FAAS_ID = "faas.id";
    TMP_FAAS_VERSION = "faas.version";
    TMP_FAAS_INSTANCE = "faas.instance";
    TMP_FAAS_MAX_MEMORY = "faas.max_memory";
    TMP_HOST_ID = "host.id";
    TMP_HOST_NAME = "host.name";
    TMP_HOST_TYPE = "host.type";
    TMP_HOST_ARCH = "host.arch";
    TMP_HOST_IMAGE_NAME = "host.image.name";
    TMP_HOST_IMAGE_ID = "host.image.id";
    TMP_HOST_IMAGE_VERSION = "host.image.version";
    TMP_K8S_CLUSTER_NAME = "k8s.cluster.name";
    TMP_K8S_NODE_NAME = "k8s.node.name";
    TMP_K8S_NODE_UID = "k8s.node.uid";
    TMP_K8S_NAMESPACE_NAME = "k8s.namespace.name";
    TMP_K8S_POD_UID = "k8s.pod.uid";
    TMP_K8S_POD_NAME = "k8s.pod.name";
    TMP_K8S_CONTAINER_NAME = "k8s.container.name";
    TMP_K8S_REPLICASET_UID = "k8s.replicaset.uid";
    TMP_K8S_REPLICASET_NAME = "k8s.replicaset.name";
    TMP_K8S_DEPLOYMENT_UID = "k8s.deployment.uid";
    TMP_K8S_DEPLOYMENT_NAME = "k8s.deployment.name";
    TMP_K8S_STATEFULSET_UID = "k8s.statefulset.uid";
    TMP_K8S_STATEFULSET_NAME = "k8s.statefulset.name";
    TMP_K8S_DAEMONSET_UID = "k8s.daemonset.uid";
    TMP_K8S_DAEMONSET_NAME = "k8s.daemonset.name";
    TMP_K8S_JOB_UID = "k8s.job.uid";
    TMP_K8S_JOB_NAME = "k8s.job.name";
    TMP_K8S_CRONJOB_UID = "k8s.cronjob.uid";
    TMP_K8S_CRONJOB_NAME = "k8s.cronjob.name";
    TMP_OS_TYPE = "os.type";
    TMP_OS_DESCRIPTION = "os.description";
    TMP_OS_NAME = "os.name";
    TMP_OS_VERSION = "os.version";
    TMP_PROCESS_PID = "process.pid";
    TMP_PROCESS_EXECUTABLE_NAME = "process.executable.name";
    TMP_PROCESS_EXECUTABLE_PATH = "process.executable.path";
    TMP_PROCESS_COMMAND = "process.command";
    TMP_PROCESS_COMMAND_LINE = "process.command_line";
    TMP_PROCESS_COMMAND_ARGS = "process.command_args";
    TMP_PROCESS_OWNER = "process.owner";
    TMP_PROCESS_RUNTIME_NAME = "process.runtime.name";
    TMP_PROCESS_RUNTIME_VERSION = "process.runtime.version";
    TMP_PROCESS_RUNTIME_DESCRIPTION = "process.runtime.description";
    TMP_SERVICE_NAME = "service.name";
    TMP_SERVICE_NAMESPACE = "service.namespace";
    TMP_SERVICE_INSTANCE_ID = "service.instance.id";
    TMP_SERVICE_VERSION = "service.version";
    TMP_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
    TMP_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
    TMP_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
    TMP_TELEMETRY_AUTO_VERSION = "telemetry.auto.version";
    TMP_WEBENGINE_NAME = "webengine.name";
    TMP_WEBENGINE_VERSION = "webengine.version";
    TMP_WEBENGINE_DESCRIPTION = "webengine.description";
    SEMRESATTRS_CLOUD_PROVIDER = TMP_CLOUD_PROVIDER;
    SEMRESATTRS_CLOUD_ACCOUNT_ID = TMP_CLOUD_ACCOUNT_ID;
    SEMRESATTRS_CLOUD_REGION = TMP_CLOUD_REGION;
    SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = TMP_CLOUD_AVAILABILITY_ZONE;
    SEMRESATTRS_CLOUD_PLATFORM = TMP_CLOUD_PLATFORM;
    SEMRESATTRS_AWS_ECS_CONTAINER_ARN = TMP_AWS_ECS_CONTAINER_ARN;
    SEMRESATTRS_AWS_ECS_CLUSTER_ARN = TMP_AWS_ECS_CLUSTER_ARN;
    SEMRESATTRS_AWS_ECS_LAUNCHTYPE = TMP_AWS_ECS_LAUNCHTYPE;
    SEMRESATTRS_AWS_ECS_TASK_ARN = TMP_AWS_ECS_TASK_ARN;
    SEMRESATTRS_AWS_ECS_TASK_FAMILY = TMP_AWS_ECS_TASK_FAMILY;
    SEMRESATTRS_AWS_ECS_TASK_REVISION = TMP_AWS_ECS_TASK_REVISION;
    SEMRESATTRS_AWS_EKS_CLUSTER_ARN = TMP_AWS_EKS_CLUSTER_ARN;
    SEMRESATTRS_AWS_LOG_GROUP_NAMES = TMP_AWS_LOG_GROUP_NAMES;
    SEMRESATTRS_AWS_LOG_GROUP_ARNS = TMP_AWS_LOG_GROUP_ARNS;
    SEMRESATTRS_AWS_LOG_STREAM_NAMES = TMP_AWS_LOG_STREAM_NAMES;
    SEMRESATTRS_AWS_LOG_STREAM_ARNS = TMP_AWS_LOG_STREAM_ARNS;
    SEMRESATTRS_CONTAINER_NAME = TMP_CONTAINER_NAME;
    SEMRESATTRS_CONTAINER_ID = TMP_CONTAINER_ID;
    SEMRESATTRS_CONTAINER_RUNTIME = TMP_CONTAINER_RUNTIME;
    SEMRESATTRS_CONTAINER_IMAGE_NAME = TMP_CONTAINER_IMAGE_NAME;
    SEMRESATTRS_CONTAINER_IMAGE_TAG = TMP_CONTAINER_IMAGE_TAG;
    SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = TMP_DEPLOYMENT_ENVIRONMENT;
    SEMRESATTRS_DEVICE_ID = TMP_DEVICE_ID;
    SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = TMP_DEVICE_MODEL_IDENTIFIER;
    SEMRESATTRS_DEVICE_MODEL_NAME = TMP_DEVICE_MODEL_NAME;
    SEMRESATTRS_FAAS_NAME = TMP_FAAS_NAME;
    SEMRESATTRS_FAAS_ID = TMP_FAAS_ID;
    SEMRESATTRS_FAAS_VERSION = TMP_FAAS_VERSION;
    SEMRESATTRS_FAAS_INSTANCE = TMP_FAAS_INSTANCE;
    SEMRESATTRS_FAAS_MAX_MEMORY = TMP_FAAS_MAX_MEMORY;
    SEMRESATTRS_HOST_ID = TMP_HOST_ID;
    SEMRESATTRS_HOST_NAME = TMP_HOST_NAME;
    SEMRESATTRS_HOST_TYPE = TMP_HOST_TYPE;
    SEMRESATTRS_HOST_ARCH = TMP_HOST_ARCH;
    SEMRESATTRS_HOST_IMAGE_NAME = TMP_HOST_IMAGE_NAME;
    SEMRESATTRS_HOST_IMAGE_ID = TMP_HOST_IMAGE_ID;
    SEMRESATTRS_HOST_IMAGE_VERSION = TMP_HOST_IMAGE_VERSION;
    SEMRESATTRS_K8S_CLUSTER_NAME = TMP_K8S_CLUSTER_NAME;
    SEMRESATTRS_K8S_NODE_NAME = TMP_K8S_NODE_NAME;
    SEMRESATTRS_K8S_NODE_UID = TMP_K8S_NODE_UID;
    SEMRESATTRS_K8S_NAMESPACE_NAME = TMP_K8S_NAMESPACE_NAME;
    SEMRESATTRS_K8S_POD_UID = TMP_K8S_POD_UID;
    SEMRESATTRS_K8S_POD_NAME = TMP_K8S_POD_NAME;
    SEMRESATTRS_K8S_CONTAINER_NAME = TMP_K8S_CONTAINER_NAME;
    SEMRESATTRS_K8S_REPLICASET_UID = TMP_K8S_REPLICASET_UID;
    SEMRESATTRS_K8S_REPLICASET_NAME = TMP_K8S_REPLICASET_NAME;
    SEMRESATTRS_K8S_DEPLOYMENT_UID = TMP_K8S_DEPLOYMENT_UID;
    SEMRESATTRS_K8S_DEPLOYMENT_NAME = TMP_K8S_DEPLOYMENT_NAME;
    SEMRESATTRS_K8S_STATEFULSET_UID = TMP_K8S_STATEFULSET_UID;
    SEMRESATTRS_K8S_STATEFULSET_NAME = TMP_K8S_STATEFULSET_NAME;
    SEMRESATTRS_K8S_DAEMONSET_UID = TMP_K8S_DAEMONSET_UID;
    SEMRESATTRS_K8S_DAEMONSET_NAME = TMP_K8S_DAEMONSET_NAME;
    SEMRESATTRS_K8S_JOB_UID = TMP_K8S_JOB_UID;
    SEMRESATTRS_K8S_JOB_NAME = TMP_K8S_JOB_NAME;
    SEMRESATTRS_K8S_CRONJOB_UID = TMP_K8S_CRONJOB_UID;
    SEMRESATTRS_K8S_CRONJOB_NAME = TMP_K8S_CRONJOB_NAME;
    SEMRESATTRS_OS_TYPE = TMP_OS_TYPE;
    SEMRESATTRS_OS_DESCRIPTION = TMP_OS_DESCRIPTION;
    SEMRESATTRS_OS_NAME = TMP_OS_NAME;
    SEMRESATTRS_OS_VERSION = TMP_OS_VERSION;
    SEMRESATTRS_PROCESS_PID = TMP_PROCESS_PID;
    SEMRESATTRS_PROCESS_EXECUTABLE_NAME = TMP_PROCESS_EXECUTABLE_NAME;
    SEMRESATTRS_PROCESS_EXECUTABLE_PATH = TMP_PROCESS_EXECUTABLE_PATH;
    SEMRESATTRS_PROCESS_COMMAND = TMP_PROCESS_COMMAND;
    SEMRESATTRS_PROCESS_COMMAND_LINE = TMP_PROCESS_COMMAND_LINE;
    SEMRESATTRS_PROCESS_COMMAND_ARGS = TMP_PROCESS_COMMAND_ARGS;
    SEMRESATTRS_PROCESS_OWNER = TMP_PROCESS_OWNER;
    SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME;
    SEMRESATTRS_PROCESS_RUNTIME_VERSION = TMP_PROCESS_RUNTIME_VERSION;
    SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = TMP_PROCESS_RUNTIME_DESCRIPTION;
    SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME;
    SEMRESATTRS_SERVICE_NAMESPACE = TMP_SERVICE_NAMESPACE;
    SEMRESATTRS_SERVICE_INSTANCE_ID = TMP_SERVICE_INSTANCE_ID;
    SEMRESATTRS_SERVICE_VERSION = TMP_SERVICE_VERSION;
    SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME;
    SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE;
    SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION;
    SEMRESATTRS_TELEMETRY_AUTO_VERSION = TMP_TELEMETRY_AUTO_VERSION;
    SEMRESATTRS_WEBENGINE_NAME = TMP_WEBENGINE_NAME;
    SEMRESATTRS_WEBENGINE_VERSION = TMP_WEBENGINE_VERSION;
    SEMRESATTRS_WEBENGINE_DESCRIPTION = TMP_WEBENGINE_DESCRIPTION;
    SemanticResourceAttributes = /* @__PURE__ */ createConstMap([
      TMP_CLOUD_PROVIDER,
      TMP_CLOUD_ACCOUNT_ID,
      TMP_CLOUD_REGION,
      TMP_CLOUD_AVAILABILITY_ZONE,
      TMP_CLOUD_PLATFORM,
      TMP_AWS_ECS_CONTAINER_ARN,
      TMP_AWS_ECS_CLUSTER_ARN,
      TMP_AWS_ECS_LAUNCHTYPE,
      TMP_AWS_ECS_TASK_ARN,
      TMP_AWS_ECS_TASK_FAMILY,
      TMP_AWS_ECS_TASK_REVISION,
      TMP_AWS_EKS_CLUSTER_ARN,
      TMP_AWS_LOG_GROUP_NAMES,
      TMP_AWS_LOG_GROUP_ARNS,
      TMP_AWS_LOG_STREAM_NAMES,
      TMP_AWS_LOG_STREAM_ARNS,
      TMP_CONTAINER_NAME,
      TMP_CONTAINER_ID,
      TMP_CONTAINER_RUNTIME,
      TMP_CONTAINER_IMAGE_NAME,
      TMP_CONTAINER_IMAGE_TAG,
      TMP_DEPLOYMENT_ENVIRONMENT,
      TMP_DEVICE_ID,
      TMP_DEVICE_MODEL_IDENTIFIER,
      TMP_DEVICE_MODEL_NAME,
      TMP_FAAS_NAME,
      TMP_FAAS_ID,
      TMP_FAAS_VERSION,
      TMP_FAAS_INSTANCE,
      TMP_FAAS_MAX_MEMORY,
      TMP_HOST_ID,
      TMP_HOST_NAME,
      TMP_HOST_TYPE,
      TMP_HOST_ARCH,
      TMP_HOST_IMAGE_NAME,
      TMP_HOST_IMAGE_ID,
      TMP_HOST_IMAGE_VERSION,
      TMP_K8S_CLUSTER_NAME,
      TMP_K8S_NODE_NAME,
      TMP_K8S_NODE_UID,
      TMP_K8S_NAMESPACE_NAME,
      TMP_K8S_POD_UID,
      TMP_K8S_POD_NAME,
      TMP_K8S_CONTAINER_NAME,
      TMP_K8S_REPLICASET_UID,
      TMP_K8S_REPLICASET_NAME,
      TMP_K8S_DEPLOYMENT_UID,
      TMP_K8S_DEPLOYMENT_NAME,
      TMP_K8S_STATEFULSET_UID,
      TMP_K8S_STATEFULSET_NAME,
      TMP_K8S_DAEMONSET_UID,
      TMP_K8S_DAEMONSET_NAME,
      TMP_K8S_JOB_UID,
      TMP_K8S_JOB_NAME,
      TMP_K8S_CRONJOB_UID,
      TMP_K8S_CRONJOB_NAME,
      TMP_OS_TYPE,
      TMP_OS_DESCRIPTION,
      TMP_OS_NAME,
      TMP_OS_VERSION,
      TMP_PROCESS_PID,
      TMP_PROCESS_EXECUTABLE_NAME,
      TMP_PROCESS_EXECUTABLE_PATH,
      TMP_PROCESS_COMMAND,
      TMP_PROCESS_COMMAND_LINE,
      TMP_PROCESS_COMMAND_ARGS,
      TMP_PROCESS_OWNER,
      TMP_PROCESS_RUNTIME_NAME,
      TMP_PROCESS_RUNTIME_VERSION,
      TMP_PROCESS_RUNTIME_DESCRIPTION,
      TMP_SERVICE_NAME,
      TMP_SERVICE_NAMESPACE,
      TMP_SERVICE_INSTANCE_ID,
      TMP_SERVICE_VERSION,
      TMP_TELEMETRY_SDK_NAME,
      TMP_TELEMETRY_SDK_LANGUAGE,
      TMP_TELEMETRY_SDK_VERSION,
      TMP_TELEMETRY_AUTO_VERSION,
      TMP_WEBENGINE_NAME,
      TMP_WEBENGINE_VERSION,
      TMP_WEBENGINE_DESCRIPTION
    ]);
    TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
    TMP_CLOUDPROVIDERVALUES_AWS = "aws";
    TMP_CLOUDPROVIDERVALUES_AZURE = "azure";
    TMP_CLOUDPROVIDERVALUES_GCP = "gcp";
    CLOUDPROVIDERVALUES_ALIBABA_CLOUD = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD;
    CLOUDPROVIDERVALUES_AWS = TMP_CLOUDPROVIDERVALUES_AWS;
    CLOUDPROVIDERVALUES_AZURE = TMP_CLOUDPROVIDERVALUES_AZURE;
    CLOUDPROVIDERVALUES_GCP = TMP_CLOUDPROVIDERVALUES_GCP;
    CloudProviderValues = /* @__PURE__ */ createConstMap([
      TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD,
      TMP_CLOUDPROVIDERVALUES_AWS,
      TMP_CLOUDPROVIDERVALUES_AZURE,
      TMP_CLOUDPROVIDERVALUES_GCP
    ]);
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = "alibaba_cloud_ecs";
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = "alibaba_cloud_fc";
    TMP_CLOUDPLATFORMVALUES_AWS_EC2 = "aws_ec2";
    TMP_CLOUDPLATFORMVALUES_AWS_ECS = "aws_ecs";
    TMP_CLOUDPLATFORMVALUES_AWS_EKS = "aws_eks";
    TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA = "aws_lambda";
    TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = "aws_elastic_beanstalk";
    TMP_CLOUDPLATFORMVALUES_AZURE_VM = "azure_vm";
    TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = "azure_container_instances";
    TMP_CLOUDPLATFORMVALUES_AZURE_AKS = "azure_aks";
    TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = "azure_functions";
    TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = "azure_app_service";
    TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = "gcp_compute_engine";
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = "gcp_cloud_run";
    TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = "gcp_kubernetes_engine";
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = "gcp_cloud_functions";
    TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE = "gcp_app_engine";
    CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS;
    CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC;
    CLOUDPLATFORMVALUES_AWS_EC2 = TMP_CLOUDPLATFORMVALUES_AWS_EC2;
    CLOUDPLATFORMVALUES_AWS_ECS = TMP_CLOUDPLATFORMVALUES_AWS_ECS;
    CLOUDPLATFORMVALUES_AWS_EKS = TMP_CLOUDPLATFORMVALUES_AWS_EKS;
    CLOUDPLATFORMVALUES_AWS_LAMBDA = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA;
    CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK;
    CLOUDPLATFORMVALUES_AZURE_VM = TMP_CLOUDPLATFORMVALUES_AZURE_VM;
    CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES;
    CLOUDPLATFORMVALUES_AZURE_AKS = TMP_CLOUDPLATFORMVALUES_AZURE_AKS;
    CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS;
    CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE;
    CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE;
    CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN;
    CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE;
    CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS;
    CLOUDPLATFORMVALUES_GCP_APP_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE;
    CloudPlatformValues = /* @__PURE__ */ createConstMap([
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS,
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC,
      TMP_CLOUDPLATFORMVALUES_AWS_EC2,
      TMP_CLOUDPLATFORMVALUES_AWS_ECS,
      TMP_CLOUDPLATFORMVALUES_AWS_EKS,
      TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA,
      TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK,
      TMP_CLOUDPLATFORMVALUES_AZURE_VM,
      TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES,
      TMP_CLOUDPLATFORMVALUES_AZURE_AKS,
      TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS,
      TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE,
      TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN,
      TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS,
      TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE
    ]);
    TMP_AWSECSLAUNCHTYPEVALUES_EC2 = "ec2";
    TMP_AWSECSLAUNCHTYPEVALUES_FARGATE = "fargate";
    AWSECSLAUNCHTYPEVALUES_EC2 = TMP_AWSECSLAUNCHTYPEVALUES_EC2;
    AWSECSLAUNCHTYPEVALUES_FARGATE = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE;
    AwsEcsLaunchtypeValues = /* @__PURE__ */ createConstMap([
      TMP_AWSECSLAUNCHTYPEVALUES_EC2,
      TMP_AWSECSLAUNCHTYPEVALUES_FARGATE
    ]);
    TMP_HOSTARCHVALUES_AMD64 = "amd64";
    TMP_HOSTARCHVALUES_ARM32 = "arm32";
    TMP_HOSTARCHVALUES_ARM64 = "arm64";
    TMP_HOSTARCHVALUES_IA64 = "ia64";
    TMP_HOSTARCHVALUES_PPC32 = "ppc32";
    TMP_HOSTARCHVALUES_PPC64 = "ppc64";
    TMP_HOSTARCHVALUES_X86 = "x86";
    HOSTARCHVALUES_AMD64 = TMP_HOSTARCHVALUES_AMD64;
    HOSTARCHVALUES_ARM32 = TMP_HOSTARCHVALUES_ARM32;
    HOSTARCHVALUES_ARM64 = TMP_HOSTARCHVALUES_ARM64;
    HOSTARCHVALUES_IA64 = TMP_HOSTARCHVALUES_IA64;
    HOSTARCHVALUES_PPC32 = TMP_HOSTARCHVALUES_PPC32;
    HOSTARCHVALUES_PPC64 = TMP_HOSTARCHVALUES_PPC64;
    HOSTARCHVALUES_X86 = TMP_HOSTARCHVALUES_X86;
    HostArchValues = /* @__PURE__ */ createConstMap([
      TMP_HOSTARCHVALUES_AMD64,
      TMP_HOSTARCHVALUES_ARM32,
      TMP_HOSTARCHVALUES_ARM64,
      TMP_HOSTARCHVALUES_IA64,
      TMP_HOSTARCHVALUES_PPC32,
      TMP_HOSTARCHVALUES_PPC64,
      TMP_HOSTARCHVALUES_X86
    ]);
    TMP_OSTYPEVALUES_WINDOWS = "windows";
    TMP_OSTYPEVALUES_LINUX = "linux";
    TMP_OSTYPEVALUES_DARWIN = "darwin";
    TMP_OSTYPEVALUES_FREEBSD = "freebsd";
    TMP_OSTYPEVALUES_NETBSD = "netbsd";
    TMP_OSTYPEVALUES_OPENBSD = "openbsd";
    TMP_OSTYPEVALUES_DRAGONFLYBSD = "dragonflybsd";
    TMP_OSTYPEVALUES_HPUX = "hpux";
    TMP_OSTYPEVALUES_AIX = "aix";
    TMP_OSTYPEVALUES_SOLARIS = "solaris";
    TMP_OSTYPEVALUES_Z_OS = "z_os";
    OSTYPEVALUES_WINDOWS = TMP_OSTYPEVALUES_WINDOWS;
    OSTYPEVALUES_LINUX = TMP_OSTYPEVALUES_LINUX;
    OSTYPEVALUES_DARWIN = TMP_OSTYPEVALUES_DARWIN;
    OSTYPEVALUES_FREEBSD = TMP_OSTYPEVALUES_FREEBSD;
    OSTYPEVALUES_NETBSD = TMP_OSTYPEVALUES_NETBSD;
    OSTYPEVALUES_OPENBSD = TMP_OSTYPEVALUES_OPENBSD;
    OSTYPEVALUES_DRAGONFLYBSD = TMP_OSTYPEVALUES_DRAGONFLYBSD;
    OSTYPEVALUES_HPUX = TMP_OSTYPEVALUES_HPUX;
    OSTYPEVALUES_AIX = TMP_OSTYPEVALUES_AIX;
    OSTYPEVALUES_SOLARIS = TMP_OSTYPEVALUES_SOLARIS;
    OSTYPEVALUES_Z_OS = TMP_OSTYPEVALUES_Z_OS;
    OsTypeValues = /* @__PURE__ */ createConstMap([
      TMP_OSTYPEVALUES_WINDOWS,
      TMP_OSTYPEVALUES_LINUX,
      TMP_OSTYPEVALUES_DARWIN,
      TMP_OSTYPEVALUES_FREEBSD,
      TMP_OSTYPEVALUES_NETBSD,
      TMP_OSTYPEVALUES_OPENBSD,
      TMP_OSTYPEVALUES_DRAGONFLYBSD,
      TMP_OSTYPEVALUES_HPUX,
      TMP_OSTYPEVALUES_AIX,
      TMP_OSTYPEVALUES_SOLARIS,
      TMP_OSTYPEVALUES_Z_OS
    ]);
    TMP_TELEMETRYSDKLANGUAGEVALUES_CPP = "cpp";
    TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET = "dotnet";
    TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG = "erlang";
    TMP_TELEMETRYSDKLANGUAGEVALUES_GO = "go";
    TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA = "java";
    TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS = "nodejs";
    TMP_TELEMETRYSDKLANGUAGEVALUES_PHP = "php";
    TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON = "python";
    TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY = "ruby";
    TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS = "webjs";
    TELEMETRYSDKLANGUAGEVALUES_CPP = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP;
    TELEMETRYSDKLANGUAGEVALUES_DOTNET = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET;
    TELEMETRYSDKLANGUAGEVALUES_ERLANG = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG;
    TELEMETRYSDKLANGUAGEVALUES_GO = TMP_TELEMETRYSDKLANGUAGEVALUES_GO;
    TELEMETRYSDKLANGUAGEVALUES_JAVA = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA;
    TELEMETRYSDKLANGUAGEVALUES_NODEJS = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS;
    TELEMETRYSDKLANGUAGEVALUES_PHP = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP;
    TELEMETRYSDKLANGUAGEVALUES_PYTHON = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON;
    TELEMETRYSDKLANGUAGEVALUES_RUBY = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY;
    TELEMETRYSDKLANGUAGEVALUES_WEBJS = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS;
    TelemetrySdkLanguageValues = /* @__PURE__ */ createConstMap([
      TMP_TELEMETRYSDKLANGUAGEVALUES_CPP,
      TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET,
      TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG,
      TMP_TELEMETRYSDKLANGUAGEVALUES_GO,
      TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA,
      TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PHP,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON,
      TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY,
      TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS
    ]);
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/esm/resource/index.js
var init_resource = __esm({
  "node_modules/@opentelemetry/semantic-conventions/build/esm/resource/index.js"() {
    init_SemanticResourceAttributes();
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/esm/stable_attributes.js
var ATTR_ASPNETCORE_RATE_LIMITING_RESULT, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED, ATTR_TELEMETRY_SDK_LANGUAGE, TELEMETRY_SDK_LANGUAGE_VALUE_CPP, TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET, TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG, TELEMETRY_SDK_LANGUAGE_VALUE_GO, TELEMETRY_SDK_LANGUAGE_VALUE_JAVA, TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS, TELEMETRY_SDK_LANGUAGE_VALUE_PHP, TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON, TELEMETRY_SDK_LANGUAGE_VALUE_RUBY, TELEMETRY_SDK_LANGUAGE_VALUE_RUST, TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT, TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS, ATTR_TELEMETRY_SDK_NAME, ATTR_TELEMETRY_SDK_VERSION, ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE, ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED, ATTR_ASPNETCORE_RATE_LIMITING_POLICY, ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED, ATTR_ASPNETCORE_ROUTING_IS_FALLBACK, ATTR_ASPNETCORE_ROUTING_MATCH_STATUS, ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE, ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS, ATTR_CLIENT_ADDRESS, ATTR_CLIENT_PORT, ATTR_ERROR_TYPE, ERROR_TYPE_VALUE_OTHER, ATTR_EXCEPTION_ESCAPED, ATTR_EXCEPTION_MESSAGE, ATTR_EXCEPTION_STACKTRACE, ATTR_EXCEPTION_TYPE, ATTR_HTTP_REQUEST_HEADER, ATTR_HTTP_REQUEST_METHOD, HTTP_REQUEST_METHOD_VALUE_OTHER, HTTP_REQUEST_METHOD_VALUE_CONNECT, HTTP_REQUEST_METHOD_VALUE_DELETE, HTTP_REQUEST_METHOD_VALUE_GET, HTTP_REQUEST_METHOD_VALUE_HEAD, HTTP_REQUEST_METHOD_VALUE_OPTIONS, HTTP_REQUEST_METHOD_VALUE_PATCH, HTTP_REQUEST_METHOD_VALUE_POST, HTTP_REQUEST_METHOD_VALUE_PUT, HTTP_REQUEST_METHOD_VALUE_TRACE, ATTR_HTTP_REQUEST_METHOD_ORIGINAL, ATTR_HTTP_REQUEST_RESEND_COUNT, ATTR_HTTP_RESPONSE_HEADER, ATTR_HTTP_RESPONSE_STATUS_CODE, ATTR_HTTP_ROUTE, ATTR_JVM_GC_ACTION, ATTR_JVM_GC_NAME, ATTR_JVM_MEMORY_POOL_NAME, ATTR_JVM_MEMORY_TYPE, JVM_MEMORY_TYPE_VALUE_HEAP, JVM_MEMORY_TYPE_VALUE_NON_HEAP, ATTR_JVM_THREAD_DAEMON, ATTR_JVM_THREAD_STATE, JVM_THREAD_STATE_VALUE_BLOCKED, JVM_THREAD_STATE_VALUE_NEW, JVM_THREAD_STATE_VALUE_RUNNABLE, JVM_THREAD_STATE_VALUE_TERMINATED, JVM_THREAD_STATE_VALUE_TIMED_WAITING, JVM_THREAD_STATE_VALUE_WAITING, ATTR_NETWORK_LOCAL_ADDRESS, ATTR_NETWORK_LOCAL_PORT, ATTR_NETWORK_PEER_ADDRESS, ATTR_NETWORK_PEER_PORT, ATTR_NETWORK_PROTOCOL_NAME, ATTR_NETWORK_PROTOCOL_VERSION, ATTR_NETWORK_TRANSPORT, NETWORK_TRANSPORT_VALUE_PIPE, NETWORK_TRANSPORT_VALUE_QUIC, NETWORK_TRANSPORT_VALUE_TCP, NETWORK_TRANSPORT_VALUE_UDP, NETWORK_TRANSPORT_VALUE_UNIX, ATTR_NETWORK_TYPE, NETWORK_TYPE_VALUE_IPV4, NETWORK_TYPE_VALUE_IPV6, ATTR_OTEL_SCOPE_NAME, ATTR_OTEL_SCOPE_VERSION, ATTR_OTEL_STATUS_CODE, OTEL_STATUS_CODE_VALUE_ERROR, OTEL_STATUS_CODE_VALUE_OK, ATTR_OTEL_STATUS_DESCRIPTION, ATTR_SERVER_ADDRESS, ATTR_SERVER_PORT, ATTR_SERVICE_NAME, ATTR_SERVICE_VERSION, ATTR_SIGNALR_CONNECTION_STATUS, SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN, SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE, SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT, ATTR_SIGNALR_TRANSPORT, SIGNALR_TRANSPORT_VALUE_LONG_POLLING, SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS, SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS, ATTR_URL_FRAGMENT, ATTR_URL_FULL, ATTR_URL_PATH, ATTR_URL_QUERY, ATTR_URL_SCHEME, ATTR_USER_AGENT_ORIGINAL;
var init_stable_attributes = __esm({
  "node_modules/@opentelemetry/semantic-conventions/build/esm/stable_attributes.js"() {
    ATTR_ASPNETCORE_RATE_LIMITING_RESULT = "aspnetcore.rate_limiting.result";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED = "acquired";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER = "endpoint_limiter";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER = "global_limiter";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED = "request_canceled";
    ATTR_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
    TELEMETRY_SDK_LANGUAGE_VALUE_CPP = "cpp";
    TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET = "dotnet";
    TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG = "erlang";
    TELEMETRY_SDK_LANGUAGE_VALUE_GO = "go";
    TELEMETRY_SDK_LANGUAGE_VALUE_JAVA = "java";
    TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS = "nodejs";
    TELEMETRY_SDK_LANGUAGE_VALUE_PHP = "php";
    TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON = "python";
    TELEMETRY_SDK_LANGUAGE_VALUE_RUBY = "ruby";
    TELEMETRY_SDK_LANGUAGE_VALUE_RUST = "rust";
    TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT = "swift";
    TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS = "webjs";
    ATTR_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
    ATTR_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
    ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE = "aspnetcore.diagnostics.handler.type";
    ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT = "aspnetcore.diagnostics.exception.result";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED = "aborted";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED = "handled";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED = "skipped";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED = "unhandled";
    ATTR_ASPNETCORE_RATE_LIMITING_POLICY = "aspnetcore.rate_limiting.policy";
    ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED = "aspnetcore.request.is_unhandled";
    ATTR_ASPNETCORE_ROUTING_IS_FALLBACK = "aspnetcore.routing.is_fallback";
    ATTR_ASPNETCORE_ROUTING_MATCH_STATUS = "aspnetcore.routing.match_status";
    ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE = "failure";
    ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS = "success";
    ATTR_CLIENT_ADDRESS = "client.address";
    ATTR_CLIENT_PORT = "client.port";
    ATTR_ERROR_TYPE = "error.type";
    ERROR_TYPE_VALUE_OTHER = "_OTHER";
    ATTR_EXCEPTION_ESCAPED = "exception.escaped";
    ATTR_EXCEPTION_MESSAGE = "exception.message";
    ATTR_EXCEPTION_STACKTRACE = "exception.stacktrace";
    ATTR_EXCEPTION_TYPE = "exception.type";
    ATTR_HTTP_REQUEST_HEADER = function(key) {
      return "http.request.header." + key;
    };
    ATTR_HTTP_REQUEST_METHOD = "http.request.method";
    HTTP_REQUEST_METHOD_VALUE_OTHER = "_OTHER";
    HTTP_REQUEST_METHOD_VALUE_CONNECT = "CONNECT";
    HTTP_REQUEST_METHOD_VALUE_DELETE = "DELETE";
    HTTP_REQUEST_METHOD_VALUE_GET = "GET";
    HTTP_REQUEST_METHOD_VALUE_HEAD = "HEAD";
    HTTP_REQUEST_METHOD_VALUE_OPTIONS = "OPTIONS";
    HTTP_REQUEST_METHOD_VALUE_PATCH = "PATCH";
    HTTP_REQUEST_METHOD_VALUE_POST = "POST";
    HTTP_REQUEST_METHOD_VALUE_PUT = "PUT";
    HTTP_REQUEST_METHOD_VALUE_TRACE = "TRACE";
    ATTR_HTTP_REQUEST_METHOD_ORIGINAL = "http.request.method_original";
    ATTR_HTTP_REQUEST_RESEND_COUNT = "http.request.resend_count";
    ATTR_HTTP_RESPONSE_HEADER = function(key) {
      return "http.response.header." + key;
    };
    ATTR_HTTP_RESPONSE_STATUS_CODE = "http.response.status_code";
    ATTR_HTTP_ROUTE = "http.route";
    ATTR_JVM_GC_ACTION = "jvm.gc.action";
    ATTR_JVM_GC_NAME = "jvm.gc.name";
    ATTR_JVM_MEMORY_POOL_NAME = "jvm.memory.pool.name";
    ATTR_JVM_MEMORY_TYPE = "jvm.memory.type";
    JVM_MEMORY_TYPE_VALUE_HEAP = "heap";
    JVM_MEMORY_TYPE_VALUE_NON_HEAP = "non_heap";
    ATTR_JVM_THREAD_DAEMON = "jvm.thread.daemon";
    ATTR_JVM_THREAD_STATE = "jvm.thread.state";
    JVM_THREAD_STATE_VALUE_BLOCKED = "blocked";
    JVM_THREAD_STATE_VALUE_NEW = "new";
    JVM_THREAD_STATE_VALUE_RUNNABLE = "runnable";
    JVM_THREAD_STATE_VALUE_TERMINATED = "terminated";
    JVM_THREAD_STATE_VALUE_TIMED_WAITING = "timed_waiting";
    JVM_THREAD_STATE_VALUE_WAITING = "waiting";
    ATTR_NETWORK_LOCAL_ADDRESS = "network.local.address";
    ATTR_NETWORK_LOCAL_PORT = "network.local.port";
    ATTR_NETWORK_PEER_ADDRESS = "network.peer.address";
    ATTR_NETWORK_PEER_PORT = "network.peer.port";
    ATTR_NETWORK_PROTOCOL_NAME = "network.protocol.name";
    ATTR_NETWORK_PROTOCOL_VERSION = "network.protocol.version";
    ATTR_NETWORK_TRANSPORT = "network.transport";
    NETWORK_TRANSPORT_VALUE_PIPE = "pipe";
    NETWORK_TRANSPORT_VALUE_QUIC = "quic";
    NETWORK_TRANSPORT_VALUE_TCP = "tcp";
    NETWORK_TRANSPORT_VALUE_UDP = "udp";
    NETWORK_TRANSPORT_VALUE_UNIX = "unix";
    ATTR_NETWORK_TYPE = "network.type";
    NETWORK_TYPE_VALUE_IPV4 = "ipv4";
    NETWORK_TYPE_VALUE_IPV6 = "ipv6";
    ATTR_OTEL_SCOPE_NAME = "otel.scope.name";
    ATTR_OTEL_SCOPE_VERSION = "otel.scope.version";
    ATTR_OTEL_STATUS_CODE = "otel.status_code";
    OTEL_STATUS_CODE_VALUE_ERROR = "ERROR";
    OTEL_STATUS_CODE_VALUE_OK = "OK";
    ATTR_OTEL_STATUS_DESCRIPTION = "otel.status_description";
    ATTR_SERVER_ADDRESS = "server.address";
    ATTR_SERVER_PORT = "server.port";
    ATTR_SERVICE_NAME = "service.name";
    ATTR_SERVICE_VERSION = "service.version";
    ATTR_SIGNALR_CONNECTION_STATUS = "signalr.connection.status";
    SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN = "app_shutdown";
    SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE = "normal_closure";
    SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT = "timeout";
    ATTR_SIGNALR_TRANSPORT = "signalr.transport";
    SIGNALR_TRANSPORT_VALUE_LONG_POLLING = "long_polling";
    SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS = "server_sent_events";
    SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS = "web_sockets";
    ATTR_URL_FRAGMENT = "url.fragment";
    ATTR_URL_FULL = "url.full";
    ATTR_URL_PATH = "url.path";
    ATTR_URL_QUERY = "url.query";
    ATTR_URL_SCHEME = "url.scheme";
    ATTR_USER_AGENT_ORIGINAL = "user_agent.original";
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/esm/stable_metrics.js
var METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS, METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES, METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS, METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE, METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION, METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS, METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS, METRIC_HTTP_CLIENT_REQUEST_DURATION, METRIC_HTTP_SERVER_REQUEST_DURATION, METRIC_JVM_CLASS_COUNT, METRIC_JVM_CLASS_LOADED, METRIC_JVM_CLASS_UNLOADED, METRIC_JVM_CPU_COUNT, METRIC_JVM_CPU_RECENT_UTILIZATION, METRIC_JVM_CPU_TIME, METRIC_JVM_GC_DURATION, METRIC_JVM_MEMORY_COMMITTED, METRIC_JVM_MEMORY_LIMIT, METRIC_JVM_MEMORY_USED, METRIC_JVM_MEMORY_USED_AFTER_LAST_GC, METRIC_JVM_THREAD_COUNT, METRIC_KESTREL_ACTIVE_CONNECTIONS, METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES, METRIC_KESTREL_CONNECTION_DURATION, METRIC_KESTREL_QUEUED_CONNECTIONS, METRIC_KESTREL_QUEUED_REQUESTS, METRIC_KESTREL_REJECTED_CONNECTIONS, METRIC_KESTREL_TLS_HANDSHAKE_DURATION, METRIC_KESTREL_UPGRADED_CONNECTIONS, METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS, METRIC_SIGNALR_SERVER_CONNECTION_DURATION;
var init_stable_metrics = __esm({
  "node_modules/@opentelemetry/semantic-conventions/build/esm/stable_metrics.js"() {
    METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS = "aspnetcore.diagnostics.exceptions";
    METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES = "aspnetcore.rate_limiting.active_request_leases";
    METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS = "aspnetcore.rate_limiting.queued_requests";
    METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE = "aspnetcore.rate_limiting.request.time_in_queue";
    METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION = "aspnetcore.rate_limiting.request_lease.duration";
    METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS = "aspnetcore.rate_limiting.requests";
    METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS = "aspnetcore.routing.match_attempts";
    METRIC_HTTP_CLIENT_REQUEST_DURATION = "http.client.request.duration";
    METRIC_HTTP_SERVER_REQUEST_DURATION = "http.server.request.duration";
    METRIC_JVM_CLASS_COUNT = "jvm.class.count";
    METRIC_JVM_CLASS_LOADED = "jvm.class.loaded";
    METRIC_JVM_CLASS_UNLOADED = "jvm.class.unloaded";
    METRIC_JVM_CPU_COUNT = "jvm.cpu.count";
    METRIC_JVM_CPU_RECENT_UTILIZATION = "jvm.cpu.recent_utilization";
    METRIC_JVM_CPU_TIME = "jvm.cpu.time";
    METRIC_JVM_GC_DURATION = "jvm.gc.duration";
    METRIC_JVM_MEMORY_COMMITTED = "jvm.memory.committed";
    METRIC_JVM_MEMORY_LIMIT = "jvm.memory.limit";
    METRIC_JVM_MEMORY_USED = "jvm.memory.used";
    METRIC_JVM_MEMORY_USED_AFTER_LAST_GC = "jvm.memory.used_after_last_gc";
    METRIC_JVM_THREAD_COUNT = "jvm.thread.count";
    METRIC_KESTREL_ACTIVE_CONNECTIONS = "kestrel.active_connections";
    METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES = "kestrel.active_tls_handshakes";
    METRIC_KESTREL_CONNECTION_DURATION = "kestrel.connection.duration";
    METRIC_KESTREL_QUEUED_CONNECTIONS = "kestrel.queued_connections";
    METRIC_KESTREL_QUEUED_REQUESTS = "kestrel.queued_requests";
    METRIC_KESTREL_REJECTED_CONNECTIONS = "kestrel.rejected_connections";
    METRIC_KESTREL_TLS_HANDSHAKE_DURATION = "kestrel.tls_handshake.duration";
    METRIC_KESTREL_UPGRADED_CONNECTIONS = "kestrel.upgraded_connections";
    METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS = "signalr.server.active_connections";
    METRIC_SIGNALR_SERVER_CONNECTION_DURATION = "signalr.server.connection.duration";
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED,
  ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE: () => ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE,
  ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS: () => ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS,
  ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT: () => ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT,
  ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE: () => ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE,
  ATTR_ASPNETCORE_RATE_LIMITING_POLICY: () => ATTR_ASPNETCORE_RATE_LIMITING_POLICY,
  ATTR_ASPNETCORE_RATE_LIMITING_RESULT: () => ATTR_ASPNETCORE_RATE_LIMITING_RESULT,
  ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED: () => ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED,
  ATTR_ASPNETCORE_ROUTING_IS_FALLBACK: () => ATTR_ASPNETCORE_ROUTING_IS_FALLBACK,
  ATTR_ASPNETCORE_ROUTING_MATCH_STATUS: () => ATTR_ASPNETCORE_ROUTING_MATCH_STATUS,
  ATTR_CLIENT_ADDRESS: () => ATTR_CLIENT_ADDRESS,
  ATTR_CLIENT_PORT: () => ATTR_CLIENT_PORT,
  ATTR_ERROR_TYPE: () => ATTR_ERROR_TYPE,
  ATTR_EXCEPTION_ESCAPED: () => ATTR_EXCEPTION_ESCAPED,
  ATTR_EXCEPTION_MESSAGE: () => ATTR_EXCEPTION_MESSAGE,
  ATTR_EXCEPTION_STACKTRACE: () => ATTR_EXCEPTION_STACKTRACE,
  ATTR_EXCEPTION_TYPE: () => ATTR_EXCEPTION_TYPE,
  ATTR_HTTP_REQUEST_HEADER: () => ATTR_HTTP_REQUEST_HEADER,
  ATTR_HTTP_REQUEST_METHOD: () => ATTR_HTTP_REQUEST_METHOD,
  ATTR_HTTP_REQUEST_METHOD_ORIGINAL: () => ATTR_HTTP_REQUEST_METHOD_ORIGINAL,
  ATTR_HTTP_REQUEST_RESEND_COUNT: () => ATTR_HTTP_REQUEST_RESEND_COUNT,
  ATTR_HTTP_RESPONSE_HEADER: () => ATTR_HTTP_RESPONSE_HEADER,
  ATTR_HTTP_RESPONSE_STATUS_CODE: () => ATTR_HTTP_RESPONSE_STATUS_CODE,
  ATTR_HTTP_ROUTE: () => ATTR_HTTP_ROUTE,
  ATTR_JVM_GC_ACTION: () => ATTR_JVM_GC_ACTION,
  ATTR_JVM_GC_NAME: () => ATTR_JVM_GC_NAME,
  ATTR_JVM_MEMORY_POOL_NAME: () => ATTR_JVM_MEMORY_POOL_NAME,
  ATTR_JVM_MEMORY_TYPE: () => ATTR_JVM_MEMORY_TYPE,
  ATTR_JVM_THREAD_DAEMON: () => ATTR_JVM_THREAD_DAEMON,
  ATTR_JVM_THREAD_STATE: () => ATTR_JVM_THREAD_STATE,
  ATTR_NETWORK_LOCAL_ADDRESS: () => ATTR_NETWORK_LOCAL_ADDRESS,
  ATTR_NETWORK_LOCAL_PORT: () => ATTR_NETWORK_LOCAL_PORT,
  ATTR_NETWORK_PEER_ADDRESS: () => ATTR_NETWORK_PEER_ADDRESS,
  ATTR_NETWORK_PEER_PORT: () => ATTR_NETWORK_PEER_PORT,
  ATTR_NETWORK_PROTOCOL_NAME: () => ATTR_NETWORK_PROTOCOL_NAME,
  ATTR_NETWORK_PROTOCOL_VERSION: () => ATTR_NETWORK_PROTOCOL_VERSION,
  ATTR_NETWORK_TRANSPORT: () => ATTR_NETWORK_TRANSPORT,
  ATTR_NETWORK_TYPE: () => ATTR_NETWORK_TYPE,
  ATTR_OTEL_SCOPE_NAME: () => ATTR_OTEL_SCOPE_NAME,
  ATTR_OTEL_SCOPE_VERSION: () => ATTR_OTEL_SCOPE_VERSION,
  ATTR_OTEL_STATUS_CODE: () => ATTR_OTEL_STATUS_CODE,
  ATTR_OTEL_STATUS_DESCRIPTION: () => ATTR_OTEL_STATUS_DESCRIPTION,
  ATTR_SERVER_ADDRESS: () => ATTR_SERVER_ADDRESS,
  ATTR_SERVER_PORT: () => ATTR_SERVER_PORT,
  ATTR_SERVICE_NAME: () => ATTR_SERVICE_NAME,
  ATTR_SERVICE_VERSION: () => ATTR_SERVICE_VERSION,
  ATTR_SIGNALR_CONNECTION_STATUS: () => ATTR_SIGNALR_CONNECTION_STATUS,
  ATTR_SIGNALR_TRANSPORT: () => ATTR_SIGNALR_TRANSPORT,
  ATTR_TELEMETRY_SDK_LANGUAGE: () => ATTR_TELEMETRY_SDK_LANGUAGE,
  ATTR_TELEMETRY_SDK_NAME: () => ATTR_TELEMETRY_SDK_NAME,
  ATTR_TELEMETRY_SDK_VERSION: () => ATTR_TELEMETRY_SDK_VERSION,
  ATTR_URL_FRAGMENT: () => ATTR_URL_FRAGMENT,
  ATTR_URL_FULL: () => ATTR_URL_FULL,
  ATTR_URL_PATH: () => ATTR_URL_PATH,
  ATTR_URL_QUERY: () => ATTR_URL_QUERY,
  ATTR_URL_SCHEME: () => ATTR_URL_SCHEME,
  ATTR_USER_AGENT_ORIGINAL: () => ATTR_USER_AGENT_ORIGINAL,
  AWSECSLAUNCHTYPEVALUES_EC2: () => AWSECSLAUNCHTYPEVALUES_EC2,
  AWSECSLAUNCHTYPEVALUES_FARGATE: () => AWSECSLAUNCHTYPEVALUES_FARGATE,
  AwsEcsLaunchtypeValues: () => AwsEcsLaunchtypeValues,
  CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS: () => CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS,
  CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC: () => CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC,
  CLOUDPLATFORMVALUES_AWS_EC2: () => CLOUDPLATFORMVALUES_AWS_EC2,
  CLOUDPLATFORMVALUES_AWS_ECS: () => CLOUDPLATFORMVALUES_AWS_ECS,
  CLOUDPLATFORMVALUES_AWS_EKS: () => CLOUDPLATFORMVALUES_AWS_EKS,
  CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK: () => CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK,
  CLOUDPLATFORMVALUES_AWS_LAMBDA: () => CLOUDPLATFORMVALUES_AWS_LAMBDA,
  CLOUDPLATFORMVALUES_AZURE_AKS: () => CLOUDPLATFORMVALUES_AZURE_AKS,
  CLOUDPLATFORMVALUES_AZURE_APP_SERVICE: () => CLOUDPLATFORMVALUES_AZURE_APP_SERVICE,
  CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES: () => CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES,
  CLOUDPLATFORMVALUES_AZURE_FUNCTIONS: () => CLOUDPLATFORMVALUES_AZURE_FUNCTIONS,
  CLOUDPLATFORMVALUES_AZURE_VM: () => CLOUDPLATFORMVALUES_AZURE_VM,
  CLOUDPLATFORMVALUES_GCP_APP_ENGINE: () => CLOUDPLATFORMVALUES_GCP_APP_ENGINE,
  CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS: () => CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS,
  CLOUDPLATFORMVALUES_GCP_CLOUD_RUN: () => CLOUDPLATFORMVALUES_GCP_CLOUD_RUN,
  CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE: () => CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE,
  CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE: () => CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE,
  CLOUDPROVIDERVALUES_ALIBABA_CLOUD: () => CLOUDPROVIDERVALUES_ALIBABA_CLOUD,
  CLOUDPROVIDERVALUES_AWS: () => CLOUDPROVIDERVALUES_AWS,
  CLOUDPROVIDERVALUES_AZURE: () => CLOUDPROVIDERVALUES_AZURE,
  CLOUDPROVIDERVALUES_GCP: () => CLOUDPROVIDERVALUES_GCP,
  CloudPlatformValues: () => CloudPlatformValues,
  CloudProviderValues: () => CloudProviderValues,
  DBCASSANDRACONSISTENCYLEVELVALUES_ALL: () => DBCASSANDRACONSISTENCYLEVELVALUES_ALL,
  DBCASSANDRACONSISTENCYLEVELVALUES_ANY: () => DBCASSANDRACONSISTENCYLEVELVALUES_ANY,
  DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL,
  DBCASSANDRACONSISTENCYLEVELVALUES_ONE: () => DBCASSANDRACONSISTENCYLEVELVALUES_ONE,
  DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM,
  DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL: () => DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL,
  DBCASSANDRACONSISTENCYLEVELVALUES_THREE: () => DBCASSANDRACONSISTENCYLEVELVALUES_THREE,
  DBCASSANDRACONSISTENCYLEVELVALUES_TWO: () => DBCASSANDRACONSISTENCYLEVELVALUES_TWO,
  DBSYSTEMVALUES_ADABAS: () => DBSYSTEMVALUES_ADABAS,
  DBSYSTEMVALUES_CACHE: () => DBSYSTEMVALUES_CACHE,
  DBSYSTEMVALUES_CASSANDRA: () => DBSYSTEMVALUES_CASSANDRA,
  DBSYSTEMVALUES_CLOUDSCAPE: () => DBSYSTEMVALUES_CLOUDSCAPE,
  DBSYSTEMVALUES_COCKROACHDB: () => DBSYSTEMVALUES_COCKROACHDB,
  DBSYSTEMVALUES_COLDFUSION: () => DBSYSTEMVALUES_COLDFUSION,
  DBSYSTEMVALUES_COSMOSDB: () => DBSYSTEMVALUES_COSMOSDB,
  DBSYSTEMVALUES_COUCHBASE: () => DBSYSTEMVALUES_COUCHBASE,
  DBSYSTEMVALUES_COUCHDB: () => DBSYSTEMVALUES_COUCHDB,
  DBSYSTEMVALUES_DB2: () => DBSYSTEMVALUES_DB2,
  DBSYSTEMVALUES_DERBY: () => DBSYSTEMVALUES_DERBY,
  DBSYSTEMVALUES_DYNAMODB: () => DBSYSTEMVALUES_DYNAMODB,
  DBSYSTEMVALUES_EDB: () => DBSYSTEMVALUES_EDB,
  DBSYSTEMVALUES_ELASTICSEARCH: () => DBSYSTEMVALUES_ELASTICSEARCH,
  DBSYSTEMVALUES_FILEMAKER: () => DBSYSTEMVALUES_FILEMAKER,
  DBSYSTEMVALUES_FIREBIRD: () => DBSYSTEMVALUES_FIREBIRD,
  DBSYSTEMVALUES_FIRSTSQL: () => DBSYSTEMVALUES_FIRSTSQL,
  DBSYSTEMVALUES_GEODE: () => DBSYSTEMVALUES_GEODE,
  DBSYSTEMVALUES_H2: () => DBSYSTEMVALUES_H2,
  DBSYSTEMVALUES_HANADB: () => DBSYSTEMVALUES_HANADB,
  DBSYSTEMVALUES_HBASE: () => DBSYSTEMVALUES_HBASE,
  DBSYSTEMVALUES_HIVE: () => DBSYSTEMVALUES_HIVE,
  DBSYSTEMVALUES_HSQLDB: () => DBSYSTEMVALUES_HSQLDB,
  DBSYSTEMVALUES_INFORMIX: () => DBSYSTEMVALUES_INFORMIX,
  DBSYSTEMVALUES_INGRES: () => DBSYSTEMVALUES_INGRES,
  DBSYSTEMVALUES_INSTANTDB: () => DBSYSTEMVALUES_INSTANTDB,
  DBSYSTEMVALUES_INTERBASE: () => DBSYSTEMVALUES_INTERBASE,
  DBSYSTEMVALUES_MARIADB: () => DBSYSTEMVALUES_MARIADB,
  DBSYSTEMVALUES_MAXDB: () => DBSYSTEMVALUES_MAXDB,
  DBSYSTEMVALUES_MEMCACHED: () => DBSYSTEMVALUES_MEMCACHED,
  DBSYSTEMVALUES_MONGODB: () => DBSYSTEMVALUES_MONGODB,
  DBSYSTEMVALUES_MSSQL: () => DBSYSTEMVALUES_MSSQL,
  DBSYSTEMVALUES_MYSQL: () => DBSYSTEMVALUES_MYSQL,
  DBSYSTEMVALUES_NEO4J: () => DBSYSTEMVALUES_NEO4J,
  DBSYSTEMVALUES_NETEZZA: () => DBSYSTEMVALUES_NETEZZA,
  DBSYSTEMVALUES_ORACLE: () => DBSYSTEMVALUES_ORACLE,
  DBSYSTEMVALUES_OTHER_SQL: () => DBSYSTEMVALUES_OTHER_SQL,
  DBSYSTEMVALUES_PERVASIVE: () => DBSYSTEMVALUES_PERVASIVE,
  DBSYSTEMVALUES_POINTBASE: () => DBSYSTEMVALUES_POINTBASE,
  DBSYSTEMVALUES_POSTGRESQL: () => DBSYSTEMVALUES_POSTGRESQL,
  DBSYSTEMVALUES_PROGRESS: () => DBSYSTEMVALUES_PROGRESS,
  DBSYSTEMVALUES_REDIS: () => DBSYSTEMVALUES_REDIS,
  DBSYSTEMVALUES_REDSHIFT: () => DBSYSTEMVALUES_REDSHIFT,
  DBSYSTEMVALUES_SQLITE: () => DBSYSTEMVALUES_SQLITE,
  DBSYSTEMVALUES_SYBASE: () => DBSYSTEMVALUES_SYBASE,
  DBSYSTEMVALUES_TERADATA: () => DBSYSTEMVALUES_TERADATA,
  DBSYSTEMVALUES_VERTICA: () => DBSYSTEMVALUES_VERTICA,
  DbCassandraConsistencyLevelValues: () => DbCassandraConsistencyLevelValues,
  DbSystemValues: () => DbSystemValues,
  ERROR_TYPE_VALUE_OTHER: () => ERROR_TYPE_VALUE_OTHER,
  FAASDOCUMENTOPERATIONVALUES_DELETE: () => FAASDOCUMENTOPERATIONVALUES_DELETE,
  FAASDOCUMENTOPERATIONVALUES_EDIT: () => FAASDOCUMENTOPERATIONVALUES_EDIT,
  FAASDOCUMENTOPERATIONVALUES_INSERT: () => FAASDOCUMENTOPERATIONVALUES_INSERT,
  FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD: () => FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD,
  FAASINVOKEDPROVIDERVALUES_AWS: () => FAASINVOKEDPROVIDERVALUES_AWS,
  FAASINVOKEDPROVIDERVALUES_AZURE: () => FAASINVOKEDPROVIDERVALUES_AZURE,
  FAASINVOKEDPROVIDERVALUES_GCP: () => FAASINVOKEDPROVIDERVALUES_GCP,
  FAASTRIGGERVALUES_DATASOURCE: () => FAASTRIGGERVALUES_DATASOURCE,
  FAASTRIGGERVALUES_HTTP: () => FAASTRIGGERVALUES_HTTP,
  FAASTRIGGERVALUES_OTHER: () => FAASTRIGGERVALUES_OTHER,
  FAASTRIGGERVALUES_PUBSUB: () => FAASTRIGGERVALUES_PUBSUB,
  FAASTRIGGERVALUES_TIMER: () => FAASTRIGGERVALUES_TIMER,
  FaasDocumentOperationValues: () => FaasDocumentOperationValues,
  FaasInvokedProviderValues: () => FaasInvokedProviderValues,
  FaasTriggerValues: () => FaasTriggerValues,
  HOSTARCHVALUES_AMD64: () => HOSTARCHVALUES_AMD64,
  HOSTARCHVALUES_ARM32: () => HOSTARCHVALUES_ARM32,
  HOSTARCHVALUES_ARM64: () => HOSTARCHVALUES_ARM64,
  HOSTARCHVALUES_IA64: () => HOSTARCHVALUES_IA64,
  HOSTARCHVALUES_PPC32: () => HOSTARCHVALUES_PPC32,
  HOSTARCHVALUES_PPC64: () => HOSTARCHVALUES_PPC64,
  HOSTARCHVALUES_X86: () => HOSTARCHVALUES_X86,
  HTTPFLAVORVALUES_HTTP_1_0: () => HTTPFLAVORVALUES_HTTP_1_0,
  HTTPFLAVORVALUES_HTTP_1_1: () => HTTPFLAVORVALUES_HTTP_1_1,
  HTTPFLAVORVALUES_HTTP_2_0: () => HTTPFLAVORVALUES_HTTP_2_0,
  HTTPFLAVORVALUES_QUIC: () => HTTPFLAVORVALUES_QUIC,
  HTTPFLAVORVALUES_SPDY: () => HTTPFLAVORVALUES_SPDY,
  HTTP_REQUEST_METHOD_VALUE_CONNECT: () => HTTP_REQUEST_METHOD_VALUE_CONNECT,
  HTTP_REQUEST_METHOD_VALUE_DELETE: () => HTTP_REQUEST_METHOD_VALUE_DELETE,
  HTTP_REQUEST_METHOD_VALUE_GET: () => HTTP_REQUEST_METHOD_VALUE_GET,
  HTTP_REQUEST_METHOD_VALUE_HEAD: () => HTTP_REQUEST_METHOD_VALUE_HEAD,
  HTTP_REQUEST_METHOD_VALUE_OPTIONS: () => HTTP_REQUEST_METHOD_VALUE_OPTIONS,
  HTTP_REQUEST_METHOD_VALUE_OTHER: () => HTTP_REQUEST_METHOD_VALUE_OTHER,
  HTTP_REQUEST_METHOD_VALUE_PATCH: () => HTTP_REQUEST_METHOD_VALUE_PATCH,
  HTTP_REQUEST_METHOD_VALUE_POST: () => HTTP_REQUEST_METHOD_VALUE_POST,
  HTTP_REQUEST_METHOD_VALUE_PUT: () => HTTP_REQUEST_METHOD_VALUE_PUT,
  HTTP_REQUEST_METHOD_VALUE_TRACE: () => HTTP_REQUEST_METHOD_VALUE_TRACE,
  HostArchValues: () => HostArchValues,
  HttpFlavorValues: () => HttpFlavorValues,
  JVM_MEMORY_TYPE_VALUE_HEAP: () => JVM_MEMORY_TYPE_VALUE_HEAP,
  JVM_MEMORY_TYPE_VALUE_NON_HEAP: () => JVM_MEMORY_TYPE_VALUE_NON_HEAP,
  JVM_THREAD_STATE_VALUE_BLOCKED: () => JVM_THREAD_STATE_VALUE_BLOCKED,
  JVM_THREAD_STATE_VALUE_NEW: () => JVM_THREAD_STATE_VALUE_NEW,
  JVM_THREAD_STATE_VALUE_RUNNABLE: () => JVM_THREAD_STATE_VALUE_RUNNABLE,
  JVM_THREAD_STATE_VALUE_TERMINATED: () => JVM_THREAD_STATE_VALUE_TERMINATED,
  JVM_THREAD_STATE_VALUE_TIMED_WAITING: () => JVM_THREAD_STATE_VALUE_TIMED_WAITING,
  JVM_THREAD_STATE_VALUE_WAITING: () => JVM_THREAD_STATE_VALUE_WAITING,
  MESSAGETYPEVALUES_RECEIVED: () => MESSAGETYPEVALUES_RECEIVED,
  MESSAGETYPEVALUES_SENT: () => MESSAGETYPEVALUES_SENT,
  MESSAGINGDESTINATIONKINDVALUES_QUEUE: () => MESSAGINGDESTINATIONKINDVALUES_QUEUE,
  MESSAGINGDESTINATIONKINDVALUES_TOPIC: () => MESSAGINGDESTINATIONKINDVALUES_TOPIC,
  MESSAGINGOPERATIONVALUES_PROCESS: () => MESSAGINGOPERATIONVALUES_PROCESS,
  MESSAGINGOPERATIONVALUES_RECEIVE: () => MESSAGINGOPERATIONVALUES_RECEIVE,
  METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS: () => METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS,
  METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES: () => METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES,
  METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS: () => METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE,
  METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS: () => METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS,
  METRIC_HTTP_CLIENT_REQUEST_DURATION: () => METRIC_HTTP_CLIENT_REQUEST_DURATION,
  METRIC_HTTP_SERVER_REQUEST_DURATION: () => METRIC_HTTP_SERVER_REQUEST_DURATION,
  METRIC_JVM_CLASS_COUNT: () => METRIC_JVM_CLASS_COUNT,
  METRIC_JVM_CLASS_LOADED: () => METRIC_JVM_CLASS_LOADED,
  METRIC_JVM_CLASS_UNLOADED: () => METRIC_JVM_CLASS_UNLOADED,
  METRIC_JVM_CPU_COUNT: () => METRIC_JVM_CPU_COUNT,
  METRIC_JVM_CPU_RECENT_UTILIZATION: () => METRIC_JVM_CPU_RECENT_UTILIZATION,
  METRIC_JVM_CPU_TIME: () => METRIC_JVM_CPU_TIME,
  METRIC_JVM_GC_DURATION: () => METRIC_JVM_GC_DURATION,
  METRIC_JVM_MEMORY_COMMITTED: () => METRIC_JVM_MEMORY_COMMITTED,
  METRIC_JVM_MEMORY_LIMIT: () => METRIC_JVM_MEMORY_LIMIT,
  METRIC_JVM_MEMORY_USED: () => METRIC_JVM_MEMORY_USED,
  METRIC_JVM_MEMORY_USED_AFTER_LAST_GC: () => METRIC_JVM_MEMORY_USED_AFTER_LAST_GC,
  METRIC_JVM_THREAD_COUNT: () => METRIC_JVM_THREAD_COUNT,
  METRIC_KESTREL_ACTIVE_CONNECTIONS: () => METRIC_KESTREL_ACTIVE_CONNECTIONS,
  METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES: () => METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES,
  METRIC_KESTREL_CONNECTION_DURATION: () => METRIC_KESTREL_CONNECTION_DURATION,
  METRIC_KESTREL_QUEUED_CONNECTIONS: () => METRIC_KESTREL_QUEUED_CONNECTIONS,
  METRIC_KESTREL_QUEUED_REQUESTS: () => METRIC_KESTREL_QUEUED_REQUESTS,
  METRIC_KESTREL_REJECTED_CONNECTIONS: () => METRIC_KESTREL_REJECTED_CONNECTIONS,
  METRIC_KESTREL_TLS_HANDSHAKE_DURATION: () => METRIC_KESTREL_TLS_HANDSHAKE_DURATION,
  METRIC_KESTREL_UPGRADED_CONNECTIONS: () => METRIC_KESTREL_UPGRADED_CONNECTIONS,
  METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS: () => METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS,
  METRIC_SIGNALR_SERVER_CONNECTION_DURATION: () => METRIC_SIGNALR_SERVER_CONNECTION_DURATION,
  MessageTypeValues: () => MessageTypeValues,
  MessagingDestinationKindValues: () => MessagingDestinationKindValues,
  MessagingOperationValues: () => MessagingOperationValues,
  NETHOSTCONNECTIONSUBTYPEVALUES_CDMA: () => NETHOSTCONNECTIONSUBTYPEVALUES_CDMA,
  NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT: () => NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT,
  NETHOSTCONNECTIONSUBTYPEVALUES_EDGE: () => NETHOSTCONNECTIONSUBTYPEVALUES_EDGE,
  NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD: () => NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B,
  NETHOSTCONNECTIONSUBTYPEVALUES_GPRS: () => NETHOSTCONNECTIONSUBTYPEVALUES_GPRS,
  NETHOSTCONNECTIONSUBTYPEVALUES_GSM: () => NETHOSTCONNECTIONSUBTYPEVALUES_GSM,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSPA,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA,
  NETHOSTCONNECTIONSUBTYPEVALUES_IDEN: () => NETHOSTCONNECTIONSUBTYPEVALUES_IDEN,
  NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN: () => NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN,
  NETHOSTCONNECTIONSUBTYPEVALUES_LTE: () => NETHOSTCONNECTIONSUBTYPEVALUES_LTE,
  NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA: () => NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA,
  NETHOSTCONNECTIONSUBTYPEVALUES_NR: () => NETHOSTCONNECTIONSUBTYPEVALUES_NR,
  NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA: () => NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA,
  NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA: () => NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA,
  NETHOSTCONNECTIONSUBTYPEVALUES_UMTS: () => NETHOSTCONNECTIONSUBTYPEVALUES_UMTS,
  NETHOSTCONNECTIONTYPEVALUES_CELL: () => NETHOSTCONNECTIONTYPEVALUES_CELL,
  NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE: () => NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE,
  NETHOSTCONNECTIONTYPEVALUES_UNKNOWN: () => NETHOSTCONNECTIONTYPEVALUES_UNKNOWN,
  NETHOSTCONNECTIONTYPEVALUES_WIFI: () => NETHOSTCONNECTIONTYPEVALUES_WIFI,
  NETHOSTCONNECTIONTYPEVALUES_WIRED: () => NETHOSTCONNECTIONTYPEVALUES_WIRED,
  NETTRANSPORTVALUES_INPROC: () => NETTRANSPORTVALUES_INPROC,
  NETTRANSPORTVALUES_IP: () => NETTRANSPORTVALUES_IP,
  NETTRANSPORTVALUES_IP_TCP: () => NETTRANSPORTVALUES_IP_TCP,
  NETTRANSPORTVALUES_IP_UDP: () => NETTRANSPORTVALUES_IP_UDP,
  NETTRANSPORTVALUES_OTHER: () => NETTRANSPORTVALUES_OTHER,
  NETTRANSPORTVALUES_PIPE: () => NETTRANSPORTVALUES_PIPE,
  NETTRANSPORTVALUES_UNIX: () => NETTRANSPORTVALUES_UNIX,
  NETWORK_TRANSPORT_VALUE_PIPE: () => NETWORK_TRANSPORT_VALUE_PIPE,
  NETWORK_TRANSPORT_VALUE_QUIC: () => NETWORK_TRANSPORT_VALUE_QUIC,
  NETWORK_TRANSPORT_VALUE_TCP: () => NETWORK_TRANSPORT_VALUE_TCP,
  NETWORK_TRANSPORT_VALUE_UDP: () => NETWORK_TRANSPORT_VALUE_UDP,
  NETWORK_TRANSPORT_VALUE_UNIX: () => NETWORK_TRANSPORT_VALUE_UNIX,
  NETWORK_TYPE_VALUE_IPV4: () => NETWORK_TYPE_VALUE_IPV4,
  NETWORK_TYPE_VALUE_IPV6: () => NETWORK_TYPE_VALUE_IPV6,
  NetHostConnectionSubtypeValues: () => NetHostConnectionSubtypeValues,
  NetHostConnectionTypeValues: () => NetHostConnectionTypeValues,
  NetTransportValues: () => NetTransportValues,
  OSTYPEVALUES_AIX: () => OSTYPEVALUES_AIX,
  OSTYPEVALUES_DARWIN: () => OSTYPEVALUES_DARWIN,
  OSTYPEVALUES_DRAGONFLYBSD: () => OSTYPEVALUES_DRAGONFLYBSD,
  OSTYPEVALUES_FREEBSD: () => OSTYPEVALUES_FREEBSD,
  OSTYPEVALUES_HPUX: () => OSTYPEVALUES_HPUX,
  OSTYPEVALUES_LINUX: () => OSTYPEVALUES_LINUX,
  OSTYPEVALUES_NETBSD: () => OSTYPEVALUES_NETBSD,
  OSTYPEVALUES_OPENBSD: () => OSTYPEVALUES_OPENBSD,
  OSTYPEVALUES_SOLARIS: () => OSTYPEVALUES_SOLARIS,
  OSTYPEVALUES_WINDOWS: () => OSTYPEVALUES_WINDOWS,
  OSTYPEVALUES_Z_OS: () => OSTYPEVALUES_Z_OS,
  OTEL_STATUS_CODE_VALUE_ERROR: () => OTEL_STATUS_CODE_VALUE_ERROR,
  OTEL_STATUS_CODE_VALUE_OK: () => OTEL_STATUS_CODE_VALUE_OK,
  OsTypeValues: () => OsTypeValues,
  RPCGRPCSTATUSCODEVALUES_ABORTED: () => RPCGRPCSTATUSCODEVALUES_ABORTED,
  RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS: () => RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS,
  RPCGRPCSTATUSCODEVALUES_CANCELLED: () => RPCGRPCSTATUSCODEVALUES_CANCELLED,
  RPCGRPCSTATUSCODEVALUES_DATA_LOSS: () => RPCGRPCSTATUSCODEVALUES_DATA_LOSS,
  RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED: () => RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED,
  RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION: () => RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION,
  RPCGRPCSTATUSCODEVALUES_INTERNAL: () => RPCGRPCSTATUSCODEVALUES_INTERNAL,
  RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT: () => RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT,
  RPCGRPCSTATUSCODEVALUES_NOT_FOUND: () => RPCGRPCSTATUSCODEVALUES_NOT_FOUND,
  RPCGRPCSTATUSCODEVALUES_OK: () => RPCGRPCSTATUSCODEVALUES_OK,
  RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE: () => RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE,
  RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED: () => RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED,
  RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED: () => RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED,
  RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED: () => RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED,
  RPCGRPCSTATUSCODEVALUES_UNAVAILABLE: () => RPCGRPCSTATUSCODEVALUES_UNAVAILABLE,
  RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED: () => RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED,
  RPCGRPCSTATUSCODEVALUES_UNKNOWN: () => RPCGRPCSTATUSCODEVALUES_UNKNOWN,
  RpcGrpcStatusCodeValues: () => RpcGrpcStatusCodeValues,
  SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET: () => SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET,
  SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: () => SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS,
  SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ: () => SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ,
  SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY,
  SEMATTRS_AWS_DYNAMODB_COUNT: () => SEMATTRS_AWS_DYNAMODB_COUNT,
  SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE: () => SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE,
  SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: () => SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES,
  SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: () => SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES,
  SEMATTRS_AWS_DYNAMODB_INDEX_NAME: () => SEMATTRS_AWS_DYNAMODB_INDEX_NAME,
  SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS: () => SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS,
  SEMATTRS_AWS_DYNAMODB_LIMIT: () => SEMATTRS_AWS_DYNAMODB_LIMIT,
  SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: () => SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES,
  SEMATTRS_AWS_DYNAMODB_PROJECTION: () => SEMATTRS_AWS_DYNAMODB_PROJECTION,
  SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY,
  SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY,
  SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT: () => SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT,
  SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD: () => SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD,
  SEMATTRS_AWS_DYNAMODB_SEGMENT: () => SEMATTRS_AWS_DYNAMODB_SEGMENT,
  SEMATTRS_AWS_DYNAMODB_SELECT: () => SEMATTRS_AWS_DYNAMODB_SELECT,
  SEMATTRS_AWS_DYNAMODB_TABLE_COUNT: () => SEMATTRS_AWS_DYNAMODB_TABLE_COUNT,
  SEMATTRS_AWS_DYNAMODB_TABLE_NAMES: () => SEMATTRS_AWS_DYNAMODB_TABLE_NAMES,
  SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS: () => SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS,
  SEMATTRS_AWS_LAMBDA_INVOKED_ARN: () => SEMATTRS_AWS_LAMBDA_INVOKED_ARN,
  SEMATTRS_CODE_FILEPATH: () => SEMATTRS_CODE_FILEPATH,
  SEMATTRS_CODE_FUNCTION: () => SEMATTRS_CODE_FUNCTION,
  SEMATTRS_CODE_LINENO: () => SEMATTRS_CODE_LINENO,
  SEMATTRS_CODE_NAMESPACE: () => SEMATTRS_CODE_NAMESPACE,
  SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL: () => SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL,
  SEMATTRS_DB_CASSANDRA_COORDINATOR_DC: () => SEMATTRS_DB_CASSANDRA_COORDINATOR_DC,
  SEMATTRS_DB_CASSANDRA_COORDINATOR_ID: () => SEMATTRS_DB_CASSANDRA_COORDINATOR_ID,
  SEMATTRS_DB_CASSANDRA_IDEMPOTENCE: () => SEMATTRS_DB_CASSANDRA_IDEMPOTENCE,
  SEMATTRS_DB_CASSANDRA_KEYSPACE: () => SEMATTRS_DB_CASSANDRA_KEYSPACE,
  SEMATTRS_DB_CASSANDRA_PAGE_SIZE: () => SEMATTRS_DB_CASSANDRA_PAGE_SIZE,
  SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: () => SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT,
  SEMATTRS_DB_CASSANDRA_TABLE: () => SEMATTRS_DB_CASSANDRA_TABLE,
  SEMATTRS_DB_CONNECTION_STRING: () => SEMATTRS_DB_CONNECTION_STRING,
  SEMATTRS_DB_HBASE_NAMESPACE: () => SEMATTRS_DB_HBASE_NAMESPACE,
  SEMATTRS_DB_JDBC_DRIVER_CLASSNAME: () => SEMATTRS_DB_JDBC_DRIVER_CLASSNAME,
  SEMATTRS_DB_MONGODB_COLLECTION: () => SEMATTRS_DB_MONGODB_COLLECTION,
  SEMATTRS_DB_MSSQL_INSTANCE_NAME: () => SEMATTRS_DB_MSSQL_INSTANCE_NAME,
  SEMATTRS_DB_NAME: () => SEMATTRS_DB_NAME,
  SEMATTRS_DB_OPERATION: () => SEMATTRS_DB_OPERATION,
  SEMATTRS_DB_REDIS_DATABASE_INDEX: () => SEMATTRS_DB_REDIS_DATABASE_INDEX,
  SEMATTRS_DB_SQL_TABLE: () => SEMATTRS_DB_SQL_TABLE,
  SEMATTRS_DB_STATEMENT: () => SEMATTRS_DB_STATEMENT,
  SEMATTRS_DB_SYSTEM: () => SEMATTRS_DB_SYSTEM,
  SEMATTRS_DB_USER: () => SEMATTRS_DB_USER,
  SEMATTRS_ENDUSER_ID: () => SEMATTRS_ENDUSER_ID,
  SEMATTRS_ENDUSER_ROLE: () => SEMATTRS_ENDUSER_ROLE,
  SEMATTRS_ENDUSER_SCOPE: () => SEMATTRS_ENDUSER_SCOPE,
  SEMATTRS_EXCEPTION_ESCAPED: () => SEMATTRS_EXCEPTION_ESCAPED,
  SEMATTRS_EXCEPTION_MESSAGE: () => SEMATTRS_EXCEPTION_MESSAGE,
  SEMATTRS_EXCEPTION_STACKTRACE: () => SEMATTRS_EXCEPTION_STACKTRACE,
  SEMATTRS_EXCEPTION_TYPE: () => SEMATTRS_EXCEPTION_TYPE,
  SEMATTRS_FAAS_COLDSTART: () => SEMATTRS_FAAS_COLDSTART,
  SEMATTRS_FAAS_CRON: () => SEMATTRS_FAAS_CRON,
  SEMATTRS_FAAS_DOCUMENT_COLLECTION: () => SEMATTRS_FAAS_DOCUMENT_COLLECTION,
  SEMATTRS_FAAS_DOCUMENT_NAME: () => SEMATTRS_FAAS_DOCUMENT_NAME,
  SEMATTRS_FAAS_DOCUMENT_OPERATION: () => SEMATTRS_FAAS_DOCUMENT_OPERATION,
  SEMATTRS_FAAS_DOCUMENT_TIME: () => SEMATTRS_FAAS_DOCUMENT_TIME,
  SEMATTRS_FAAS_EXECUTION: () => SEMATTRS_FAAS_EXECUTION,
  SEMATTRS_FAAS_INVOKED_NAME: () => SEMATTRS_FAAS_INVOKED_NAME,
  SEMATTRS_FAAS_INVOKED_PROVIDER: () => SEMATTRS_FAAS_INVOKED_PROVIDER,
  SEMATTRS_FAAS_INVOKED_REGION: () => SEMATTRS_FAAS_INVOKED_REGION,
  SEMATTRS_FAAS_TIME: () => SEMATTRS_FAAS_TIME,
  SEMATTRS_FAAS_TRIGGER: () => SEMATTRS_FAAS_TRIGGER,
  SEMATTRS_HTTP_CLIENT_IP: () => SEMATTRS_HTTP_CLIENT_IP,
  SEMATTRS_HTTP_FLAVOR: () => SEMATTRS_HTTP_FLAVOR,
  SEMATTRS_HTTP_HOST: () => SEMATTRS_HTTP_HOST,
  SEMATTRS_HTTP_METHOD: () => SEMATTRS_HTTP_METHOD,
  SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH: () => SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH,
  SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: () => SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,
  SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH: () => SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH,
  SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: () => SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,
  SEMATTRS_HTTP_ROUTE: () => SEMATTRS_HTTP_ROUTE,
  SEMATTRS_HTTP_SCHEME: () => SEMATTRS_HTTP_SCHEME,
  SEMATTRS_HTTP_SERVER_NAME: () => SEMATTRS_HTTP_SERVER_NAME,
  SEMATTRS_HTTP_STATUS_CODE: () => SEMATTRS_HTTP_STATUS_CODE,
  SEMATTRS_HTTP_TARGET: () => SEMATTRS_HTTP_TARGET,
  SEMATTRS_HTTP_URL: () => SEMATTRS_HTTP_URL,
  SEMATTRS_HTTP_USER_AGENT: () => SEMATTRS_HTTP_USER_AGENT,
  SEMATTRS_MESSAGE_COMPRESSED_SIZE: () => SEMATTRS_MESSAGE_COMPRESSED_SIZE,
  SEMATTRS_MESSAGE_ID: () => SEMATTRS_MESSAGE_ID,
  SEMATTRS_MESSAGE_TYPE: () => SEMATTRS_MESSAGE_TYPE,
  SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE: () => SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE,
  SEMATTRS_MESSAGING_CONSUMER_ID: () => SEMATTRS_MESSAGING_CONSUMER_ID,
  SEMATTRS_MESSAGING_CONVERSATION_ID: () => SEMATTRS_MESSAGING_CONVERSATION_ID,
  SEMATTRS_MESSAGING_DESTINATION: () => SEMATTRS_MESSAGING_DESTINATION,
  SEMATTRS_MESSAGING_DESTINATION_KIND: () => SEMATTRS_MESSAGING_DESTINATION_KIND,
  SEMATTRS_MESSAGING_KAFKA_CLIENT_ID: () => SEMATTRS_MESSAGING_KAFKA_CLIENT_ID,
  SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP: () => SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP,
  SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY: () => SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY,
  SEMATTRS_MESSAGING_KAFKA_PARTITION: () => SEMATTRS_MESSAGING_KAFKA_PARTITION,
  SEMATTRS_MESSAGING_KAFKA_TOMBSTONE: () => SEMATTRS_MESSAGING_KAFKA_TOMBSTONE,
  SEMATTRS_MESSAGING_MESSAGE_ID: () => SEMATTRS_MESSAGING_MESSAGE_ID,
  SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: () => SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES,
  SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: () => SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES,
  SEMATTRS_MESSAGING_OPERATION: () => SEMATTRS_MESSAGING_OPERATION,
  SEMATTRS_MESSAGING_PROTOCOL: () => SEMATTRS_MESSAGING_PROTOCOL,
  SEMATTRS_MESSAGING_PROTOCOL_VERSION: () => SEMATTRS_MESSAGING_PROTOCOL_VERSION,
  SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY: () => SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY,
  SEMATTRS_MESSAGING_SYSTEM: () => SEMATTRS_MESSAGING_SYSTEM,
  SEMATTRS_MESSAGING_TEMP_DESTINATION: () => SEMATTRS_MESSAGING_TEMP_DESTINATION,
  SEMATTRS_MESSAGING_URL: () => SEMATTRS_MESSAGING_URL,
  SEMATTRS_NET_HOST_CARRIER_ICC: () => SEMATTRS_NET_HOST_CARRIER_ICC,
  SEMATTRS_NET_HOST_CARRIER_MCC: () => SEMATTRS_NET_HOST_CARRIER_MCC,
  SEMATTRS_NET_HOST_CARRIER_MNC: () => SEMATTRS_NET_HOST_CARRIER_MNC,
  SEMATTRS_NET_HOST_CARRIER_NAME: () => SEMATTRS_NET_HOST_CARRIER_NAME,
  SEMATTRS_NET_HOST_CONNECTION_SUBTYPE: () => SEMATTRS_NET_HOST_CONNECTION_SUBTYPE,
  SEMATTRS_NET_HOST_CONNECTION_TYPE: () => SEMATTRS_NET_HOST_CONNECTION_TYPE,
  SEMATTRS_NET_HOST_IP: () => SEMATTRS_NET_HOST_IP,
  SEMATTRS_NET_HOST_NAME: () => SEMATTRS_NET_HOST_NAME,
  SEMATTRS_NET_HOST_PORT: () => SEMATTRS_NET_HOST_PORT,
  SEMATTRS_NET_PEER_IP: () => SEMATTRS_NET_PEER_IP,
  SEMATTRS_NET_PEER_NAME: () => SEMATTRS_NET_PEER_NAME,
  SEMATTRS_NET_PEER_PORT: () => SEMATTRS_NET_PEER_PORT,
  SEMATTRS_NET_TRANSPORT: () => SEMATTRS_NET_TRANSPORT,
  SEMATTRS_PEER_SERVICE: () => SEMATTRS_PEER_SERVICE,
  SEMATTRS_RPC_GRPC_STATUS_CODE: () => SEMATTRS_RPC_GRPC_STATUS_CODE,
  SEMATTRS_RPC_JSONRPC_ERROR_CODE: () => SEMATTRS_RPC_JSONRPC_ERROR_CODE,
  SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE: () => SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE,
  SEMATTRS_RPC_JSONRPC_REQUEST_ID: () => SEMATTRS_RPC_JSONRPC_REQUEST_ID,
  SEMATTRS_RPC_JSONRPC_VERSION: () => SEMATTRS_RPC_JSONRPC_VERSION,
  SEMATTRS_RPC_METHOD: () => SEMATTRS_RPC_METHOD,
  SEMATTRS_RPC_SERVICE: () => SEMATTRS_RPC_SERVICE,
  SEMATTRS_RPC_SYSTEM: () => SEMATTRS_RPC_SYSTEM,
  SEMATTRS_THREAD_ID: () => SEMATTRS_THREAD_ID,
  SEMATTRS_THREAD_NAME: () => SEMATTRS_THREAD_NAME,
  SEMRESATTRS_AWS_ECS_CLUSTER_ARN: () => SEMRESATTRS_AWS_ECS_CLUSTER_ARN,
  SEMRESATTRS_AWS_ECS_CONTAINER_ARN: () => SEMRESATTRS_AWS_ECS_CONTAINER_ARN,
  SEMRESATTRS_AWS_ECS_LAUNCHTYPE: () => SEMRESATTRS_AWS_ECS_LAUNCHTYPE,
  SEMRESATTRS_AWS_ECS_TASK_ARN: () => SEMRESATTRS_AWS_ECS_TASK_ARN,
  SEMRESATTRS_AWS_ECS_TASK_FAMILY: () => SEMRESATTRS_AWS_ECS_TASK_FAMILY,
  SEMRESATTRS_AWS_ECS_TASK_REVISION: () => SEMRESATTRS_AWS_ECS_TASK_REVISION,
  SEMRESATTRS_AWS_EKS_CLUSTER_ARN: () => SEMRESATTRS_AWS_EKS_CLUSTER_ARN,
  SEMRESATTRS_AWS_LOG_GROUP_ARNS: () => SEMRESATTRS_AWS_LOG_GROUP_ARNS,
  SEMRESATTRS_AWS_LOG_GROUP_NAMES: () => SEMRESATTRS_AWS_LOG_GROUP_NAMES,
  SEMRESATTRS_AWS_LOG_STREAM_ARNS: () => SEMRESATTRS_AWS_LOG_STREAM_ARNS,
  SEMRESATTRS_AWS_LOG_STREAM_NAMES: () => SEMRESATTRS_AWS_LOG_STREAM_NAMES,
  SEMRESATTRS_CLOUD_ACCOUNT_ID: () => SEMRESATTRS_CLOUD_ACCOUNT_ID,
  SEMRESATTRS_CLOUD_AVAILABILITY_ZONE: () => SEMRESATTRS_CLOUD_AVAILABILITY_ZONE,
  SEMRESATTRS_CLOUD_PLATFORM: () => SEMRESATTRS_CLOUD_PLATFORM,
  SEMRESATTRS_CLOUD_PROVIDER: () => SEMRESATTRS_CLOUD_PROVIDER,
  SEMRESATTRS_CLOUD_REGION: () => SEMRESATTRS_CLOUD_REGION,
  SEMRESATTRS_CONTAINER_ID: () => SEMRESATTRS_CONTAINER_ID,
  SEMRESATTRS_CONTAINER_IMAGE_NAME: () => SEMRESATTRS_CONTAINER_IMAGE_NAME,
  SEMRESATTRS_CONTAINER_IMAGE_TAG: () => SEMRESATTRS_CONTAINER_IMAGE_TAG,
  SEMRESATTRS_CONTAINER_NAME: () => SEMRESATTRS_CONTAINER_NAME,
  SEMRESATTRS_CONTAINER_RUNTIME: () => SEMRESATTRS_CONTAINER_RUNTIME,
  SEMRESATTRS_DEPLOYMENT_ENVIRONMENT: () => SEMRESATTRS_DEPLOYMENT_ENVIRONMENT,
  SEMRESATTRS_DEVICE_ID: () => SEMRESATTRS_DEVICE_ID,
  SEMRESATTRS_DEVICE_MODEL_IDENTIFIER: () => SEMRESATTRS_DEVICE_MODEL_IDENTIFIER,
  SEMRESATTRS_DEVICE_MODEL_NAME: () => SEMRESATTRS_DEVICE_MODEL_NAME,
  SEMRESATTRS_FAAS_ID: () => SEMRESATTRS_FAAS_ID,
  SEMRESATTRS_FAAS_INSTANCE: () => SEMRESATTRS_FAAS_INSTANCE,
  SEMRESATTRS_FAAS_MAX_MEMORY: () => SEMRESATTRS_FAAS_MAX_MEMORY,
  SEMRESATTRS_FAAS_NAME: () => SEMRESATTRS_FAAS_NAME,
  SEMRESATTRS_FAAS_VERSION: () => SEMRESATTRS_FAAS_VERSION,
  SEMRESATTRS_HOST_ARCH: () => SEMRESATTRS_HOST_ARCH,
  SEMRESATTRS_HOST_ID: () => SEMRESATTRS_HOST_ID,
  SEMRESATTRS_HOST_IMAGE_ID: () => SEMRESATTRS_HOST_IMAGE_ID,
  SEMRESATTRS_HOST_IMAGE_NAME: () => SEMRESATTRS_HOST_IMAGE_NAME,
  SEMRESATTRS_HOST_IMAGE_VERSION: () => SEMRESATTRS_HOST_IMAGE_VERSION,
  SEMRESATTRS_HOST_NAME: () => SEMRESATTRS_HOST_NAME,
  SEMRESATTRS_HOST_TYPE: () => SEMRESATTRS_HOST_TYPE,
  SEMRESATTRS_K8S_CLUSTER_NAME: () => SEMRESATTRS_K8S_CLUSTER_NAME,
  SEMRESATTRS_K8S_CONTAINER_NAME: () => SEMRESATTRS_K8S_CONTAINER_NAME,
  SEMRESATTRS_K8S_CRONJOB_NAME: () => SEMRESATTRS_K8S_CRONJOB_NAME,
  SEMRESATTRS_K8S_CRONJOB_UID: () => SEMRESATTRS_K8S_CRONJOB_UID,
  SEMRESATTRS_K8S_DAEMONSET_NAME: () => SEMRESATTRS_K8S_DAEMONSET_NAME,
  SEMRESATTRS_K8S_DAEMONSET_UID: () => SEMRESATTRS_K8S_DAEMONSET_UID,
  SEMRESATTRS_K8S_DEPLOYMENT_NAME: () => SEMRESATTRS_K8S_DEPLOYMENT_NAME,
  SEMRESATTRS_K8S_DEPLOYMENT_UID: () => SEMRESATTRS_K8S_DEPLOYMENT_UID,
  SEMRESATTRS_K8S_JOB_NAME: () => SEMRESATTRS_K8S_JOB_NAME,
  SEMRESATTRS_K8S_JOB_UID: () => SEMRESATTRS_K8S_JOB_UID,
  SEMRESATTRS_K8S_NAMESPACE_NAME: () => SEMRESATTRS_K8S_NAMESPACE_NAME,
  SEMRESATTRS_K8S_NODE_NAME: () => SEMRESATTRS_K8S_NODE_NAME,
  SEMRESATTRS_K8S_NODE_UID: () => SEMRESATTRS_K8S_NODE_UID,
  SEMRESATTRS_K8S_POD_NAME: () => SEMRESATTRS_K8S_POD_NAME,
  SEMRESATTRS_K8S_POD_UID: () => SEMRESATTRS_K8S_POD_UID,
  SEMRESATTRS_K8S_REPLICASET_NAME: () => SEMRESATTRS_K8S_REPLICASET_NAME,
  SEMRESATTRS_K8S_REPLICASET_UID: () => SEMRESATTRS_K8S_REPLICASET_UID,
  SEMRESATTRS_K8S_STATEFULSET_NAME: () => SEMRESATTRS_K8S_STATEFULSET_NAME,
  SEMRESATTRS_K8S_STATEFULSET_UID: () => SEMRESATTRS_K8S_STATEFULSET_UID,
  SEMRESATTRS_OS_DESCRIPTION: () => SEMRESATTRS_OS_DESCRIPTION,
  SEMRESATTRS_OS_NAME: () => SEMRESATTRS_OS_NAME,
  SEMRESATTRS_OS_TYPE: () => SEMRESATTRS_OS_TYPE,
  SEMRESATTRS_OS_VERSION: () => SEMRESATTRS_OS_VERSION,
  SEMRESATTRS_PROCESS_COMMAND: () => SEMRESATTRS_PROCESS_COMMAND,
  SEMRESATTRS_PROCESS_COMMAND_ARGS: () => SEMRESATTRS_PROCESS_COMMAND_ARGS,
  SEMRESATTRS_PROCESS_COMMAND_LINE: () => SEMRESATTRS_PROCESS_COMMAND_LINE,
  SEMRESATTRS_PROCESS_EXECUTABLE_NAME: () => SEMRESATTRS_PROCESS_EXECUTABLE_NAME,
  SEMRESATTRS_PROCESS_EXECUTABLE_PATH: () => SEMRESATTRS_PROCESS_EXECUTABLE_PATH,
  SEMRESATTRS_PROCESS_OWNER: () => SEMRESATTRS_PROCESS_OWNER,
  SEMRESATTRS_PROCESS_PID: () => SEMRESATTRS_PROCESS_PID,
  SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION: () => SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION,
  SEMRESATTRS_PROCESS_RUNTIME_NAME: () => SEMRESATTRS_PROCESS_RUNTIME_NAME,
  SEMRESATTRS_PROCESS_RUNTIME_VERSION: () => SEMRESATTRS_PROCESS_RUNTIME_VERSION,
  SEMRESATTRS_SERVICE_INSTANCE_ID: () => SEMRESATTRS_SERVICE_INSTANCE_ID,
  SEMRESATTRS_SERVICE_NAME: () => SEMRESATTRS_SERVICE_NAME,
  SEMRESATTRS_SERVICE_NAMESPACE: () => SEMRESATTRS_SERVICE_NAMESPACE,
  SEMRESATTRS_SERVICE_VERSION: () => SEMRESATTRS_SERVICE_VERSION,
  SEMRESATTRS_TELEMETRY_AUTO_VERSION: () => SEMRESATTRS_TELEMETRY_AUTO_VERSION,
  SEMRESATTRS_TELEMETRY_SDK_LANGUAGE: () => SEMRESATTRS_TELEMETRY_SDK_LANGUAGE,
  SEMRESATTRS_TELEMETRY_SDK_NAME: () => SEMRESATTRS_TELEMETRY_SDK_NAME,
  SEMRESATTRS_TELEMETRY_SDK_VERSION: () => SEMRESATTRS_TELEMETRY_SDK_VERSION,
  SEMRESATTRS_WEBENGINE_DESCRIPTION: () => SEMRESATTRS_WEBENGINE_DESCRIPTION,
  SEMRESATTRS_WEBENGINE_NAME: () => SEMRESATTRS_WEBENGINE_NAME,
  SEMRESATTRS_WEBENGINE_VERSION: () => SEMRESATTRS_WEBENGINE_VERSION,
  SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN: () => SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN,
  SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE: () => SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE,
  SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT: () => SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT,
  SIGNALR_TRANSPORT_VALUE_LONG_POLLING: () => SIGNALR_TRANSPORT_VALUE_LONG_POLLING,
  SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS: () => SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS,
  SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS: () => SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS,
  SemanticAttributes: () => SemanticAttributes,
  SemanticResourceAttributes: () => SemanticResourceAttributes,
  TELEMETRYSDKLANGUAGEVALUES_CPP: () => TELEMETRYSDKLANGUAGEVALUES_CPP,
  TELEMETRYSDKLANGUAGEVALUES_DOTNET: () => TELEMETRYSDKLANGUAGEVALUES_DOTNET,
  TELEMETRYSDKLANGUAGEVALUES_ERLANG: () => TELEMETRYSDKLANGUAGEVALUES_ERLANG,
  TELEMETRYSDKLANGUAGEVALUES_GO: () => TELEMETRYSDKLANGUAGEVALUES_GO,
  TELEMETRYSDKLANGUAGEVALUES_JAVA: () => TELEMETRYSDKLANGUAGEVALUES_JAVA,
  TELEMETRYSDKLANGUAGEVALUES_NODEJS: () => TELEMETRYSDKLANGUAGEVALUES_NODEJS,
  TELEMETRYSDKLANGUAGEVALUES_PHP: () => TELEMETRYSDKLANGUAGEVALUES_PHP,
  TELEMETRYSDKLANGUAGEVALUES_PYTHON: () => TELEMETRYSDKLANGUAGEVALUES_PYTHON,
  TELEMETRYSDKLANGUAGEVALUES_RUBY: () => TELEMETRYSDKLANGUAGEVALUES_RUBY,
  TELEMETRYSDKLANGUAGEVALUES_WEBJS: () => TELEMETRYSDKLANGUAGEVALUES_WEBJS,
  TELEMETRY_SDK_LANGUAGE_VALUE_CPP: () => TELEMETRY_SDK_LANGUAGE_VALUE_CPP,
  TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET: () => TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET,
  TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG: () => TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG,
  TELEMETRY_SDK_LANGUAGE_VALUE_GO: () => TELEMETRY_SDK_LANGUAGE_VALUE_GO,
  TELEMETRY_SDK_LANGUAGE_VALUE_JAVA: () => TELEMETRY_SDK_LANGUAGE_VALUE_JAVA,
  TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS: () => TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS,
  TELEMETRY_SDK_LANGUAGE_VALUE_PHP: () => TELEMETRY_SDK_LANGUAGE_VALUE_PHP,
  TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON: () => TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON,
  TELEMETRY_SDK_LANGUAGE_VALUE_RUBY: () => TELEMETRY_SDK_LANGUAGE_VALUE_RUBY,
  TELEMETRY_SDK_LANGUAGE_VALUE_RUST: () => TELEMETRY_SDK_LANGUAGE_VALUE_RUST,
  TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT: () => TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT,
  TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS: () => TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS,
  TelemetrySdkLanguageValues: () => TelemetrySdkLanguageValues
});
var init_esm2 = __esm({
  "node_modules/@opentelemetry/semantic-conventions/build/esm/index.js"() {
    init_trace2();
    init_resource();
    init_stable_attributes();
    init_stable_metrics();
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js
var require_sdk_info = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDK_INFO = void 0;
    var version_1 = require_version();
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    exports.SDK_INFO = {
      [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_NAME]: "opentelemetry",
      [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_NAME]: "node",
      [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE]: semantic_conventions_1.TELEMETRYSDKLANGUAGEVALUES_NODEJS,
      [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_VERSION]: version_1.VERSION
    };
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js
var require_timer_util = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unrefTimer = void 0;
    function unrefTimer(timer) {
      timer.unref();
    }
    exports.unrefTimer = unrefTimer;
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/index.js
var require_node = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unrefTimer = exports.SDK_INFO = exports.otperformance = exports.RandomIdGenerator = exports.hexToBase64 = exports._globalThis = exports.getEnv = exports.getEnvWithoutDefaults = void 0;
    var environment_1 = require_environment2();
    Object.defineProperty(exports, "getEnvWithoutDefaults", { enumerable: true, get: function() {
      return environment_1.getEnvWithoutDefaults;
    } });
    Object.defineProperty(exports, "getEnv", { enumerable: true, get: function() {
      return environment_1.getEnv;
    } });
    var globalThis_1 = require_globalThis();
    Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
      return globalThis_1._globalThis;
    } });
    var hex_to_base64_1 = require_hex_to_base64();
    Object.defineProperty(exports, "hexToBase64", { enumerable: true, get: function() {
      return hex_to_base64_1.hexToBase64;
    } });
    var RandomIdGenerator_1 = require_RandomIdGenerator();
    Object.defineProperty(exports, "RandomIdGenerator", { enumerable: true, get: function() {
      return RandomIdGenerator_1.RandomIdGenerator;
    } });
    var performance_1 = require_performance();
    Object.defineProperty(exports, "otperformance", { enumerable: true, get: function() {
      return performance_1.otperformance;
    } });
    var sdk_info_1 = require_sdk_info();
    Object.defineProperty(exports, "SDK_INFO", { enumerable: true, get: function() {
      return sdk_info_1.SDK_INFO;
    } });
    var timer_util_1 = require_timer_util();
    Object.defineProperty(exports, "unrefTimer", { enumerable: true, get: function() {
      return timer_util_1.unrefTimer;
    } });
  }
});

// node_modules/@opentelemetry/core/build/src/platform/index.js
var require_platform = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unrefTimer = exports.otperformance = exports.hexToBase64 = exports.getEnvWithoutDefaults = exports.getEnv = exports._globalThis = exports.SDK_INFO = exports.RandomIdGenerator = void 0;
    var node_1 = require_node();
    Object.defineProperty(exports, "RandomIdGenerator", { enumerable: true, get: function() {
      return node_1.RandomIdGenerator;
    } });
    Object.defineProperty(exports, "SDK_INFO", { enumerable: true, get: function() {
      return node_1.SDK_INFO;
    } });
    Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
      return node_1._globalThis;
    } });
    Object.defineProperty(exports, "getEnv", { enumerable: true, get: function() {
      return node_1.getEnv;
    } });
    Object.defineProperty(exports, "getEnvWithoutDefaults", { enumerable: true, get: function() {
      return node_1.getEnvWithoutDefaults;
    } });
    Object.defineProperty(exports, "hexToBase64", { enumerable: true, get: function() {
      return node_1.hexToBase64;
    } });
    Object.defineProperty(exports, "otperformance", { enumerable: true, get: function() {
      return node_1.otperformance;
    } });
    Object.defineProperty(exports, "unrefTimer", { enumerable: true, get: function() {
      return node_1.unrefTimer;
    } });
  }
});

// node_modules/@opentelemetry/core/build/src/common/time.js
var require_time = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addHrTimes = exports.isTimeInput = exports.isTimeInputHrTime = exports.hrTimeToMicroseconds = exports.hrTimeToMilliseconds = exports.hrTimeToNanoseconds = exports.hrTimeToTimeStamp = exports.hrTimeDuration = exports.timeInputToHrTime = exports.hrTime = exports.getTimeOrigin = exports.millisToHrTime = void 0;
    var platform_1 = require_platform();
    var NANOSECOND_DIGITS = 9;
    var NANOSECOND_DIGITS_IN_MILLIS = 6;
    var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
    var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
    function millisToHrTime(epochMillis) {
      const epochSeconds = epochMillis / 1e3;
      const seconds = Math.trunc(epochSeconds);
      const nanos = Math.round(epochMillis % 1e3 * MILLISECONDS_TO_NANOSECONDS);
      return [seconds, nanos];
    }
    exports.millisToHrTime = millisToHrTime;
    function getTimeOrigin() {
      let timeOrigin = platform_1.otperformance.timeOrigin;
      if (typeof timeOrigin !== "number") {
        const perf = platform_1.otperformance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
      }
      return timeOrigin;
    }
    exports.getTimeOrigin = getTimeOrigin;
    function hrTime(performanceNow) {
      const timeOrigin = millisToHrTime(getTimeOrigin());
      const now = millisToHrTime(typeof performanceNow === "number" ? performanceNow : platform_1.otperformance.now());
      return addHrTimes(timeOrigin, now);
    }
    exports.hrTime = hrTime;
    function timeInputToHrTime(time) {
      if (isTimeInputHrTime(time)) {
        return time;
      } else if (typeof time === "number") {
        if (time < getTimeOrigin()) {
          return hrTime(time);
        } else {
          return millisToHrTime(time);
        }
      } else if (time instanceof Date) {
        return millisToHrTime(time.getTime());
      } else {
        throw TypeError("Invalid input type");
      }
    }
    exports.timeInputToHrTime = timeInputToHrTime;
    function hrTimeDuration(startTime, endTime) {
      let seconds = endTime[0] - startTime[0];
      let nanos = endTime[1] - startTime[1];
      if (nanos < 0) {
        seconds -= 1;
        nanos += SECOND_TO_NANOSECONDS;
      }
      return [seconds, nanos];
    }
    exports.hrTimeDuration = hrTimeDuration;
    function hrTimeToTimeStamp(time) {
      const precision = NANOSECOND_DIGITS;
      const tmp = `${"0".repeat(precision)}${time[1]}Z`;
      const nanoString = tmp.substring(tmp.length - precision - 1);
      const date = new Date(time[0] * 1e3).toISOString();
      return date.replace("000Z", nanoString);
    }
    exports.hrTimeToTimeStamp = hrTimeToTimeStamp;
    function hrTimeToNanoseconds(time) {
      return time[0] * SECOND_TO_NANOSECONDS + time[1];
    }
    exports.hrTimeToNanoseconds = hrTimeToNanoseconds;
    function hrTimeToMilliseconds(time) {
      return time[0] * 1e3 + time[1] / 1e6;
    }
    exports.hrTimeToMilliseconds = hrTimeToMilliseconds;
    function hrTimeToMicroseconds(time) {
      return time[0] * 1e6 + time[1] / 1e3;
    }
    exports.hrTimeToMicroseconds = hrTimeToMicroseconds;
    function isTimeInputHrTime(value) {
      return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
    }
    exports.isTimeInputHrTime = isTimeInputHrTime;
    function isTimeInput(value) {
      return isTimeInputHrTime(value) || typeof value === "number" || value instanceof Date;
    }
    exports.isTimeInput = isTimeInput;
    function addHrTimes(time1, time2) {
      const out = [time1[0] + time2[0], time1[1] + time2[1]];
      if (out[1] >= SECOND_TO_NANOSECONDS) {
        out[1] -= SECOND_TO_NANOSECONDS;
        out[0] += 1;
      }
      return out;
    }
    exports.addHrTimes = addHrTimes;
  }
});

// node_modules/@opentelemetry/core/build/src/ExportResult.js
var require_ExportResult = __commonJS({
  "node_modules/@opentelemetry/core/build/src/ExportResult.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExportResultCode = void 0;
    var ExportResultCode;
    (function(ExportResultCode2) {
      ExportResultCode2[ExportResultCode2["SUCCESS"] = 0] = "SUCCESS";
      ExportResultCode2[ExportResultCode2["FAILED"] = 1] = "FAILED";
    })(ExportResultCode = exports.ExportResultCode || (exports.ExportResultCode = {}));
  }
});

// node_modules/@opentelemetry/core/build/src/propagation/composite.js
var require_composite = __commonJS({
  "node_modules/@opentelemetry/core/build/src/propagation/composite.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompositePropagator = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var CompositePropagator = class {
      /**
       * Construct a composite propagator from a list of propagators.
       *
       * @param [config] Configuration object for composite propagator
       */
      constructor(config = {}) {
        var _a12;
        this._propagators = (_a12 = config.propagators) !== null && _a12 !== void 0 ? _a12 : [];
        this._fields = Array.from(new Set(this._propagators.map((p2) => typeof p2.fields === "function" ? p2.fields() : []).reduce((x2, y2) => x2.concat(y2), [])));
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same carrier key, the propagator later in the list
       * will "win".
       *
       * @param context Context to inject
       * @param carrier Carrier into which context will be injected
       */
      inject(context3, carrier, setter) {
        for (const propagator of this._propagators) {
          try {
            propagator.inject(context3, carrier, setter);
          } catch (err) {
            api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
          }
        }
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same context key, the propagator later in the list
       * will "win".
       *
       * @param context Context to add values to
       * @param carrier Carrier from which to extract context
       */
      extract(context3, carrier, getter) {
        return this._propagators.reduce((ctx, propagator) => {
          try {
            return propagator.extract(ctx, carrier, getter);
          } catch (err) {
            api_1.diag.warn(`Failed to extract with ${propagator.constructor.name}. Err: ${err.message}`);
          }
          return ctx;
        }, context3);
      }
      fields() {
        return this._fields.slice();
      }
    };
    exports.CompositePropagator = CompositePropagator;
  }
});

// node_modules/@opentelemetry/core/build/src/internal/validators.js
var require_validators = __commonJS({
  "node_modules/@opentelemetry/core/build/src/internal/validators.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateValue = exports.validateKey = void 0;
    var VALID_KEY_CHAR_RANGE2 = "[_0-9a-z-*/]";
    var VALID_KEY2 = `[a-z]${VALID_KEY_CHAR_RANGE2}{0,255}`;
    var VALID_VENDOR_KEY2 = `[a-z0-9]${VALID_KEY_CHAR_RANGE2}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE2}{0,13}`;
    var VALID_KEY_REGEX2 = new RegExp(`^(?:${VALID_KEY2}|${VALID_VENDOR_KEY2})$`);
    var VALID_VALUE_BASE_REGEX2 = /^[ -~]{0,255}[!-~]$/;
    var INVALID_VALUE_COMMA_EQUAL_REGEX2 = /,|=/;
    function validateKey2(key) {
      return VALID_KEY_REGEX2.test(key);
    }
    exports.validateKey = validateKey2;
    function validateValue2(value) {
      return VALID_VALUE_BASE_REGEX2.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX2.test(value);
    }
    exports.validateValue = validateValue2;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/TraceState.js
var require_TraceState = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/TraceState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TraceState = void 0;
    var validators_1 = require_validators();
    var MAX_TRACE_STATE_ITEMS2 = 32;
    var MAX_TRACE_STATE_LEN2 = 512;
    var LIST_MEMBERS_SEPARATOR2 = ",";
    var LIST_MEMBER_KEY_VALUE_SPLITTER2 = "=";
    var TraceState = class _TraceState {
      constructor(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      set(key, value) {
        const traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      }
      unset(key) {
        const traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      }
      get(key) {
        return this._internalState.get(key);
      }
      serialize() {
        return this._keys().reduce((agg, key) => {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER2 + this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR2);
      }
      _parse(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN2)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR2).reverse().reduce((agg, part) => {
          const listMember = part.trim();
          const i2 = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER2);
          if (i2 !== -1) {
            const key = listMember.slice(0, i2);
            const value = listMember.slice(i2 + 1, part.length);
            if ((0, validators_1.validateKey)(key) && (0, validators_1.validateValue)(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS2) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS2));
        }
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        const traceState = new _TraceState();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      }
    };
    exports.TraceState = TraceState;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js
var require_W3CTraceContextPropagator = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.W3CTraceContextPropagator = exports.parseTraceParent = exports.TRACE_STATE_HEADER = exports.TRACE_PARENT_HEADER = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing();
    var TraceState_1 = require_TraceState();
    exports.TRACE_PARENT_HEADER = "traceparent";
    exports.TRACE_STATE_HEADER = "tracestate";
    var VERSION2 = "00";
    var VERSION_PART = "(?!ff)[\\da-f]{2}";
    var TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}";
    var PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}";
    var FLAGS_PART = "[\\da-f]{2}";
    var TRACE_PARENT_REGEX = new RegExp(`^\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\s?$`);
    function parseTraceParent(traceParent) {
      const match4 = TRACE_PARENT_REGEX.exec(traceParent);
      if (!match4)
        return null;
      if (match4[1] === "00" && match4[5])
        return null;
      return {
        traceId: match4[2],
        spanId: match4[3],
        traceFlags: parseInt(match4[4], 16)
      };
    }
    exports.parseTraceParent = parseTraceParent;
    var W3CTraceContextPropagator = class {
      inject(context3, carrier, setter) {
        const spanContext = api_1.trace.getSpanContext(context3);
        if (!spanContext || (0, suppress_tracing_1.isTracingSuppressed)(context3) || !(0, api_1.isSpanContextValid)(spanContext))
          return;
        const traceParent = `${VERSION2}-${spanContext.traceId}-${spanContext.spanId}-0${Number(spanContext.traceFlags || api_1.TraceFlags.NONE).toString(16)}`;
        setter.set(carrier, exports.TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) {
          setter.set(carrier, exports.TRACE_STATE_HEADER, spanContext.traceState.serialize());
        }
      }
      extract(context3, carrier, getter) {
        const traceParentHeader = getter.get(carrier, exports.TRACE_PARENT_HEADER);
        if (!traceParentHeader)
          return context3;
        const traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
        if (typeof traceParent !== "string")
          return context3;
        const spanContext = parseTraceParent(traceParent);
        if (!spanContext)
          return context3;
        spanContext.isRemote = true;
        const traceStateHeader = getter.get(carrier, exports.TRACE_STATE_HEADER);
        if (traceStateHeader) {
          const state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
          spanContext.traceState = new TraceState_1.TraceState(typeof state === "string" ? state : void 0);
        }
        return api_1.trace.setSpanContext(context3, spanContext);
      }
      fields() {
        return [exports.TRACE_PARENT_HEADER, exports.TRACE_STATE_HEADER];
      }
    };
    exports.W3CTraceContextPropagator = W3CTraceContextPropagator;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js
var require_rpc_metadata = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRPCMetadata = exports.deleteRPCMetadata = exports.setRPCMetadata = exports.RPCType = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var RPC_METADATA_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key RPC_METADATA");
    var RPCType;
    (function(RPCType2) {
      RPCType2["HTTP"] = "http";
    })(RPCType = exports.RPCType || (exports.RPCType = {}));
    function setRPCMetadata(context3, meta) {
      return context3.setValue(RPC_METADATA_KEY, meta);
    }
    exports.setRPCMetadata = setRPCMetadata;
    function deleteRPCMetadata(context3) {
      return context3.deleteValue(RPC_METADATA_KEY);
    }
    exports.deleteRPCMetadata = deleteRPCMetadata;
    function getRPCMetadata(context3) {
      return context3.getValue(RPC_METADATA_KEY);
    }
    exports.getRPCMetadata = getRPCMetadata;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js
var require_AlwaysOffSampler = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AlwaysOffSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var AlwaysOffSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return "AlwaysOffSampler";
      }
    };
    exports.AlwaysOffSampler = AlwaysOffSampler;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js
var require_AlwaysOnSampler = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AlwaysOnSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var AlwaysOnSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.RECORD_AND_SAMPLED
        };
      }
      toString() {
        return "AlwaysOnSampler";
      }
    };
    exports.AlwaysOnSampler = AlwaysOnSampler;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js
var require_ParentBasedSampler = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParentBasedSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var global_error_handler_1 = require_global_error_handler();
    var AlwaysOffSampler_1 = require_AlwaysOffSampler();
    var AlwaysOnSampler_1 = require_AlwaysOnSampler();
    var ParentBasedSampler = class {
      constructor(config) {
        var _a12, _b5, _c4, _d4;
        this._root = config.root;
        if (!this._root) {
          (0, global_error_handler_1.globalErrorHandler)(new Error("ParentBasedSampler must have a root sampler configured"));
          this._root = new AlwaysOnSampler_1.AlwaysOnSampler();
        }
        this._remoteParentSampled = (_a12 = config.remoteParentSampled) !== null && _a12 !== void 0 ? _a12 : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._remoteParentNotSampled = (_b5 = config.remoteParentNotSampled) !== null && _b5 !== void 0 ? _b5 : new AlwaysOffSampler_1.AlwaysOffSampler();
        this._localParentSampled = (_c4 = config.localParentSampled) !== null && _c4 !== void 0 ? _c4 : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._localParentNotSampled = (_d4 = config.localParentNotSampled) !== null && _d4 !== void 0 ? _d4 : new AlwaysOffSampler_1.AlwaysOffSampler();
      }
      shouldSample(context3, traceId, spanName, spanKind, attributes, links) {
        const parentContext = api_1.trace.getSpanContext(context3);
        if (!parentContext || !(0, api_1.isSpanContextValid)(parentContext)) {
          return this._root.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
          if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
            return this._remoteParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
          }
          return this._remoteParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
          return this._localParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
      }
      toString() {
        return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
      }
    };
    exports.ParentBasedSampler = ParentBasedSampler;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js
var require_TraceIdRatioBasedSampler = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TraceIdRatioBasedSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var TraceIdRatioBasedSampler = class {
      constructor(_ratio = 0) {
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 4294967295);
      }
      shouldSample(context3, traceId) {
        return {
          decision: (0, api_1.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? api_1.SamplingDecision.RECORD_AND_SAMPLED : api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return `TraceIdRatioBased{${this._ratio}}`;
      }
      _normalize(ratio) {
        if (typeof ratio !== "number" || isNaN(ratio))
          return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
      }
      _accumulate(traceId) {
        let accumulation = 0;
        for (let i2 = 0; i2 < traceId.length / 8; i2++) {
          const pos = i2 * 8;
          const part = parseInt(traceId.slice(pos, pos + 8), 16);
          accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
      }
    };
    exports.TraceIdRatioBasedSampler = TraceIdRatioBasedSampler;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js
var require_lodash_merge = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isPlainObject = void 0;
    var objectTag = "[object Object]";
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    var objectCtorString = funcToString.call(Object);
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    var nativeObjectToString = objectProto.toString;
    function overArg(func2, transform) {
      return function(arg) {
        return func2(transform(arg));
      };
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
        return false;
      }
      const proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      const Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
    }
    exports.isPlainObject = isPlainObject;
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function getRawTag(value) {
      const isOwn = hasOwnProperty2.call(value, symToStringTag), tag2 = value[symToStringTag];
      let unmasked = false;
      try {
        value[symToStringTag] = void 0;
        unmasked = true;
      } catch (e2) {
      }
      const result4 = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag2;
        } else {
          delete value[symToStringTag];
        }
      }
      return result4;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
  }
});

// node_modules/@opentelemetry/core/build/src/utils/merge.js
var require_merge = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/merge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = void 0;
    var lodash_merge_1 = require_lodash_merge();
    var MAX_LEVEL = 20;
    function merge5(...args) {
      let result4 = args.shift();
      const objects = /* @__PURE__ */ new WeakMap();
      while (args.length > 0) {
        result4 = mergeTwoObjects(result4, args.shift(), 0, objects);
      }
      return result4;
    }
    exports.merge = merge5;
    function takeValue(value) {
      if (isArray(value)) {
        return value.slice();
      }
      return value;
    }
    function mergeTwoObjects(one, two, level = 0, objects) {
      let result4;
      if (level > MAX_LEVEL) {
        return void 0;
      }
      level++;
      if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {
        result4 = takeValue(two);
      } else if (isArray(one)) {
        result4 = one.slice();
        if (isArray(two)) {
          for (let i2 = 0, j2 = two.length; i2 < j2; i2++) {
            result4.push(takeValue(two[i2]));
          }
        } else if (isObject(two)) {
          const keys4 = Object.keys(two);
          for (let i2 = 0, j2 = keys4.length; i2 < j2; i2++) {
            const key = keys4[i2];
            result4[key] = takeValue(two[key]);
          }
        }
      } else if (isObject(one)) {
        if (isObject(two)) {
          if (!shouldMerge(one, two)) {
            return two;
          }
          result4 = Object.assign({}, one);
          const keys4 = Object.keys(two);
          for (let i2 = 0, j2 = keys4.length; i2 < j2; i2++) {
            const key = keys4[i2];
            const twoValue = two[key];
            if (isPrimitive(twoValue)) {
              if (typeof twoValue === "undefined") {
                delete result4[key];
              } else {
                result4[key] = twoValue;
              }
            } else {
              const obj1 = result4[key];
              const obj2 = twoValue;
              if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {
                delete result4[key];
              } else {
                if (isObject(obj1) && isObject(obj2)) {
                  const arr1 = objects.get(obj1) || [];
                  const arr2 = objects.get(obj2) || [];
                  arr1.push({ obj: one, key });
                  arr2.push({ obj: two, key });
                  objects.set(obj1, arr1);
                  objects.set(obj2, arr2);
                }
                result4[key] = mergeTwoObjects(result4[key], twoValue, level, objects);
              }
            }
          }
        } else {
          result4 = two;
        }
      }
      return result4;
    }
    function wasObjectReferenced(obj, key, objects) {
      const arr = objects.get(obj[key]) || [];
      for (let i2 = 0, j2 = arr.length; i2 < j2; i2++) {
        const info = arr[i2];
        if (info.key === key && info.obj === obj) {
          return true;
        }
      }
      return false;
    }
    function isArray(value) {
      return Array.isArray(value);
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isObject(value) {
      return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === "object";
    }
    function isPrimitive(value) {
      return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "undefined" || value instanceof Date || value instanceof RegExp || value === null;
    }
    function shouldMerge(one, two) {
      if (!(0, lodash_merge_1.isPlainObject)(one) || !(0, lodash_merge_1.isPlainObject)(two)) {
        return false;
      }
      return true;
    }
  }
});

// node_modules/@opentelemetry/core/build/src/utils/timeout.js
var require_timeout = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/timeout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callWithTimeout = exports.TimeoutError = void 0;
    var TimeoutError = class _TimeoutError extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, _TimeoutError.prototype);
      }
    };
    exports.TimeoutError = TimeoutError;
    function callWithTimeout(promise2, timeout4) {
      let timeoutHandle;
      const timeoutPromise = new Promise(function timeoutFunction(_resolve, reject3) {
        timeoutHandle = setTimeout(function timeoutHandler() {
          reject3(new TimeoutError("Operation timed out."));
        }, timeout4);
      });
      return Promise.race([promise2, timeoutPromise]).then((result4) => {
        clearTimeout(timeoutHandle);
        return result4;
      }, (reason) => {
        clearTimeout(timeoutHandle);
        throw reason;
      });
    }
    exports.callWithTimeout = callWithTimeout;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/url.js
var require_url = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isUrlIgnored = exports.urlMatches = void 0;
    function urlMatches(url, urlToMatch) {
      if (typeof urlToMatch === "string") {
        return url === urlToMatch;
      } else {
        return !!url.match(urlToMatch);
      }
    }
    exports.urlMatches = urlMatches;
    function isUrlIgnored(url, ignoredUrls) {
      if (!ignoredUrls) {
        return false;
      }
      for (const ignoreUrl of ignoredUrls) {
        if (urlMatches(url, ignoreUrl)) {
          return true;
        }
      }
      return false;
    }
    exports.isUrlIgnored = isUrlIgnored;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/wrap.js
var require_wrap = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/wrap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isWrapped = void 0;
    function isWrapped(func2) {
      return typeof func2 === "function" && typeof func2.__original === "function" && typeof func2.__unwrap === "function" && func2.__wrapped === true;
    }
    exports.isWrapped = isWrapped;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/promise.js
var require_promise = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/promise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Deferred = void 0;
    var Deferred = class {
      constructor() {
        this._promise = new Promise((resolve, reject3) => {
          this._resolve = resolve;
          this._reject = reject3;
        });
      }
      get promise() {
        return this._promise;
      }
      resolve(val) {
        this._resolve(val);
      }
      reject(err) {
        this._reject(err);
      }
    };
    exports.Deferred = Deferred;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/callback.js
var require_callback = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/callback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BindOnceFuture = void 0;
    var promise_1 = require_promise();
    var BindOnceFuture = class {
      constructor(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new promise_1.Deferred();
      }
      get isCalled() {
        return this._isCalled;
      }
      get promise() {
        return this._deferred.promise;
      }
      call(...args) {
        if (!this._isCalled) {
          this._isCalled = true;
          try {
            Promise.resolve(this._callback.call(this._that, ...args)).then((val) => this._deferred.resolve(val), (err) => this._deferred.reject(err));
          } catch (err) {
            this._deferred.reject(err);
          }
        }
        return this._deferred.promise;
      }
    };
    exports.BindOnceFuture = BindOnceFuture;
  }
});

// node_modules/@opentelemetry/core/build/src/internal/exporter.js
var require_exporter = __commonJS({
  "node_modules/@opentelemetry/core/build/src/internal/exporter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._export = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing();
    function _export(exporter, arg) {
      return new Promise((resolve) => {
        api_1.context.with((0, suppress_tracing_1.suppressTracing)(api_1.context.active()), () => {
          exporter.export(arg, (result4) => {
            resolve(result4);
          });
        });
      });
    }
    exports._export = _export;
  }
});

// node_modules/@opentelemetry/core/build/src/index.js
var require_src = __commonJS({
  "node_modules/@opentelemetry/core/build/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = exports.TraceState = exports.unsuppressTracing = exports.suppressTracing = exports.isTracingSuppressed = exports.TraceIdRatioBasedSampler = exports.ParentBasedSampler = exports.AlwaysOnSampler = exports.AlwaysOffSampler = exports.setRPCMetadata = exports.getRPCMetadata = exports.deleteRPCMetadata = exports.RPCType = exports.parseTraceParent = exports.W3CTraceContextPropagator = exports.TRACE_STATE_HEADER = exports.TRACE_PARENT_HEADER = exports.CompositePropagator = exports.unrefTimer = exports.otperformance = exports.hexToBase64 = exports.getEnvWithoutDefaults = exports.getEnv = exports._globalThis = exports.SDK_INFO = exports.RandomIdGenerator = exports.baggageUtils = exports.ExportResultCode = exports.hexToBinary = exports.timeInputToHrTime = exports.millisToHrTime = exports.isTimeInputHrTime = exports.isTimeInput = exports.hrTimeToTimeStamp = exports.hrTimeToNanoseconds = exports.hrTimeToMilliseconds = exports.hrTimeToMicroseconds = exports.hrTimeDuration = exports.hrTime = exports.getTimeOrigin = exports.addHrTimes = exports.loggingErrorHandler = exports.setGlobalErrorHandler = exports.globalErrorHandler = exports.sanitizeAttributes = exports.isAttributeValue = exports.isAttributeKey = exports.AnchoredClock = exports.W3CBaggagePropagator = void 0;
    exports.internal = exports.VERSION = exports.BindOnceFuture = exports.isWrapped = exports.urlMatches = exports.isUrlIgnored = exports.callWithTimeout = exports.TimeoutError = exports.TracesSamplerValues = exports.merge = exports.parseEnvironment = exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = exports.DEFAULT_ENVIRONMENT = void 0;
    var W3CBaggagePropagator_1 = require_W3CBaggagePropagator();
    Object.defineProperty(exports, "W3CBaggagePropagator", { enumerable: true, get: function() {
      return W3CBaggagePropagator_1.W3CBaggagePropagator;
    } });
    var anchored_clock_1 = require_anchored_clock();
    Object.defineProperty(exports, "AnchoredClock", { enumerable: true, get: function() {
      return anchored_clock_1.AnchoredClock;
    } });
    var attributes_1 = require_attributes();
    Object.defineProperty(exports, "isAttributeKey", { enumerable: true, get: function() {
      return attributes_1.isAttributeKey;
    } });
    Object.defineProperty(exports, "isAttributeValue", { enumerable: true, get: function() {
      return attributes_1.isAttributeValue;
    } });
    Object.defineProperty(exports, "sanitizeAttributes", { enumerable: true, get: function() {
      return attributes_1.sanitizeAttributes;
    } });
    var global_error_handler_1 = require_global_error_handler();
    Object.defineProperty(exports, "globalErrorHandler", { enumerable: true, get: function() {
      return global_error_handler_1.globalErrorHandler;
    } });
    Object.defineProperty(exports, "setGlobalErrorHandler", { enumerable: true, get: function() {
      return global_error_handler_1.setGlobalErrorHandler;
    } });
    var logging_error_handler_1 = require_logging_error_handler();
    Object.defineProperty(exports, "loggingErrorHandler", { enumerable: true, get: function() {
      return logging_error_handler_1.loggingErrorHandler;
    } });
    var time_1 = require_time();
    Object.defineProperty(exports, "addHrTimes", { enumerable: true, get: function() {
      return time_1.addHrTimes;
    } });
    Object.defineProperty(exports, "getTimeOrigin", { enumerable: true, get: function() {
      return time_1.getTimeOrigin;
    } });
    Object.defineProperty(exports, "hrTime", { enumerable: true, get: function() {
      return time_1.hrTime;
    } });
    Object.defineProperty(exports, "hrTimeDuration", { enumerable: true, get: function() {
      return time_1.hrTimeDuration;
    } });
    Object.defineProperty(exports, "hrTimeToMicroseconds", { enumerable: true, get: function() {
      return time_1.hrTimeToMicroseconds;
    } });
    Object.defineProperty(exports, "hrTimeToMilliseconds", { enumerable: true, get: function() {
      return time_1.hrTimeToMilliseconds;
    } });
    Object.defineProperty(exports, "hrTimeToNanoseconds", { enumerable: true, get: function() {
      return time_1.hrTimeToNanoseconds;
    } });
    Object.defineProperty(exports, "hrTimeToTimeStamp", { enumerable: true, get: function() {
      return time_1.hrTimeToTimeStamp;
    } });
    Object.defineProperty(exports, "isTimeInput", { enumerable: true, get: function() {
      return time_1.isTimeInput;
    } });
    Object.defineProperty(exports, "isTimeInputHrTime", { enumerable: true, get: function() {
      return time_1.isTimeInputHrTime;
    } });
    Object.defineProperty(exports, "millisToHrTime", { enumerable: true, get: function() {
      return time_1.millisToHrTime;
    } });
    Object.defineProperty(exports, "timeInputToHrTime", { enumerable: true, get: function() {
      return time_1.timeInputToHrTime;
    } });
    var hex_to_binary_1 = require_hex_to_binary();
    Object.defineProperty(exports, "hexToBinary", { enumerable: true, get: function() {
      return hex_to_binary_1.hexToBinary;
    } });
    var ExportResult_1 = require_ExportResult();
    Object.defineProperty(exports, "ExportResultCode", { enumerable: true, get: function() {
      return ExportResult_1.ExportResultCode;
    } });
    var utils_1 = require_utils();
    exports.baggageUtils = {
      getKeyPairs: utils_1.getKeyPairs,
      serializeKeyPairs: utils_1.serializeKeyPairs,
      parseKeyPairsIntoRecord: utils_1.parseKeyPairsIntoRecord,
      parsePairKeyValue: utils_1.parsePairKeyValue
    };
    var platform_1 = require_platform();
    Object.defineProperty(exports, "RandomIdGenerator", { enumerable: true, get: function() {
      return platform_1.RandomIdGenerator;
    } });
    Object.defineProperty(exports, "SDK_INFO", { enumerable: true, get: function() {
      return platform_1.SDK_INFO;
    } });
    Object.defineProperty(exports, "_globalThis", { enumerable: true, get: function() {
      return platform_1._globalThis;
    } });
    Object.defineProperty(exports, "getEnv", { enumerable: true, get: function() {
      return platform_1.getEnv;
    } });
    Object.defineProperty(exports, "getEnvWithoutDefaults", { enumerable: true, get: function() {
      return platform_1.getEnvWithoutDefaults;
    } });
    Object.defineProperty(exports, "hexToBase64", { enumerable: true, get: function() {
      return platform_1.hexToBase64;
    } });
    Object.defineProperty(exports, "otperformance", { enumerable: true, get: function() {
      return platform_1.otperformance;
    } });
    Object.defineProperty(exports, "unrefTimer", { enumerable: true, get: function() {
      return platform_1.unrefTimer;
    } });
    var composite_1 = require_composite();
    Object.defineProperty(exports, "CompositePropagator", { enumerable: true, get: function() {
      return composite_1.CompositePropagator;
    } });
    var W3CTraceContextPropagator_1 = require_W3CTraceContextPropagator();
    Object.defineProperty(exports, "TRACE_PARENT_HEADER", { enumerable: true, get: function() {
      return W3CTraceContextPropagator_1.TRACE_PARENT_HEADER;
    } });
    Object.defineProperty(exports, "TRACE_STATE_HEADER", { enumerable: true, get: function() {
      return W3CTraceContextPropagator_1.TRACE_STATE_HEADER;
    } });
    Object.defineProperty(exports, "W3CTraceContextPropagator", { enumerable: true, get: function() {
      return W3CTraceContextPropagator_1.W3CTraceContextPropagator;
    } });
    Object.defineProperty(exports, "parseTraceParent", { enumerable: true, get: function() {
      return W3CTraceContextPropagator_1.parseTraceParent;
    } });
    var rpc_metadata_1 = require_rpc_metadata();
    Object.defineProperty(exports, "RPCType", { enumerable: true, get: function() {
      return rpc_metadata_1.RPCType;
    } });
    Object.defineProperty(exports, "deleteRPCMetadata", { enumerable: true, get: function() {
      return rpc_metadata_1.deleteRPCMetadata;
    } });
    Object.defineProperty(exports, "getRPCMetadata", { enumerable: true, get: function() {
      return rpc_metadata_1.getRPCMetadata;
    } });
    Object.defineProperty(exports, "setRPCMetadata", { enumerable: true, get: function() {
      return rpc_metadata_1.setRPCMetadata;
    } });
    var AlwaysOffSampler_1 = require_AlwaysOffSampler();
    Object.defineProperty(exports, "AlwaysOffSampler", { enumerable: true, get: function() {
      return AlwaysOffSampler_1.AlwaysOffSampler;
    } });
    var AlwaysOnSampler_1 = require_AlwaysOnSampler();
    Object.defineProperty(exports, "AlwaysOnSampler", { enumerable: true, get: function() {
      return AlwaysOnSampler_1.AlwaysOnSampler;
    } });
    var ParentBasedSampler_1 = require_ParentBasedSampler();
    Object.defineProperty(exports, "ParentBasedSampler", { enumerable: true, get: function() {
      return ParentBasedSampler_1.ParentBasedSampler;
    } });
    var TraceIdRatioBasedSampler_1 = require_TraceIdRatioBasedSampler();
    Object.defineProperty(exports, "TraceIdRatioBasedSampler", { enumerable: true, get: function() {
      return TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler;
    } });
    var suppress_tracing_1 = require_suppress_tracing();
    Object.defineProperty(exports, "isTracingSuppressed", { enumerable: true, get: function() {
      return suppress_tracing_1.isTracingSuppressed;
    } });
    Object.defineProperty(exports, "suppressTracing", { enumerable: true, get: function() {
      return suppress_tracing_1.suppressTracing;
    } });
    Object.defineProperty(exports, "unsuppressTracing", { enumerable: true, get: function() {
      return suppress_tracing_1.unsuppressTracing;
    } });
    var TraceState_1 = require_TraceState();
    Object.defineProperty(exports, "TraceState", { enumerable: true, get: function() {
      return TraceState_1.TraceState;
    } });
    var environment_1 = require_environment();
    Object.defineProperty(exports, "DEFAULT_ATTRIBUTE_COUNT_LIMIT", { enumerable: true, get: function() {
      return environment_1.DEFAULT_ATTRIBUTE_COUNT_LIMIT;
    } });
    Object.defineProperty(exports, "DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT", { enumerable: true, get: function() {
      return environment_1.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;
    } });
    Object.defineProperty(exports, "DEFAULT_ENVIRONMENT", { enumerable: true, get: function() {
      return environment_1.DEFAULT_ENVIRONMENT;
    } });
    Object.defineProperty(exports, "DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT", { enumerable: true, get: function() {
      return environment_1.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT;
    } });
    Object.defineProperty(exports, "DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT", { enumerable: true, get: function() {
      return environment_1.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT;
    } });
    Object.defineProperty(exports, "parseEnvironment", { enumerable: true, get: function() {
      return environment_1.parseEnvironment;
    } });
    var merge_1 = require_merge();
    Object.defineProperty(exports, "merge", { enumerable: true, get: function() {
      return merge_1.merge;
    } });
    var sampling_1 = require_sampling();
    Object.defineProperty(exports, "TracesSamplerValues", { enumerable: true, get: function() {
      return sampling_1.TracesSamplerValues;
    } });
    var timeout_1 = require_timeout();
    Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
      return timeout_1.TimeoutError;
    } });
    Object.defineProperty(exports, "callWithTimeout", { enumerable: true, get: function() {
      return timeout_1.callWithTimeout;
    } });
    var url_1 = require_url();
    Object.defineProperty(exports, "isUrlIgnored", { enumerable: true, get: function() {
      return url_1.isUrlIgnored;
    } });
    Object.defineProperty(exports, "urlMatches", { enumerable: true, get: function() {
      return url_1.urlMatches;
    } });
    var wrap_1 = require_wrap();
    Object.defineProperty(exports, "isWrapped", { enumerable: true, get: function() {
      return wrap_1.isWrapped;
    } });
    var callback_1 = require_callback();
    Object.defineProperty(exports, "BindOnceFuture", { enumerable: true, get: function() {
      return callback_1.BindOnceFuture;
    } });
    var version_1 = require_version();
    Object.defineProperty(exports, "VERSION", { enumerable: true, get: function() {
      return version_1.VERSION;
    } });
    var exporter_1 = require_exporter();
    exports.internal = {
      _export: exporter_1._export
    };
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/enums.js
var require_enums = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/enums.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExceptionEventName = void 0;
    exports.ExceptionEventName = "exception";
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/Span.js
var require_Span = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/Span.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Span = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src();
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var enums_1 = require_enums();
    var Span2 = class {
      /**
       * Constructs a new Span instance.
       *
       * @deprecated calling Span constructor directly is not supported. Please use tracer.startSpan.
       * */
      constructor(parentTracer, context3, spanName, spanContext, kind, parentSpanId, links = [], startTime, _deprecatedClock, attributes) {
        this.attributes = {};
        this.links = [];
        this.events = [];
        this._droppedAttributesCount = 0;
        this._droppedEventsCount = 0;
        this._droppedLinksCount = 0;
        this.status = {
          code: api_1.SpanStatusCode.UNSET
        };
        this.endTime = [0, 0];
        this._ended = false;
        this._duration = [-1, -1];
        this.name = spanName;
        this._spanContext = spanContext;
        this.parentSpanId = parentSpanId;
        this.kind = kind;
        this.links = links;
        const now = Date.now();
        this._performanceStartTime = core_1.otperformance.now();
        this._performanceOffset = now - (this._performanceStartTime + (0, core_1.getTimeOrigin)());
        this._startTimeProvided = startTime != null;
        this.startTime = this._getTime(startTime !== null && startTime !== void 0 ? startTime : now);
        this.resource = parentTracer.resource;
        this.instrumentationLibrary = parentTracer.instrumentationLibrary;
        this._spanLimits = parentTracer.getSpanLimits();
        this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;
        if (attributes != null) {
          this.setAttributes(attributes);
        }
        this._spanProcessor = parentTracer.getActiveSpanProcessor();
        this._spanProcessor.onStart(this, context3);
      }
      spanContext() {
        return this._spanContext;
      }
      setAttribute(key, value) {
        if (value == null || this._isSpanEnded())
          return this;
        if (key.length === 0) {
          api_1.diag.warn(`Invalid attribute key: ${key}`);
          return this;
        }
        if (!(0, core_1.isAttributeValue)(value)) {
          api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
          return this;
        }
        if (Object.keys(this.attributes).length >= this._spanLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {
          this._droppedAttributesCount++;
          return this;
        }
        this.attributes[key] = this._truncateToSize(value);
        return this;
      }
      setAttributes(attributes) {
        for (const [k2, v2] of Object.entries(attributes)) {
          this.setAttribute(k2, v2);
        }
        return this;
      }
      /**
       *
       * @param name Span Name
       * @param [attributesOrStartTime] Span attributes or start time
       *     if type is {@type TimeInput} and 3rd param is undefined
       * @param [timeStamp] Specified time stamp for the event
       */
      addEvent(name, attributesOrStartTime, timeStamp) {
        if (this._isSpanEnded())
          return this;
        if (this._spanLimits.eventCountLimit === 0) {
          api_1.diag.warn("No events allowed.");
          this._droppedEventsCount++;
          return this;
        }
        if (this.events.length >= this._spanLimits.eventCountLimit) {
          if (this._droppedEventsCount === 0) {
            api_1.diag.debug("Dropping extra events.");
          }
          this.events.shift();
          this._droppedEventsCount++;
        }
        if ((0, core_1.isTimeInput)(attributesOrStartTime)) {
          if (!(0, core_1.isTimeInput)(timeStamp)) {
            timeStamp = attributesOrStartTime;
          }
          attributesOrStartTime = void 0;
        }
        const attributes = (0, core_1.sanitizeAttributes)(attributesOrStartTime);
        this.events.push({
          name,
          attributes,
          time: this._getTime(timeStamp),
          droppedAttributesCount: 0
        });
        return this;
      }
      addLink(link) {
        this.links.push(link);
        return this;
      }
      addLinks(links) {
        this.links.push(...links);
        return this;
      }
      setStatus(status) {
        if (this._isSpanEnded())
          return this;
        this.status = Object.assign({}, status);
        if (this.status.message != null && typeof status.message !== "string") {
          api_1.diag.warn(`Dropping invalid status.message of type '${typeof status.message}', expected 'string'`);
          delete this.status.message;
        }
        return this;
      }
      updateName(name) {
        if (this._isSpanEnded())
          return this;
        this.name = name;
        return this;
      }
      end(endTime) {
        if (this._isSpanEnded()) {
          api_1.diag.error(`${this.name} ${this._spanContext.traceId}-${this._spanContext.spanId} - You can only call end() on a span once.`);
          return;
        }
        this._ended = true;
        this.endTime = this._getTime(endTime);
        this._duration = (0, core_1.hrTimeDuration)(this.startTime, this.endTime);
        if (this._duration[0] < 0) {
          api_1.diag.warn("Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.", this.startTime, this.endTime);
          this.endTime = this.startTime.slice();
          this._duration = [0, 0];
        }
        if (this._droppedEventsCount > 0) {
          api_1.diag.warn(`Dropped ${this._droppedEventsCount} events because eventCountLimit reached`);
        }
        this._spanProcessor.onEnd(this);
      }
      _getTime(inp) {
        if (typeof inp === "number" && inp <= core_1.otperformance.now()) {
          return (0, core_1.hrTime)(inp + this._performanceOffset);
        }
        if (typeof inp === "number") {
          return (0, core_1.millisToHrTime)(inp);
        }
        if (inp instanceof Date) {
          return (0, core_1.millisToHrTime)(inp.getTime());
        }
        if ((0, core_1.isTimeInputHrTime)(inp)) {
          return inp;
        }
        if (this._startTimeProvided) {
          return (0, core_1.millisToHrTime)(Date.now());
        }
        const msDuration = core_1.otperformance.now() - this._performanceStartTime;
        return (0, core_1.addHrTimes)(this.startTime, (0, core_1.millisToHrTime)(msDuration));
      }
      isRecording() {
        return this._ended === false;
      }
      recordException(exception, time) {
        const attributes = {};
        if (typeof exception === "string") {
          attributes[semantic_conventions_1.SEMATTRS_EXCEPTION_MESSAGE] = exception;
        } else if (exception) {
          if (exception.code) {
            attributes[semantic_conventions_1.SEMATTRS_EXCEPTION_TYPE] = exception.code.toString();
          } else if (exception.name) {
            attributes[semantic_conventions_1.SEMATTRS_EXCEPTION_TYPE] = exception.name;
          }
          if (exception.message) {
            attributes[semantic_conventions_1.SEMATTRS_EXCEPTION_MESSAGE] = exception.message;
          }
          if (exception.stack) {
            attributes[semantic_conventions_1.SEMATTRS_EXCEPTION_STACKTRACE] = exception.stack;
          }
        }
        if (attributes[semantic_conventions_1.SEMATTRS_EXCEPTION_TYPE] || attributes[semantic_conventions_1.SEMATTRS_EXCEPTION_MESSAGE]) {
          this.addEvent(enums_1.ExceptionEventName, attributes, time);
        } else {
          api_1.diag.warn(`Failed to record an exception ${exception}`);
        }
      }
      get duration() {
        return this._duration;
      }
      get ended() {
        return this._ended;
      }
      get droppedAttributesCount() {
        return this._droppedAttributesCount;
      }
      get droppedEventsCount() {
        return this._droppedEventsCount;
      }
      get droppedLinksCount() {
        return this._droppedLinksCount;
      }
      _isSpanEnded() {
        if (this._ended) {
          api_1.diag.warn(`Can not execute the operation on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`);
        }
        return this._ended;
      }
      // Utility function to truncate given value within size
      // for value type of string, will truncate to given limit
      // for type of non-string, will return same value
      _truncateToLimitUtil(value, limit) {
        if (value.length <= limit) {
          return value;
        }
        return value.substring(0, limit);
      }
      /**
       * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then
       * return string with truncated to {@code attributeValueLengthLimit} characters
       *
       * If the given attribute value is array of strings then
       * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters
       *
       * Otherwise return same Attribute {@code value}
       *
       * @param value Attribute value
       * @returns truncated attribute value if required, otherwise same value
       */
      _truncateToSize(value) {
        const limit = this._attributeValueLengthLimit;
        if (limit <= 0) {
          api_1.diag.warn(`Attribute value limit must be positive, got ${limit}`);
          return value;
        }
        if (typeof value === "string") {
          return this._truncateToLimitUtil(value, limit);
        }
        if (Array.isArray(value)) {
          return value.map((val) => typeof val === "string" ? this._truncateToLimitUtil(val, limit) : val);
        }
        return value;
      }
    };
    exports.Span = Span2;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/Sampler.js
var require_Sampler = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/Sampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SamplingDecision = void 0;
    var SamplingDecision2;
    (function(SamplingDecision3) {
      SamplingDecision3[SamplingDecision3["NOT_RECORD"] = 0] = "NOT_RECORD";
      SamplingDecision3[SamplingDecision3["RECORD"] = 1] = "RECORD";
      SamplingDecision3[SamplingDecision3["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision2 = exports.SamplingDecision || (exports.SamplingDecision = {}));
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/AlwaysOffSampler.js
var require_AlwaysOffSampler2 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/AlwaysOffSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AlwaysOffSampler = void 0;
    var Sampler_1 = require_Sampler();
    var AlwaysOffSampler = class {
      shouldSample() {
        return {
          decision: Sampler_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return "AlwaysOffSampler";
      }
    };
    exports.AlwaysOffSampler = AlwaysOffSampler;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/AlwaysOnSampler.js
var require_AlwaysOnSampler2 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/AlwaysOnSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AlwaysOnSampler = void 0;
    var Sampler_1 = require_Sampler();
    var AlwaysOnSampler = class {
      shouldSample() {
        return {
          decision: Sampler_1.SamplingDecision.RECORD_AND_SAMPLED
        };
      }
      toString() {
        return "AlwaysOnSampler";
      }
    };
    exports.AlwaysOnSampler = AlwaysOnSampler;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/ParentBasedSampler.js
var require_ParentBasedSampler2 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/ParentBasedSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParentBasedSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src();
    var AlwaysOffSampler_1 = require_AlwaysOffSampler2();
    var AlwaysOnSampler_1 = require_AlwaysOnSampler2();
    var ParentBasedSampler = class {
      constructor(config) {
        var _a12, _b5, _c4, _d4;
        this._root = config.root;
        if (!this._root) {
          (0, core_1.globalErrorHandler)(new Error("ParentBasedSampler must have a root sampler configured"));
          this._root = new AlwaysOnSampler_1.AlwaysOnSampler();
        }
        this._remoteParentSampled = (_a12 = config.remoteParentSampled) !== null && _a12 !== void 0 ? _a12 : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._remoteParentNotSampled = (_b5 = config.remoteParentNotSampled) !== null && _b5 !== void 0 ? _b5 : new AlwaysOffSampler_1.AlwaysOffSampler();
        this._localParentSampled = (_c4 = config.localParentSampled) !== null && _c4 !== void 0 ? _c4 : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._localParentNotSampled = (_d4 = config.localParentNotSampled) !== null && _d4 !== void 0 ? _d4 : new AlwaysOffSampler_1.AlwaysOffSampler();
      }
      shouldSample(context3, traceId, spanName, spanKind, attributes, links) {
        const parentContext = api_1.trace.getSpanContext(context3);
        if (!parentContext || !(0, api_1.isSpanContextValid)(parentContext)) {
          return this._root.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
          if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
            return this._remoteParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
          }
          return this._remoteParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
          return this._localParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
      }
      toString() {
        return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
      }
    };
    exports.ParentBasedSampler = ParentBasedSampler;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/TraceIdRatioBasedSampler.js
var require_TraceIdRatioBasedSampler2 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/TraceIdRatioBasedSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TraceIdRatioBasedSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var Sampler_1 = require_Sampler();
    var TraceIdRatioBasedSampler = class {
      constructor(_ratio = 0) {
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 4294967295);
      }
      shouldSample(context3, traceId) {
        return {
          decision: (0, api_1.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? Sampler_1.SamplingDecision.RECORD_AND_SAMPLED : Sampler_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return `TraceIdRatioBased{${this._ratio}}`;
      }
      _normalize(ratio) {
        if (typeof ratio !== "number" || isNaN(ratio))
          return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
      }
      _accumulate(traceId) {
        let accumulation = 0;
        for (let i2 = 0; i2 < traceId.length / 8; i2++) {
          const pos = i2 * 8;
          const part = parseInt(traceId.slice(pos, pos + 8), 16);
          accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
      }
    };
    exports.TraceIdRatioBasedSampler = TraceIdRatioBasedSampler;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/config.js
var require_config = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildSamplerFromEnv = exports.loadDefaultConfig = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src();
    var AlwaysOffSampler_1 = require_AlwaysOffSampler2();
    var AlwaysOnSampler_1 = require_AlwaysOnSampler2();
    var ParentBasedSampler_1 = require_ParentBasedSampler2();
    var TraceIdRatioBasedSampler_1 = require_TraceIdRatioBasedSampler2();
    var FALLBACK_OTEL_TRACES_SAMPLER = core_1.TracesSamplerValues.AlwaysOn;
    var DEFAULT_RATIO = 1;
    function loadDefaultConfig() {
      const env = (0, core_1.getEnv)();
      return {
        sampler: buildSamplerFromEnv(env),
        forceFlushTimeoutMillis: 3e4,
        generalLimits: {
          attributeValueLengthLimit: env.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT,
          attributeCountLimit: env.OTEL_ATTRIBUTE_COUNT_LIMIT
        },
        spanLimits: {
          attributeValueLengthLimit: env.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,
          attributeCountLimit: env.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,
          linkCountLimit: env.OTEL_SPAN_LINK_COUNT_LIMIT,
          eventCountLimit: env.OTEL_SPAN_EVENT_COUNT_LIMIT,
          attributePerEventCountLimit: env.OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
          attributePerLinkCountLimit: env.OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT
        },
        mergeResourceWithDefaults: true
      };
    }
    exports.loadDefaultConfig = loadDefaultConfig;
    function buildSamplerFromEnv(environment5 = (0, core_1.getEnv)()) {
      switch (environment5.OTEL_TRACES_SAMPLER) {
        case core_1.TracesSamplerValues.AlwaysOn:
          return new AlwaysOnSampler_1.AlwaysOnSampler();
        case core_1.TracesSamplerValues.AlwaysOff:
          return new AlwaysOffSampler_1.AlwaysOffSampler();
        case core_1.TracesSamplerValues.ParentBasedAlwaysOn:
          return new ParentBasedSampler_1.ParentBasedSampler({
            root: new AlwaysOnSampler_1.AlwaysOnSampler()
          });
        case core_1.TracesSamplerValues.ParentBasedAlwaysOff:
          return new ParentBasedSampler_1.ParentBasedSampler({
            root: new AlwaysOffSampler_1.AlwaysOffSampler()
          });
        case core_1.TracesSamplerValues.TraceIdRatio:
          return new TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment5));
        case core_1.TracesSamplerValues.ParentBasedTraceIdRatio:
          return new ParentBasedSampler_1.ParentBasedSampler({
            root: new TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment5))
          });
        default:
          api_1.diag.error(`OTEL_TRACES_SAMPLER value "${environment5.OTEL_TRACES_SAMPLER} invalid, defaulting to ${FALLBACK_OTEL_TRACES_SAMPLER}".`);
          return new AlwaysOnSampler_1.AlwaysOnSampler();
      }
    }
    exports.buildSamplerFromEnv = buildSamplerFromEnv;
    function getSamplerProbabilityFromEnv(environment5) {
      if (environment5.OTEL_TRACES_SAMPLER_ARG === void 0 || environment5.OTEL_TRACES_SAMPLER_ARG === "") {
        api_1.diag.error(`OTEL_TRACES_SAMPLER_ARG is blank, defaulting to ${DEFAULT_RATIO}.`);
        return DEFAULT_RATIO;
      }
      const probability = Number(environment5.OTEL_TRACES_SAMPLER_ARG);
      if (isNaN(probability)) {
        api_1.diag.error(`OTEL_TRACES_SAMPLER_ARG=${environment5.OTEL_TRACES_SAMPLER_ARG} was given, but it is invalid, defaulting to ${DEFAULT_RATIO}.`);
        return DEFAULT_RATIO;
      }
      if (probability < 0 || probability > 1) {
        api_1.diag.error(`OTEL_TRACES_SAMPLER_ARG=${environment5.OTEL_TRACES_SAMPLER_ARG} was given, but it is out of range ([0..1]), defaulting to ${DEFAULT_RATIO}.`);
        return DEFAULT_RATIO;
      }
      return probability;
    }
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/utility.js
var require_utility = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/utility.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reconfigureLimits = exports.mergeConfig = void 0;
    var config_1 = require_config();
    var core_1 = require_src();
    function mergeConfig(userConfig) {
      const perInstanceDefaults = {
        sampler: (0, config_1.buildSamplerFromEnv)()
      };
      const DEFAULT_CONFIG = (0, config_1.loadDefaultConfig)();
      const target = Object.assign({}, DEFAULT_CONFIG, perInstanceDefaults, userConfig);
      target.generalLimits = Object.assign({}, DEFAULT_CONFIG.generalLimits, userConfig.generalLimits || {});
      target.spanLimits = Object.assign({}, DEFAULT_CONFIG.spanLimits, userConfig.spanLimits || {});
      return target;
    }
    exports.mergeConfig = mergeConfig;
    function reconfigureLimits(userConfig) {
      var _a12, _b5, _c4, _d4, _e4, _f3, _g2, _h, _j, _k, _l, _m;
      const spanLimits = Object.assign({}, userConfig.spanLimits);
      const parsedEnvConfig = (0, core_1.getEnvWithoutDefaults)();
      spanLimits.attributeCountLimit = (_f3 = (_e4 = (_d4 = (_b5 = (_a12 = userConfig.spanLimits) === null || _a12 === void 0 ? void 0 : _a12.attributeCountLimit) !== null && _b5 !== void 0 ? _b5 : (_c4 = userConfig.generalLimits) === null || _c4 === void 0 ? void 0 : _c4.attributeCountLimit) !== null && _d4 !== void 0 ? _d4 : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) !== null && _e4 !== void 0 ? _e4 : parsedEnvConfig.OTEL_ATTRIBUTE_COUNT_LIMIT) !== null && _f3 !== void 0 ? _f3 : core_1.DEFAULT_ATTRIBUTE_COUNT_LIMIT;
      spanLimits.attributeValueLengthLimit = (_m = (_l = (_k = (_h = (_g2 = userConfig.spanLimits) === null || _g2 === void 0 ? void 0 : _g2.attributeValueLengthLimit) !== null && _h !== void 0 ? _h : (_j = userConfig.generalLimits) === null || _j === void 0 ? void 0 : _j.attributeValueLengthLimit) !== null && _k !== void 0 ? _k : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _l !== void 0 ? _l : parsedEnvConfig.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _m !== void 0 ? _m : core_1.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;
      return Object.assign({}, userConfig, { spanLimits });
    }
    exports.reconfigureLimits = reconfigureLimits;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/export/BatchSpanProcessorBase.js
var require_BatchSpanProcessorBase = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/export/BatchSpanProcessorBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BatchSpanProcessorBase = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src();
    var BatchSpanProcessorBase = class {
      constructor(_exporter, config) {
        this._exporter = _exporter;
        this._isExporting = false;
        this._finishedSpans = [];
        this._droppedSpansCount = 0;
        const env = (0, core_1.getEnv)();
        this._maxExportBatchSize = typeof (config === null || config === void 0 ? void 0 : config.maxExportBatchSize) === "number" ? config.maxExportBatchSize : env.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;
        this._maxQueueSize = typeof (config === null || config === void 0 ? void 0 : config.maxQueueSize) === "number" ? config.maxQueueSize : env.OTEL_BSP_MAX_QUEUE_SIZE;
        this._scheduledDelayMillis = typeof (config === null || config === void 0 ? void 0 : config.scheduledDelayMillis) === "number" ? config.scheduledDelayMillis : env.OTEL_BSP_SCHEDULE_DELAY;
        this._exportTimeoutMillis = typeof (config === null || config === void 0 ? void 0 : config.exportTimeoutMillis) === "number" ? config.exportTimeoutMillis : env.OTEL_BSP_EXPORT_TIMEOUT;
        this._shutdownOnce = new core_1.BindOnceFuture(this._shutdown, this);
        if (this._maxExportBatchSize > this._maxQueueSize) {
          api_1.diag.warn("BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize");
          this._maxExportBatchSize = this._maxQueueSize;
        }
      }
      forceFlush() {
        if (this._shutdownOnce.isCalled) {
          return this._shutdownOnce.promise;
        }
        return this._flushAll();
      }
      // does nothing.
      onStart(_span, _parentContext) {
      }
      onEnd(span) {
        if (this._shutdownOnce.isCalled) {
          return;
        }
        if ((span.spanContext().traceFlags & api_1.TraceFlags.SAMPLED) === 0) {
          return;
        }
        this._addToBuffer(span);
      }
      shutdown() {
        return this._shutdownOnce.call();
      }
      _shutdown() {
        return Promise.resolve().then(() => {
          return this.onShutdown();
        }).then(() => {
          return this._flushAll();
        }).then(() => {
          return this._exporter.shutdown();
        });
      }
      /** Add a span in the buffer. */
      _addToBuffer(span) {
        if (this._finishedSpans.length >= this._maxQueueSize) {
          if (this._droppedSpansCount === 0) {
            api_1.diag.debug("maxQueueSize reached, dropping spans");
          }
          this._droppedSpansCount++;
          return;
        }
        if (this._droppedSpansCount > 0) {
          api_1.diag.warn(`Dropped ${this._droppedSpansCount} spans because maxQueueSize reached`);
          this._droppedSpansCount = 0;
        }
        this._finishedSpans.push(span);
        this._maybeStartTimer();
      }
      /**
       * Send all spans to the exporter respecting the batch size limit
       * This function is used only on forceFlush or shutdown,
       * for all other cases _flush should be used
       * */
      _flushAll() {
        return new Promise((resolve, reject3) => {
          const promises = [];
          const count2 = Math.ceil(this._finishedSpans.length / this._maxExportBatchSize);
          for (let i2 = 0, j2 = count2; i2 < j2; i2++) {
            promises.push(this._flushOneBatch());
          }
          Promise.all(promises).then(() => {
            resolve();
          }).catch(reject3);
        });
      }
      _flushOneBatch() {
        this._clearTimer();
        if (this._finishedSpans.length === 0) {
          return Promise.resolve();
        }
        return new Promise((resolve, reject3) => {
          const timer = setTimeout(() => {
            reject3(new Error("Timeout"));
          }, this._exportTimeoutMillis);
          api_1.context.with((0, core_1.suppressTracing)(api_1.context.active()), () => {
            let spans;
            if (this._finishedSpans.length <= this._maxExportBatchSize) {
              spans = this._finishedSpans;
              this._finishedSpans = [];
            } else {
              spans = this._finishedSpans.splice(0, this._maxExportBatchSize);
            }
            const doExport = () => this._exporter.export(spans, (result4) => {
              var _a12;
              clearTimeout(timer);
              if (result4.code === core_1.ExportResultCode.SUCCESS) {
                resolve();
              } else {
                reject3((_a12 = result4.error) !== null && _a12 !== void 0 ? _a12 : new Error("BatchSpanProcessor: span export failed"));
              }
            });
            let pendingResources = null;
            for (let i2 = 0, len = spans.length; i2 < len; i2++) {
              const span = spans[i2];
              if (span.resource.asyncAttributesPending && span.resource.waitForAsyncAttributes) {
                pendingResources !== null && pendingResources !== void 0 ? pendingResources : pendingResources = [];
                pendingResources.push(span.resource.waitForAsyncAttributes());
              }
            }
            if (pendingResources === null) {
              doExport();
            } else {
              Promise.all(pendingResources).then(doExport, (err) => {
                (0, core_1.globalErrorHandler)(err);
                reject3(err);
              });
            }
          });
        });
      }
      _maybeStartTimer() {
        if (this._isExporting)
          return;
        const flush = () => {
          this._isExporting = true;
          this._flushOneBatch().finally(() => {
            this._isExporting = false;
            if (this._finishedSpans.length > 0) {
              this._clearTimer();
              this._maybeStartTimer();
            }
          }).catch((e2) => {
            this._isExporting = false;
            (0, core_1.globalErrorHandler)(e2);
          });
        };
        if (this._finishedSpans.length >= this._maxExportBatchSize) {
          return flush();
        }
        if (this._timer !== void 0)
          return;
        this._timer = setTimeout(() => flush(), this._scheduledDelayMillis);
        (0, core_1.unrefTimer)(this._timer);
      }
      _clearTimer() {
        if (this._timer !== void 0) {
          clearTimeout(this._timer);
          this._timer = void 0;
        }
      }
    };
    exports.BatchSpanProcessorBase = BatchSpanProcessorBase;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/export/BatchSpanProcessor.js
var require_BatchSpanProcessor = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/export/BatchSpanProcessor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BatchSpanProcessor = void 0;
    var BatchSpanProcessorBase_1 = require_BatchSpanProcessorBase();
    var BatchSpanProcessor = class extends BatchSpanProcessorBase_1.BatchSpanProcessorBase {
      onShutdown() {
      }
    };
    exports.BatchSpanProcessor = BatchSpanProcessor;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/RandomIdGenerator.js
var require_RandomIdGenerator2 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/RandomIdGenerator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RandomIdGenerator = void 0;
    var SPAN_ID_BYTES = 8;
    var TRACE_ID_BYTES = 16;
    var RandomIdGenerator = class {
      constructor() {
        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
        this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
      }
    };
    exports.RandomIdGenerator = RandomIdGenerator;
    var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
    function getIdGenerator(bytes) {
      return function generateId() {
        for (let i2 = 0; i2 < bytes / 4; i2++) {
          SHARED_BUFFER.writeUInt32BE(Math.random() * 2 ** 32 >>> 0, i2 * 4);
        }
        for (let i2 = 0; i2 < bytes; i2++) {
          if (SHARED_BUFFER[i2] > 0) {
            break;
          } else if (i2 === bytes - 1) {
            SHARED_BUFFER[bytes - 1] = 1;
          }
        }
        return SHARED_BUFFER.toString("hex", 0, bytes);
      };
    }
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/index.js
var require_node2 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RandomIdGenerator = exports.BatchSpanProcessor = void 0;
    var BatchSpanProcessor_1 = require_BatchSpanProcessor();
    Object.defineProperty(exports, "BatchSpanProcessor", { enumerable: true, get: function() {
      return BatchSpanProcessor_1.BatchSpanProcessor;
    } });
    var RandomIdGenerator_1 = require_RandomIdGenerator2();
    Object.defineProperty(exports, "RandomIdGenerator", { enumerable: true, get: function() {
      return RandomIdGenerator_1.RandomIdGenerator;
    } });
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/platform/index.js
var require_platform2 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/platform/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RandomIdGenerator = exports.BatchSpanProcessor = void 0;
    var node_1 = require_node2();
    Object.defineProperty(exports, "BatchSpanProcessor", { enumerable: true, get: function() {
      return node_1.BatchSpanProcessor;
    } });
    Object.defineProperty(exports, "RandomIdGenerator", { enumerable: true, get: function() {
      return node_1.RandomIdGenerator;
    } });
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/Tracer.js
var require_Tracer = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/Tracer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tracer = void 0;
    var api = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src();
    var Span_1 = require_Span();
    var utility_1 = require_utility();
    var platform_1 = require_platform2();
    var Tracer3 = class {
      /**
       * Constructs a new Tracer instance.
       */
      constructor(instrumentationLibrary, config, _tracerProvider) {
        this._tracerProvider = _tracerProvider;
        const localConfig = (0, utility_1.mergeConfig)(config);
        this._sampler = localConfig.sampler;
        this._generalLimits = localConfig.generalLimits;
        this._spanLimits = localConfig.spanLimits;
        this._idGenerator = config.idGenerator || new platform_1.RandomIdGenerator();
        this.resource = _tracerProvider.resource;
        this.instrumentationLibrary = instrumentationLibrary;
      }
      /**
       * Starts a new Span or returns the default NoopSpan based on the sampling
       * decision.
       */
      startSpan(name, options = {}, context3 = api.context.active()) {
        var _a12, _b5, _c4;
        if (options.root) {
          context3 = api.trace.deleteSpan(context3);
        }
        const parentSpan = api.trace.getSpan(context3);
        if ((0, core_1.isTracingSuppressed)(context3)) {
          api.diag.debug("Instrumentation suppressed, returning Noop Span");
          const nonRecordingSpan = api.trace.wrapSpanContext(api.INVALID_SPAN_CONTEXT);
          return nonRecordingSpan;
        }
        const parentSpanContext = parentSpan === null || parentSpan === void 0 ? void 0 : parentSpan.spanContext();
        const spanId = this._idGenerator.generateSpanId();
        let traceId;
        let traceState;
        let parentSpanId;
        if (!parentSpanContext || !api.trace.isSpanContextValid(parentSpanContext)) {
          traceId = this._idGenerator.generateTraceId();
        } else {
          traceId = parentSpanContext.traceId;
          traceState = parentSpanContext.traceState;
          parentSpanId = parentSpanContext.spanId;
        }
        const spanKind = (_a12 = options.kind) !== null && _a12 !== void 0 ? _a12 : api.SpanKind.INTERNAL;
        const links = ((_b5 = options.links) !== null && _b5 !== void 0 ? _b5 : []).map((link) => {
          return {
            context: link.context,
            attributes: (0, core_1.sanitizeAttributes)(link.attributes)
          };
        });
        const attributes = (0, core_1.sanitizeAttributes)(options.attributes);
        const samplingResult = this._sampler.shouldSample(context3, traceId, name, spanKind, attributes, links);
        traceState = (_c4 = samplingResult.traceState) !== null && _c4 !== void 0 ? _c4 : traceState;
        const traceFlags = samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE;
        const spanContext = { traceId, spanId, traceFlags, traceState };
        if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) {
          api.diag.debug("Recording is off, propagating context in a non-recording span");
          const nonRecordingSpan = api.trace.wrapSpanContext(spanContext);
          return nonRecordingSpan;
        }
        const initAttributes = (0, core_1.sanitizeAttributes)(Object.assign(attributes, samplingResult.attributes));
        const span = new Span_1.Span(this, context3, name, spanContext, spanKind, parentSpanId, links, options.startTime, void 0, initAttributes);
        return span;
      }
      startActiveSpan(name, arg2, arg3, arg4) {
        let opts;
        let ctx;
        let fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        const parentContext = ctx !== null && ctx !== void 0 ? ctx : api.context.active();
        const span = this.startSpan(name, opts, parentContext);
        const contextWithSpanSet = api.trace.setSpan(parentContext, span);
        return api.context.with(contextWithSpanSet, fn, void 0, span);
      }
      /** Returns the active {@link GeneralLimits}. */
      getGeneralLimits() {
        return this._generalLimits;
      }
      /** Returns the active {@link SpanLimits}. */
      getSpanLimits() {
        return this._spanLimits;
      }
      getActiveSpanProcessor() {
        return this._tracerProvider.getActiveSpanProcessor();
      }
    };
    exports.Tracer = Tracer3;
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/node/default-service-name.js
var require_default_service_name = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/node/default-service-name.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultServiceName = void 0;
    function defaultServiceName() {
      return `unknown_service:${process.argv0}`;
    }
    exports.defaultServiceName = defaultServiceName;
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/node/index.js
var require_node3 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultServiceName = void 0;
    var default_service_name_1 = require_default_service_name();
    Object.defineProperty(exports, "defaultServiceName", { enumerable: true, get: function() {
      return default_service_name_1.defaultServiceName;
    } });
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/index.js
var require_platform3 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultServiceName = void 0;
    var node_1 = require_node3();
    Object.defineProperty(exports, "defaultServiceName", { enumerable: true, get: function() {
      return node_1.defaultServiceName;
    } });
  }
});

// node_modules/@opentelemetry/resources/build/src/Resource.js
var require_Resource = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/Resource.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Resource = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var core_1 = require_src();
    var platform_1 = require_platform3();
    var Resource = class _Resource {
      constructor(attributes, asyncAttributesPromise) {
        var _a12;
        this._attributes = attributes;
        this.asyncAttributesPending = asyncAttributesPromise != null;
        this._syncAttributes = (_a12 = this._attributes) !== null && _a12 !== void 0 ? _a12 : {};
        this._asyncAttributesPromise = asyncAttributesPromise === null || asyncAttributesPromise === void 0 ? void 0 : asyncAttributesPromise.then((asyncAttributes) => {
          this._attributes = Object.assign({}, this._attributes, asyncAttributes);
          this.asyncAttributesPending = false;
          return asyncAttributes;
        }, (err) => {
          api_1.diag.debug("a resource's async attributes promise rejected: %s", err);
          this.asyncAttributesPending = false;
          return {};
        });
      }
      /**
       * Returns an empty Resource
       */
      static empty() {
        return _Resource.EMPTY;
      }
      /**
       * Returns a Resource that identifies the SDK in use.
       */
      static default() {
        return new _Resource({
          [semantic_conventions_1.SEMRESATTRS_SERVICE_NAME]: (0, platform_1.defaultServiceName)(),
          [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE]: core_1.SDK_INFO[semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE],
          [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_NAME]: core_1.SDK_INFO[semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_NAME],
          [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_VERSION]: core_1.SDK_INFO[semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_VERSION]
        });
      }
      get attributes() {
        var _a12;
        if (this.asyncAttributesPending) {
          api_1.diag.error("Accessing resource attributes before async attributes settled");
        }
        return (_a12 = this._attributes) !== null && _a12 !== void 0 ? _a12 : {};
      }
      /**
       * Returns a promise that will never be rejected. Resolves when all async attributes have finished being added to
       * this Resource's attributes. This is useful in exporters to block until resource detection
       * has finished.
       */
      async waitForAsyncAttributes() {
        if (this.asyncAttributesPending) {
          await this._asyncAttributesPromise;
        }
      }
      /**
       * Returns a new, merged {@link Resource} by merging the current Resource
       * with the other Resource. In case of a collision, other Resource takes
       * precedence.
       *
       * @param other the Resource that will be merged with this.
       * @returns the newly merged Resource.
       */
      merge(other) {
        var _a12;
        if (!other)
          return this;
        const mergedSyncAttributes = Object.assign(Object.assign({}, this._syncAttributes), (_a12 = other._syncAttributes) !== null && _a12 !== void 0 ? _a12 : other.attributes);
        if (!this._asyncAttributesPromise && !other._asyncAttributesPromise) {
          return new _Resource(mergedSyncAttributes);
        }
        const mergedAttributesPromise = Promise.all([
          this._asyncAttributesPromise,
          other._asyncAttributesPromise
        ]).then(([thisAsyncAttributes, otherAsyncAttributes]) => {
          var _a13;
          return Object.assign(Object.assign(Object.assign(Object.assign({}, this._syncAttributes), thisAsyncAttributes), (_a13 = other._syncAttributes) !== null && _a13 !== void 0 ? _a13 : other.attributes), otherAsyncAttributes);
        });
        return new _Resource(mergedSyncAttributes, mergedAttributesPromise);
      }
    };
    exports.Resource = Resource;
    Resource.EMPTY = new Resource({});
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/utils.js
var require_utils2 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalizeType = exports.normalizeArch = void 0;
    var normalizeArch = (nodeArchString) => {
      switch (nodeArchString) {
        case "arm":
          return "arm32";
        case "ppc":
          return "ppc32";
        case "x64":
          return "amd64";
        default:
          return nodeArchString;
      }
    };
    exports.normalizeArch = normalizeArch;
    var normalizeType = (nodePlatform) => {
      switch (nodePlatform) {
        case "sunos":
          return "solaris";
        case "win32":
          return "windows";
        default:
          return nodePlatform;
      }
    };
    exports.normalizeType = normalizeType;
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/execAsync.js
var require_execAsync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/execAsync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.execAsync = void 0;
    var child_process = __require("child_process");
    var util = __require("util");
    exports.execAsync = util.promisify(child_process.exec);
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-darwin.js
var require_getMachineId_darwin = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-darwin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMachineId = void 0;
    var execAsync_1 = require_execAsync();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      try {
        const result4 = await (0, execAsync_1.execAsync)('ioreg -rd1 -c "IOPlatformExpertDevice"');
        const idLine = result4.stdout.split("\n").find((line) => line.includes("IOPlatformUUID"));
        if (!idLine) {
          return "";
        }
        const parts = idLine.split('" = "');
        if (parts.length === 2) {
          return parts[1].slice(0, -1);
        }
      } catch (e2) {
        api_1.diag.debug(`error reading machine id: ${e2}`);
      }
      return "";
    }
    exports.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-linux.js
var require_getMachineId_linux = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-linux.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMachineId = void 0;
    var fs_1 = __require("fs");
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      const paths = ["/etc/machine-id", "/var/lib/dbus/machine-id"];
      for (const path9 of paths) {
        try {
          const result4 = await fs_1.promises.readFile(path9, { encoding: "utf8" });
          return result4.trim();
        } catch (e2) {
          api_1.diag.debug(`error reading machine id: ${e2}`);
        }
      }
      return "";
    }
    exports.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-bsd.js
var require_getMachineId_bsd = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-bsd.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMachineId = void 0;
    var fs_1 = __require("fs");
    var execAsync_1 = require_execAsync();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      try {
        const result4 = await fs_1.promises.readFile("/etc/hostid", { encoding: "utf8" });
        return result4.trim();
      } catch (e2) {
        api_1.diag.debug(`error reading machine id: ${e2}`);
      }
      try {
        const result4 = await (0, execAsync_1.execAsync)("kenv -q smbios.system.uuid");
        return result4.stdout.trim();
      } catch (e2) {
        api_1.diag.debug(`error reading machine id: ${e2}`);
      }
      return "";
    }
    exports.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-win.js
var require_getMachineId_win = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-win.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMachineId = void 0;
    var process2 = __require("process");
    var execAsync_1 = require_execAsync();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      const args = "QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid";
      let command = "%windir%\\System32\\REG.exe";
      if (process2.arch === "ia32" && "PROCESSOR_ARCHITEW6432" in process2.env) {
        command = "%windir%\\sysnative\\cmd.exe /c " + command;
      }
      try {
        const result4 = await (0, execAsync_1.execAsync)(`${command} ${args}`);
        const parts = result4.stdout.split("REG_SZ");
        if (parts.length === 2) {
          return parts[1].trim();
        }
      } catch (e2) {
        api_1.diag.debug(`error reading machine id: ${e2}`);
      }
      return "";
    }
    exports.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-unsupported.js
var require_getMachineId_unsupported = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-unsupported.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMachineId = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      api_1.diag.debug("could not read machine-id: unsupported platform");
      return "";
    }
    exports.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId.js
var require_getMachineId = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMachineId = void 0;
    var process2 = __require("process");
    var getMachineId;
    exports.getMachineId = getMachineId;
    switch (process2.platform) {
      case "darwin":
        exports.getMachineId = getMachineId = require_getMachineId_darwin().getMachineId;
        break;
      case "linux":
        exports.getMachineId = getMachineId = require_getMachineId_linux().getMachineId;
        break;
      case "freebsd":
        exports.getMachineId = getMachineId = require_getMachineId_bsd().getMachineId;
        break;
      case "win32":
        exports.getMachineId = getMachineId = require_getMachineId_win().getMachineId;
        break;
      default:
        exports.getMachineId = getMachineId = require_getMachineId_unsupported().getMachineId;
    }
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/HostDetectorSync.js
var require_HostDetectorSync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/HostDetectorSync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hostDetectorSync = void 0;
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var Resource_1 = require_Resource();
    var os_1 = __require("os");
    var utils_1 = require_utils2();
    var getMachineId_1 = require_getMachineId();
    var HostDetectorSync = class {
      detect(_config) {
        const attributes = {
          [semantic_conventions_1.SEMRESATTRS_HOST_NAME]: (0, os_1.hostname)(),
          [semantic_conventions_1.SEMRESATTRS_HOST_ARCH]: (0, utils_1.normalizeArch)((0, os_1.arch)())
        };
        return new Resource_1.Resource(attributes, this._getAsyncAttributes());
      }
      _getAsyncAttributes() {
        return (0, getMachineId_1.getMachineId)().then((machineId) => {
          const attributes = {};
          if (machineId) {
            attributes[semantic_conventions_1.SEMRESATTRS_HOST_ID] = machineId;
          }
          return attributes;
        });
      }
    };
    exports.hostDetectorSync = new HostDetectorSync();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/HostDetector.js
var require_HostDetector = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/HostDetector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hostDetector = void 0;
    var HostDetectorSync_1 = require_HostDetectorSync();
    var HostDetector = class {
      detect(_config) {
        return Promise.resolve(HostDetectorSync_1.hostDetectorSync.detect(_config));
      }
    };
    exports.hostDetector = new HostDetector();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/OSDetectorSync.js
var require_OSDetectorSync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/OSDetectorSync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.osDetectorSync = void 0;
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var Resource_1 = require_Resource();
    var os_1 = __require("os");
    var utils_1 = require_utils2();
    var OSDetectorSync = class {
      detect(_config) {
        const attributes = {
          [semantic_conventions_1.SEMRESATTRS_OS_TYPE]: (0, utils_1.normalizeType)((0, os_1.platform)()),
          [semantic_conventions_1.SEMRESATTRS_OS_VERSION]: (0, os_1.release)()
        };
        return new Resource_1.Resource(attributes);
      }
    };
    exports.osDetectorSync = new OSDetectorSync();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/OSDetector.js
var require_OSDetector = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/OSDetector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.osDetector = void 0;
    var OSDetectorSync_1 = require_OSDetectorSync();
    var OSDetector = class {
      detect(_config) {
        return Promise.resolve(OSDetectorSync_1.osDetectorSync.detect(_config));
      }
    };
    exports.osDetector = new OSDetector();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ProcessDetectorSync.js
var require_ProcessDetectorSync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ProcessDetectorSync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.processDetectorSync = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var Resource_1 = require_Resource();
    var os3 = __require("os");
    var ProcessDetectorSync = class {
      detect(_config) {
        const attributes = {
          [semantic_conventions_1.SEMRESATTRS_PROCESS_PID]: process.pid,
          [semantic_conventions_1.SEMRESATTRS_PROCESS_EXECUTABLE_NAME]: process.title,
          [semantic_conventions_1.SEMRESATTRS_PROCESS_EXECUTABLE_PATH]: process.execPath,
          [semantic_conventions_1.SEMRESATTRS_PROCESS_COMMAND_ARGS]: [
            process.argv[0],
            ...process.execArgv,
            ...process.argv.slice(1)
          ],
          [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_VERSION]: process.versions.node,
          [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_NAME]: "nodejs",
          [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION]: "Node.js"
        };
        if (process.argv.length > 1) {
          attributes[semantic_conventions_1.SEMRESATTRS_PROCESS_COMMAND] = process.argv[1];
        }
        try {
          const userInfo = os3.userInfo();
          attributes[semantic_conventions_1.SEMRESATTRS_PROCESS_OWNER] = userInfo.username;
        } catch (e2) {
          api_1.diag.debug(`error obtaining process owner: ${e2}`);
        }
        return new Resource_1.Resource(attributes);
      }
    };
    exports.processDetectorSync = new ProcessDetectorSync();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ProcessDetector.js
var require_ProcessDetector = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ProcessDetector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.processDetector = void 0;
    var ProcessDetectorSync_1 = require_ProcessDetectorSync();
    var ProcessDetector = class {
      detect(config) {
        return Promise.resolve(ProcessDetectorSync_1.processDetectorSync.detect(config));
      }
    };
    exports.processDetector = new ProcessDetector();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ServiceInstanceIdDetectorSync.js
var require_ServiceInstanceIdDetectorSync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ServiceInstanceIdDetectorSync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serviceInstanceIdDetectorSync = void 0;
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var Resource_1 = require_Resource();
    var crypto_1 = __require("crypto");
    var ServiceInstanceIdDetectorSync = class {
      detect(_config) {
        const attributes = {
          [semantic_conventions_1.SEMRESATTRS_SERVICE_INSTANCE_ID]: (0, crypto_1.randomUUID)()
        };
        return new Resource_1.Resource(attributes);
      }
    };
    exports.serviceInstanceIdDetectorSync = new ServiceInstanceIdDetectorSync();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/index.js
var require_node4 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serviceInstanceIdDetectorSync = exports.processDetectorSync = exports.processDetector = exports.osDetectorSync = exports.osDetector = exports.hostDetectorSync = exports.hostDetector = void 0;
    var HostDetector_1 = require_HostDetector();
    Object.defineProperty(exports, "hostDetector", { enumerable: true, get: function() {
      return HostDetector_1.hostDetector;
    } });
    var HostDetectorSync_1 = require_HostDetectorSync();
    Object.defineProperty(exports, "hostDetectorSync", { enumerable: true, get: function() {
      return HostDetectorSync_1.hostDetectorSync;
    } });
    var OSDetector_1 = require_OSDetector();
    Object.defineProperty(exports, "osDetector", { enumerable: true, get: function() {
      return OSDetector_1.osDetector;
    } });
    var OSDetectorSync_1 = require_OSDetectorSync();
    Object.defineProperty(exports, "osDetectorSync", { enumerable: true, get: function() {
      return OSDetectorSync_1.osDetectorSync;
    } });
    var ProcessDetector_1 = require_ProcessDetector();
    Object.defineProperty(exports, "processDetector", { enumerable: true, get: function() {
      return ProcessDetector_1.processDetector;
    } });
    var ProcessDetectorSync_1 = require_ProcessDetectorSync();
    Object.defineProperty(exports, "processDetectorSync", { enumerable: true, get: function() {
      return ProcessDetectorSync_1.processDetectorSync;
    } });
    var ServiceInstanceIdDetectorSync_1 = require_ServiceInstanceIdDetectorSync();
    Object.defineProperty(exports, "serviceInstanceIdDetectorSync", { enumerable: true, get: function() {
      return ServiceInstanceIdDetectorSync_1.serviceInstanceIdDetectorSync;
    } });
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/index.js
var require_platform4 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serviceInstanceIdDetectorSync = exports.processDetectorSync = exports.processDetector = exports.osDetectorSync = exports.osDetector = exports.hostDetectorSync = exports.hostDetector = void 0;
    var node_1 = require_node4();
    Object.defineProperty(exports, "hostDetector", { enumerable: true, get: function() {
      return node_1.hostDetector;
    } });
    Object.defineProperty(exports, "hostDetectorSync", { enumerable: true, get: function() {
      return node_1.hostDetectorSync;
    } });
    Object.defineProperty(exports, "osDetector", { enumerable: true, get: function() {
      return node_1.osDetector;
    } });
    Object.defineProperty(exports, "osDetectorSync", { enumerable: true, get: function() {
      return node_1.osDetectorSync;
    } });
    Object.defineProperty(exports, "processDetector", { enumerable: true, get: function() {
      return node_1.processDetector;
    } });
    Object.defineProperty(exports, "processDetectorSync", { enumerable: true, get: function() {
      return node_1.processDetectorSync;
    } });
    Object.defineProperty(exports, "serviceInstanceIdDetectorSync", { enumerable: true, get: function() {
      return node_1.serviceInstanceIdDetectorSync;
    } });
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetectorSync.js
var require_BrowserDetectorSync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetectorSync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.browserDetectorSync = void 0;
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var Resource_1 = require_Resource();
    var BrowserDetectorSync = class {
      detect(config) {
        var _a12, _b5, _c4;
        const isBrowser = typeof navigator !== "undefined" && ((_b5 = (_a12 = global.process) === null || _a12 === void 0 ? void 0 : _a12.versions) === null || _b5 === void 0 ? void 0 : _b5.node) === void 0 && // Node.js v21 adds `navigator`
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore don't have Bun types
        ((_c4 = global.Bun) === null || _c4 === void 0 ? void 0 : _c4.version) === void 0;
        if (!isBrowser) {
          return Resource_1.Resource.empty();
        }
        const browserResource = {
          [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_NAME]: "browser",
          [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION]: "Web Browser",
          [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_VERSION]: navigator.userAgent
        };
        return this._getResourceAttributes(browserResource, config);
      }
      /**
       * Validates process resource attribute map from process variables
       *
       * @param browserResource The un-sanitized resource attributes from process as key/value pairs.
       * @param config: Config
       * @returns The sanitized resource attributes.
       */
      _getResourceAttributes(browserResource, _config) {
        if (browserResource[semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_VERSION] === "") {
          api_1.diag.debug("BrowserDetector failed: Unable to find required browser resources. ");
          return Resource_1.Resource.empty();
        } else {
          return new Resource_1.Resource(Object.assign({}, browserResource));
        }
      }
    };
    exports.browserDetectorSync = new BrowserDetectorSync();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetector.js
var require_BrowserDetector = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.browserDetector = void 0;
    var BrowserDetectorSync_1 = require_BrowserDetectorSync();
    var BrowserDetector = class {
      detect(config) {
        return Promise.resolve(BrowserDetectorSync_1.browserDetectorSync.detect(config));
      }
    };
    exports.browserDetector = new BrowserDetector();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/EnvDetectorSync.js
var require_EnvDetectorSync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/EnvDetectorSync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.envDetectorSync = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src();
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var Resource_1 = require_Resource();
    var EnvDetectorSync = class {
      constructor() {
        this._MAX_LENGTH = 255;
        this._COMMA_SEPARATOR = ",";
        this._LABEL_KEY_VALUE_SPLITTER = "=";
        this._ERROR_MESSAGE_INVALID_CHARS = "should be a ASCII string with a length greater than 0 and not exceed " + this._MAX_LENGTH + " characters.";
        this._ERROR_MESSAGE_INVALID_VALUE = "should be a ASCII string with a length not exceed " + this._MAX_LENGTH + " characters.";
      }
      /**
       * Returns a {@link Resource} populated with attributes from the
       * OTEL_RESOURCE_ATTRIBUTES environment variable. Note this is an async
       * function to conform to the Detector interface.
       *
       * @param config The resource detection config
       */
      detect(_config) {
        const attributes = {};
        const env = (0, core_1.getEnv)();
        const rawAttributes = env.OTEL_RESOURCE_ATTRIBUTES;
        const serviceName = env.OTEL_SERVICE_NAME;
        if (rawAttributes) {
          try {
            const parsedAttributes = this._parseResourceAttributes(rawAttributes);
            Object.assign(attributes, parsedAttributes);
          } catch (e2) {
            api_1.diag.debug(`EnvDetector failed: ${e2.message}`);
          }
        }
        if (serviceName) {
          attributes[semantic_conventions_1.SEMRESATTRS_SERVICE_NAME] = serviceName;
        }
        return new Resource_1.Resource(attributes);
      }
      /**
       * Creates an attribute map from the OTEL_RESOURCE_ATTRIBUTES environment
       * variable.
       *
       * OTEL_RESOURCE_ATTRIBUTES: A comma-separated list of attributes describing
       * the source in more detail, e.g. key1=val1,key2=val2. Domain names and
       * paths are accepted as attribute keys. Values may be quoted or unquoted in
       * general. If a value contains whitespace, =, or " characters, it must
       * always be quoted.
       *
       * @param rawEnvAttributes The resource attributes as a comma-separated list
       * of key/value pairs.
       * @returns The sanitized resource attributes.
       */
      _parseResourceAttributes(rawEnvAttributes) {
        if (!rawEnvAttributes)
          return {};
        const attributes = {};
        const rawAttributes = rawEnvAttributes.split(this._COMMA_SEPARATOR, -1);
        for (const rawAttribute of rawAttributes) {
          const keyValuePair = rawAttribute.split(this._LABEL_KEY_VALUE_SPLITTER, -1);
          if (keyValuePair.length !== 2) {
            continue;
          }
          let [key, value] = keyValuePair;
          key = key.trim();
          value = value.trim().split(/^"|"$/).join("");
          if (!this._isValidAndNotEmpty(key)) {
            throw new Error(`Attribute key ${this._ERROR_MESSAGE_INVALID_CHARS}`);
          }
          if (!this._isValid(value)) {
            throw new Error(`Attribute value ${this._ERROR_MESSAGE_INVALID_VALUE}`);
          }
          attributes[key] = decodeURIComponent(value);
        }
        return attributes;
      }
      /**
       * Determines whether the given String is a valid printable ASCII string with
       * a length not exceed _MAX_LENGTH characters.
       *
       * @param str The String to be validated.
       * @returns Whether the String is valid.
       */
      _isValid(name) {
        return name.length <= this._MAX_LENGTH && this._isBaggageOctetString(name);
      }
      // https://www.w3.org/TR/baggage/#definition
      _isBaggageOctetString(str) {
        for (let i2 = 0; i2 < str.length; i2++) {
          const ch = str.charCodeAt(i2);
          if (ch < 33 || ch === 44 || ch === 59 || ch === 92 || ch > 126) {
            return false;
          }
        }
        return true;
      }
      /**
       * Determines whether the given String is a valid printable ASCII string with
       * a length greater than 0 and not exceed _MAX_LENGTH characters.
       *
       * @param str The String to be validated.
       * @returns Whether the String is valid and not empty.
       */
      _isValidAndNotEmpty(str) {
        return str.length > 0 && this._isValid(str);
      }
    };
    exports.envDetectorSync = new EnvDetectorSync();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/EnvDetector.js
var require_EnvDetector = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/EnvDetector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.envDetector = void 0;
    var EnvDetectorSync_1 = require_EnvDetectorSync();
    var EnvDetector = class {
      /**
       * Returns a {@link Resource} populated with attributes from the
       * OTEL_RESOURCE_ATTRIBUTES environment variable. Note this is an async
       * function to conform to the Detector interface.
       *
       * @param config The resource detection config
       */
      detect(config) {
        return Promise.resolve(EnvDetectorSync_1.envDetectorSync.detect(config));
      }
    };
    exports.envDetector = new EnvDetector();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/index.js
var require_detectors = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.envDetectorSync = exports.browserDetectorSync = exports.envDetector = exports.browserDetector = exports.serviceInstanceIdDetectorSync = exports.processDetectorSync = exports.processDetector = exports.osDetectorSync = exports.osDetector = exports.hostDetectorSync = exports.hostDetector = void 0;
    var platform_1 = require_platform4();
    Object.defineProperty(exports, "hostDetector", { enumerable: true, get: function() {
      return platform_1.hostDetector;
    } });
    Object.defineProperty(exports, "hostDetectorSync", { enumerable: true, get: function() {
      return platform_1.hostDetectorSync;
    } });
    Object.defineProperty(exports, "osDetector", { enumerable: true, get: function() {
      return platform_1.osDetector;
    } });
    Object.defineProperty(exports, "osDetectorSync", { enumerable: true, get: function() {
      return platform_1.osDetectorSync;
    } });
    Object.defineProperty(exports, "processDetector", { enumerable: true, get: function() {
      return platform_1.processDetector;
    } });
    Object.defineProperty(exports, "processDetectorSync", { enumerable: true, get: function() {
      return platform_1.processDetectorSync;
    } });
    Object.defineProperty(exports, "serviceInstanceIdDetectorSync", { enumerable: true, get: function() {
      return platform_1.serviceInstanceIdDetectorSync;
    } });
    var BrowserDetector_1 = require_BrowserDetector();
    Object.defineProperty(exports, "browserDetector", { enumerable: true, get: function() {
      return BrowserDetector_1.browserDetector;
    } });
    var EnvDetector_1 = require_EnvDetector();
    Object.defineProperty(exports, "envDetector", { enumerable: true, get: function() {
      return EnvDetector_1.envDetector;
    } });
    var BrowserDetectorSync_1 = require_BrowserDetectorSync();
    Object.defineProperty(exports, "browserDetectorSync", { enumerable: true, get: function() {
      return BrowserDetectorSync_1.browserDetectorSync;
    } });
    var EnvDetectorSync_1 = require_EnvDetectorSync();
    Object.defineProperty(exports, "envDetectorSync", { enumerable: true, get: function() {
      return EnvDetectorSync_1.envDetectorSync;
    } });
  }
});

// node_modules/@opentelemetry/resources/build/src/utils.js
var require_utils3 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isPromiseLike = void 0;
    var isPromiseLike = (val) => {
      return val !== null && typeof val === "object" && typeof val.then === "function";
    };
    exports.isPromiseLike = isPromiseLike;
  }
});

// node_modules/@opentelemetry/resources/build/src/detect-resources.js
var require_detect_resources = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detect-resources.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.detectResourcesSync = exports.detectResources = void 0;
    var Resource_1 = require_Resource();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var utils_1 = require_utils3();
    var detectResources = async (config = {}) => {
      const resources = await Promise.all((config.detectors || []).map(async (d2) => {
        try {
          const resource = await d2.detect(config);
          api_1.diag.debug(`${d2.constructor.name} found resource.`, resource);
          return resource;
        } catch (e2) {
          api_1.diag.debug(`${d2.constructor.name} failed: ${e2.message}`);
          return Resource_1.Resource.empty();
        }
      }));
      logResources(resources);
      return resources.reduce((acc, resource) => acc.merge(resource), Resource_1.Resource.empty());
    };
    exports.detectResources = detectResources;
    var detectResourcesSync = (config = {}) => {
      var _a12;
      const resources = ((_a12 = config.detectors) !== null && _a12 !== void 0 ? _a12 : []).map((d2) => {
        try {
          const resourceOrPromise = d2.detect(config);
          let resource;
          if ((0, utils_1.isPromiseLike)(resourceOrPromise)) {
            const createPromise = async () => {
              var _a13;
              const resolvedResource = await resourceOrPromise;
              await ((_a13 = resolvedResource.waitForAsyncAttributes) === null || _a13 === void 0 ? void 0 : _a13.call(resolvedResource));
              return resolvedResource.attributes;
            };
            resource = new Resource_1.Resource({}, createPromise());
          } else {
            resource = resourceOrPromise;
          }
          if (resource.waitForAsyncAttributes) {
            void resource.waitForAsyncAttributes().then(() => api_1.diag.debug(`${d2.constructor.name} found resource.`, resource));
          } else {
            api_1.diag.debug(`${d2.constructor.name} found resource.`, resource);
          }
          return resource;
        } catch (e2) {
          api_1.diag.error(`${d2.constructor.name} failed: ${e2.message}`);
          return Resource_1.Resource.empty();
        }
      });
      const mergedResources = resources.reduce((acc, resource) => acc.merge(resource), Resource_1.Resource.empty());
      if (mergedResources.waitForAsyncAttributes) {
        void mergedResources.waitForAsyncAttributes().then(() => {
          logResources(resources);
        });
      }
      return mergedResources;
    };
    exports.detectResourcesSync = detectResourcesSync;
    var logResources = (resources) => {
      resources.forEach((resource) => {
        if (Object.keys(resource.attributes).length > 0) {
          const resourceDebugString = JSON.stringify(resource.attributes, null, 4);
          api_1.diag.verbose(resourceDebugString);
        }
      });
    };
  }
});

// node_modules/@opentelemetry/resources/build/src/index.js
var require_src2 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.detectResources = exports.detectResourcesSync = exports.serviceInstanceIdDetectorSync = exports.processDetectorSync = exports.processDetector = exports.osDetectorSync = exports.osDetector = exports.hostDetectorSync = exports.hostDetector = exports.envDetectorSync = exports.envDetector = exports.browserDetectorSync = exports.browserDetector = exports.defaultServiceName = exports.Resource = void 0;
    var Resource_1 = require_Resource();
    Object.defineProperty(exports, "Resource", { enumerable: true, get: function() {
      return Resource_1.Resource;
    } });
    var platform_1 = require_platform3();
    Object.defineProperty(exports, "defaultServiceName", { enumerable: true, get: function() {
      return platform_1.defaultServiceName;
    } });
    var detectors_1 = require_detectors();
    Object.defineProperty(exports, "browserDetector", { enumerable: true, get: function() {
      return detectors_1.browserDetector;
    } });
    Object.defineProperty(exports, "browserDetectorSync", { enumerable: true, get: function() {
      return detectors_1.browserDetectorSync;
    } });
    Object.defineProperty(exports, "envDetector", { enumerable: true, get: function() {
      return detectors_1.envDetector;
    } });
    Object.defineProperty(exports, "envDetectorSync", { enumerable: true, get: function() {
      return detectors_1.envDetectorSync;
    } });
    Object.defineProperty(exports, "hostDetector", { enumerable: true, get: function() {
      return detectors_1.hostDetector;
    } });
    Object.defineProperty(exports, "hostDetectorSync", { enumerable: true, get: function() {
      return detectors_1.hostDetectorSync;
    } });
    Object.defineProperty(exports, "osDetector", { enumerable: true, get: function() {
      return detectors_1.osDetector;
    } });
    Object.defineProperty(exports, "osDetectorSync", { enumerable: true, get: function() {
      return detectors_1.osDetectorSync;
    } });
    Object.defineProperty(exports, "processDetector", { enumerable: true, get: function() {
      return detectors_1.processDetector;
    } });
    Object.defineProperty(exports, "processDetectorSync", { enumerable: true, get: function() {
      return detectors_1.processDetectorSync;
    } });
    Object.defineProperty(exports, "serviceInstanceIdDetectorSync", { enumerable: true, get: function() {
      return detectors_1.serviceInstanceIdDetectorSync;
    } });
    var detect_resources_1 = require_detect_resources();
    Object.defineProperty(exports, "detectResourcesSync", { enumerable: true, get: function() {
      return detect_resources_1.detectResourcesSync;
    } });
    Object.defineProperty(exports, "detectResources", { enumerable: true, get: function() {
      return detect_resources_1.detectResources;
    } });
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/MultiSpanProcessor.js
var require_MultiSpanProcessor = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/MultiSpanProcessor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultiSpanProcessor = void 0;
    var core_1 = require_src();
    var MultiSpanProcessor = class {
      constructor(_spanProcessors) {
        this._spanProcessors = _spanProcessors;
      }
      forceFlush() {
        const promises = [];
        for (const spanProcessor of this._spanProcessors) {
          promises.push(spanProcessor.forceFlush());
        }
        return new Promise((resolve) => {
          Promise.all(promises).then(() => {
            resolve();
          }).catch((error) => {
            (0, core_1.globalErrorHandler)(error || new Error("MultiSpanProcessor: forceFlush failed"));
            resolve();
          });
        });
      }
      onStart(span, context3) {
        for (const spanProcessor of this._spanProcessors) {
          spanProcessor.onStart(span, context3);
        }
      }
      onEnd(span) {
        for (const spanProcessor of this._spanProcessors) {
          spanProcessor.onEnd(span);
        }
      }
      shutdown() {
        const promises = [];
        for (const spanProcessor of this._spanProcessors) {
          promises.push(spanProcessor.shutdown());
        }
        return new Promise((resolve, reject3) => {
          Promise.all(promises).then(() => {
            resolve();
          }, reject3);
        });
      }
    };
    exports.MultiSpanProcessor = MultiSpanProcessor;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/export/NoopSpanProcessor.js
var require_NoopSpanProcessor = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/export/NoopSpanProcessor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoopSpanProcessor = void 0;
    var NoopSpanProcessor = class {
      onStart(_span, _context) {
      }
      onEnd(_span) {
      }
      shutdown() {
        return Promise.resolve();
      }
      forceFlush() {
        return Promise.resolve();
      }
    };
    exports.NoopSpanProcessor = NoopSpanProcessor;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/BasicTracerProvider.js
var require_BasicTracerProvider = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/BasicTracerProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BasicTracerProvider = exports.ForceFlushState = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src();
    var resources_1 = require_src2();
    var Tracer_1 = require_Tracer();
    var config_1 = require_config();
    var MultiSpanProcessor_1 = require_MultiSpanProcessor();
    var NoopSpanProcessor_1 = require_NoopSpanProcessor();
    var platform_1 = require_platform2();
    var utility_1 = require_utility();
    var ForceFlushState;
    (function(ForceFlushState2) {
      ForceFlushState2[ForceFlushState2["resolved"] = 0] = "resolved";
      ForceFlushState2[ForceFlushState2["timeout"] = 1] = "timeout";
      ForceFlushState2[ForceFlushState2["error"] = 2] = "error";
      ForceFlushState2[ForceFlushState2["unresolved"] = 3] = "unresolved";
    })(ForceFlushState = exports.ForceFlushState || (exports.ForceFlushState = {}));
    var BasicTracerProvider = class {
      constructor(config = {}) {
        var _a12, _b5;
        this._registeredSpanProcessors = [];
        this._tracers = /* @__PURE__ */ new Map();
        const mergedConfig = (0, core_1.merge)({}, (0, config_1.loadDefaultConfig)(), (0, utility_1.reconfigureLimits)(config));
        this.resource = (_a12 = mergedConfig.resource) !== null && _a12 !== void 0 ? _a12 : resources_1.Resource.empty();
        if (mergedConfig.mergeResourceWithDefaults) {
          this.resource = resources_1.Resource.default().merge(this.resource);
        }
        this._config = Object.assign({}, mergedConfig, {
          resource: this.resource
        });
        if ((_b5 = config.spanProcessors) === null || _b5 === void 0 ? void 0 : _b5.length) {
          this._registeredSpanProcessors = [...config.spanProcessors];
          this.activeSpanProcessor = new MultiSpanProcessor_1.MultiSpanProcessor(this._registeredSpanProcessors);
        } else {
          const defaultExporter = this._buildExporterFromEnv();
          if (defaultExporter !== void 0) {
            const batchProcessor = new platform_1.BatchSpanProcessor(defaultExporter);
            this.activeSpanProcessor = batchProcessor;
          } else {
            this.activeSpanProcessor = new NoopSpanProcessor_1.NoopSpanProcessor();
          }
        }
      }
      getTracer(name, version, options) {
        const key = `${name}@${version || ""}:${(options === null || options === void 0 ? void 0 : options.schemaUrl) || ""}`;
        if (!this._tracers.has(key)) {
          this._tracers.set(key, new Tracer_1.Tracer({ name, version, schemaUrl: options === null || options === void 0 ? void 0 : options.schemaUrl }, this._config, this));
        }
        return this._tracers.get(key);
      }
      /**
       * @deprecated please use {@link TracerConfig} spanProcessors property
       * Adds a new {@link SpanProcessor} to this tracer.
       * @param spanProcessor the new SpanProcessor to be added.
       */
      addSpanProcessor(spanProcessor) {
        if (this._registeredSpanProcessors.length === 0) {
          this.activeSpanProcessor.shutdown().catch((err) => api_1.diag.error("Error while trying to shutdown current span processor", err));
        }
        this._registeredSpanProcessors.push(spanProcessor);
        this.activeSpanProcessor = new MultiSpanProcessor_1.MultiSpanProcessor(this._registeredSpanProcessors);
      }
      getActiveSpanProcessor() {
        return this.activeSpanProcessor;
      }
      /**
       * Register this TracerProvider for use with the OpenTelemetry API.
       * Undefined values may be replaced with defaults, and
       * null values will be skipped.
       *
       * @param config Configuration object for SDK registration
       */
      register(config = {}) {
        api_1.trace.setGlobalTracerProvider(this);
        if (config.propagator === void 0) {
          config.propagator = this._buildPropagatorFromEnv();
        }
        if (config.contextManager) {
          api_1.context.setGlobalContextManager(config.contextManager);
        }
        if (config.propagator) {
          api_1.propagation.setGlobalPropagator(config.propagator);
        }
      }
      forceFlush() {
        const timeout4 = this._config.forceFlushTimeoutMillis;
        const promises = this._registeredSpanProcessors.map((spanProcessor) => {
          return new Promise((resolve) => {
            let state;
            const timeoutInterval = setTimeout(() => {
              resolve(new Error(`Span processor did not completed within timeout period of ${timeout4} ms`));
              state = ForceFlushState.timeout;
            }, timeout4);
            spanProcessor.forceFlush().then(() => {
              clearTimeout(timeoutInterval);
              if (state !== ForceFlushState.timeout) {
                state = ForceFlushState.resolved;
                resolve(state);
              }
            }).catch((error) => {
              clearTimeout(timeoutInterval);
              state = ForceFlushState.error;
              resolve(error);
            });
          });
        });
        return new Promise((resolve, reject3) => {
          Promise.all(promises).then((results) => {
            const errors = results.filter((result4) => result4 !== ForceFlushState.resolved);
            if (errors.length > 0) {
              reject3(errors);
            } else {
              resolve();
            }
          }).catch((error) => reject3([error]));
        });
      }
      shutdown() {
        return this.activeSpanProcessor.shutdown();
      }
      /**
       * TS cannot yet infer the type of this.constructor:
       * https://github.com/Microsoft/TypeScript/issues/3841#issuecomment-337560146
       * There is no need to override either of the getters in your child class.
       * The type of the registered component maps should be the same across all
       * classes in the inheritance tree.
       */
      _getPropagator(name) {
        var _a12;
        return (_a12 = this.constructor._registeredPropagators.get(name)) === null || _a12 === void 0 ? void 0 : _a12();
      }
      _getSpanExporter(name) {
        var _a12;
        return (_a12 = this.constructor._registeredExporters.get(name)) === null || _a12 === void 0 ? void 0 : _a12();
      }
      _buildPropagatorFromEnv() {
        const uniquePropagatorNames = Array.from(new Set((0, core_1.getEnv)().OTEL_PROPAGATORS));
        const propagators = uniquePropagatorNames.map((name) => {
          const propagator = this._getPropagator(name);
          if (!propagator) {
            api_1.diag.warn(`Propagator "${name}" requested through environment variable is unavailable.`);
          }
          return propagator;
        });
        const validPropagators = propagators.reduce((list2, item) => {
          if (item) {
            list2.push(item);
          }
          return list2;
        }, []);
        if (validPropagators.length === 0) {
          return;
        } else if (uniquePropagatorNames.length === 1) {
          return validPropagators[0];
        } else {
          return new core_1.CompositePropagator({
            propagators: validPropagators
          });
        }
      }
      _buildExporterFromEnv() {
        const exporterName = (0, core_1.getEnv)().OTEL_TRACES_EXPORTER;
        if (exporterName === "none" || exporterName === "")
          return;
        const exporter = this._getSpanExporter(exporterName);
        if (!exporter) {
          api_1.diag.error(`Exporter "${exporterName}" requested through environment variable is unavailable.`);
        }
        return exporter;
      }
    };
    exports.BasicTracerProvider = BasicTracerProvider;
    BasicTracerProvider._registeredPropagators = /* @__PURE__ */ new Map([
      ["tracecontext", () => new core_1.W3CTraceContextPropagator()],
      ["baggage", () => new core_1.W3CBaggagePropagator()]
    ]);
    BasicTracerProvider._registeredExporters = /* @__PURE__ */ new Map();
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/export/ConsoleSpanExporter.js
var require_ConsoleSpanExporter = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/export/ConsoleSpanExporter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConsoleSpanExporter = void 0;
    var core_1 = require_src();
    var ConsoleSpanExporter2 = class {
      /**
       * Export spans.
       * @param spans
       * @param resultCallback
       */
      export(spans, resultCallback) {
        return this._sendSpans(spans, resultCallback);
      }
      /**
       * Shutdown the exporter.
       */
      shutdown() {
        this._sendSpans([]);
        return this.forceFlush();
      }
      /**
       * Exports any pending spans in exporter
       */
      forceFlush() {
        return Promise.resolve();
      }
      /**
       * converts span info into more readable format
       * @param span
       */
      _exportInfo(span) {
        var _a12;
        return {
          resource: {
            attributes: span.resource.attributes
          },
          instrumentationScope: span.instrumentationLibrary,
          traceId: span.spanContext().traceId,
          parentId: span.parentSpanId,
          traceState: (_a12 = span.spanContext().traceState) === null || _a12 === void 0 ? void 0 : _a12.serialize(),
          name: span.name,
          id: span.spanContext().spanId,
          kind: span.kind,
          timestamp: (0, core_1.hrTimeToMicroseconds)(span.startTime),
          duration: (0, core_1.hrTimeToMicroseconds)(span.duration),
          attributes: span.attributes,
          status: span.status,
          events: span.events,
          links: span.links
        };
      }
      /**
       * Showing spans in console
       * @param spans
       * @param done
       */
      _sendSpans(spans, done7) {
        for (const span of spans) {
          console.dir(this._exportInfo(span), { depth: 3 });
        }
        if (done7) {
          return done7({ code: core_1.ExportResultCode.SUCCESS });
        }
      }
    };
    exports.ConsoleSpanExporter = ConsoleSpanExporter2;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/export/InMemorySpanExporter.js
var require_InMemorySpanExporter = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/export/InMemorySpanExporter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InMemorySpanExporter = void 0;
    var core_1 = require_src();
    var InMemorySpanExporter = class {
      constructor() {
        this._finishedSpans = [];
        this._stopped = false;
      }
      export(spans, resultCallback) {
        if (this._stopped)
          return resultCallback({
            code: core_1.ExportResultCode.FAILED,
            error: new Error("Exporter has been stopped")
          });
        this._finishedSpans.push(...spans);
        setTimeout(() => resultCallback({ code: core_1.ExportResultCode.SUCCESS }), 0);
      }
      shutdown() {
        this._stopped = true;
        this._finishedSpans = [];
        return this.forceFlush();
      }
      /**
       * Exports any pending spans in the exporter
       */
      forceFlush() {
        return Promise.resolve();
      }
      reset() {
        this._finishedSpans = [];
      }
      getFinishedSpans() {
        return this._finishedSpans;
      }
    };
    exports.InMemorySpanExporter = InMemorySpanExporter;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/export/SimpleSpanProcessor.js
var require_SimpleSpanProcessor = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/export/SimpleSpanProcessor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SimpleSpanProcessor = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src();
    var SimpleSpanProcessor2 = class {
      constructor(_exporter) {
        this._exporter = _exporter;
        this._shutdownOnce = new core_1.BindOnceFuture(this._shutdown, this);
        this._unresolvedExports = /* @__PURE__ */ new Set();
      }
      async forceFlush() {
        await Promise.all(Array.from(this._unresolvedExports));
        if (this._exporter.forceFlush) {
          await this._exporter.forceFlush();
        }
      }
      onStart(_span, _parentContext) {
      }
      onEnd(span) {
        var _a12, _b5;
        if (this._shutdownOnce.isCalled) {
          return;
        }
        if ((span.spanContext().traceFlags & api_1.TraceFlags.SAMPLED) === 0) {
          return;
        }
        const doExport = () => core_1.internal._export(this._exporter, [span]).then((result4) => {
          var _a13;
          if (result4.code !== core_1.ExportResultCode.SUCCESS) {
            (0, core_1.globalErrorHandler)((_a13 = result4.error) !== null && _a13 !== void 0 ? _a13 : new Error(`SimpleSpanProcessor: span export failed (status ${result4})`));
          }
        }).catch((error) => {
          (0, core_1.globalErrorHandler)(error);
        });
        if (span.resource.asyncAttributesPending) {
          const exportPromise = (_b5 = (_a12 = span.resource).waitForAsyncAttributes) === null || _b5 === void 0 ? void 0 : _b5.call(_a12).then(() => {
            if (exportPromise != null) {
              this._unresolvedExports.delete(exportPromise);
            }
            return doExport();
          }, (err) => (0, core_1.globalErrorHandler)(err));
          if (exportPromise != null) {
            this._unresolvedExports.add(exportPromise);
          }
        } else {
          void doExport();
        }
      }
      shutdown() {
        return this._shutdownOnce.call();
      }
      _shutdown() {
        return this._exporter.shutdown();
      }
    };
    exports.SimpleSpanProcessor = SimpleSpanProcessor2;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/index.js
var require_src3 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Span = exports.SamplingDecision = exports.TraceIdRatioBasedSampler = exports.ParentBasedSampler = exports.AlwaysOnSampler = exports.AlwaysOffSampler = exports.NoopSpanProcessor = exports.SimpleSpanProcessor = exports.InMemorySpanExporter = exports.ConsoleSpanExporter = exports.RandomIdGenerator = exports.BatchSpanProcessor = exports.ForceFlushState = exports.BasicTracerProvider = exports.Tracer = void 0;
    var Tracer_1 = require_Tracer();
    Object.defineProperty(exports, "Tracer", { enumerable: true, get: function() {
      return Tracer_1.Tracer;
    } });
    var BasicTracerProvider_1 = require_BasicTracerProvider();
    Object.defineProperty(exports, "BasicTracerProvider", { enumerable: true, get: function() {
      return BasicTracerProvider_1.BasicTracerProvider;
    } });
    Object.defineProperty(exports, "ForceFlushState", { enumerable: true, get: function() {
      return BasicTracerProvider_1.ForceFlushState;
    } });
    var platform_1 = require_platform2();
    Object.defineProperty(exports, "BatchSpanProcessor", { enumerable: true, get: function() {
      return platform_1.BatchSpanProcessor;
    } });
    Object.defineProperty(exports, "RandomIdGenerator", { enumerable: true, get: function() {
      return platform_1.RandomIdGenerator;
    } });
    var ConsoleSpanExporter_1 = require_ConsoleSpanExporter();
    Object.defineProperty(exports, "ConsoleSpanExporter", { enumerable: true, get: function() {
      return ConsoleSpanExporter_1.ConsoleSpanExporter;
    } });
    var InMemorySpanExporter_1 = require_InMemorySpanExporter();
    Object.defineProperty(exports, "InMemorySpanExporter", { enumerable: true, get: function() {
      return InMemorySpanExporter_1.InMemorySpanExporter;
    } });
    var SimpleSpanProcessor_1 = require_SimpleSpanProcessor();
    Object.defineProperty(exports, "SimpleSpanProcessor", { enumerable: true, get: function() {
      return SimpleSpanProcessor_1.SimpleSpanProcessor;
    } });
    var NoopSpanProcessor_1 = require_NoopSpanProcessor();
    Object.defineProperty(exports, "NoopSpanProcessor", { enumerable: true, get: function() {
      return NoopSpanProcessor_1.NoopSpanProcessor;
    } });
    var AlwaysOffSampler_1 = require_AlwaysOffSampler2();
    Object.defineProperty(exports, "AlwaysOffSampler", { enumerable: true, get: function() {
      return AlwaysOffSampler_1.AlwaysOffSampler;
    } });
    var AlwaysOnSampler_1 = require_AlwaysOnSampler2();
    Object.defineProperty(exports, "AlwaysOnSampler", { enumerable: true, get: function() {
      return AlwaysOnSampler_1.AlwaysOnSampler;
    } });
    var ParentBasedSampler_1 = require_ParentBasedSampler2();
    Object.defineProperty(exports, "ParentBasedSampler", { enumerable: true, get: function() {
      return ParentBasedSampler_1.ParentBasedSampler;
    } });
    var TraceIdRatioBasedSampler_1 = require_TraceIdRatioBasedSampler2();
    Object.defineProperty(exports, "TraceIdRatioBasedSampler", { enumerable: true, get: function() {
      return TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler;
    } });
    var Sampler_1 = require_Sampler();
    Object.defineProperty(exports, "SamplingDecision", { enumerable: true, get: function() {
      return Sampler_1.SamplingDecision;
    } });
    var Span_1 = require_Span();
    Object.defineProperty(exports, "Span", { enumerable: true, get: function() {
      return Span_1.Span;
    } });
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js
var require_suppress_tracing2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTracingSuppressed = exports.unsuppressTracing = exports.suppressTracing = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var SUPPRESS_TRACING_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
    function suppressTracing(context3) {
      return context3.setValue(SUPPRESS_TRACING_KEY, true);
    }
    exports.suppressTracing = suppressTracing;
    function unsuppressTracing(context3) {
      return context3.deleteValue(SUPPRESS_TRACING_KEY);
    }
    exports.unsuppressTracing = unsuppressTracing;
    function isTracingSuppressed(context3) {
      return context3.getValue(SUPPRESS_TRACING_KEY) === true;
    }
    exports.isTracingSuppressed = isTracingSuppressed;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/baggage/constants.js
var require_constants2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/baggage/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BAGGAGE_MAX_TOTAL_LENGTH = exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = exports.BAGGAGE_HEADER = exports.BAGGAGE_ITEMS_SEPARATOR = exports.BAGGAGE_PROPERTIES_SEPARATOR = exports.BAGGAGE_KEY_PAIR_SEPARATOR = void 0;
    exports.BAGGAGE_KEY_PAIR_SEPARATOR = "=";
    exports.BAGGAGE_PROPERTIES_SEPARATOR = ";";
    exports.BAGGAGE_ITEMS_SEPARATOR = ",";
    exports.BAGGAGE_HEADER = "baggage";
    exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
    exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
    exports.BAGGAGE_MAX_TOTAL_LENGTH = 8192;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/baggage/utils.js
var require_utils4 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/baggage/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseKeyPairsIntoRecord = exports.parsePairKeyValue = exports.getKeyPairs = exports.serializeKeyPairs = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var constants_1 = require_constants2();
    function serializeKeyPairs(keyPairs) {
      return keyPairs.reduce((hValue, current) => {
        const value = `${hValue}${hValue !== "" ? constants_1.BAGGAGE_ITEMS_SEPARATOR : ""}${current}`;
        return value.length > constants_1.BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
      }, "");
    }
    exports.serializeKeyPairs = serializeKeyPairs;
    function getKeyPairs(baggage) {
      return baggage.getAllEntries().map(([key, value]) => {
        let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;
        if (value.metadata !== void 0) {
          entry += constants_1.BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
        }
        return entry;
      });
    }
    exports.getKeyPairs = getKeyPairs;
    function parsePairKeyValue(entry) {
      const valueProps = entry.split(constants_1.BAGGAGE_PROPERTIES_SEPARATOR);
      if (valueProps.length <= 0)
        return;
      const keyPairPart = valueProps.shift();
      if (!keyPairPart)
        return;
      const separatorIndex = keyPairPart.indexOf(constants_1.BAGGAGE_KEY_PAIR_SEPARATOR);
      if (separatorIndex <= 0)
        return;
      const key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
      const value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
      let metadata;
      if (valueProps.length > 0) {
        metadata = (0, api_1.baggageEntryMetadataFromString)(valueProps.join(constants_1.BAGGAGE_PROPERTIES_SEPARATOR));
      }
      return { key, value, metadata };
    }
    exports.parsePairKeyValue = parsePairKeyValue;
    function parseKeyPairsIntoRecord(value) {
      if (typeof value !== "string" || value.length === 0)
        return {};
      return value.split(constants_1.BAGGAGE_ITEMS_SEPARATOR).map((entry) => {
        return parsePairKeyValue(entry);
      }).filter((keyPair) => keyPair !== void 0 && keyPair.value.length > 0).reduce((headers, keyPair) => {
        headers[keyPair.key] = keyPair.value;
        return headers;
      }, {});
    }
    exports.parseKeyPairsIntoRecord = parseKeyPairsIntoRecord;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js
var require_W3CBaggagePropagator2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.W3CBaggagePropagator = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing2();
    var constants_1 = require_constants2();
    var utils_1 = require_utils4();
    var W3CBaggagePropagator = class {
      inject(context3, carrier, setter) {
        const baggage = api_1.propagation.getBaggage(context3);
        if (!baggage || (0, suppress_tracing_1.isTracingSuppressed)(context3))
          return;
        const keyPairs = (0, utils_1.getKeyPairs)(baggage).filter((pair) => {
          return pair.length <= constants_1.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
        }).slice(0, constants_1.BAGGAGE_MAX_NAME_VALUE_PAIRS);
        const headerValue = (0, utils_1.serializeKeyPairs)(keyPairs);
        if (headerValue.length > 0) {
          setter.set(carrier, constants_1.BAGGAGE_HEADER, headerValue);
        }
      }
      extract(context3, carrier, getter) {
        const headerValue = getter.get(carrier, constants_1.BAGGAGE_HEADER);
        const baggageString = Array.isArray(headerValue) ? headerValue.join(constants_1.BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString)
          return context3;
        const baggage = {};
        if (baggageString.length === 0) {
          return context3;
        }
        const pairs = baggageString.split(constants_1.BAGGAGE_ITEMS_SEPARATOR);
        pairs.forEach((entry) => {
          const keyPair = (0, utils_1.parsePairKeyValue)(entry);
          if (keyPair) {
            const baggageEntry = { value: keyPair.value };
            if (keyPair.metadata) {
              baggageEntry.metadata = keyPair.metadata;
            }
            baggage[keyPair.key] = baggageEntry;
          }
        });
        if (Object.entries(baggage).length === 0) {
          return context3;
        }
        return api_1.propagation.setBaggage(context3, api_1.propagation.createBaggage(baggage));
      }
      fields() {
        return [constants_1.BAGGAGE_HEADER];
      }
    };
    exports.W3CBaggagePropagator = W3CBaggagePropagator;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/common/anchored-clock.js
var require_anchored_clock2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/common/anchored-clock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnchoredClock = void 0;
    var AnchoredClock = class {
      /**
       * Create a new AnchoredClock anchored to the current time returned by systemClock.
       *
       * @param systemClock should be a clock that returns the number of milliseconds since January 1 1970 such as Date
       * @param monotonicClock should be a clock that counts milliseconds monotonically such as window.performance or perf_hooks.performance
       */
      constructor(systemClock, monotonicClock) {
        this._monotonicClock = monotonicClock;
        this._epochMillis = systemClock.now();
        this._performanceMillis = monotonicClock.now();
      }
      /**
       * Returns the current time by adding the number of milliseconds since the
       * AnchoredClock was created to the creation epoch time
       */
      now() {
        const delta = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + delta;
      }
    };
    exports.AnchoredClock = AnchoredClock;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/common/attributes.js
var require_attributes2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/common/attributes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAttributeValue = exports.isAttributeKey = exports.sanitizeAttributes = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    function sanitizeAttributes(attributes) {
      const out = {};
      if (typeof attributes !== "object" || attributes == null) {
        return out;
      }
      for (const [key, val] of Object.entries(attributes)) {
        if (!isAttributeKey(key)) {
          api_1.diag.warn(`Invalid attribute key: ${key}`);
          continue;
        }
        if (!isAttributeValue(val)) {
          api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
          continue;
        }
        if (Array.isArray(val)) {
          out[key] = val.slice();
        } else {
          out[key] = val;
        }
      }
      return out;
    }
    exports.sanitizeAttributes = sanitizeAttributes;
    function isAttributeKey(key) {
      return typeof key === "string" && key.length > 0;
    }
    exports.isAttributeKey = isAttributeKey;
    function isAttributeValue(val) {
      if (val == null) {
        return true;
      }
      if (Array.isArray(val)) {
        return isHomogeneousAttributeValueArray(val);
      }
      return isValidPrimitiveAttributeValue(val);
    }
    exports.isAttributeValue = isAttributeValue;
    function isHomogeneousAttributeValueArray(arr) {
      let type;
      for (const element of arr) {
        if (element == null)
          continue;
        if (!type) {
          if (isValidPrimitiveAttributeValue(element)) {
            type = typeof element;
            continue;
          }
          return false;
        }
        if (typeof element === type) {
          continue;
        }
        return false;
      }
      return true;
    }
    function isValidPrimitiveAttributeValue(val) {
      switch (typeof val) {
        case "number":
        case "boolean":
        case "string":
          return true;
      }
      return false;
    }
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js
var require_logging_error_handler2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loggingErrorHandler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    function loggingErrorHandler() {
      return (ex) => {
        api_1.diag.error(stringifyException(ex));
      };
    }
    exports.loggingErrorHandler = loggingErrorHandler;
    function stringifyException(ex) {
      if (typeof ex === "string") {
        return ex;
      } else {
        return JSON.stringify(flattenException(ex));
      }
    }
    function flattenException(ex) {
      const result4 = {};
      let current = ex;
      while (current !== null) {
        Object.getOwnPropertyNames(current).forEach((propertyName) => {
          if (result4[propertyName])
            return;
          const value = current[propertyName];
          if (value) {
            result4[propertyName] = String(value);
          }
        });
        current = Object.getPrototypeOf(current);
      }
      return result4;
    }
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/common/global-error-handler.js
var require_global_error_handler2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/common/global-error-handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.globalErrorHandler = exports.setGlobalErrorHandler = void 0;
    var logging_error_handler_1 = require_logging_error_handler2();
    var delegateHandler = (0, logging_error_handler_1.loggingErrorHandler)();
    function setGlobalErrorHandler(handler) {
      delegateHandler = handler;
    }
    exports.setGlobalErrorHandler = setGlobalErrorHandler;
    function globalErrorHandler(ex) {
      try {
        delegateHandler(ex);
      } catch (_a12) {
      }
    }
    exports.globalErrorHandler = globalErrorHandler;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/utils/sampling.js
var require_sampling2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/utils/sampling.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TracesSamplerValues = void 0;
    var TracesSamplerValues;
    (function(TracesSamplerValues2) {
      TracesSamplerValues2["AlwaysOff"] = "always_off";
      TracesSamplerValues2["AlwaysOn"] = "always_on";
      TracesSamplerValues2["ParentBasedAlwaysOff"] = "parentbased_always_off";
      TracesSamplerValues2["ParentBasedAlwaysOn"] = "parentbased_always_on";
      TracesSamplerValues2["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
      TracesSamplerValues2["TraceIdRatio"] = "traceidratio";
    })(TracesSamplerValues = exports.TracesSamplerValues || (exports.TracesSamplerValues = {}));
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/utils/environment.js
var require_environment3 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/utils/environment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseEnvironment = exports.DEFAULT_ENVIRONMENT = exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var sampling_1 = require_sampling2();
    var DEFAULT_LIST_SEPARATOR = ",";
    var ENVIRONMENT_BOOLEAN_KEYS = ["OTEL_SDK_DISABLED"];
    function isEnvVarABoolean(key) {
      return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_NUMBERS_KEYS = [
      "OTEL_BSP_EXPORT_TIMEOUT",
      "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BSP_MAX_QUEUE_SIZE",
      "OTEL_BSP_SCHEDULE_DELAY",
      "OTEL_BLRP_EXPORT_TIMEOUT",
      "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BLRP_MAX_QUEUE_SIZE",
      "OTEL_BLRP_SCHEDULE_DELAY",
      "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_LINK_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT",
      "OTEL_EXPORTER_OTLP_TIMEOUT",
      "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
      "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
      "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT",
      "OTEL_EXPORTER_JAEGER_AGENT_PORT"
    ];
    function isEnvVarANumber(key) {
      return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_LISTS_KEYS = [
      "OTEL_NO_PATCH_MODULES",
      "OTEL_PROPAGATORS"
    ];
    function isEnvVarAList(key) {
      return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
    }
    exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
    exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
    exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
    exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
    exports.DEFAULT_ENVIRONMENT = {
      OTEL_SDK_DISABLED: false,
      CONTAINER_NAME: "",
      ECS_CONTAINER_METADATA_URI_V4: "",
      ECS_CONTAINER_METADATA_URI: "",
      HOSTNAME: "",
      KUBERNETES_SERVICE_HOST: "",
      NAMESPACE: "",
      OTEL_BSP_EXPORT_TIMEOUT: 3e4,
      OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BSP_MAX_QUEUE_SIZE: 2048,
      OTEL_BSP_SCHEDULE_DELAY: 5e3,
      OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
      OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
      OTEL_BLRP_SCHEDULE_DELAY: 5e3,
      OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
      OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
      OTEL_EXPORTER_JAEGER_ENDPOINT: "",
      OTEL_EXPORTER_JAEGER_PASSWORD: "",
      OTEL_EXPORTER_JAEGER_USER: "",
      OTEL_EXPORTER_OTLP_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_HEADERS: "",
      OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
      OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
      OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
      OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
      OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
      OTEL_LOG_LEVEL: api_1.DiagLogLevel.INFO,
      OTEL_NO_PATCH_MODULES: [],
      OTEL_PROPAGATORS: ["tracecontext", "baggage"],
      OTEL_RESOURCE_ATTRIBUTES: "",
      OTEL_SERVICE_NAME: "",
      OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
      OTEL_SPAN_LINK_COUNT_LIMIT: 128,
      OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
      OTEL_TRACES_EXPORTER: "",
      OTEL_TRACES_SAMPLER: sampling_1.TracesSamplerValues.ParentBasedAlwaysOn,
      OTEL_TRACES_SAMPLER_ARG: "",
      OTEL_LOGS_EXPORTER: "",
      OTEL_EXPORTER_OTLP_INSECURE: "",
      OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
      OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
      OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
      OTEL_EXPORTER_OTLP_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative"
    };
    function parseBoolean(key, environment5, values3) {
      if (typeof values3[key] === "undefined") {
        return;
      }
      const value = String(values3[key]);
      environment5[key] = value.toLowerCase() === "true";
    }
    function parseNumber(name, environment5, values3, min2 = -Infinity, max2 = Infinity) {
      if (typeof values3[name] !== "undefined") {
        const value = Number(values3[name]);
        if (!isNaN(value)) {
          if (value < min2) {
            environment5[name] = min2;
          } else if (value > max2) {
            environment5[name] = max2;
          } else {
            environment5[name] = value;
          }
        }
      }
    }
    function parseStringList(name, output, input, separator = DEFAULT_LIST_SEPARATOR) {
      const givenValue = input[name];
      if (typeof givenValue === "string") {
        output[name] = givenValue.split(separator).map((v2) => v2.trim());
      }
    }
    var logLevelMap = {
      ALL: api_1.DiagLogLevel.ALL,
      VERBOSE: api_1.DiagLogLevel.VERBOSE,
      DEBUG: api_1.DiagLogLevel.DEBUG,
      INFO: api_1.DiagLogLevel.INFO,
      WARN: api_1.DiagLogLevel.WARN,
      ERROR: api_1.DiagLogLevel.ERROR,
      NONE: api_1.DiagLogLevel.NONE
    };
    function setLogLevelFromEnv(key, environment5, values3) {
      const value = values3[key];
      if (typeof value === "string") {
        const theLevel = logLevelMap[value.toUpperCase()];
        if (theLevel != null) {
          environment5[key] = theLevel;
        }
      }
    }
    function parseEnvironment(values3) {
      const environment5 = {};
      for (const env in exports.DEFAULT_ENVIRONMENT) {
        const key = env;
        switch (key) {
          case "OTEL_LOG_LEVEL":
            setLogLevelFromEnv(key, environment5, values3);
            break;
          default:
            if (isEnvVarABoolean(key)) {
              parseBoolean(key, environment5, values3);
            } else if (isEnvVarANumber(key)) {
              parseNumber(key, environment5, values3);
            } else if (isEnvVarAList(key)) {
              parseStringList(key, environment5, values3);
            } else {
              const value = values3[key];
              if (typeof value !== "undefined" && value !== null) {
                environment5[key] = String(value);
              }
            }
        }
      }
      return environment5;
    }
    exports.parseEnvironment = parseEnvironment;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/platform/node/environment.js
var require_environment4 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/platform/node/environment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnvWithoutDefaults = exports.getEnv = void 0;
    var environment_1 = require_environment3();
    function getEnv() {
      const processEnv = (0, environment_1.parseEnvironment)(process.env);
      return Object.assign({}, environment_1.DEFAULT_ENVIRONMENT, processEnv);
    }
    exports.getEnv = getEnv;
    function getEnvWithoutDefaults() {
      return (0, environment_1.parseEnvironment)(process.env);
    }
    exports.getEnvWithoutDefaults = getEnvWithoutDefaults;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js
var require_globalThis2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._globalThis = void 0;
    exports._globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/common/hex-to-binary.js
var require_hex_to_binary2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/common/hex-to-binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hexToBinary = void 0;
    function intValue(charCode) {
      if (charCode >= 48 && charCode <= 57) {
        return charCode - 48;
      }
      if (charCode >= 97 && charCode <= 102) {
        return charCode - 87;
      }
      return charCode - 55;
    }
    function hexToBinary(hexStr) {
      const buf = new Uint8Array(hexStr.length / 2);
      let offset = 0;
      for (let i2 = 0; i2 < hexStr.length; i2 += 2) {
        const hi = intValue(hexStr.charCodeAt(i2));
        const lo = intValue(hexStr.charCodeAt(i2 + 1));
        buf[offset++] = hi << 4 | lo;
      }
      return buf;
    }
    exports.hexToBinary = hexToBinary;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js
var require_hex_to_base642 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hexToBase64 = void 0;
    var hex_to_binary_1 = require_hex_to_binary2();
    function hexToBase64(hexStr) {
      return Buffer.from((0, hex_to_binary_1.hexToBinary)(hexStr)).toString("base64");
    }
    exports.hexToBase64 = hexToBase64;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js
var require_RandomIdGenerator3 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RandomIdGenerator = void 0;
    var SPAN_ID_BYTES = 8;
    var TRACE_ID_BYTES = 16;
    var RandomIdGenerator = class {
      constructor() {
        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
        this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
      }
    };
    exports.RandomIdGenerator = RandomIdGenerator;
    var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
    function getIdGenerator(bytes) {
      return function generateId() {
        for (let i2 = 0; i2 < bytes / 4; i2++) {
          SHARED_BUFFER.writeUInt32BE(Math.random() * 2 ** 32 >>> 0, i2 * 4);
        }
        for (let i2 = 0; i2 < bytes; i2++) {
          if (SHARED_BUFFER[i2] > 0) {
            break;
          } else if (i2 === bytes - 1) {
            SHARED_BUFFER[bytes - 1] = 1;
          }
        }
        return SHARED_BUFFER.toString("hex", 0, bytes);
      };
    }
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/platform/node/performance.js
var require_performance2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/platform/node/performance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.otperformance = void 0;
    var perf_hooks_1 = __require("perf_hooks");
    exports.otperformance = perf_hooks_1.performance;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/version.js
var require_version2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VERSION = void 0;
    exports.VERSION = "1.24.1";
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/semantic-conventions/build/src/internal/utils.js
var require_utils5 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/semantic-conventions/build/src/internal/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConstMap = void 0;
    // @__NO_SIDE_EFFECTS__
    function createConstMap2(values3) {
      let res = {};
      const len = values3.length;
      for (let lp = 0; lp < len; lp++) {
        const val = values3[lp];
        if (val) {
          res[String(val).toUpperCase().replace(/[-.]/g, "_")] = val;
        }
      }
      return res;
    }
    exports.createConstMap = createConstMap2;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js
var require_SemanticAttributes = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SEMATTRS_NET_HOST_CARRIER_ICC = exports.SEMATTRS_NET_HOST_CARRIER_MNC = exports.SEMATTRS_NET_HOST_CARRIER_MCC = exports.SEMATTRS_NET_HOST_CARRIER_NAME = exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = exports.SEMATTRS_NET_HOST_NAME = exports.SEMATTRS_NET_HOST_PORT = exports.SEMATTRS_NET_HOST_IP = exports.SEMATTRS_NET_PEER_NAME = exports.SEMATTRS_NET_PEER_PORT = exports.SEMATTRS_NET_PEER_IP = exports.SEMATTRS_NET_TRANSPORT = exports.SEMATTRS_FAAS_INVOKED_REGION = exports.SEMATTRS_FAAS_INVOKED_PROVIDER = exports.SEMATTRS_FAAS_INVOKED_NAME = exports.SEMATTRS_FAAS_COLDSTART = exports.SEMATTRS_FAAS_CRON = exports.SEMATTRS_FAAS_TIME = exports.SEMATTRS_FAAS_DOCUMENT_NAME = exports.SEMATTRS_FAAS_DOCUMENT_TIME = exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = exports.SEMATTRS_FAAS_EXECUTION = exports.SEMATTRS_FAAS_TRIGGER = exports.SEMATTRS_EXCEPTION_ESCAPED = exports.SEMATTRS_EXCEPTION_STACKTRACE = exports.SEMATTRS_EXCEPTION_MESSAGE = exports.SEMATTRS_EXCEPTION_TYPE = exports.SEMATTRS_DB_SQL_TABLE = exports.SEMATTRS_DB_MONGODB_COLLECTION = exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = exports.SEMATTRS_DB_HBASE_NAMESPACE = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = exports.SEMATTRS_DB_CASSANDRA_TABLE = exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = exports.SEMATTRS_DB_OPERATION = exports.SEMATTRS_DB_STATEMENT = exports.SEMATTRS_DB_NAME = exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = exports.SEMATTRS_DB_USER = exports.SEMATTRS_DB_CONNECTION_STRING = exports.SEMATTRS_DB_SYSTEM = exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = void 0;
    exports.SEMATTRS_MESSAGING_DESTINATION_KIND = exports.SEMATTRS_MESSAGING_DESTINATION = exports.SEMATTRS_MESSAGING_SYSTEM = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = exports.SEMATTRS_AWS_DYNAMODB_COUNT = exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_SELECT = exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = exports.SEMATTRS_AWS_DYNAMODB_LIMIT = exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = exports.SEMATTRS_HTTP_CLIENT_IP = exports.SEMATTRS_HTTP_ROUTE = exports.SEMATTRS_HTTP_SERVER_NAME = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = exports.SEMATTRS_HTTP_USER_AGENT = exports.SEMATTRS_HTTP_FLAVOR = exports.SEMATTRS_HTTP_STATUS_CODE = exports.SEMATTRS_HTTP_SCHEME = exports.SEMATTRS_HTTP_HOST = exports.SEMATTRS_HTTP_TARGET = exports.SEMATTRS_HTTP_URL = exports.SEMATTRS_HTTP_METHOD = exports.SEMATTRS_CODE_LINENO = exports.SEMATTRS_CODE_FILEPATH = exports.SEMATTRS_CODE_NAMESPACE = exports.SEMATTRS_CODE_FUNCTION = exports.SEMATTRS_THREAD_NAME = exports.SEMATTRS_THREAD_ID = exports.SEMATTRS_ENDUSER_SCOPE = exports.SEMATTRS_ENDUSER_ROLE = exports.SEMATTRS_ENDUSER_ID = exports.SEMATTRS_PEER_SERVICE = void 0;
    exports.DBSYSTEMVALUES_FILEMAKER = exports.DBSYSTEMVALUES_DERBY = exports.DBSYSTEMVALUES_FIREBIRD = exports.DBSYSTEMVALUES_ADABAS = exports.DBSYSTEMVALUES_CACHE = exports.DBSYSTEMVALUES_EDB = exports.DBSYSTEMVALUES_FIRSTSQL = exports.DBSYSTEMVALUES_INGRES = exports.DBSYSTEMVALUES_HANADB = exports.DBSYSTEMVALUES_MAXDB = exports.DBSYSTEMVALUES_PROGRESS = exports.DBSYSTEMVALUES_HSQLDB = exports.DBSYSTEMVALUES_CLOUDSCAPE = exports.DBSYSTEMVALUES_HIVE = exports.DBSYSTEMVALUES_REDSHIFT = exports.DBSYSTEMVALUES_POSTGRESQL = exports.DBSYSTEMVALUES_DB2 = exports.DBSYSTEMVALUES_ORACLE = exports.DBSYSTEMVALUES_MYSQL = exports.DBSYSTEMVALUES_MSSQL = exports.DBSYSTEMVALUES_OTHER_SQL = exports.SemanticAttributes = exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_ID = exports.SEMATTRS_MESSAGE_TYPE = exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = exports.SEMATTRS_RPC_JSONRPC_VERSION = exports.SEMATTRS_RPC_GRPC_STATUS_CODE = exports.SEMATTRS_RPC_METHOD = exports.SEMATTRS_RPC_SERVICE = exports.SEMATTRS_RPC_SYSTEM = exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = exports.SEMATTRS_MESSAGING_CONSUMER_ID = exports.SEMATTRS_MESSAGING_OPERATION = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = exports.SEMATTRS_MESSAGING_CONVERSATION_ID = exports.SEMATTRS_MESSAGING_MESSAGE_ID = exports.SEMATTRS_MESSAGING_URL = exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = exports.SEMATTRS_MESSAGING_PROTOCOL = exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = void 0;
    exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = exports.FaasDocumentOperationValues = exports.FAASDOCUMENTOPERATIONVALUES_DELETE = exports.FAASDOCUMENTOPERATIONVALUES_EDIT = exports.FAASDOCUMENTOPERATIONVALUES_INSERT = exports.FaasTriggerValues = exports.FAASTRIGGERVALUES_OTHER = exports.FAASTRIGGERVALUES_TIMER = exports.FAASTRIGGERVALUES_PUBSUB = exports.FAASTRIGGERVALUES_HTTP = exports.FAASTRIGGERVALUES_DATASOURCE = exports.DbCassandraConsistencyLevelValues = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = exports.DbSystemValues = exports.DBSYSTEMVALUES_COCKROACHDB = exports.DBSYSTEMVALUES_MEMCACHED = exports.DBSYSTEMVALUES_ELASTICSEARCH = exports.DBSYSTEMVALUES_GEODE = exports.DBSYSTEMVALUES_NEO4J = exports.DBSYSTEMVALUES_DYNAMODB = exports.DBSYSTEMVALUES_COSMOSDB = exports.DBSYSTEMVALUES_COUCHDB = exports.DBSYSTEMVALUES_COUCHBASE = exports.DBSYSTEMVALUES_REDIS = exports.DBSYSTEMVALUES_MONGODB = exports.DBSYSTEMVALUES_HBASE = exports.DBSYSTEMVALUES_CASSANDRA = exports.DBSYSTEMVALUES_COLDFUSION = exports.DBSYSTEMVALUES_H2 = exports.DBSYSTEMVALUES_VERTICA = exports.DBSYSTEMVALUES_TERADATA = exports.DBSYSTEMVALUES_SYBASE = exports.DBSYSTEMVALUES_SQLITE = exports.DBSYSTEMVALUES_POINTBASE = exports.DBSYSTEMVALUES_PERVASIVE = exports.DBSYSTEMVALUES_NETEZZA = exports.DBSYSTEMVALUES_MARIADB = exports.DBSYSTEMVALUES_INTERBASE = exports.DBSYSTEMVALUES_INSTANTDB = exports.DBSYSTEMVALUES_INFORMIX = void 0;
    exports.MESSAGINGOPERATIONVALUES_RECEIVE = exports.MessagingDestinationKindValues = exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = exports.HttpFlavorValues = exports.HTTPFLAVORVALUES_QUIC = exports.HTTPFLAVORVALUES_SPDY = exports.HTTPFLAVORVALUES_HTTP_2_0 = exports.HTTPFLAVORVALUES_HTTP_1_1 = exports.HTTPFLAVORVALUES_HTTP_1_0 = exports.NetHostConnectionSubtypeValues = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = exports.NetHostConnectionTypeValues = exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = exports.NETHOSTCONNECTIONTYPEVALUES_CELL = exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = exports.NetTransportValues = exports.NETTRANSPORTVALUES_OTHER = exports.NETTRANSPORTVALUES_INPROC = exports.NETTRANSPORTVALUES_PIPE = exports.NETTRANSPORTVALUES_UNIX = exports.NETTRANSPORTVALUES_IP = exports.NETTRANSPORTVALUES_IP_UDP = exports.NETTRANSPORTVALUES_IP_TCP = exports.FaasInvokedProviderValues = exports.FAASINVOKEDPROVIDERVALUES_GCP = exports.FAASINVOKEDPROVIDERVALUES_AZURE = exports.FAASINVOKEDPROVIDERVALUES_AWS = void 0;
    exports.MessageTypeValues = exports.MESSAGETYPEVALUES_RECEIVED = exports.MESSAGETYPEVALUES_SENT = exports.RpcGrpcStatusCodeValues = exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = exports.RPCGRPCSTATUSCODEVALUES_ABORTED = exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = exports.RPCGRPCSTATUSCODEVALUES_OK = exports.MessagingOperationValues = exports.MESSAGINGOPERATIONVALUES_PROCESS = void 0;
    var utils_1 = require_utils5();
    var TMP_AWS_LAMBDA_INVOKED_ARN2 = "aws.lambda.invoked_arn";
    var TMP_DB_SYSTEM2 = "db.system";
    var TMP_DB_CONNECTION_STRING2 = "db.connection_string";
    var TMP_DB_USER2 = "db.user";
    var TMP_DB_JDBC_DRIVER_CLASSNAME2 = "db.jdbc.driver_classname";
    var TMP_DB_NAME2 = "db.name";
    var TMP_DB_STATEMENT2 = "db.statement";
    var TMP_DB_OPERATION2 = "db.operation";
    var TMP_DB_MSSQL_INSTANCE_NAME2 = "db.mssql.instance_name";
    var TMP_DB_CASSANDRA_KEYSPACE2 = "db.cassandra.keyspace";
    var TMP_DB_CASSANDRA_PAGE_SIZE2 = "db.cassandra.page_size";
    var TMP_DB_CASSANDRA_CONSISTENCY_LEVEL2 = "db.cassandra.consistency_level";
    var TMP_DB_CASSANDRA_TABLE2 = "db.cassandra.table";
    var TMP_DB_CASSANDRA_IDEMPOTENCE2 = "db.cassandra.idempotence";
    var TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT2 = "db.cassandra.speculative_execution_count";
    var TMP_DB_CASSANDRA_COORDINATOR_ID2 = "db.cassandra.coordinator.id";
    var TMP_DB_CASSANDRA_COORDINATOR_DC2 = "db.cassandra.coordinator.dc";
    var TMP_DB_HBASE_NAMESPACE2 = "db.hbase.namespace";
    var TMP_DB_REDIS_DATABASE_INDEX2 = "db.redis.database_index";
    var TMP_DB_MONGODB_COLLECTION2 = "db.mongodb.collection";
    var TMP_DB_SQL_TABLE2 = "db.sql.table";
    var TMP_EXCEPTION_TYPE2 = "exception.type";
    var TMP_EXCEPTION_MESSAGE2 = "exception.message";
    var TMP_EXCEPTION_STACKTRACE2 = "exception.stacktrace";
    var TMP_EXCEPTION_ESCAPED2 = "exception.escaped";
    var TMP_FAAS_TRIGGER2 = "faas.trigger";
    var TMP_FAAS_EXECUTION2 = "faas.execution";
    var TMP_FAAS_DOCUMENT_COLLECTION2 = "faas.document.collection";
    var TMP_FAAS_DOCUMENT_OPERATION2 = "faas.document.operation";
    var TMP_FAAS_DOCUMENT_TIME2 = "faas.document.time";
    var TMP_FAAS_DOCUMENT_NAME2 = "faas.document.name";
    var TMP_FAAS_TIME2 = "faas.time";
    var TMP_FAAS_CRON2 = "faas.cron";
    var TMP_FAAS_COLDSTART2 = "faas.coldstart";
    var TMP_FAAS_INVOKED_NAME2 = "faas.invoked_name";
    var TMP_FAAS_INVOKED_PROVIDER2 = "faas.invoked_provider";
    var TMP_FAAS_INVOKED_REGION2 = "faas.invoked_region";
    var TMP_NET_TRANSPORT2 = "net.transport";
    var TMP_NET_PEER_IP2 = "net.peer.ip";
    var TMP_NET_PEER_PORT2 = "net.peer.port";
    var TMP_NET_PEER_NAME2 = "net.peer.name";
    var TMP_NET_HOST_IP2 = "net.host.ip";
    var TMP_NET_HOST_PORT2 = "net.host.port";
    var TMP_NET_HOST_NAME2 = "net.host.name";
    var TMP_NET_HOST_CONNECTION_TYPE2 = "net.host.connection.type";
    var TMP_NET_HOST_CONNECTION_SUBTYPE2 = "net.host.connection.subtype";
    var TMP_NET_HOST_CARRIER_NAME2 = "net.host.carrier.name";
    var TMP_NET_HOST_CARRIER_MCC2 = "net.host.carrier.mcc";
    var TMP_NET_HOST_CARRIER_MNC2 = "net.host.carrier.mnc";
    var TMP_NET_HOST_CARRIER_ICC2 = "net.host.carrier.icc";
    var TMP_PEER_SERVICE2 = "peer.service";
    var TMP_ENDUSER_ID2 = "enduser.id";
    var TMP_ENDUSER_ROLE2 = "enduser.role";
    var TMP_ENDUSER_SCOPE2 = "enduser.scope";
    var TMP_THREAD_ID2 = "thread.id";
    var TMP_THREAD_NAME2 = "thread.name";
    var TMP_CODE_FUNCTION2 = "code.function";
    var TMP_CODE_NAMESPACE2 = "code.namespace";
    var TMP_CODE_FILEPATH2 = "code.filepath";
    var TMP_CODE_LINENO2 = "code.lineno";
    var TMP_HTTP_METHOD2 = "http.method";
    var TMP_HTTP_URL2 = "http.url";
    var TMP_HTTP_TARGET2 = "http.target";
    var TMP_HTTP_HOST2 = "http.host";
    var TMP_HTTP_SCHEME2 = "http.scheme";
    var TMP_HTTP_STATUS_CODE2 = "http.status_code";
    var TMP_HTTP_FLAVOR2 = "http.flavor";
    var TMP_HTTP_USER_AGENT2 = "http.user_agent";
    var TMP_HTTP_REQUEST_CONTENT_LENGTH2 = "http.request_content_length";
    var TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED2 = "http.request_content_length_uncompressed";
    var TMP_HTTP_RESPONSE_CONTENT_LENGTH2 = "http.response_content_length";
    var TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2 = "http.response_content_length_uncompressed";
    var TMP_HTTP_SERVER_NAME2 = "http.server_name";
    var TMP_HTTP_ROUTE2 = "http.route";
    var TMP_HTTP_CLIENT_IP2 = "http.client_ip";
    var TMP_AWS_DYNAMODB_TABLE_NAMES2 = "aws.dynamodb.table_names";
    var TMP_AWS_DYNAMODB_CONSUMED_CAPACITY2 = "aws.dynamodb.consumed_capacity";
    var TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS2 = "aws.dynamodb.item_collection_metrics";
    var TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY2 = "aws.dynamodb.provisioned_read_capacity";
    var TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY2 = "aws.dynamodb.provisioned_write_capacity";
    var TMP_AWS_DYNAMODB_CONSISTENT_READ2 = "aws.dynamodb.consistent_read";
    var TMP_AWS_DYNAMODB_PROJECTION2 = "aws.dynamodb.projection";
    var TMP_AWS_DYNAMODB_LIMIT2 = "aws.dynamodb.limit";
    var TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET2 = "aws.dynamodb.attributes_to_get";
    var TMP_AWS_DYNAMODB_INDEX_NAME2 = "aws.dynamodb.index_name";
    var TMP_AWS_DYNAMODB_SELECT2 = "aws.dynamodb.select";
    var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES2 = "aws.dynamodb.global_secondary_indexes";
    var TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES2 = "aws.dynamodb.local_secondary_indexes";
    var TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE2 = "aws.dynamodb.exclusive_start_table";
    var TMP_AWS_DYNAMODB_TABLE_COUNT2 = "aws.dynamodb.table_count";
    var TMP_AWS_DYNAMODB_SCAN_FORWARD2 = "aws.dynamodb.scan_forward";
    var TMP_AWS_DYNAMODB_SEGMENT2 = "aws.dynamodb.segment";
    var TMP_AWS_DYNAMODB_TOTAL_SEGMENTS2 = "aws.dynamodb.total_segments";
    var TMP_AWS_DYNAMODB_COUNT2 = "aws.dynamodb.count";
    var TMP_AWS_DYNAMODB_SCANNED_COUNT2 = "aws.dynamodb.scanned_count";
    var TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS2 = "aws.dynamodb.attribute_definitions";
    var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES2 = "aws.dynamodb.global_secondary_index_updates";
    var TMP_MESSAGING_SYSTEM2 = "messaging.system";
    var TMP_MESSAGING_DESTINATION2 = "messaging.destination";
    var TMP_MESSAGING_DESTINATION_KIND2 = "messaging.destination_kind";
    var TMP_MESSAGING_TEMP_DESTINATION2 = "messaging.temp_destination";
    var TMP_MESSAGING_PROTOCOL2 = "messaging.protocol";
    var TMP_MESSAGING_PROTOCOL_VERSION2 = "messaging.protocol_version";
    var TMP_MESSAGING_URL2 = "messaging.url";
    var TMP_MESSAGING_MESSAGE_ID2 = "messaging.message_id";
    var TMP_MESSAGING_CONVERSATION_ID2 = "messaging.conversation_id";
    var TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES2 = "messaging.message_payload_size_bytes";
    var TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES2 = "messaging.message_payload_compressed_size_bytes";
    var TMP_MESSAGING_OPERATION2 = "messaging.operation";
    var TMP_MESSAGING_CONSUMER_ID2 = "messaging.consumer_id";
    var TMP_MESSAGING_RABBITMQ_ROUTING_KEY2 = "messaging.rabbitmq.routing_key";
    var TMP_MESSAGING_KAFKA_MESSAGE_KEY2 = "messaging.kafka.message_key";
    var TMP_MESSAGING_KAFKA_CONSUMER_GROUP2 = "messaging.kafka.consumer_group";
    var TMP_MESSAGING_KAFKA_CLIENT_ID2 = "messaging.kafka.client_id";
    var TMP_MESSAGING_KAFKA_PARTITION2 = "messaging.kafka.partition";
    var TMP_MESSAGING_KAFKA_TOMBSTONE2 = "messaging.kafka.tombstone";
    var TMP_RPC_SYSTEM2 = "rpc.system";
    var TMP_RPC_SERVICE2 = "rpc.service";
    var TMP_RPC_METHOD2 = "rpc.method";
    var TMP_RPC_GRPC_STATUS_CODE2 = "rpc.grpc.status_code";
    var TMP_RPC_JSONRPC_VERSION2 = "rpc.jsonrpc.version";
    var TMP_RPC_JSONRPC_REQUEST_ID2 = "rpc.jsonrpc.request_id";
    var TMP_RPC_JSONRPC_ERROR_CODE2 = "rpc.jsonrpc.error_code";
    var TMP_RPC_JSONRPC_ERROR_MESSAGE2 = "rpc.jsonrpc.error_message";
    var TMP_MESSAGE_TYPE2 = "message.type";
    var TMP_MESSAGE_ID2 = "message.id";
    var TMP_MESSAGE_COMPRESSED_SIZE2 = "message.compressed_size";
    var TMP_MESSAGE_UNCOMPRESSED_SIZE2 = "message.uncompressed_size";
    exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = TMP_AWS_LAMBDA_INVOKED_ARN2;
    exports.SEMATTRS_DB_SYSTEM = TMP_DB_SYSTEM2;
    exports.SEMATTRS_DB_CONNECTION_STRING = TMP_DB_CONNECTION_STRING2;
    exports.SEMATTRS_DB_USER = TMP_DB_USER2;
    exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = TMP_DB_JDBC_DRIVER_CLASSNAME2;
    exports.SEMATTRS_DB_NAME = TMP_DB_NAME2;
    exports.SEMATTRS_DB_STATEMENT = TMP_DB_STATEMENT2;
    exports.SEMATTRS_DB_OPERATION = TMP_DB_OPERATION2;
    exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = TMP_DB_MSSQL_INSTANCE_NAME2;
    exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = TMP_DB_CASSANDRA_KEYSPACE2;
    exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = TMP_DB_CASSANDRA_PAGE_SIZE2;
    exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL2;
    exports.SEMATTRS_DB_CASSANDRA_TABLE = TMP_DB_CASSANDRA_TABLE2;
    exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = TMP_DB_CASSANDRA_IDEMPOTENCE2;
    exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT2;
    exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = TMP_DB_CASSANDRA_COORDINATOR_ID2;
    exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = TMP_DB_CASSANDRA_COORDINATOR_DC2;
    exports.SEMATTRS_DB_HBASE_NAMESPACE = TMP_DB_HBASE_NAMESPACE2;
    exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = TMP_DB_REDIS_DATABASE_INDEX2;
    exports.SEMATTRS_DB_MONGODB_COLLECTION = TMP_DB_MONGODB_COLLECTION2;
    exports.SEMATTRS_DB_SQL_TABLE = TMP_DB_SQL_TABLE2;
    exports.SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE2;
    exports.SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE2;
    exports.SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE2;
    exports.SEMATTRS_EXCEPTION_ESCAPED = TMP_EXCEPTION_ESCAPED2;
    exports.SEMATTRS_FAAS_TRIGGER = TMP_FAAS_TRIGGER2;
    exports.SEMATTRS_FAAS_EXECUTION = TMP_FAAS_EXECUTION2;
    exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = TMP_FAAS_DOCUMENT_COLLECTION2;
    exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = TMP_FAAS_DOCUMENT_OPERATION2;
    exports.SEMATTRS_FAAS_DOCUMENT_TIME = TMP_FAAS_DOCUMENT_TIME2;
    exports.SEMATTRS_FAAS_DOCUMENT_NAME = TMP_FAAS_DOCUMENT_NAME2;
    exports.SEMATTRS_FAAS_TIME = TMP_FAAS_TIME2;
    exports.SEMATTRS_FAAS_CRON = TMP_FAAS_CRON2;
    exports.SEMATTRS_FAAS_COLDSTART = TMP_FAAS_COLDSTART2;
    exports.SEMATTRS_FAAS_INVOKED_NAME = TMP_FAAS_INVOKED_NAME2;
    exports.SEMATTRS_FAAS_INVOKED_PROVIDER = TMP_FAAS_INVOKED_PROVIDER2;
    exports.SEMATTRS_FAAS_INVOKED_REGION = TMP_FAAS_INVOKED_REGION2;
    exports.SEMATTRS_NET_TRANSPORT = TMP_NET_TRANSPORT2;
    exports.SEMATTRS_NET_PEER_IP = TMP_NET_PEER_IP2;
    exports.SEMATTRS_NET_PEER_PORT = TMP_NET_PEER_PORT2;
    exports.SEMATTRS_NET_PEER_NAME = TMP_NET_PEER_NAME2;
    exports.SEMATTRS_NET_HOST_IP = TMP_NET_HOST_IP2;
    exports.SEMATTRS_NET_HOST_PORT = TMP_NET_HOST_PORT2;
    exports.SEMATTRS_NET_HOST_NAME = TMP_NET_HOST_NAME2;
    exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = TMP_NET_HOST_CONNECTION_TYPE2;
    exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = TMP_NET_HOST_CONNECTION_SUBTYPE2;
    exports.SEMATTRS_NET_HOST_CARRIER_NAME = TMP_NET_HOST_CARRIER_NAME2;
    exports.SEMATTRS_NET_HOST_CARRIER_MCC = TMP_NET_HOST_CARRIER_MCC2;
    exports.SEMATTRS_NET_HOST_CARRIER_MNC = TMP_NET_HOST_CARRIER_MNC2;
    exports.SEMATTRS_NET_HOST_CARRIER_ICC = TMP_NET_HOST_CARRIER_ICC2;
    exports.SEMATTRS_PEER_SERVICE = TMP_PEER_SERVICE2;
    exports.SEMATTRS_ENDUSER_ID = TMP_ENDUSER_ID2;
    exports.SEMATTRS_ENDUSER_ROLE = TMP_ENDUSER_ROLE2;
    exports.SEMATTRS_ENDUSER_SCOPE = TMP_ENDUSER_SCOPE2;
    exports.SEMATTRS_THREAD_ID = TMP_THREAD_ID2;
    exports.SEMATTRS_THREAD_NAME = TMP_THREAD_NAME2;
    exports.SEMATTRS_CODE_FUNCTION = TMP_CODE_FUNCTION2;
    exports.SEMATTRS_CODE_NAMESPACE = TMP_CODE_NAMESPACE2;
    exports.SEMATTRS_CODE_FILEPATH = TMP_CODE_FILEPATH2;
    exports.SEMATTRS_CODE_LINENO = TMP_CODE_LINENO2;
    exports.SEMATTRS_HTTP_METHOD = TMP_HTTP_METHOD2;
    exports.SEMATTRS_HTTP_URL = TMP_HTTP_URL2;
    exports.SEMATTRS_HTTP_TARGET = TMP_HTTP_TARGET2;
    exports.SEMATTRS_HTTP_HOST = TMP_HTTP_HOST2;
    exports.SEMATTRS_HTTP_SCHEME = TMP_HTTP_SCHEME2;
    exports.SEMATTRS_HTTP_STATUS_CODE = TMP_HTTP_STATUS_CODE2;
    exports.SEMATTRS_HTTP_FLAVOR = TMP_HTTP_FLAVOR2;
    exports.SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT2;
    exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = TMP_HTTP_REQUEST_CONTENT_LENGTH2;
    exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED2;
    exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = TMP_HTTP_RESPONSE_CONTENT_LENGTH2;
    exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2;
    exports.SEMATTRS_HTTP_SERVER_NAME = TMP_HTTP_SERVER_NAME2;
    exports.SEMATTRS_HTTP_ROUTE = TMP_HTTP_ROUTE2;
    exports.SEMATTRS_HTTP_CLIENT_IP = TMP_HTTP_CLIENT_IP2;
    exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = TMP_AWS_DYNAMODB_TABLE_NAMES2;
    exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY2;
    exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS2;
    exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY2;
    exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY2;
    exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = TMP_AWS_DYNAMODB_CONSISTENT_READ2;
    exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = TMP_AWS_DYNAMODB_PROJECTION2;
    exports.SEMATTRS_AWS_DYNAMODB_LIMIT = TMP_AWS_DYNAMODB_LIMIT2;
    exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET2;
    exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = TMP_AWS_DYNAMODB_INDEX_NAME2;
    exports.SEMATTRS_AWS_DYNAMODB_SELECT = TMP_AWS_DYNAMODB_SELECT2;
    exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES2;
    exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES2;
    exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE2;
    exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = TMP_AWS_DYNAMODB_TABLE_COUNT2;
    exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = TMP_AWS_DYNAMODB_SCAN_FORWARD2;
    exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = TMP_AWS_DYNAMODB_SEGMENT2;
    exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS2;
    exports.SEMATTRS_AWS_DYNAMODB_COUNT = TMP_AWS_DYNAMODB_COUNT2;
    exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = TMP_AWS_DYNAMODB_SCANNED_COUNT2;
    exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS2;
    exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES2;
    exports.SEMATTRS_MESSAGING_SYSTEM = TMP_MESSAGING_SYSTEM2;
    exports.SEMATTRS_MESSAGING_DESTINATION = TMP_MESSAGING_DESTINATION2;
    exports.SEMATTRS_MESSAGING_DESTINATION_KIND = TMP_MESSAGING_DESTINATION_KIND2;
    exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = TMP_MESSAGING_TEMP_DESTINATION2;
    exports.SEMATTRS_MESSAGING_PROTOCOL = TMP_MESSAGING_PROTOCOL2;
    exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = TMP_MESSAGING_PROTOCOL_VERSION2;
    exports.SEMATTRS_MESSAGING_URL = TMP_MESSAGING_URL2;
    exports.SEMATTRS_MESSAGING_MESSAGE_ID = TMP_MESSAGING_MESSAGE_ID2;
    exports.SEMATTRS_MESSAGING_CONVERSATION_ID = TMP_MESSAGING_CONVERSATION_ID2;
    exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES2;
    exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES2;
    exports.SEMATTRS_MESSAGING_OPERATION = TMP_MESSAGING_OPERATION2;
    exports.SEMATTRS_MESSAGING_CONSUMER_ID = TMP_MESSAGING_CONSUMER_ID2;
    exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = TMP_MESSAGING_RABBITMQ_ROUTING_KEY2;
    exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = TMP_MESSAGING_KAFKA_MESSAGE_KEY2;
    exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = TMP_MESSAGING_KAFKA_CONSUMER_GROUP2;
    exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = TMP_MESSAGING_KAFKA_CLIENT_ID2;
    exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = TMP_MESSAGING_KAFKA_PARTITION2;
    exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = TMP_MESSAGING_KAFKA_TOMBSTONE2;
    exports.SEMATTRS_RPC_SYSTEM = TMP_RPC_SYSTEM2;
    exports.SEMATTRS_RPC_SERVICE = TMP_RPC_SERVICE2;
    exports.SEMATTRS_RPC_METHOD = TMP_RPC_METHOD2;
    exports.SEMATTRS_RPC_GRPC_STATUS_CODE = TMP_RPC_GRPC_STATUS_CODE2;
    exports.SEMATTRS_RPC_JSONRPC_VERSION = TMP_RPC_JSONRPC_VERSION2;
    exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = TMP_RPC_JSONRPC_REQUEST_ID2;
    exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = TMP_RPC_JSONRPC_ERROR_CODE2;
    exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = TMP_RPC_JSONRPC_ERROR_MESSAGE2;
    exports.SEMATTRS_MESSAGE_TYPE = TMP_MESSAGE_TYPE2;
    exports.SEMATTRS_MESSAGE_ID = TMP_MESSAGE_ID2;
    exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = TMP_MESSAGE_COMPRESSED_SIZE2;
    exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = TMP_MESSAGE_UNCOMPRESSED_SIZE2;
    exports.SemanticAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_AWS_LAMBDA_INVOKED_ARN2,
      TMP_DB_SYSTEM2,
      TMP_DB_CONNECTION_STRING2,
      TMP_DB_USER2,
      TMP_DB_JDBC_DRIVER_CLASSNAME2,
      TMP_DB_NAME2,
      TMP_DB_STATEMENT2,
      TMP_DB_OPERATION2,
      TMP_DB_MSSQL_INSTANCE_NAME2,
      TMP_DB_CASSANDRA_KEYSPACE2,
      TMP_DB_CASSANDRA_PAGE_SIZE2,
      TMP_DB_CASSANDRA_CONSISTENCY_LEVEL2,
      TMP_DB_CASSANDRA_TABLE2,
      TMP_DB_CASSANDRA_IDEMPOTENCE2,
      TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT2,
      TMP_DB_CASSANDRA_COORDINATOR_ID2,
      TMP_DB_CASSANDRA_COORDINATOR_DC2,
      TMP_DB_HBASE_NAMESPACE2,
      TMP_DB_REDIS_DATABASE_INDEX2,
      TMP_DB_MONGODB_COLLECTION2,
      TMP_DB_SQL_TABLE2,
      TMP_EXCEPTION_TYPE2,
      TMP_EXCEPTION_MESSAGE2,
      TMP_EXCEPTION_STACKTRACE2,
      TMP_EXCEPTION_ESCAPED2,
      TMP_FAAS_TRIGGER2,
      TMP_FAAS_EXECUTION2,
      TMP_FAAS_DOCUMENT_COLLECTION2,
      TMP_FAAS_DOCUMENT_OPERATION2,
      TMP_FAAS_DOCUMENT_TIME2,
      TMP_FAAS_DOCUMENT_NAME2,
      TMP_FAAS_TIME2,
      TMP_FAAS_CRON2,
      TMP_FAAS_COLDSTART2,
      TMP_FAAS_INVOKED_NAME2,
      TMP_FAAS_INVOKED_PROVIDER2,
      TMP_FAAS_INVOKED_REGION2,
      TMP_NET_TRANSPORT2,
      TMP_NET_PEER_IP2,
      TMP_NET_PEER_PORT2,
      TMP_NET_PEER_NAME2,
      TMP_NET_HOST_IP2,
      TMP_NET_HOST_PORT2,
      TMP_NET_HOST_NAME2,
      TMP_NET_HOST_CONNECTION_TYPE2,
      TMP_NET_HOST_CONNECTION_SUBTYPE2,
      TMP_NET_HOST_CARRIER_NAME2,
      TMP_NET_HOST_CARRIER_MCC2,
      TMP_NET_HOST_CARRIER_MNC2,
      TMP_NET_HOST_CARRIER_ICC2,
      TMP_PEER_SERVICE2,
      TMP_ENDUSER_ID2,
      TMP_ENDUSER_ROLE2,
      TMP_ENDUSER_SCOPE2,
      TMP_THREAD_ID2,
      TMP_THREAD_NAME2,
      TMP_CODE_FUNCTION2,
      TMP_CODE_NAMESPACE2,
      TMP_CODE_FILEPATH2,
      TMP_CODE_LINENO2,
      TMP_HTTP_METHOD2,
      TMP_HTTP_URL2,
      TMP_HTTP_TARGET2,
      TMP_HTTP_HOST2,
      TMP_HTTP_SCHEME2,
      TMP_HTTP_STATUS_CODE2,
      TMP_HTTP_FLAVOR2,
      TMP_HTTP_USER_AGENT2,
      TMP_HTTP_REQUEST_CONTENT_LENGTH2,
      TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED2,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH2,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2,
      TMP_HTTP_SERVER_NAME2,
      TMP_HTTP_ROUTE2,
      TMP_HTTP_CLIENT_IP2,
      TMP_AWS_DYNAMODB_TABLE_NAMES2,
      TMP_AWS_DYNAMODB_CONSUMED_CAPACITY2,
      TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS2,
      TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY2,
      TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY2,
      TMP_AWS_DYNAMODB_CONSISTENT_READ2,
      TMP_AWS_DYNAMODB_PROJECTION2,
      TMP_AWS_DYNAMODB_LIMIT2,
      TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET2,
      TMP_AWS_DYNAMODB_INDEX_NAME2,
      TMP_AWS_DYNAMODB_SELECT2,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES2,
      TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES2,
      TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE2,
      TMP_AWS_DYNAMODB_TABLE_COUNT2,
      TMP_AWS_DYNAMODB_SCAN_FORWARD2,
      TMP_AWS_DYNAMODB_SEGMENT2,
      TMP_AWS_DYNAMODB_TOTAL_SEGMENTS2,
      TMP_AWS_DYNAMODB_COUNT2,
      TMP_AWS_DYNAMODB_SCANNED_COUNT2,
      TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS2,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES2,
      TMP_MESSAGING_SYSTEM2,
      TMP_MESSAGING_DESTINATION2,
      TMP_MESSAGING_DESTINATION_KIND2,
      TMP_MESSAGING_TEMP_DESTINATION2,
      TMP_MESSAGING_PROTOCOL2,
      TMP_MESSAGING_PROTOCOL_VERSION2,
      TMP_MESSAGING_URL2,
      TMP_MESSAGING_MESSAGE_ID2,
      TMP_MESSAGING_CONVERSATION_ID2,
      TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES2,
      TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES2,
      TMP_MESSAGING_OPERATION2,
      TMP_MESSAGING_CONSUMER_ID2,
      TMP_MESSAGING_RABBITMQ_ROUTING_KEY2,
      TMP_MESSAGING_KAFKA_MESSAGE_KEY2,
      TMP_MESSAGING_KAFKA_CONSUMER_GROUP2,
      TMP_MESSAGING_KAFKA_CLIENT_ID2,
      TMP_MESSAGING_KAFKA_PARTITION2,
      TMP_MESSAGING_KAFKA_TOMBSTONE2,
      TMP_RPC_SYSTEM2,
      TMP_RPC_SERVICE2,
      TMP_RPC_METHOD2,
      TMP_RPC_GRPC_STATUS_CODE2,
      TMP_RPC_JSONRPC_VERSION2,
      TMP_RPC_JSONRPC_REQUEST_ID2,
      TMP_RPC_JSONRPC_ERROR_CODE2,
      TMP_RPC_JSONRPC_ERROR_MESSAGE2,
      TMP_MESSAGE_TYPE2,
      TMP_MESSAGE_ID2,
      TMP_MESSAGE_COMPRESSED_SIZE2,
      TMP_MESSAGE_UNCOMPRESSED_SIZE2
    ]);
    var TMP_DBSYSTEMVALUES_OTHER_SQL2 = "other_sql";
    var TMP_DBSYSTEMVALUES_MSSQL2 = "mssql";
    var TMP_DBSYSTEMVALUES_MYSQL2 = "mysql";
    var TMP_DBSYSTEMVALUES_ORACLE2 = "oracle";
    var TMP_DBSYSTEMVALUES_DB22 = "db2";
    var TMP_DBSYSTEMVALUES_POSTGRESQL2 = "postgresql";
    var TMP_DBSYSTEMVALUES_REDSHIFT2 = "redshift";
    var TMP_DBSYSTEMVALUES_HIVE2 = "hive";
    var TMP_DBSYSTEMVALUES_CLOUDSCAPE2 = "cloudscape";
    var TMP_DBSYSTEMVALUES_HSQLDB2 = "hsqldb";
    var TMP_DBSYSTEMVALUES_PROGRESS2 = "progress";
    var TMP_DBSYSTEMVALUES_MAXDB2 = "maxdb";
    var TMP_DBSYSTEMVALUES_HANADB2 = "hanadb";
    var TMP_DBSYSTEMVALUES_INGRES2 = "ingres";
    var TMP_DBSYSTEMVALUES_FIRSTSQL2 = "firstsql";
    var TMP_DBSYSTEMVALUES_EDB2 = "edb";
    var TMP_DBSYSTEMVALUES_CACHE2 = "cache";
    var TMP_DBSYSTEMVALUES_ADABAS2 = "adabas";
    var TMP_DBSYSTEMVALUES_FIREBIRD2 = "firebird";
    var TMP_DBSYSTEMVALUES_DERBY2 = "derby";
    var TMP_DBSYSTEMVALUES_FILEMAKER2 = "filemaker";
    var TMP_DBSYSTEMVALUES_INFORMIX2 = "informix";
    var TMP_DBSYSTEMVALUES_INSTANTDB2 = "instantdb";
    var TMP_DBSYSTEMVALUES_INTERBASE2 = "interbase";
    var TMP_DBSYSTEMVALUES_MARIADB2 = "mariadb";
    var TMP_DBSYSTEMVALUES_NETEZZA2 = "netezza";
    var TMP_DBSYSTEMVALUES_PERVASIVE2 = "pervasive";
    var TMP_DBSYSTEMVALUES_POINTBASE2 = "pointbase";
    var TMP_DBSYSTEMVALUES_SQLITE2 = "sqlite";
    var TMP_DBSYSTEMVALUES_SYBASE2 = "sybase";
    var TMP_DBSYSTEMVALUES_TERADATA2 = "teradata";
    var TMP_DBSYSTEMVALUES_VERTICA2 = "vertica";
    var TMP_DBSYSTEMVALUES_H22 = "h2";
    var TMP_DBSYSTEMVALUES_COLDFUSION2 = "coldfusion";
    var TMP_DBSYSTEMVALUES_CASSANDRA2 = "cassandra";
    var TMP_DBSYSTEMVALUES_HBASE2 = "hbase";
    var TMP_DBSYSTEMVALUES_MONGODB2 = "mongodb";
    var TMP_DBSYSTEMVALUES_REDIS2 = "redis";
    var TMP_DBSYSTEMVALUES_COUCHBASE2 = "couchbase";
    var TMP_DBSYSTEMVALUES_COUCHDB2 = "couchdb";
    var TMP_DBSYSTEMVALUES_COSMOSDB2 = "cosmosdb";
    var TMP_DBSYSTEMVALUES_DYNAMODB2 = "dynamodb";
    var TMP_DBSYSTEMVALUES_NEO4J2 = "neo4j";
    var TMP_DBSYSTEMVALUES_GEODE2 = "geode";
    var TMP_DBSYSTEMVALUES_ELASTICSEARCH2 = "elasticsearch";
    var TMP_DBSYSTEMVALUES_MEMCACHED2 = "memcached";
    var TMP_DBSYSTEMVALUES_COCKROACHDB2 = "cockroachdb";
    exports.DBSYSTEMVALUES_OTHER_SQL = TMP_DBSYSTEMVALUES_OTHER_SQL2;
    exports.DBSYSTEMVALUES_MSSQL = TMP_DBSYSTEMVALUES_MSSQL2;
    exports.DBSYSTEMVALUES_MYSQL = TMP_DBSYSTEMVALUES_MYSQL2;
    exports.DBSYSTEMVALUES_ORACLE = TMP_DBSYSTEMVALUES_ORACLE2;
    exports.DBSYSTEMVALUES_DB2 = TMP_DBSYSTEMVALUES_DB22;
    exports.DBSYSTEMVALUES_POSTGRESQL = TMP_DBSYSTEMVALUES_POSTGRESQL2;
    exports.DBSYSTEMVALUES_REDSHIFT = TMP_DBSYSTEMVALUES_REDSHIFT2;
    exports.DBSYSTEMVALUES_HIVE = TMP_DBSYSTEMVALUES_HIVE2;
    exports.DBSYSTEMVALUES_CLOUDSCAPE = TMP_DBSYSTEMVALUES_CLOUDSCAPE2;
    exports.DBSYSTEMVALUES_HSQLDB = TMP_DBSYSTEMVALUES_HSQLDB2;
    exports.DBSYSTEMVALUES_PROGRESS = TMP_DBSYSTEMVALUES_PROGRESS2;
    exports.DBSYSTEMVALUES_MAXDB = TMP_DBSYSTEMVALUES_MAXDB2;
    exports.DBSYSTEMVALUES_HANADB = TMP_DBSYSTEMVALUES_HANADB2;
    exports.DBSYSTEMVALUES_INGRES = TMP_DBSYSTEMVALUES_INGRES2;
    exports.DBSYSTEMVALUES_FIRSTSQL = TMP_DBSYSTEMVALUES_FIRSTSQL2;
    exports.DBSYSTEMVALUES_EDB = TMP_DBSYSTEMVALUES_EDB2;
    exports.DBSYSTEMVALUES_CACHE = TMP_DBSYSTEMVALUES_CACHE2;
    exports.DBSYSTEMVALUES_ADABAS = TMP_DBSYSTEMVALUES_ADABAS2;
    exports.DBSYSTEMVALUES_FIREBIRD = TMP_DBSYSTEMVALUES_FIREBIRD2;
    exports.DBSYSTEMVALUES_DERBY = TMP_DBSYSTEMVALUES_DERBY2;
    exports.DBSYSTEMVALUES_FILEMAKER = TMP_DBSYSTEMVALUES_FILEMAKER2;
    exports.DBSYSTEMVALUES_INFORMIX = TMP_DBSYSTEMVALUES_INFORMIX2;
    exports.DBSYSTEMVALUES_INSTANTDB = TMP_DBSYSTEMVALUES_INSTANTDB2;
    exports.DBSYSTEMVALUES_INTERBASE = TMP_DBSYSTEMVALUES_INTERBASE2;
    exports.DBSYSTEMVALUES_MARIADB = TMP_DBSYSTEMVALUES_MARIADB2;
    exports.DBSYSTEMVALUES_NETEZZA = TMP_DBSYSTEMVALUES_NETEZZA2;
    exports.DBSYSTEMVALUES_PERVASIVE = TMP_DBSYSTEMVALUES_PERVASIVE2;
    exports.DBSYSTEMVALUES_POINTBASE = TMP_DBSYSTEMVALUES_POINTBASE2;
    exports.DBSYSTEMVALUES_SQLITE = TMP_DBSYSTEMVALUES_SQLITE2;
    exports.DBSYSTEMVALUES_SYBASE = TMP_DBSYSTEMVALUES_SYBASE2;
    exports.DBSYSTEMVALUES_TERADATA = TMP_DBSYSTEMVALUES_TERADATA2;
    exports.DBSYSTEMVALUES_VERTICA = TMP_DBSYSTEMVALUES_VERTICA2;
    exports.DBSYSTEMVALUES_H2 = TMP_DBSYSTEMVALUES_H22;
    exports.DBSYSTEMVALUES_COLDFUSION = TMP_DBSYSTEMVALUES_COLDFUSION2;
    exports.DBSYSTEMVALUES_CASSANDRA = TMP_DBSYSTEMVALUES_CASSANDRA2;
    exports.DBSYSTEMVALUES_HBASE = TMP_DBSYSTEMVALUES_HBASE2;
    exports.DBSYSTEMVALUES_MONGODB = TMP_DBSYSTEMVALUES_MONGODB2;
    exports.DBSYSTEMVALUES_REDIS = TMP_DBSYSTEMVALUES_REDIS2;
    exports.DBSYSTEMVALUES_COUCHBASE = TMP_DBSYSTEMVALUES_COUCHBASE2;
    exports.DBSYSTEMVALUES_COUCHDB = TMP_DBSYSTEMVALUES_COUCHDB2;
    exports.DBSYSTEMVALUES_COSMOSDB = TMP_DBSYSTEMVALUES_COSMOSDB2;
    exports.DBSYSTEMVALUES_DYNAMODB = TMP_DBSYSTEMVALUES_DYNAMODB2;
    exports.DBSYSTEMVALUES_NEO4J = TMP_DBSYSTEMVALUES_NEO4J2;
    exports.DBSYSTEMVALUES_GEODE = TMP_DBSYSTEMVALUES_GEODE2;
    exports.DBSYSTEMVALUES_ELASTICSEARCH = TMP_DBSYSTEMVALUES_ELASTICSEARCH2;
    exports.DBSYSTEMVALUES_MEMCACHED = TMP_DBSYSTEMVALUES_MEMCACHED2;
    exports.DBSYSTEMVALUES_COCKROACHDB = TMP_DBSYSTEMVALUES_COCKROACHDB2;
    exports.DbSystemValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_DBSYSTEMVALUES_OTHER_SQL2,
      TMP_DBSYSTEMVALUES_MSSQL2,
      TMP_DBSYSTEMVALUES_MYSQL2,
      TMP_DBSYSTEMVALUES_ORACLE2,
      TMP_DBSYSTEMVALUES_DB22,
      TMP_DBSYSTEMVALUES_POSTGRESQL2,
      TMP_DBSYSTEMVALUES_REDSHIFT2,
      TMP_DBSYSTEMVALUES_HIVE2,
      TMP_DBSYSTEMVALUES_CLOUDSCAPE2,
      TMP_DBSYSTEMVALUES_HSQLDB2,
      TMP_DBSYSTEMVALUES_PROGRESS2,
      TMP_DBSYSTEMVALUES_MAXDB2,
      TMP_DBSYSTEMVALUES_HANADB2,
      TMP_DBSYSTEMVALUES_INGRES2,
      TMP_DBSYSTEMVALUES_FIRSTSQL2,
      TMP_DBSYSTEMVALUES_EDB2,
      TMP_DBSYSTEMVALUES_CACHE2,
      TMP_DBSYSTEMVALUES_ADABAS2,
      TMP_DBSYSTEMVALUES_FIREBIRD2,
      TMP_DBSYSTEMVALUES_DERBY2,
      TMP_DBSYSTEMVALUES_FILEMAKER2,
      TMP_DBSYSTEMVALUES_INFORMIX2,
      TMP_DBSYSTEMVALUES_INSTANTDB2,
      TMP_DBSYSTEMVALUES_INTERBASE2,
      TMP_DBSYSTEMVALUES_MARIADB2,
      TMP_DBSYSTEMVALUES_NETEZZA2,
      TMP_DBSYSTEMVALUES_PERVASIVE2,
      TMP_DBSYSTEMVALUES_POINTBASE2,
      TMP_DBSYSTEMVALUES_SQLITE2,
      TMP_DBSYSTEMVALUES_SYBASE2,
      TMP_DBSYSTEMVALUES_TERADATA2,
      TMP_DBSYSTEMVALUES_VERTICA2,
      TMP_DBSYSTEMVALUES_H22,
      TMP_DBSYSTEMVALUES_COLDFUSION2,
      TMP_DBSYSTEMVALUES_CASSANDRA2,
      TMP_DBSYSTEMVALUES_HBASE2,
      TMP_DBSYSTEMVALUES_MONGODB2,
      TMP_DBSYSTEMVALUES_REDIS2,
      TMP_DBSYSTEMVALUES_COUCHBASE2,
      TMP_DBSYSTEMVALUES_COUCHDB2,
      TMP_DBSYSTEMVALUES_COSMOSDB2,
      TMP_DBSYSTEMVALUES_DYNAMODB2,
      TMP_DBSYSTEMVALUES_NEO4J2,
      TMP_DBSYSTEMVALUES_GEODE2,
      TMP_DBSYSTEMVALUES_ELASTICSEARCH2,
      TMP_DBSYSTEMVALUES_MEMCACHED2,
      TMP_DBSYSTEMVALUES_COCKROACHDB2
    ]);
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL2 = "all";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM2 = "each_quorum";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM2 = "quorum";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM2 = "local_quorum";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE2 = "one";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO2 = "two";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE2 = "three";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE2 = "local_one";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY2 = "any";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL2 = "serial";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL2 = "local_serial";
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL2;
    exports.DbCassandraConsistencyLevelValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL2
    ]);
    var TMP_FAASTRIGGERVALUES_DATASOURCE2 = "datasource";
    var TMP_FAASTRIGGERVALUES_HTTP2 = "http";
    var TMP_FAASTRIGGERVALUES_PUBSUB2 = "pubsub";
    var TMP_FAASTRIGGERVALUES_TIMER2 = "timer";
    var TMP_FAASTRIGGERVALUES_OTHER2 = "other";
    exports.FAASTRIGGERVALUES_DATASOURCE = TMP_FAASTRIGGERVALUES_DATASOURCE2;
    exports.FAASTRIGGERVALUES_HTTP = TMP_FAASTRIGGERVALUES_HTTP2;
    exports.FAASTRIGGERVALUES_PUBSUB = TMP_FAASTRIGGERVALUES_PUBSUB2;
    exports.FAASTRIGGERVALUES_TIMER = TMP_FAASTRIGGERVALUES_TIMER2;
    exports.FAASTRIGGERVALUES_OTHER = TMP_FAASTRIGGERVALUES_OTHER2;
    exports.FaasTriggerValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_FAASTRIGGERVALUES_DATASOURCE2,
      TMP_FAASTRIGGERVALUES_HTTP2,
      TMP_FAASTRIGGERVALUES_PUBSUB2,
      TMP_FAASTRIGGERVALUES_TIMER2,
      TMP_FAASTRIGGERVALUES_OTHER2
    ]);
    var TMP_FAASDOCUMENTOPERATIONVALUES_INSERT2 = "insert";
    var TMP_FAASDOCUMENTOPERATIONVALUES_EDIT2 = "edit";
    var TMP_FAASDOCUMENTOPERATIONVALUES_DELETE2 = "delete";
    exports.FAASDOCUMENTOPERATIONVALUES_INSERT = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT2;
    exports.FAASDOCUMENTOPERATIONVALUES_EDIT = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT2;
    exports.FAASDOCUMENTOPERATIONVALUES_DELETE = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE2;
    exports.FaasDocumentOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_FAASDOCUMENTOPERATIONVALUES_INSERT2,
      TMP_FAASDOCUMENTOPERATIONVALUES_EDIT2,
      TMP_FAASDOCUMENTOPERATIONVALUES_DELETE2
    ]);
    var TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD2 = "alibaba_cloud";
    var TMP_FAASINVOKEDPROVIDERVALUES_AWS2 = "aws";
    var TMP_FAASINVOKEDPROVIDERVALUES_AZURE2 = "azure";
    var TMP_FAASINVOKEDPROVIDERVALUES_GCP2 = "gcp";
    exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD2;
    exports.FAASINVOKEDPROVIDERVALUES_AWS = TMP_FAASINVOKEDPROVIDERVALUES_AWS2;
    exports.FAASINVOKEDPROVIDERVALUES_AZURE = TMP_FAASINVOKEDPROVIDERVALUES_AZURE2;
    exports.FAASINVOKEDPROVIDERVALUES_GCP = TMP_FAASINVOKEDPROVIDERVALUES_GCP2;
    exports.FaasInvokedProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD2,
      TMP_FAASINVOKEDPROVIDERVALUES_AWS2,
      TMP_FAASINVOKEDPROVIDERVALUES_AZURE2,
      TMP_FAASINVOKEDPROVIDERVALUES_GCP2
    ]);
    var TMP_NETTRANSPORTVALUES_IP_TCP2 = "ip_tcp";
    var TMP_NETTRANSPORTVALUES_IP_UDP2 = "ip_udp";
    var TMP_NETTRANSPORTVALUES_IP2 = "ip";
    var TMP_NETTRANSPORTVALUES_UNIX2 = "unix";
    var TMP_NETTRANSPORTVALUES_PIPE2 = "pipe";
    var TMP_NETTRANSPORTVALUES_INPROC2 = "inproc";
    var TMP_NETTRANSPORTVALUES_OTHER2 = "other";
    exports.NETTRANSPORTVALUES_IP_TCP = TMP_NETTRANSPORTVALUES_IP_TCP2;
    exports.NETTRANSPORTVALUES_IP_UDP = TMP_NETTRANSPORTVALUES_IP_UDP2;
    exports.NETTRANSPORTVALUES_IP = TMP_NETTRANSPORTVALUES_IP2;
    exports.NETTRANSPORTVALUES_UNIX = TMP_NETTRANSPORTVALUES_UNIX2;
    exports.NETTRANSPORTVALUES_PIPE = TMP_NETTRANSPORTVALUES_PIPE2;
    exports.NETTRANSPORTVALUES_INPROC = TMP_NETTRANSPORTVALUES_INPROC2;
    exports.NETTRANSPORTVALUES_OTHER = TMP_NETTRANSPORTVALUES_OTHER2;
    exports.NetTransportValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_NETTRANSPORTVALUES_IP_TCP2,
      TMP_NETTRANSPORTVALUES_IP_UDP2,
      TMP_NETTRANSPORTVALUES_IP2,
      TMP_NETTRANSPORTVALUES_UNIX2,
      TMP_NETTRANSPORTVALUES_PIPE2,
      TMP_NETTRANSPORTVALUES_INPROC2,
      TMP_NETTRANSPORTVALUES_OTHER2
    ]);
    var TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI2 = "wifi";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED2 = "wired";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_CELL2 = "cell";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE2 = "unavailable";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN2 = "unknown";
    exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI2;
    exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED2;
    exports.NETHOSTCONNECTIONTYPEVALUES_CELL = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL2;
    exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE2;
    exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN2;
    exports.NetHostConnectionTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI2,
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED2,
      TMP_NETHOSTCONNECTIONTYPEVALUES_CELL2,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE2,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN2
    ]);
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS2 = "gprs";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE2 = "edge";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS2 = "umts";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2 = "cdma";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_02 = "evdo_0";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A2 = "evdo_a";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT2 = "cdma2000_1xrtt";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA2 = "hsdpa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA2 = "hsupa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA2 = "hspa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN2 = "iden";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B2 = "evdo_b";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE2 = "lte";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD2 = "ehrpd";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP2 = "hspap";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM2 = "gsm";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA2 = "td_scdma";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN2 = "iwlan";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR2 = "nr";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA2 = "nrnsa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA2 = "lte_ca";
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_02;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA2;
    exports.NetHostConnectionSubtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_02,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA2
    ]);
    var TMP_HTTPFLAVORVALUES_HTTP_1_02 = "1.0";
    var TMP_HTTPFLAVORVALUES_HTTP_1_12 = "1.1";
    var TMP_HTTPFLAVORVALUES_HTTP_2_02 = "2.0";
    var TMP_HTTPFLAVORVALUES_SPDY2 = "SPDY";
    var TMP_HTTPFLAVORVALUES_QUIC2 = "QUIC";
    exports.HTTPFLAVORVALUES_HTTP_1_0 = TMP_HTTPFLAVORVALUES_HTTP_1_02;
    exports.HTTPFLAVORVALUES_HTTP_1_1 = TMP_HTTPFLAVORVALUES_HTTP_1_12;
    exports.HTTPFLAVORVALUES_HTTP_2_0 = TMP_HTTPFLAVORVALUES_HTTP_2_02;
    exports.HTTPFLAVORVALUES_SPDY = TMP_HTTPFLAVORVALUES_SPDY2;
    exports.HTTPFLAVORVALUES_QUIC = TMP_HTTPFLAVORVALUES_QUIC2;
    exports.HttpFlavorValues = {
      HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_02,
      HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_12,
      HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_02,
      SPDY: TMP_HTTPFLAVORVALUES_SPDY2,
      QUIC: TMP_HTTPFLAVORVALUES_QUIC2
    };
    var TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE2 = "queue";
    var TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC2 = "topic";
    exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE2;
    exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC2;
    exports.MessagingDestinationKindValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE2,
      TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC2
    ]);
    var TMP_MESSAGINGOPERATIONVALUES_RECEIVE2 = "receive";
    var TMP_MESSAGINGOPERATIONVALUES_PROCESS2 = "process";
    exports.MESSAGINGOPERATIONVALUES_RECEIVE = TMP_MESSAGINGOPERATIONVALUES_RECEIVE2;
    exports.MESSAGINGOPERATIONVALUES_PROCESS = TMP_MESSAGINGOPERATIONVALUES_PROCESS2;
    exports.MessagingOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_MESSAGINGOPERATIONVALUES_RECEIVE2,
      TMP_MESSAGINGOPERATIONVALUES_PROCESS2
    ]);
    var TMP_RPCGRPCSTATUSCODEVALUES_OK2 = 0;
    var TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED2 = 1;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN2 = 2;
    var TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT2 = 3;
    var TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED2 = 4;
    var TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND2 = 5;
    var TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS2 = 6;
    var TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED2 = 7;
    var TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED2 = 8;
    var TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION2 = 9;
    var TMP_RPCGRPCSTATUSCODEVALUES_ABORTED2 = 10;
    var TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE2 = 11;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED2 = 12;
    var TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL2 = 13;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE2 = 14;
    var TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS2 = 15;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED2 = 16;
    exports.RPCGRPCSTATUSCODEVALUES_OK = TMP_RPCGRPCSTATUSCODEVALUES_OK2;
    exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED2;
    exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN2;
    exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT2;
    exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED2;
    exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND2;
    exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS2;
    exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED2;
    exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED2;
    exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION2;
    exports.RPCGRPCSTATUSCODEVALUES_ABORTED = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED2;
    exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE2;
    exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED2;
    exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL2;
    exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE2;
    exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS2;
    exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED2;
    exports.RpcGrpcStatusCodeValues = {
      OK: TMP_RPCGRPCSTATUSCODEVALUES_OK2,
      CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED2,
      UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN2,
      INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT2,
      DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED2,
      NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND2,
      ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS2,
      PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED2,
      RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED2,
      FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION2,
      ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED2,
      OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE2,
      UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED2,
      INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL2,
      UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE2,
      DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS2,
      UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED2
    };
    var TMP_MESSAGETYPEVALUES_SENT2 = "SENT";
    var TMP_MESSAGETYPEVALUES_RECEIVED2 = "RECEIVED";
    exports.MESSAGETYPEVALUES_SENT = TMP_MESSAGETYPEVALUES_SENT2;
    exports.MESSAGETYPEVALUES_RECEIVED = TMP_MESSAGETYPEVALUES_RECEIVED2;
    exports.MessageTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_MESSAGETYPEVALUES_SENT2,
      TMP_MESSAGETYPEVALUES_RECEIVED2
    ]);
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js
var require_trace = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_SemanticAttributes(), exports);
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js
var require_SemanticResourceAttributes = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SEMRESATTRS_K8S_STATEFULSET_NAME = exports.SEMRESATTRS_K8S_STATEFULSET_UID = exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = exports.SEMRESATTRS_K8S_REPLICASET_NAME = exports.SEMRESATTRS_K8S_REPLICASET_UID = exports.SEMRESATTRS_K8S_CONTAINER_NAME = exports.SEMRESATTRS_K8S_POD_NAME = exports.SEMRESATTRS_K8S_POD_UID = exports.SEMRESATTRS_K8S_NAMESPACE_NAME = exports.SEMRESATTRS_K8S_NODE_UID = exports.SEMRESATTRS_K8S_NODE_NAME = exports.SEMRESATTRS_K8S_CLUSTER_NAME = exports.SEMRESATTRS_HOST_IMAGE_VERSION = exports.SEMRESATTRS_HOST_IMAGE_ID = exports.SEMRESATTRS_HOST_IMAGE_NAME = exports.SEMRESATTRS_HOST_ARCH = exports.SEMRESATTRS_HOST_TYPE = exports.SEMRESATTRS_HOST_NAME = exports.SEMRESATTRS_HOST_ID = exports.SEMRESATTRS_FAAS_MAX_MEMORY = exports.SEMRESATTRS_FAAS_INSTANCE = exports.SEMRESATTRS_FAAS_VERSION = exports.SEMRESATTRS_FAAS_ID = exports.SEMRESATTRS_FAAS_NAME = exports.SEMRESATTRS_DEVICE_MODEL_NAME = exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = exports.SEMRESATTRS_DEVICE_ID = exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = exports.SEMRESATTRS_CONTAINER_RUNTIME = exports.SEMRESATTRS_CONTAINER_ID = exports.SEMRESATTRS_CONTAINER_NAME = exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = exports.SEMRESATTRS_AWS_ECS_TASK_ARN = exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = exports.SEMRESATTRS_CLOUD_PLATFORM = exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = exports.SEMRESATTRS_CLOUD_REGION = exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = exports.SEMRESATTRS_CLOUD_PROVIDER = void 0;
    exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = exports.CLOUDPLATFORMVALUES_AZURE_AKS = exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = exports.CLOUDPLATFORMVALUES_AZURE_VM = exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = exports.CLOUDPLATFORMVALUES_AWS_EKS = exports.CLOUDPLATFORMVALUES_AWS_ECS = exports.CLOUDPLATFORMVALUES_AWS_EC2 = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = exports.CloudProviderValues = exports.CLOUDPROVIDERVALUES_GCP = exports.CLOUDPROVIDERVALUES_AZURE = exports.CLOUDPROVIDERVALUES_AWS = exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = exports.SemanticResourceAttributes = exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = exports.SEMRESATTRS_WEBENGINE_VERSION = exports.SEMRESATTRS_WEBENGINE_NAME = exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = exports.SEMRESATTRS_TELEMETRY_SDK_NAME = exports.SEMRESATTRS_SERVICE_VERSION = exports.SEMRESATTRS_SERVICE_INSTANCE_ID = exports.SEMRESATTRS_SERVICE_NAMESPACE = exports.SEMRESATTRS_SERVICE_NAME = exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = exports.SEMRESATTRS_PROCESS_OWNER = exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = exports.SEMRESATTRS_PROCESS_COMMAND_LINE = exports.SEMRESATTRS_PROCESS_COMMAND = exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = exports.SEMRESATTRS_PROCESS_PID = exports.SEMRESATTRS_OS_VERSION = exports.SEMRESATTRS_OS_NAME = exports.SEMRESATTRS_OS_DESCRIPTION = exports.SEMRESATTRS_OS_TYPE = exports.SEMRESATTRS_K8S_CRONJOB_NAME = exports.SEMRESATTRS_K8S_CRONJOB_UID = exports.SEMRESATTRS_K8S_JOB_NAME = exports.SEMRESATTRS_K8S_JOB_UID = exports.SEMRESATTRS_K8S_DAEMONSET_NAME = exports.SEMRESATTRS_K8S_DAEMONSET_UID = void 0;
    exports.TelemetrySdkLanguageValues = exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = exports.TELEMETRYSDKLANGUAGEVALUES_PHP = exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = exports.TELEMETRYSDKLANGUAGEVALUES_GO = exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = exports.TELEMETRYSDKLANGUAGEVALUES_CPP = exports.OsTypeValues = exports.OSTYPEVALUES_Z_OS = exports.OSTYPEVALUES_SOLARIS = exports.OSTYPEVALUES_AIX = exports.OSTYPEVALUES_HPUX = exports.OSTYPEVALUES_DRAGONFLYBSD = exports.OSTYPEVALUES_OPENBSD = exports.OSTYPEVALUES_NETBSD = exports.OSTYPEVALUES_FREEBSD = exports.OSTYPEVALUES_DARWIN = exports.OSTYPEVALUES_LINUX = exports.OSTYPEVALUES_WINDOWS = exports.HostArchValues = exports.HOSTARCHVALUES_X86 = exports.HOSTARCHVALUES_PPC64 = exports.HOSTARCHVALUES_PPC32 = exports.HOSTARCHVALUES_IA64 = exports.HOSTARCHVALUES_ARM64 = exports.HOSTARCHVALUES_ARM32 = exports.HOSTARCHVALUES_AMD64 = exports.AwsEcsLaunchtypeValues = exports.AWSECSLAUNCHTYPEVALUES_FARGATE = exports.AWSECSLAUNCHTYPEVALUES_EC2 = exports.CloudPlatformValues = exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = void 0;
    var utils_1 = require_utils5();
    var TMP_CLOUD_PROVIDER2 = "cloud.provider";
    var TMP_CLOUD_ACCOUNT_ID2 = "cloud.account.id";
    var TMP_CLOUD_REGION2 = "cloud.region";
    var TMP_CLOUD_AVAILABILITY_ZONE2 = "cloud.availability_zone";
    var TMP_CLOUD_PLATFORM2 = "cloud.platform";
    var TMP_AWS_ECS_CONTAINER_ARN2 = "aws.ecs.container.arn";
    var TMP_AWS_ECS_CLUSTER_ARN2 = "aws.ecs.cluster.arn";
    var TMP_AWS_ECS_LAUNCHTYPE2 = "aws.ecs.launchtype";
    var TMP_AWS_ECS_TASK_ARN2 = "aws.ecs.task.arn";
    var TMP_AWS_ECS_TASK_FAMILY2 = "aws.ecs.task.family";
    var TMP_AWS_ECS_TASK_REVISION2 = "aws.ecs.task.revision";
    var TMP_AWS_EKS_CLUSTER_ARN2 = "aws.eks.cluster.arn";
    var TMP_AWS_LOG_GROUP_NAMES2 = "aws.log.group.names";
    var TMP_AWS_LOG_GROUP_ARNS2 = "aws.log.group.arns";
    var TMP_AWS_LOG_STREAM_NAMES2 = "aws.log.stream.names";
    var TMP_AWS_LOG_STREAM_ARNS2 = "aws.log.stream.arns";
    var TMP_CONTAINER_NAME2 = "container.name";
    var TMP_CONTAINER_ID2 = "container.id";
    var TMP_CONTAINER_RUNTIME2 = "container.runtime";
    var TMP_CONTAINER_IMAGE_NAME2 = "container.image.name";
    var TMP_CONTAINER_IMAGE_TAG2 = "container.image.tag";
    var TMP_DEPLOYMENT_ENVIRONMENT2 = "deployment.environment";
    var TMP_DEVICE_ID2 = "device.id";
    var TMP_DEVICE_MODEL_IDENTIFIER2 = "device.model.identifier";
    var TMP_DEVICE_MODEL_NAME2 = "device.model.name";
    var TMP_FAAS_NAME2 = "faas.name";
    var TMP_FAAS_ID2 = "faas.id";
    var TMP_FAAS_VERSION2 = "faas.version";
    var TMP_FAAS_INSTANCE2 = "faas.instance";
    var TMP_FAAS_MAX_MEMORY2 = "faas.max_memory";
    var TMP_HOST_ID2 = "host.id";
    var TMP_HOST_NAME2 = "host.name";
    var TMP_HOST_TYPE2 = "host.type";
    var TMP_HOST_ARCH2 = "host.arch";
    var TMP_HOST_IMAGE_NAME2 = "host.image.name";
    var TMP_HOST_IMAGE_ID2 = "host.image.id";
    var TMP_HOST_IMAGE_VERSION2 = "host.image.version";
    var TMP_K8S_CLUSTER_NAME2 = "k8s.cluster.name";
    var TMP_K8S_NODE_NAME2 = "k8s.node.name";
    var TMP_K8S_NODE_UID2 = "k8s.node.uid";
    var TMP_K8S_NAMESPACE_NAME2 = "k8s.namespace.name";
    var TMP_K8S_POD_UID2 = "k8s.pod.uid";
    var TMP_K8S_POD_NAME2 = "k8s.pod.name";
    var TMP_K8S_CONTAINER_NAME2 = "k8s.container.name";
    var TMP_K8S_REPLICASET_UID2 = "k8s.replicaset.uid";
    var TMP_K8S_REPLICASET_NAME2 = "k8s.replicaset.name";
    var TMP_K8S_DEPLOYMENT_UID2 = "k8s.deployment.uid";
    var TMP_K8S_DEPLOYMENT_NAME2 = "k8s.deployment.name";
    var TMP_K8S_STATEFULSET_UID2 = "k8s.statefulset.uid";
    var TMP_K8S_STATEFULSET_NAME2 = "k8s.statefulset.name";
    var TMP_K8S_DAEMONSET_UID2 = "k8s.daemonset.uid";
    var TMP_K8S_DAEMONSET_NAME2 = "k8s.daemonset.name";
    var TMP_K8S_JOB_UID2 = "k8s.job.uid";
    var TMP_K8S_JOB_NAME2 = "k8s.job.name";
    var TMP_K8S_CRONJOB_UID2 = "k8s.cronjob.uid";
    var TMP_K8S_CRONJOB_NAME2 = "k8s.cronjob.name";
    var TMP_OS_TYPE2 = "os.type";
    var TMP_OS_DESCRIPTION2 = "os.description";
    var TMP_OS_NAME2 = "os.name";
    var TMP_OS_VERSION2 = "os.version";
    var TMP_PROCESS_PID2 = "process.pid";
    var TMP_PROCESS_EXECUTABLE_NAME2 = "process.executable.name";
    var TMP_PROCESS_EXECUTABLE_PATH2 = "process.executable.path";
    var TMP_PROCESS_COMMAND2 = "process.command";
    var TMP_PROCESS_COMMAND_LINE2 = "process.command_line";
    var TMP_PROCESS_COMMAND_ARGS2 = "process.command_args";
    var TMP_PROCESS_OWNER2 = "process.owner";
    var TMP_PROCESS_RUNTIME_NAME2 = "process.runtime.name";
    var TMP_PROCESS_RUNTIME_VERSION2 = "process.runtime.version";
    var TMP_PROCESS_RUNTIME_DESCRIPTION2 = "process.runtime.description";
    var TMP_SERVICE_NAME2 = "service.name";
    var TMP_SERVICE_NAMESPACE2 = "service.namespace";
    var TMP_SERVICE_INSTANCE_ID2 = "service.instance.id";
    var TMP_SERVICE_VERSION2 = "service.version";
    var TMP_TELEMETRY_SDK_NAME2 = "telemetry.sdk.name";
    var TMP_TELEMETRY_SDK_LANGUAGE2 = "telemetry.sdk.language";
    var TMP_TELEMETRY_SDK_VERSION2 = "telemetry.sdk.version";
    var TMP_TELEMETRY_AUTO_VERSION2 = "telemetry.auto.version";
    var TMP_WEBENGINE_NAME2 = "webengine.name";
    var TMP_WEBENGINE_VERSION2 = "webengine.version";
    var TMP_WEBENGINE_DESCRIPTION2 = "webengine.description";
    exports.SEMRESATTRS_CLOUD_PROVIDER = TMP_CLOUD_PROVIDER2;
    exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = TMP_CLOUD_ACCOUNT_ID2;
    exports.SEMRESATTRS_CLOUD_REGION = TMP_CLOUD_REGION2;
    exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = TMP_CLOUD_AVAILABILITY_ZONE2;
    exports.SEMRESATTRS_CLOUD_PLATFORM = TMP_CLOUD_PLATFORM2;
    exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = TMP_AWS_ECS_CONTAINER_ARN2;
    exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = TMP_AWS_ECS_CLUSTER_ARN2;
    exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = TMP_AWS_ECS_LAUNCHTYPE2;
    exports.SEMRESATTRS_AWS_ECS_TASK_ARN = TMP_AWS_ECS_TASK_ARN2;
    exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = TMP_AWS_ECS_TASK_FAMILY2;
    exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = TMP_AWS_ECS_TASK_REVISION2;
    exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = TMP_AWS_EKS_CLUSTER_ARN2;
    exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = TMP_AWS_LOG_GROUP_NAMES2;
    exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = TMP_AWS_LOG_GROUP_ARNS2;
    exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = TMP_AWS_LOG_STREAM_NAMES2;
    exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = TMP_AWS_LOG_STREAM_ARNS2;
    exports.SEMRESATTRS_CONTAINER_NAME = TMP_CONTAINER_NAME2;
    exports.SEMRESATTRS_CONTAINER_ID = TMP_CONTAINER_ID2;
    exports.SEMRESATTRS_CONTAINER_RUNTIME = TMP_CONTAINER_RUNTIME2;
    exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = TMP_CONTAINER_IMAGE_NAME2;
    exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = TMP_CONTAINER_IMAGE_TAG2;
    exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = TMP_DEPLOYMENT_ENVIRONMENT2;
    exports.SEMRESATTRS_DEVICE_ID = TMP_DEVICE_ID2;
    exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = TMP_DEVICE_MODEL_IDENTIFIER2;
    exports.SEMRESATTRS_DEVICE_MODEL_NAME = TMP_DEVICE_MODEL_NAME2;
    exports.SEMRESATTRS_FAAS_NAME = TMP_FAAS_NAME2;
    exports.SEMRESATTRS_FAAS_ID = TMP_FAAS_ID2;
    exports.SEMRESATTRS_FAAS_VERSION = TMP_FAAS_VERSION2;
    exports.SEMRESATTRS_FAAS_INSTANCE = TMP_FAAS_INSTANCE2;
    exports.SEMRESATTRS_FAAS_MAX_MEMORY = TMP_FAAS_MAX_MEMORY2;
    exports.SEMRESATTRS_HOST_ID = TMP_HOST_ID2;
    exports.SEMRESATTRS_HOST_NAME = TMP_HOST_NAME2;
    exports.SEMRESATTRS_HOST_TYPE = TMP_HOST_TYPE2;
    exports.SEMRESATTRS_HOST_ARCH = TMP_HOST_ARCH2;
    exports.SEMRESATTRS_HOST_IMAGE_NAME = TMP_HOST_IMAGE_NAME2;
    exports.SEMRESATTRS_HOST_IMAGE_ID = TMP_HOST_IMAGE_ID2;
    exports.SEMRESATTRS_HOST_IMAGE_VERSION = TMP_HOST_IMAGE_VERSION2;
    exports.SEMRESATTRS_K8S_CLUSTER_NAME = TMP_K8S_CLUSTER_NAME2;
    exports.SEMRESATTRS_K8S_NODE_NAME = TMP_K8S_NODE_NAME2;
    exports.SEMRESATTRS_K8S_NODE_UID = TMP_K8S_NODE_UID2;
    exports.SEMRESATTRS_K8S_NAMESPACE_NAME = TMP_K8S_NAMESPACE_NAME2;
    exports.SEMRESATTRS_K8S_POD_UID = TMP_K8S_POD_UID2;
    exports.SEMRESATTRS_K8S_POD_NAME = TMP_K8S_POD_NAME2;
    exports.SEMRESATTRS_K8S_CONTAINER_NAME = TMP_K8S_CONTAINER_NAME2;
    exports.SEMRESATTRS_K8S_REPLICASET_UID = TMP_K8S_REPLICASET_UID2;
    exports.SEMRESATTRS_K8S_REPLICASET_NAME = TMP_K8S_REPLICASET_NAME2;
    exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = TMP_K8S_DEPLOYMENT_UID2;
    exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = TMP_K8S_DEPLOYMENT_NAME2;
    exports.SEMRESATTRS_K8S_STATEFULSET_UID = TMP_K8S_STATEFULSET_UID2;
    exports.SEMRESATTRS_K8S_STATEFULSET_NAME = TMP_K8S_STATEFULSET_NAME2;
    exports.SEMRESATTRS_K8S_DAEMONSET_UID = TMP_K8S_DAEMONSET_UID2;
    exports.SEMRESATTRS_K8S_DAEMONSET_NAME = TMP_K8S_DAEMONSET_NAME2;
    exports.SEMRESATTRS_K8S_JOB_UID = TMP_K8S_JOB_UID2;
    exports.SEMRESATTRS_K8S_JOB_NAME = TMP_K8S_JOB_NAME2;
    exports.SEMRESATTRS_K8S_CRONJOB_UID = TMP_K8S_CRONJOB_UID2;
    exports.SEMRESATTRS_K8S_CRONJOB_NAME = TMP_K8S_CRONJOB_NAME2;
    exports.SEMRESATTRS_OS_TYPE = TMP_OS_TYPE2;
    exports.SEMRESATTRS_OS_DESCRIPTION = TMP_OS_DESCRIPTION2;
    exports.SEMRESATTRS_OS_NAME = TMP_OS_NAME2;
    exports.SEMRESATTRS_OS_VERSION = TMP_OS_VERSION2;
    exports.SEMRESATTRS_PROCESS_PID = TMP_PROCESS_PID2;
    exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = TMP_PROCESS_EXECUTABLE_NAME2;
    exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = TMP_PROCESS_EXECUTABLE_PATH2;
    exports.SEMRESATTRS_PROCESS_COMMAND = TMP_PROCESS_COMMAND2;
    exports.SEMRESATTRS_PROCESS_COMMAND_LINE = TMP_PROCESS_COMMAND_LINE2;
    exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = TMP_PROCESS_COMMAND_ARGS2;
    exports.SEMRESATTRS_PROCESS_OWNER = TMP_PROCESS_OWNER2;
    exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME2;
    exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = TMP_PROCESS_RUNTIME_VERSION2;
    exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = TMP_PROCESS_RUNTIME_DESCRIPTION2;
    exports.SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME2;
    exports.SEMRESATTRS_SERVICE_NAMESPACE = TMP_SERVICE_NAMESPACE2;
    exports.SEMRESATTRS_SERVICE_INSTANCE_ID = TMP_SERVICE_INSTANCE_ID2;
    exports.SEMRESATTRS_SERVICE_VERSION = TMP_SERVICE_VERSION2;
    exports.SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME2;
    exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE2;
    exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION2;
    exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = TMP_TELEMETRY_AUTO_VERSION2;
    exports.SEMRESATTRS_WEBENGINE_NAME = TMP_WEBENGINE_NAME2;
    exports.SEMRESATTRS_WEBENGINE_VERSION = TMP_WEBENGINE_VERSION2;
    exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = TMP_WEBENGINE_DESCRIPTION2;
    exports.SemanticResourceAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_CLOUD_PROVIDER2,
      TMP_CLOUD_ACCOUNT_ID2,
      TMP_CLOUD_REGION2,
      TMP_CLOUD_AVAILABILITY_ZONE2,
      TMP_CLOUD_PLATFORM2,
      TMP_AWS_ECS_CONTAINER_ARN2,
      TMP_AWS_ECS_CLUSTER_ARN2,
      TMP_AWS_ECS_LAUNCHTYPE2,
      TMP_AWS_ECS_TASK_ARN2,
      TMP_AWS_ECS_TASK_FAMILY2,
      TMP_AWS_ECS_TASK_REVISION2,
      TMP_AWS_EKS_CLUSTER_ARN2,
      TMP_AWS_LOG_GROUP_NAMES2,
      TMP_AWS_LOG_GROUP_ARNS2,
      TMP_AWS_LOG_STREAM_NAMES2,
      TMP_AWS_LOG_STREAM_ARNS2,
      TMP_CONTAINER_NAME2,
      TMP_CONTAINER_ID2,
      TMP_CONTAINER_RUNTIME2,
      TMP_CONTAINER_IMAGE_NAME2,
      TMP_CONTAINER_IMAGE_TAG2,
      TMP_DEPLOYMENT_ENVIRONMENT2,
      TMP_DEVICE_ID2,
      TMP_DEVICE_MODEL_IDENTIFIER2,
      TMP_DEVICE_MODEL_NAME2,
      TMP_FAAS_NAME2,
      TMP_FAAS_ID2,
      TMP_FAAS_VERSION2,
      TMP_FAAS_INSTANCE2,
      TMP_FAAS_MAX_MEMORY2,
      TMP_HOST_ID2,
      TMP_HOST_NAME2,
      TMP_HOST_TYPE2,
      TMP_HOST_ARCH2,
      TMP_HOST_IMAGE_NAME2,
      TMP_HOST_IMAGE_ID2,
      TMP_HOST_IMAGE_VERSION2,
      TMP_K8S_CLUSTER_NAME2,
      TMP_K8S_NODE_NAME2,
      TMP_K8S_NODE_UID2,
      TMP_K8S_NAMESPACE_NAME2,
      TMP_K8S_POD_UID2,
      TMP_K8S_POD_NAME2,
      TMP_K8S_CONTAINER_NAME2,
      TMP_K8S_REPLICASET_UID2,
      TMP_K8S_REPLICASET_NAME2,
      TMP_K8S_DEPLOYMENT_UID2,
      TMP_K8S_DEPLOYMENT_NAME2,
      TMP_K8S_STATEFULSET_UID2,
      TMP_K8S_STATEFULSET_NAME2,
      TMP_K8S_DAEMONSET_UID2,
      TMP_K8S_DAEMONSET_NAME2,
      TMP_K8S_JOB_UID2,
      TMP_K8S_JOB_NAME2,
      TMP_K8S_CRONJOB_UID2,
      TMP_K8S_CRONJOB_NAME2,
      TMP_OS_TYPE2,
      TMP_OS_DESCRIPTION2,
      TMP_OS_NAME2,
      TMP_OS_VERSION2,
      TMP_PROCESS_PID2,
      TMP_PROCESS_EXECUTABLE_NAME2,
      TMP_PROCESS_EXECUTABLE_PATH2,
      TMP_PROCESS_COMMAND2,
      TMP_PROCESS_COMMAND_LINE2,
      TMP_PROCESS_COMMAND_ARGS2,
      TMP_PROCESS_OWNER2,
      TMP_PROCESS_RUNTIME_NAME2,
      TMP_PROCESS_RUNTIME_VERSION2,
      TMP_PROCESS_RUNTIME_DESCRIPTION2,
      TMP_SERVICE_NAME2,
      TMP_SERVICE_NAMESPACE2,
      TMP_SERVICE_INSTANCE_ID2,
      TMP_SERVICE_VERSION2,
      TMP_TELEMETRY_SDK_NAME2,
      TMP_TELEMETRY_SDK_LANGUAGE2,
      TMP_TELEMETRY_SDK_VERSION2,
      TMP_TELEMETRY_AUTO_VERSION2,
      TMP_WEBENGINE_NAME2,
      TMP_WEBENGINE_VERSION2,
      TMP_WEBENGINE_DESCRIPTION2
    ]);
    var TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD2 = "alibaba_cloud";
    var TMP_CLOUDPROVIDERVALUES_AWS2 = "aws";
    var TMP_CLOUDPROVIDERVALUES_AZURE2 = "azure";
    var TMP_CLOUDPROVIDERVALUES_GCP2 = "gcp";
    exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD2;
    exports.CLOUDPROVIDERVALUES_AWS = TMP_CLOUDPROVIDERVALUES_AWS2;
    exports.CLOUDPROVIDERVALUES_AZURE = TMP_CLOUDPROVIDERVALUES_AZURE2;
    exports.CLOUDPROVIDERVALUES_GCP = TMP_CLOUDPROVIDERVALUES_GCP2;
    exports.CloudProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD2,
      TMP_CLOUDPROVIDERVALUES_AWS2,
      TMP_CLOUDPROVIDERVALUES_AZURE2,
      TMP_CLOUDPROVIDERVALUES_GCP2
    ]);
    var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS2 = "alibaba_cloud_ecs";
    var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC2 = "alibaba_cloud_fc";
    var TMP_CLOUDPLATFORMVALUES_AWS_EC22 = "aws_ec2";
    var TMP_CLOUDPLATFORMVALUES_AWS_ECS2 = "aws_ecs";
    var TMP_CLOUDPLATFORMVALUES_AWS_EKS2 = "aws_eks";
    var TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA2 = "aws_lambda";
    var TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK2 = "aws_elastic_beanstalk";
    var TMP_CLOUDPLATFORMVALUES_AZURE_VM2 = "azure_vm";
    var TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES2 = "azure_container_instances";
    var TMP_CLOUDPLATFORMVALUES_AZURE_AKS2 = "azure_aks";
    var TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS2 = "azure_functions";
    var TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE2 = "azure_app_service";
    var TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE2 = "gcp_compute_engine";
    var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN2 = "gcp_cloud_run";
    var TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE2 = "gcp_kubernetes_engine";
    var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS2 = "gcp_cloud_functions";
    var TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE2 = "gcp_app_engine";
    exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS2;
    exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC2;
    exports.CLOUDPLATFORMVALUES_AWS_EC2 = TMP_CLOUDPLATFORMVALUES_AWS_EC22;
    exports.CLOUDPLATFORMVALUES_AWS_ECS = TMP_CLOUDPLATFORMVALUES_AWS_ECS2;
    exports.CLOUDPLATFORMVALUES_AWS_EKS = TMP_CLOUDPLATFORMVALUES_AWS_EKS2;
    exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA2;
    exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK2;
    exports.CLOUDPLATFORMVALUES_AZURE_VM = TMP_CLOUDPLATFORMVALUES_AZURE_VM2;
    exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES2;
    exports.CLOUDPLATFORMVALUES_AZURE_AKS = TMP_CLOUDPLATFORMVALUES_AZURE_AKS2;
    exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS2;
    exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE2;
    exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE2;
    exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN2;
    exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE2;
    exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS2;
    exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE2;
    exports.CloudPlatformValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS2,
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC2,
      TMP_CLOUDPLATFORMVALUES_AWS_EC22,
      TMP_CLOUDPLATFORMVALUES_AWS_ECS2,
      TMP_CLOUDPLATFORMVALUES_AWS_EKS2,
      TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA2,
      TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK2,
      TMP_CLOUDPLATFORMVALUES_AZURE_VM2,
      TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES2,
      TMP_CLOUDPLATFORMVALUES_AZURE_AKS2,
      TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS2,
      TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE2,
      TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE2,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN2,
      TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE2,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS2,
      TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE2
    ]);
    var TMP_AWSECSLAUNCHTYPEVALUES_EC22 = "ec2";
    var TMP_AWSECSLAUNCHTYPEVALUES_FARGATE2 = "fargate";
    exports.AWSECSLAUNCHTYPEVALUES_EC2 = TMP_AWSECSLAUNCHTYPEVALUES_EC22;
    exports.AWSECSLAUNCHTYPEVALUES_FARGATE = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE2;
    exports.AwsEcsLaunchtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_AWSECSLAUNCHTYPEVALUES_EC22,
      TMP_AWSECSLAUNCHTYPEVALUES_FARGATE2
    ]);
    var TMP_HOSTARCHVALUES_AMD642 = "amd64";
    var TMP_HOSTARCHVALUES_ARM322 = "arm32";
    var TMP_HOSTARCHVALUES_ARM642 = "arm64";
    var TMP_HOSTARCHVALUES_IA642 = "ia64";
    var TMP_HOSTARCHVALUES_PPC322 = "ppc32";
    var TMP_HOSTARCHVALUES_PPC642 = "ppc64";
    var TMP_HOSTARCHVALUES_X862 = "x86";
    exports.HOSTARCHVALUES_AMD64 = TMP_HOSTARCHVALUES_AMD642;
    exports.HOSTARCHVALUES_ARM32 = TMP_HOSTARCHVALUES_ARM322;
    exports.HOSTARCHVALUES_ARM64 = TMP_HOSTARCHVALUES_ARM642;
    exports.HOSTARCHVALUES_IA64 = TMP_HOSTARCHVALUES_IA642;
    exports.HOSTARCHVALUES_PPC32 = TMP_HOSTARCHVALUES_PPC322;
    exports.HOSTARCHVALUES_PPC64 = TMP_HOSTARCHVALUES_PPC642;
    exports.HOSTARCHVALUES_X86 = TMP_HOSTARCHVALUES_X862;
    exports.HostArchValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_HOSTARCHVALUES_AMD642,
      TMP_HOSTARCHVALUES_ARM322,
      TMP_HOSTARCHVALUES_ARM642,
      TMP_HOSTARCHVALUES_IA642,
      TMP_HOSTARCHVALUES_PPC322,
      TMP_HOSTARCHVALUES_PPC642,
      TMP_HOSTARCHVALUES_X862
    ]);
    var TMP_OSTYPEVALUES_WINDOWS2 = "windows";
    var TMP_OSTYPEVALUES_LINUX2 = "linux";
    var TMP_OSTYPEVALUES_DARWIN2 = "darwin";
    var TMP_OSTYPEVALUES_FREEBSD2 = "freebsd";
    var TMP_OSTYPEVALUES_NETBSD2 = "netbsd";
    var TMP_OSTYPEVALUES_OPENBSD2 = "openbsd";
    var TMP_OSTYPEVALUES_DRAGONFLYBSD2 = "dragonflybsd";
    var TMP_OSTYPEVALUES_HPUX2 = "hpux";
    var TMP_OSTYPEVALUES_AIX2 = "aix";
    var TMP_OSTYPEVALUES_SOLARIS2 = "solaris";
    var TMP_OSTYPEVALUES_Z_OS2 = "z_os";
    exports.OSTYPEVALUES_WINDOWS = TMP_OSTYPEVALUES_WINDOWS2;
    exports.OSTYPEVALUES_LINUX = TMP_OSTYPEVALUES_LINUX2;
    exports.OSTYPEVALUES_DARWIN = TMP_OSTYPEVALUES_DARWIN2;
    exports.OSTYPEVALUES_FREEBSD = TMP_OSTYPEVALUES_FREEBSD2;
    exports.OSTYPEVALUES_NETBSD = TMP_OSTYPEVALUES_NETBSD2;
    exports.OSTYPEVALUES_OPENBSD = TMP_OSTYPEVALUES_OPENBSD2;
    exports.OSTYPEVALUES_DRAGONFLYBSD = TMP_OSTYPEVALUES_DRAGONFLYBSD2;
    exports.OSTYPEVALUES_HPUX = TMP_OSTYPEVALUES_HPUX2;
    exports.OSTYPEVALUES_AIX = TMP_OSTYPEVALUES_AIX2;
    exports.OSTYPEVALUES_SOLARIS = TMP_OSTYPEVALUES_SOLARIS2;
    exports.OSTYPEVALUES_Z_OS = TMP_OSTYPEVALUES_Z_OS2;
    exports.OsTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_OSTYPEVALUES_WINDOWS2,
      TMP_OSTYPEVALUES_LINUX2,
      TMP_OSTYPEVALUES_DARWIN2,
      TMP_OSTYPEVALUES_FREEBSD2,
      TMP_OSTYPEVALUES_NETBSD2,
      TMP_OSTYPEVALUES_OPENBSD2,
      TMP_OSTYPEVALUES_DRAGONFLYBSD2,
      TMP_OSTYPEVALUES_HPUX2,
      TMP_OSTYPEVALUES_AIX2,
      TMP_OSTYPEVALUES_SOLARIS2,
      TMP_OSTYPEVALUES_Z_OS2
    ]);
    var TMP_TELEMETRYSDKLANGUAGEVALUES_CPP2 = "cpp";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET2 = "dotnet";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG2 = "erlang";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_GO2 = "go";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA2 = "java";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS2 = "nodejs";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_PHP2 = "php";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON2 = "python";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY2 = "ruby";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS2 = "webjs";
    exports.TELEMETRYSDKLANGUAGEVALUES_CPP = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP2;
    exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET2;
    exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG2;
    exports.TELEMETRYSDKLANGUAGEVALUES_GO = TMP_TELEMETRYSDKLANGUAGEVALUES_GO2;
    exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA2;
    exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS2;
    exports.TELEMETRYSDKLANGUAGEVALUES_PHP = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP2;
    exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON2;
    exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY2;
    exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS2;
    exports.TelemetrySdkLanguageValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_TELEMETRYSDKLANGUAGEVALUES_CPP2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_GO2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PHP2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS2
    ]);
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js
var require_resource = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_SemanticResourceAttributes(), exports);
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/semantic-conventions/build/src/index.js
var require_src4 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/semantic-conventions/build/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_trace(), exports);
    __exportStar(require_resource(), exports);
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js
var require_sdk_info2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDK_INFO = void 0;
    var version_1 = require_version2();
    var semantic_conventions_1 = require_src4();
    exports.SDK_INFO = {
      [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_NAME]: "opentelemetry",
      [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_NAME]: "node",
      [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE]: semantic_conventions_1.TelemetrySdkLanguageValues.NODEJS,
      [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_VERSION]: version_1.VERSION
    };
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js
var require_timer_util2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unrefTimer = void 0;
    function unrefTimer(timer) {
      timer.unref();
    }
    exports.unrefTimer = unrefTimer;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/platform/node/index.js
var require_node5 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/platform/node/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnv = exports.getEnvWithoutDefaults = void 0;
    var environment_1 = require_environment4();
    Object.defineProperty(exports, "getEnvWithoutDefaults", { enumerable: true, get: function() {
      return environment_1.getEnvWithoutDefaults;
    } });
    Object.defineProperty(exports, "getEnv", { enumerable: true, get: function() {
      return environment_1.getEnv;
    } });
    __exportStar(require_globalThis2(), exports);
    __exportStar(require_hex_to_base642(), exports);
    __exportStar(require_RandomIdGenerator3(), exports);
    __exportStar(require_performance2(), exports);
    __exportStar(require_sdk_info2(), exports);
    __exportStar(require_timer_util2(), exports);
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/platform/index.js
var require_platform5 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/platform/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_node5(), exports);
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/common/time.js
var require_time2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/common/time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addHrTimes = exports.isTimeInput = exports.isTimeInputHrTime = exports.hrTimeToMicroseconds = exports.hrTimeToMilliseconds = exports.hrTimeToNanoseconds = exports.hrTimeToTimeStamp = exports.hrTimeDuration = exports.timeInputToHrTime = exports.hrTime = exports.getTimeOrigin = exports.millisToHrTime = void 0;
    var platform_1 = require_platform5();
    var NANOSECOND_DIGITS = 9;
    var NANOSECOND_DIGITS_IN_MILLIS = 6;
    var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
    var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
    function millisToHrTime(epochMillis) {
      const epochSeconds = epochMillis / 1e3;
      const seconds = Math.trunc(epochSeconds);
      const nanos = Math.round(epochMillis % 1e3 * MILLISECONDS_TO_NANOSECONDS);
      return [seconds, nanos];
    }
    exports.millisToHrTime = millisToHrTime;
    function getTimeOrigin() {
      let timeOrigin = platform_1.otperformance.timeOrigin;
      if (typeof timeOrigin !== "number") {
        const perf = platform_1.otperformance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
      }
      return timeOrigin;
    }
    exports.getTimeOrigin = getTimeOrigin;
    function hrTime(performanceNow) {
      const timeOrigin = millisToHrTime(getTimeOrigin());
      const now = millisToHrTime(typeof performanceNow === "number" ? performanceNow : platform_1.otperformance.now());
      return addHrTimes(timeOrigin, now);
    }
    exports.hrTime = hrTime;
    function timeInputToHrTime(time) {
      if (isTimeInputHrTime(time)) {
        return time;
      } else if (typeof time === "number") {
        if (time < getTimeOrigin()) {
          return hrTime(time);
        } else {
          return millisToHrTime(time);
        }
      } else if (time instanceof Date) {
        return millisToHrTime(time.getTime());
      } else {
        throw TypeError("Invalid input type");
      }
    }
    exports.timeInputToHrTime = timeInputToHrTime;
    function hrTimeDuration(startTime, endTime) {
      let seconds = endTime[0] - startTime[0];
      let nanos = endTime[1] - startTime[1];
      if (nanos < 0) {
        seconds -= 1;
        nanos += SECOND_TO_NANOSECONDS;
      }
      return [seconds, nanos];
    }
    exports.hrTimeDuration = hrTimeDuration;
    function hrTimeToTimeStamp(time) {
      const precision = NANOSECOND_DIGITS;
      const tmp = `${"0".repeat(precision)}${time[1]}Z`;
      const nanoString = tmp.substr(tmp.length - precision - 1);
      const date = new Date(time[0] * 1e3).toISOString();
      return date.replace("000Z", nanoString);
    }
    exports.hrTimeToTimeStamp = hrTimeToTimeStamp;
    function hrTimeToNanoseconds(time) {
      return time[0] * SECOND_TO_NANOSECONDS + time[1];
    }
    exports.hrTimeToNanoseconds = hrTimeToNanoseconds;
    function hrTimeToMilliseconds(time) {
      return time[0] * 1e3 + time[1] / 1e6;
    }
    exports.hrTimeToMilliseconds = hrTimeToMilliseconds;
    function hrTimeToMicroseconds(time) {
      return time[0] * 1e6 + time[1] / 1e3;
    }
    exports.hrTimeToMicroseconds = hrTimeToMicroseconds;
    function isTimeInputHrTime(value) {
      return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
    }
    exports.isTimeInputHrTime = isTimeInputHrTime;
    function isTimeInput(value) {
      return isTimeInputHrTime(value) || typeof value === "number" || value instanceof Date;
    }
    exports.isTimeInput = isTimeInput;
    function addHrTimes(time1, time2) {
      const out = [time1[0] + time2[0], time1[1] + time2[1]];
      if (out[1] >= SECOND_TO_NANOSECONDS) {
        out[1] -= SECOND_TO_NANOSECONDS;
        out[0] += 1;
      }
      return out;
    }
    exports.addHrTimes = addHrTimes;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/common/types.js
var require_types = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/common/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/ExportResult.js
var require_ExportResult2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/ExportResult.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExportResultCode = void 0;
    var ExportResultCode;
    (function(ExportResultCode2) {
      ExportResultCode2[ExportResultCode2["SUCCESS"] = 0] = "SUCCESS";
      ExportResultCode2[ExportResultCode2["FAILED"] = 1] = "FAILED";
    })(ExportResultCode = exports.ExportResultCode || (exports.ExportResultCode = {}));
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/propagation/composite.js
var require_composite2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/propagation/composite.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompositePropagator = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var CompositePropagator = class {
      /**
       * Construct a composite propagator from a list of propagators.
       *
       * @param [config] Configuration object for composite propagator
       */
      constructor(config = {}) {
        var _a12;
        this._propagators = (_a12 = config.propagators) !== null && _a12 !== void 0 ? _a12 : [];
        this._fields = Array.from(new Set(this._propagators.map((p2) => typeof p2.fields === "function" ? p2.fields() : []).reduce((x2, y2) => x2.concat(y2), [])));
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same carrier key, the propagator later in the list
       * will "win".
       *
       * @param context Context to inject
       * @param carrier Carrier into which context will be injected
       */
      inject(context3, carrier, setter) {
        for (const propagator of this._propagators) {
          try {
            propagator.inject(context3, carrier, setter);
          } catch (err) {
            api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
          }
        }
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same context key, the propagator later in the list
       * will "win".
       *
       * @param context Context to add values to
       * @param carrier Carrier from which to extract context
       */
      extract(context3, carrier, getter) {
        return this._propagators.reduce((ctx, propagator) => {
          try {
            return propagator.extract(ctx, carrier, getter);
          } catch (err) {
            api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
          }
          return ctx;
        }, context3);
      }
      fields() {
        return this._fields.slice();
      }
    };
    exports.CompositePropagator = CompositePropagator;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/internal/validators.js
var require_validators2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/internal/validators.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateValue = exports.validateKey = void 0;
    var VALID_KEY_CHAR_RANGE2 = "[_0-9a-z-*/]";
    var VALID_KEY2 = `[a-z]${VALID_KEY_CHAR_RANGE2}{0,255}`;
    var VALID_VENDOR_KEY2 = `[a-z0-9]${VALID_KEY_CHAR_RANGE2}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE2}{0,13}`;
    var VALID_KEY_REGEX2 = new RegExp(`^(?:${VALID_KEY2}|${VALID_VENDOR_KEY2})$`);
    var VALID_VALUE_BASE_REGEX2 = /^[ -~]{0,255}[!-~]$/;
    var INVALID_VALUE_COMMA_EQUAL_REGEX2 = /,|=/;
    function validateKey2(key) {
      return VALID_KEY_REGEX2.test(key);
    }
    exports.validateKey = validateKey2;
    function validateValue2(value) {
      return VALID_VALUE_BASE_REGEX2.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX2.test(value);
    }
    exports.validateValue = validateValue2;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/trace/TraceState.js
var require_TraceState2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/trace/TraceState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TraceState = void 0;
    var validators_1 = require_validators2();
    var MAX_TRACE_STATE_ITEMS2 = 32;
    var MAX_TRACE_STATE_LEN2 = 512;
    var LIST_MEMBERS_SEPARATOR2 = ",";
    var LIST_MEMBER_KEY_VALUE_SPLITTER2 = "=";
    var TraceState = class _TraceState {
      constructor(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      set(key, value) {
        const traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      }
      unset(key) {
        const traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      }
      get(key) {
        return this._internalState.get(key);
      }
      serialize() {
        return this._keys().reduce((agg, key) => {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER2 + this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR2);
      }
      _parse(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN2)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR2).reverse().reduce((agg, part) => {
          const listMember = part.trim();
          const i2 = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER2);
          if (i2 !== -1) {
            const key = listMember.slice(0, i2);
            const value = listMember.slice(i2 + 1, part.length);
            if ((0, validators_1.validateKey)(key) && (0, validators_1.validateValue)(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS2) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS2));
        }
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        const traceState = new _TraceState();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      }
    };
    exports.TraceState = TraceState;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js
var require_W3CTraceContextPropagator2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.W3CTraceContextPropagator = exports.parseTraceParent = exports.TRACE_STATE_HEADER = exports.TRACE_PARENT_HEADER = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing2();
    var TraceState_1 = require_TraceState2();
    exports.TRACE_PARENT_HEADER = "traceparent";
    exports.TRACE_STATE_HEADER = "tracestate";
    var VERSION2 = "00";
    var VERSION_PART = "(?!ff)[\\da-f]{2}";
    var TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}";
    var PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}";
    var FLAGS_PART = "[\\da-f]{2}";
    var TRACE_PARENT_REGEX = new RegExp(`^\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\s?$`);
    function parseTraceParent(traceParent) {
      const match4 = TRACE_PARENT_REGEX.exec(traceParent);
      if (!match4)
        return null;
      if (match4[1] === "00" && match4[5])
        return null;
      return {
        traceId: match4[2],
        spanId: match4[3],
        traceFlags: parseInt(match4[4], 16)
      };
    }
    exports.parseTraceParent = parseTraceParent;
    var W3CTraceContextPropagator = class {
      inject(context3, carrier, setter) {
        const spanContext = api_1.trace.getSpanContext(context3);
        if (!spanContext || (0, suppress_tracing_1.isTracingSuppressed)(context3) || !(0, api_1.isSpanContextValid)(spanContext))
          return;
        const traceParent = `${VERSION2}-${spanContext.traceId}-${spanContext.spanId}-0${Number(spanContext.traceFlags || api_1.TraceFlags.NONE).toString(16)}`;
        setter.set(carrier, exports.TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) {
          setter.set(carrier, exports.TRACE_STATE_HEADER, spanContext.traceState.serialize());
        }
      }
      extract(context3, carrier, getter) {
        const traceParentHeader = getter.get(carrier, exports.TRACE_PARENT_HEADER);
        if (!traceParentHeader)
          return context3;
        const traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
        if (typeof traceParent !== "string")
          return context3;
        const spanContext = parseTraceParent(traceParent);
        if (!spanContext)
          return context3;
        spanContext.isRemote = true;
        const traceStateHeader = getter.get(carrier, exports.TRACE_STATE_HEADER);
        if (traceStateHeader) {
          const state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
          spanContext.traceState = new TraceState_1.TraceState(typeof state === "string" ? state : void 0);
        }
        return api_1.trace.setSpanContext(context3, spanContext);
      }
      fields() {
        return [exports.TRACE_PARENT_HEADER, exports.TRACE_STATE_HEADER];
      }
    };
    exports.W3CTraceContextPropagator = W3CTraceContextPropagator;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/trace/IdGenerator.js
var require_IdGenerator = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/trace/IdGenerator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js
var require_rpc_metadata2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRPCMetadata = exports.deleteRPCMetadata = exports.setRPCMetadata = exports.RPCType = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var RPC_METADATA_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key RPC_METADATA");
    var RPCType;
    (function(RPCType2) {
      RPCType2["HTTP"] = "http";
    })(RPCType = exports.RPCType || (exports.RPCType = {}));
    function setRPCMetadata(context3, meta) {
      return context3.setValue(RPC_METADATA_KEY, meta);
    }
    exports.setRPCMetadata = setRPCMetadata;
    function deleteRPCMetadata(context3) {
      return context3.deleteValue(RPC_METADATA_KEY);
    }
    exports.deleteRPCMetadata = deleteRPCMetadata;
    function getRPCMetadata(context3) {
      return context3.getValue(RPC_METADATA_KEY);
    }
    exports.getRPCMetadata = getRPCMetadata;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js
var require_AlwaysOffSampler3 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AlwaysOffSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var AlwaysOffSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return "AlwaysOffSampler";
      }
    };
    exports.AlwaysOffSampler = AlwaysOffSampler;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js
var require_AlwaysOnSampler3 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AlwaysOnSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var AlwaysOnSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.RECORD_AND_SAMPLED
        };
      }
      toString() {
        return "AlwaysOnSampler";
      }
    };
    exports.AlwaysOnSampler = AlwaysOnSampler;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js
var require_ParentBasedSampler3 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParentBasedSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var global_error_handler_1 = require_global_error_handler2();
    var AlwaysOffSampler_1 = require_AlwaysOffSampler3();
    var AlwaysOnSampler_1 = require_AlwaysOnSampler3();
    var ParentBasedSampler = class {
      constructor(config) {
        var _a12, _b5, _c4, _d4;
        this._root = config.root;
        if (!this._root) {
          (0, global_error_handler_1.globalErrorHandler)(new Error("ParentBasedSampler must have a root sampler configured"));
          this._root = new AlwaysOnSampler_1.AlwaysOnSampler();
        }
        this._remoteParentSampled = (_a12 = config.remoteParentSampled) !== null && _a12 !== void 0 ? _a12 : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._remoteParentNotSampled = (_b5 = config.remoteParentNotSampled) !== null && _b5 !== void 0 ? _b5 : new AlwaysOffSampler_1.AlwaysOffSampler();
        this._localParentSampled = (_c4 = config.localParentSampled) !== null && _c4 !== void 0 ? _c4 : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._localParentNotSampled = (_d4 = config.localParentNotSampled) !== null && _d4 !== void 0 ? _d4 : new AlwaysOffSampler_1.AlwaysOffSampler();
      }
      shouldSample(context3, traceId, spanName, spanKind, attributes, links) {
        const parentContext = api_1.trace.getSpanContext(context3);
        if (!parentContext || !(0, api_1.isSpanContextValid)(parentContext)) {
          return this._root.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
          if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
            return this._remoteParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
          }
          return this._remoteParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
          return this._localParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
      }
      toString() {
        return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
      }
    };
    exports.ParentBasedSampler = ParentBasedSampler;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js
var require_TraceIdRatioBasedSampler3 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TraceIdRatioBasedSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var TraceIdRatioBasedSampler = class {
      constructor(_ratio = 0) {
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 4294967295);
      }
      shouldSample(context3, traceId) {
        return {
          decision: (0, api_1.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? api_1.SamplingDecision.RECORD_AND_SAMPLED : api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return `TraceIdRatioBased{${this._ratio}}`;
      }
      _normalize(ratio) {
        if (typeof ratio !== "number" || isNaN(ratio))
          return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
      }
      _accumulate(traceId) {
        let accumulation = 0;
        for (let i2 = 0; i2 < traceId.length / 8; i2++) {
          const pos = i2 * 8;
          const part = parseInt(traceId.slice(pos, pos + 8), 16);
          accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
      }
    };
    exports.TraceIdRatioBasedSampler = TraceIdRatioBasedSampler;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js
var require_lodash_merge2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isPlainObject = void 0;
    var objectTag = "[object Object]";
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    var objectCtorString = funcToString.call(Object);
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    var nativeObjectToString = objectProto.toString;
    function overArg(func2, transform) {
      return function(arg) {
        return func2(transform(arg));
      };
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
        return false;
      }
      const proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      const Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
    }
    exports.isPlainObject = isPlainObject;
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function getRawTag(value) {
      const isOwn = hasOwnProperty2.call(value, symToStringTag), tag2 = value[symToStringTag];
      let unmasked = false;
      try {
        value[symToStringTag] = void 0;
        unmasked = true;
      } catch (e2) {
      }
      const result4 = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag2;
        } else {
          delete value[symToStringTag];
        }
      }
      return result4;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/utils/merge.js
var require_merge2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/utils/merge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = void 0;
    var lodash_merge_1 = require_lodash_merge2();
    var MAX_LEVEL = 20;
    function merge5(...args) {
      let result4 = args.shift();
      const objects = /* @__PURE__ */ new WeakMap();
      while (args.length > 0) {
        result4 = mergeTwoObjects(result4, args.shift(), 0, objects);
      }
      return result4;
    }
    exports.merge = merge5;
    function takeValue(value) {
      if (isArray(value)) {
        return value.slice();
      }
      return value;
    }
    function mergeTwoObjects(one, two, level = 0, objects) {
      let result4;
      if (level > MAX_LEVEL) {
        return void 0;
      }
      level++;
      if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {
        result4 = takeValue(two);
      } else if (isArray(one)) {
        result4 = one.slice();
        if (isArray(two)) {
          for (let i2 = 0, j2 = two.length; i2 < j2; i2++) {
            result4.push(takeValue(two[i2]));
          }
        } else if (isObject(two)) {
          const keys4 = Object.keys(two);
          for (let i2 = 0, j2 = keys4.length; i2 < j2; i2++) {
            const key = keys4[i2];
            result4[key] = takeValue(two[key]);
          }
        }
      } else if (isObject(one)) {
        if (isObject(two)) {
          if (!shouldMerge(one, two)) {
            return two;
          }
          result4 = Object.assign({}, one);
          const keys4 = Object.keys(two);
          for (let i2 = 0, j2 = keys4.length; i2 < j2; i2++) {
            const key = keys4[i2];
            const twoValue = two[key];
            if (isPrimitive(twoValue)) {
              if (typeof twoValue === "undefined") {
                delete result4[key];
              } else {
                result4[key] = twoValue;
              }
            } else {
              const obj1 = result4[key];
              const obj2 = twoValue;
              if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {
                delete result4[key];
              } else {
                if (isObject(obj1) && isObject(obj2)) {
                  const arr1 = objects.get(obj1) || [];
                  const arr2 = objects.get(obj2) || [];
                  arr1.push({ obj: one, key });
                  arr2.push({ obj: two, key });
                  objects.set(obj1, arr1);
                  objects.set(obj2, arr2);
                }
                result4[key] = mergeTwoObjects(result4[key], twoValue, level, objects);
              }
            }
          }
        } else {
          result4 = two;
        }
      }
      return result4;
    }
    function wasObjectReferenced(obj, key, objects) {
      const arr = objects.get(obj[key]) || [];
      for (let i2 = 0, j2 = arr.length; i2 < j2; i2++) {
        const info = arr[i2];
        if (info.key === key && info.obj === obj) {
          return true;
        }
      }
      return false;
    }
    function isArray(value) {
      return Array.isArray(value);
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isObject(value) {
      return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === "object";
    }
    function isPrimitive(value) {
      return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "undefined" || value instanceof Date || value instanceof RegExp || value === null;
    }
    function shouldMerge(one, two) {
      if (!(0, lodash_merge_1.isPlainObject)(one) || !(0, lodash_merge_1.isPlainObject)(two)) {
        return false;
      }
      return true;
    }
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/utils/timeout.js
var require_timeout2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/utils/timeout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callWithTimeout = exports.TimeoutError = void 0;
    var TimeoutError = class _TimeoutError extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, _TimeoutError.prototype);
      }
    };
    exports.TimeoutError = TimeoutError;
    function callWithTimeout(promise2, timeout4) {
      let timeoutHandle;
      const timeoutPromise = new Promise(function timeoutFunction(_resolve, reject3) {
        timeoutHandle = setTimeout(function timeoutHandler() {
          reject3(new TimeoutError("Operation timed out."));
        }, timeout4);
      });
      return Promise.race([promise2, timeoutPromise]).then((result4) => {
        clearTimeout(timeoutHandle);
        return result4;
      }, (reason) => {
        clearTimeout(timeoutHandle);
        throw reason;
      });
    }
    exports.callWithTimeout = callWithTimeout;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/utils/url.js
var require_url2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/utils/url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isUrlIgnored = exports.urlMatches = void 0;
    function urlMatches(url, urlToMatch) {
      if (typeof urlToMatch === "string") {
        return url === urlToMatch;
      } else {
        return !!url.match(urlToMatch);
      }
    }
    exports.urlMatches = urlMatches;
    function isUrlIgnored(url, ignoredUrls) {
      if (!ignoredUrls) {
        return false;
      }
      for (const ignoreUrl of ignoredUrls) {
        if (urlMatches(url, ignoreUrl)) {
          return true;
        }
      }
      return false;
    }
    exports.isUrlIgnored = isUrlIgnored;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/utils/wrap.js
var require_wrap2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/utils/wrap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isWrapped = void 0;
    function isWrapped(func2) {
      return typeof func2 === "function" && typeof func2.__original === "function" && typeof func2.__unwrap === "function" && func2.__wrapped === true;
    }
    exports.isWrapped = isWrapped;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/utils/promise.js
var require_promise2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/utils/promise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Deferred = void 0;
    var Deferred = class {
      constructor() {
        this._promise = new Promise((resolve, reject3) => {
          this._resolve = resolve;
          this._reject = reject3;
        });
      }
      get promise() {
        return this._promise;
      }
      resolve(val) {
        this._resolve(val);
      }
      reject(err) {
        this._reject(err);
      }
    };
    exports.Deferred = Deferred;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/utils/callback.js
var require_callback2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/utils/callback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BindOnceFuture = void 0;
    var promise_1 = require_promise2();
    var BindOnceFuture = class {
      constructor(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new promise_1.Deferred();
      }
      get isCalled() {
        return this._isCalled;
      }
      get promise() {
        return this._deferred.promise;
      }
      call(...args) {
        if (!this._isCalled) {
          this._isCalled = true;
          try {
            Promise.resolve(this._callback.call(this._that, ...args)).then((val) => this._deferred.resolve(val), (err) => this._deferred.reject(err));
          } catch (err) {
            this._deferred.reject(err);
          }
        }
        return this._deferred.promise;
      }
    };
    exports.BindOnceFuture = BindOnceFuture;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/internal/exporter.js
var require_exporter2 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/internal/exporter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._export = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing2();
    function _export(exporter, arg) {
      return new Promise((resolve) => {
        api_1.context.with((0, suppress_tracing_1.suppressTracing)(api_1.context.active()), () => {
          exporter.export(arg, (result4) => {
            resolve(result4);
          });
        });
      });
    }
    exports._export = _export;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/index.js
var require_src5 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/node_modules/@opentelemetry/core/build/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.internal = exports.baggageUtils = void 0;
    __exportStar(require_W3CBaggagePropagator2(), exports);
    __exportStar(require_anchored_clock2(), exports);
    __exportStar(require_attributes2(), exports);
    __exportStar(require_global_error_handler2(), exports);
    __exportStar(require_logging_error_handler2(), exports);
    __exportStar(require_time2(), exports);
    __exportStar(require_types(), exports);
    __exportStar(require_hex_to_binary2(), exports);
    __exportStar(require_ExportResult2(), exports);
    exports.baggageUtils = require_utils4();
    __exportStar(require_platform5(), exports);
    __exportStar(require_composite2(), exports);
    __exportStar(require_W3CTraceContextPropagator2(), exports);
    __exportStar(require_IdGenerator(), exports);
    __exportStar(require_rpc_metadata2(), exports);
    __exportStar(require_AlwaysOffSampler3(), exports);
    __exportStar(require_AlwaysOnSampler3(), exports);
    __exportStar(require_ParentBasedSampler3(), exports);
    __exportStar(require_TraceIdRatioBasedSampler3(), exports);
    __exportStar(require_suppress_tracing2(), exports);
    __exportStar(require_TraceState2(), exports);
    __exportStar(require_environment3(), exports);
    __exportStar(require_merge2(), exports);
    __exportStar(require_sampling2(), exports);
    __exportStar(require_timeout2(), exports);
    __exportStar(require_url2(), exports);
    __exportStar(require_wrap2(), exports);
    __exportStar(require_callback2(), exports);
    __exportStar(require_version2(), exports);
    var exporter_1 = require_exporter2();
    exports.internal = {
      _export: exporter_1._export
    };
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js
var require_suppress_tracing3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTracingSuppressed = exports.unsuppressTracing = exports.suppressTracing = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var SUPPRESS_TRACING_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
    function suppressTracing(context3) {
      return context3.setValue(SUPPRESS_TRACING_KEY, true);
    }
    exports.suppressTracing = suppressTracing;
    function unsuppressTracing(context3) {
      return context3.deleteValue(SUPPRESS_TRACING_KEY);
    }
    exports.unsuppressTracing = unsuppressTracing;
    function isTracingSuppressed(context3) {
      return context3.getValue(SUPPRESS_TRACING_KEY) === true;
    }
    exports.isTracingSuppressed = isTracingSuppressed;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/baggage/constants.js
var require_constants3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/baggage/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BAGGAGE_MAX_TOTAL_LENGTH = exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = exports.BAGGAGE_HEADER = exports.BAGGAGE_ITEMS_SEPARATOR = exports.BAGGAGE_PROPERTIES_SEPARATOR = exports.BAGGAGE_KEY_PAIR_SEPARATOR = void 0;
    exports.BAGGAGE_KEY_PAIR_SEPARATOR = "=";
    exports.BAGGAGE_PROPERTIES_SEPARATOR = ";";
    exports.BAGGAGE_ITEMS_SEPARATOR = ",";
    exports.BAGGAGE_HEADER = "baggage";
    exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
    exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
    exports.BAGGAGE_MAX_TOTAL_LENGTH = 8192;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/baggage/utils.js
var require_utils6 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/baggage/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseKeyPairsIntoRecord = exports.parsePairKeyValue = exports.getKeyPairs = exports.serializeKeyPairs = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var constants_1 = require_constants3();
    function serializeKeyPairs(keyPairs) {
      return keyPairs.reduce((hValue, current) => {
        const value = `${hValue}${hValue !== "" ? constants_1.BAGGAGE_ITEMS_SEPARATOR : ""}${current}`;
        return value.length > constants_1.BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
      }, "");
    }
    exports.serializeKeyPairs = serializeKeyPairs;
    function getKeyPairs(baggage) {
      return baggage.getAllEntries().map(([key, value]) => {
        let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;
        if (value.metadata !== void 0) {
          entry += constants_1.BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
        }
        return entry;
      });
    }
    exports.getKeyPairs = getKeyPairs;
    function parsePairKeyValue(entry) {
      const valueProps = entry.split(constants_1.BAGGAGE_PROPERTIES_SEPARATOR);
      if (valueProps.length <= 0)
        return;
      const keyPairPart = valueProps.shift();
      if (!keyPairPart)
        return;
      const separatorIndex = keyPairPart.indexOf(constants_1.BAGGAGE_KEY_PAIR_SEPARATOR);
      if (separatorIndex <= 0)
        return;
      const key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
      const value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
      let metadata;
      if (valueProps.length > 0) {
        metadata = (0, api_1.baggageEntryMetadataFromString)(valueProps.join(constants_1.BAGGAGE_PROPERTIES_SEPARATOR));
      }
      return { key, value, metadata };
    }
    exports.parsePairKeyValue = parsePairKeyValue;
    function parseKeyPairsIntoRecord(value) {
      if (typeof value !== "string" || value.length === 0)
        return {};
      return value.split(constants_1.BAGGAGE_ITEMS_SEPARATOR).map((entry) => {
        return parsePairKeyValue(entry);
      }).filter((keyPair) => keyPair !== void 0 && keyPair.value.length > 0).reduce((headers, keyPair) => {
        headers[keyPair.key] = keyPair.value;
        return headers;
      }, {});
    }
    exports.parseKeyPairsIntoRecord = parseKeyPairsIntoRecord;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js
var require_W3CBaggagePropagator3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.W3CBaggagePropagator = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing3();
    var constants_1 = require_constants3();
    var utils_1 = require_utils6();
    var W3CBaggagePropagator = class {
      inject(context3, carrier, setter) {
        const baggage = api_1.propagation.getBaggage(context3);
        if (!baggage || (0, suppress_tracing_1.isTracingSuppressed)(context3))
          return;
        const keyPairs = (0, utils_1.getKeyPairs)(baggage).filter((pair) => {
          return pair.length <= constants_1.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
        }).slice(0, constants_1.BAGGAGE_MAX_NAME_VALUE_PAIRS);
        const headerValue = (0, utils_1.serializeKeyPairs)(keyPairs);
        if (headerValue.length > 0) {
          setter.set(carrier, constants_1.BAGGAGE_HEADER, headerValue);
        }
      }
      extract(context3, carrier, getter) {
        const headerValue = getter.get(carrier, constants_1.BAGGAGE_HEADER);
        const baggageString = Array.isArray(headerValue) ? headerValue.join(constants_1.BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString)
          return context3;
        const baggage = {};
        if (baggageString.length === 0) {
          return context3;
        }
        const pairs = baggageString.split(constants_1.BAGGAGE_ITEMS_SEPARATOR);
        pairs.forEach((entry) => {
          const keyPair = (0, utils_1.parsePairKeyValue)(entry);
          if (keyPair) {
            const baggageEntry = { value: keyPair.value };
            if (keyPair.metadata) {
              baggageEntry.metadata = keyPair.metadata;
            }
            baggage[keyPair.key] = baggageEntry;
          }
        });
        if (Object.entries(baggage).length === 0) {
          return context3;
        }
        return api_1.propagation.setBaggage(context3, api_1.propagation.createBaggage(baggage));
      }
      fields() {
        return [constants_1.BAGGAGE_HEADER];
      }
    };
    exports.W3CBaggagePropagator = W3CBaggagePropagator;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/common/anchored-clock.js
var require_anchored_clock3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/common/anchored-clock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnchoredClock = void 0;
    var AnchoredClock = class {
      /**
       * Create a new AnchoredClock anchored to the current time returned by systemClock.
       *
       * @param systemClock should be a clock that returns the number of milliseconds since January 1 1970 such as Date
       * @param monotonicClock should be a clock that counts milliseconds monotonically such as window.performance or perf_hooks.performance
       */
      constructor(systemClock, monotonicClock) {
        this._monotonicClock = monotonicClock;
        this._epochMillis = systemClock.now();
        this._performanceMillis = monotonicClock.now();
      }
      /**
       * Returns the current time by adding the number of milliseconds since the
       * AnchoredClock was created to the creation epoch time
       */
      now() {
        const delta = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + delta;
      }
    };
    exports.AnchoredClock = AnchoredClock;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/common/attributes.js
var require_attributes3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/common/attributes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAttributeValue = exports.isAttributeKey = exports.sanitizeAttributes = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    function sanitizeAttributes(attributes) {
      const out = {};
      if (typeof attributes !== "object" || attributes == null) {
        return out;
      }
      for (const [key, val] of Object.entries(attributes)) {
        if (!isAttributeKey(key)) {
          api_1.diag.warn(`Invalid attribute key: ${key}`);
          continue;
        }
        if (!isAttributeValue(val)) {
          api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
          continue;
        }
        if (Array.isArray(val)) {
          out[key] = val.slice();
        } else {
          out[key] = val;
        }
      }
      return out;
    }
    exports.sanitizeAttributes = sanitizeAttributes;
    function isAttributeKey(key) {
      return typeof key === "string" && key.length > 0;
    }
    exports.isAttributeKey = isAttributeKey;
    function isAttributeValue(val) {
      if (val == null) {
        return true;
      }
      if (Array.isArray(val)) {
        return isHomogeneousAttributeValueArray(val);
      }
      return isValidPrimitiveAttributeValue(val);
    }
    exports.isAttributeValue = isAttributeValue;
    function isHomogeneousAttributeValueArray(arr) {
      let type;
      for (const element of arr) {
        if (element == null)
          continue;
        if (!type) {
          if (isValidPrimitiveAttributeValue(element)) {
            type = typeof element;
            continue;
          }
          return false;
        }
        if (typeof element === type) {
          continue;
        }
        return false;
      }
      return true;
    }
    function isValidPrimitiveAttributeValue(val) {
      switch (typeof val) {
        case "number":
        case "boolean":
        case "string":
          return true;
      }
      return false;
    }
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js
var require_logging_error_handler3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loggingErrorHandler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    function loggingErrorHandler() {
      return (ex) => {
        api_1.diag.error(stringifyException(ex));
      };
    }
    exports.loggingErrorHandler = loggingErrorHandler;
    function stringifyException(ex) {
      if (typeof ex === "string") {
        return ex;
      } else {
        return JSON.stringify(flattenException(ex));
      }
    }
    function flattenException(ex) {
      const result4 = {};
      let current = ex;
      while (current !== null) {
        Object.getOwnPropertyNames(current).forEach((propertyName) => {
          if (result4[propertyName])
            return;
          const value = current[propertyName];
          if (value) {
            result4[propertyName] = String(value);
          }
        });
        current = Object.getPrototypeOf(current);
      }
      return result4;
    }
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/common/global-error-handler.js
var require_global_error_handler3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/common/global-error-handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.globalErrorHandler = exports.setGlobalErrorHandler = void 0;
    var logging_error_handler_1 = require_logging_error_handler3();
    var delegateHandler = (0, logging_error_handler_1.loggingErrorHandler)();
    function setGlobalErrorHandler(handler) {
      delegateHandler = handler;
    }
    exports.setGlobalErrorHandler = setGlobalErrorHandler;
    function globalErrorHandler(ex) {
      try {
        delegateHandler(ex);
      } catch (_a12) {
      }
    }
    exports.globalErrorHandler = globalErrorHandler;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/utils/sampling.js
var require_sampling3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/utils/sampling.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TracesSamplerValues = void 0;
    var TracesSamplerValues;
    (function(TracesSamplerValues2) {
      TracesSamplerValues2["AlwaysOff"] = "always_off";
      TracesSamplerValues2["AlwaysOn"] = "always_on";
      TracesSamplerValues2["ParentBasedAlwaysOff"] = "parentbased_always_off";
      TracesSamplerValues2["ParentBasedAlwaysOn"] = "parentbased_always_on";
      TracesSamplerValues2["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
      TracesSamplerValues2["TraceIdRatio"] = "traceidratio";
    })(TracesSamplerValues = exports.TracesSamplerValues || (exports.TracesSamplerValues = {}));
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/utils/environment.js
var require_environment5 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/utils/environment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseEnvironment = exports.DEFAULT_ENVIRONMENT = exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var sampling_1 = require_sampling3();
    var DEFAULT_LIST_SEPARATOR = ",";
    var ENVIRONMENT_BOOLEAN_KEYS = ["OTEL_SDK_DISABLED"];
    function isEnvVarABoolean(key) {
      return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_NUMBERS_KEYS = [
      "OTEL_BSP_EXPORT_TIMEOUT",
      "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BSP_MAX_QUEUE_SIZE",
      "OTEL_BSP_SCHEDULE_DELAY",
      "OTEL_BLRP_EXPORT_TIMEOUT",
      "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BLRP_MAX_QUEUE_SIZE",
      "OTEL_BLRP_SCHEDULE_DELAY",
      "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_LINK_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT",
      "OTEL_EXPORTER_OTLP_TIMEOUT",
      "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
      "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
      "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT",
      "OTEL_EXPORTER_JAEGER_AGENT_PORT"
    ];
    function isEnvVarANumber(key) {
      return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_LISTS_KEYS = [
      "OTEL_NO_PATCH_MODULES",
      "OTEL_PROPAGATORS"
    ];
    function isEnvVarAList(key) {
      return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
    }
    exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
    exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
    exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
    exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
    exports.DEFAULT_ENVIRONMENT = {
      OTEL_SDK_DISABLED: false,
      CONTAINER_NAME: "",
      ECS_CONTAINER_METADATA_URI_V4: "",
      ECS_CONTAINER_METADATA_URI: "",
      HOSTNAME: "",
      KUBERNETES_SERVICE_HOST: "",
      NAMESPACE: "",
      OTEL_BSP_EXPORT_TIMEOUT: 3e4,
      OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BSP_MAX_QUEUE_SIZE: 2048,
      OTEL_BSP_SCHEDULE_DELAY: 5e3,
      OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
      OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
      OTEL_BLRP_SCHEDULE_DELAY: 5e3,
      OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
      OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
      OTEL_EXPORTER_JAEGER_ENDPOINT: "",
      OTEL_EXPORTER_JAEGER_PASSWORD: "",
      OTEL_EXPORTER_JAEGER_USER: "",
      OTEL_EXPORTER_OTLP_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_HEADERS: "",
      OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
      OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
      OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
      OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
      OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
      OTEL_LOG_LEVEL: api_1.DiagLogLevel.INFO,
      OTEL_NO_PATCH_MODULES: [],
      OTEL_PROPAGATORS: ["tracecontext", "baggage"],
      OTEL_RESOURCE_ATTRIBUTES: "",
      OTEL_SERVICE_NAME: "",
      OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
      OTEL_SPAN_LINK_COUNT_LIMIT: 128,
      OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
      OTEL_TRACES_EXPORTER: "",
      OTEL_TRACES_SAMPLER: sampling_1.TracesSamplerValues.ParentBasedAlwaysOn,
      OTEL_TRACES_SAMPLER_ARG: "",
      OTEL_LOGS_EXPORTER: "",
      OTEL_EXPORTER_OTLP_INSECURE: "",
      OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
      OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
      OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
      OTEL_EXPORTER_OTLP_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative"
    };
    function parseBoolean(key, environment5, values3) {
      if (typeof values3[key] === "undefined") {
        return;
      }
      const value = String(values3[key]);
      environment5[key] = value.toLowerCase() === "true";
    }
    function parseNumber(name, environment5, values3, min2 = -Infinity, max2 = Infinity) {
      if (typeof values3[name] !== "undefined") {
        const value = Number(values3[name]);
        if (!isNaN(value)) {
          if (value < min2) {
            environment5[name] = min2;
          } else if (value > max2) {
            environment5[name] = max2;
          } else {
            environment5[name] = value;
          }
        }
      }
    }
    function parseStringList(name, output, input, separator = DEFAULT_LIST_SEPARATOR) {
      const givenValue = input[name];
      if (typeof givenValue === "string") {
        output[name] = givenValue.split(separator).map((v2) => v2.trim());
      }
    }
    var logLevelMap = {
      ALL: api_1.DiagLogLevel.ALL,
      VERBOSE: api_1.DiagLogLevel.VERBOSE,
      DEBUG: api_1.DiagLogLevel.DEBUG,
      INFO: api_1.DiagLogLevel.INFO,
      WARN: api_1.DiagLogLevel.WARN,
      ERROR: api_1.DiagLogLevel.ERROR,
      NONE: api_1.DiagLogLevel.NONE
    };
    function setLogLevelFromEnv(key, environment5, values3) {
      const value = values3[key];
      if (typeof value === "string") {
        const theLevel = logLevelMap[value.toUpperCase()];
        if (theLevel != null) {
          environment5[key] = theLevel;
        }
      }
    }
    function parseEnvironment(values3) {
      const environment5 = {};
      for (const env in exports.DEFAULT_ENVIRONMENT) {
        const key = env;
        switch (key) {
          case "OTEL_LOG_LEVEL":
            setLogLevelFromEnv(key, environment5, values3);
            break;
          default:
            if (isEnvVarABoolean(key)) {
              parseBoolean(key, environment5, values3);
            } else if (isEnvVarANumber(key)) {
              parseNumber(key, environment5, values3);
            } else if (isEnvVarAList(key)) {
              parseStringList(key, environment5, values3);
            } else {
              const value = values3[key];
              if (typeof value !== "undefined" && value !== null) {
                environment5[key] = String(value);
              }
            }
        }
      }
      return environment5;
    }
    exports.parseEnvironment = parseEnvironment;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/environment.js
var require_environment6 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/environment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnvWithoutDefaults = exports.getEnv = void 0;
    var environment_1 = require_environment5();
    function getEnv() {
      const processEnv = (0, environment_1.parseEnvironment)(process.env);
      return Object.assign({}, environment_1.DEFAULT_ENVIRONMENT, processEnv);
    }
    exports.getEnv = getEnv;
    function getEnvWithoutDefaults() {
      return (0, environment_1.parseEnvironment)(process.env);
    }
    exports.getEnvWithoutDefaults = getEnvWithoutDefaults;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js
var require_globalThis3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._globalThis = void 0;
    exports._globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/common/hex-to-binary.js
var require_hex_to_binary3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/common/hex-to-binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hexToBinary = void 0;
    function intValue(charCode) {
      if (charCode >= 48 && charCode <= 57) {
        return charCode - 48;
      }
      if (charCode >= 97 && charCode <= 102) {
        return charCode - 87;
      }
      return charCode - 55;
    }
    function hexToBinary(hexStr) {
      const buf = new Uint8Array(hexStr.length / 2);
      let offset = 0;
      for (let i2 = 0; i2 < hexStr.length; i2 += 2) {
        const hi = intValue(hexStr.charCodeAt(i2));
        const lo = intValue(hexStr.charCodeAt(i2 + 1));
        buf[offset++] = hi << 4 | lo;
      }
      return buf;
    }
    exports.hexToBinary = hexToBinary;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js
var require_hex_to_base643 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hexToBase64 = void 0;
    var hex_to_binary_1 = require_hex_to_binary3();
    function hexToBase64(hexStr) {
      return Buffer.from((0, hex_to_binary_1.hexToBinary)(hexStr)).toString("base64");
    }
    exports.hexToBase64 = hexToBase64;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js
var require_RandomIdGenerator4 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RandomIdGenerator = void 0;
    var SPAN_ID_BYTES = 8;
    var TRACE_ID_BYTES = 16;
    var RandomIdGenerator = class {
      constructor() {
        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
        this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
      }
    };
    exports.RandomIdGenerator = RandomIdGenerator;
    var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
    function getIdGenerator(bytes) {
      return function generateId() {
        for (let i2 = 0; i2 < bytes / 4; i2++) {
          SHARED_BUFFER.writeUInt32BE(Math.random() * 2 ** 32 >>> 0, i2 * 4);
        }
        for (let i2 = 0; i2 < bytes; i2++) {
          if (SHARED_BUFFER[i2] > 0) {
            break;
          } else if (i2 === bytes - 1) {
            SHARED_BUFFER[bytes - 1] = 1;
          }
        }
        return SHARED_BUFFER.toString("hex", 0, bytes);
      };
    }
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/performance.js
var require_performance3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/performance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.otperformance = void 0;
    var perf_hooks_1 = __require("perf_hooks");
    exports.otperformance = perf_hooks_1.performance;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/version.js
var require_version3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VERSION = void 0;
    exports.VERSION = "1.24.1";
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/src/internal/utils.js
var require_utils7 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/src/internal/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConstMap = void 0;
    // @__NO_SIDE_EFFECTS__
    function createConstMap2(values3) {
      let res = {};
      const len = values3.length;
      for (let lp = 0; lp < len; lp++) {
        const val = values3[lp];
        if (val) {
          res[String(val).toUpperCase().replace(/[-.]/g, "_")] = val;
        }
      }
      return res;
    }
    exports.createConstMap = createConstMap2;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js
var require_SemanticAttributes2 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SEMATTRS_NET_HOST_CARRIER_ICC = exports.SEMATTRS_NET_HOST_CARRIER_MNC = exports.SEMATTRS_NET_HOST_CARRIER_MCC = exports.SEMATTRS_NET_HOST_CARRIER_NAME = exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = exports.SEMATTRS_NET_HOST_NAME = exports.SEMATTRS_NET_HOST_PORT = exports.SEMATTRS_NET_HOST_IP = exports.SEMATTRS_NET_PEER_NAME = exports.SEMATTRS_NET_PEER_PORT = exports.SEMATTRS_NET_PEER_IP = exports.SEMATTRS_NET_TRANSPORT = exports.SEMATTRS_FAAS_INVOKED_REGION = exports.SEMATTRS_FAAS_INVOKED_PROVIDER = exports.SEMATTRS_FAAS_INVOKED_NAME = exports.SEMATTRS_FAAS_COLDSTART = exports.SEMATTRS_FAAS_CRON = exports.SEMATTRS_FAAS_TIME = exports.SEMATTRS_FAAS_DOCUMENT_NAME = exports.SEMATTRS_FAAS_DOCUMENT_TIME = exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = exports.SEMATTRS_FAAS_EXECUTION = exports.SEMATTRS_FAAS_TRIGGER = exports.SEMATTRS_EXCEPTION_ESCAPED = exports.SEMATTRS_EXCEPTION_STACKTRACE = exports.SEMATTRS_EXCEPTION_MESSAGE = exports.SEMATTRS_EXCEPTION_TYPE = exports.SEMATTRS_DB_SQL_TABLE = exports.SEMATTRS_DB_MONGODB_COLLECTION = exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = exports.SEMATTRS_DB_HBASE_NAMESPACE = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = exports.SEMATTRS_DB_CASSANDRA_TABLE = exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = exports.SEMATTRS_DB_OPERATION = exports.SEMATTRS_DB_STATEMENT = exports.SEMATTRS_DB_NAME = exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = exports.SEMATTRS_DB_USER = exports.SEMATTRS_DB_CONNECTION_STRING = exports.SEMATTRS_DB_SYSTEM = exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = void 0;
    exports.SEMATTRS_MESSAGING_DESTINATION_KIND = exports.SEMATTRS_MESSAGING_DESTINATION = exports.SEMATTRS_MESSAGING_SYSTEM = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = exports.SEMATTRS_AWS_DYNAMODB_COUNT = exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_SELECT = exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = exports.SEMATTRS_AWS_DYNAMODB_LIMIT = exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = exports.SEMATTRS_HTTP_CLIENT_IP = exports.SEMATTRS_HTTP_ROUTE = exports.SEMATTRS_HTTP_SERVER_NAME = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = exports.SEMATTRS_HTTP_USER_AGENT = exports.SEMATTRS_HTTP_FLAVOR = exports.SEMATTRS_HTTP_STATUS_CODE = exports.SEMATTRS_HTTP_SCHEME = exports.SEMATTRS_HTTP_HOST = exports.SEMATTRS_HTTP_TARGET = exports.SEMATTRS_HTTP_URL = exports.SEMATTRS_HTTP_METHOD = exports.SEMATTRS_CODE_LINENO = exports.SEMATTRS_CODE_FILEPATH = exports.SEMATTRS_CODE_NAMESPACE = exports.SEMATTRS_CODE_FUNCTION = exports.SEMATTRS_THREAD_NAME = exports.SEMATTRS_THREAD_ID = exports.SEMATTRS_ENDUSER_SCOPE = exports.SEMATTRS_ENDUSER_ROLE = exports.SEMATTRS_ENDUSER_ID = exports.SEMATTRS_PEER_SERVICE = void 0;
    exports.DBSYSTEMVALUES_FILEMAKER = exports.DBSYSTEMVALUES_DERBY = exports.DBSYSTEMVALUES_FIREBIRD = exports.DBSYSTEMVALUES_ADABAS = exports.DBSYSTEMVALUES_CACHE = exports.DBSYSTEMVALUES_EDB = exports.DBSYSTEMVALUES_FIRSTSQL = exports.DBSYSTEMVALUES_INGRES = exports.DBSYSTEMVALUES_HANADB = exports.DBSYSTEMVALUES_MAXDB = exports.DBSYSTEMVALUES_PROGRESS = exports.DBSYSTEMVALUES_HSQLDB = exports.DBSYSTEMVALUES_CLOUDSCAPE = exports.DBSYSTEMVALUES_HIVE = exports.DBSYSTEMVALUES_REDSHIFT = exports.DBSYSTEMVALUES_POSTGRESQL = exports.DBSYSTEMVALUES_DB2 = exports.DBSYSTEMVALUES_ORACLE = exports.DBSYSTEMVALUES_MYSQL = exports.DBSYSTEMVALUES_MSSQL = exports.DBSYSTEMVALUES_OTHER_SQL = exports.SemanticAttributes = exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_ID = exports.SEMATTRS_MESSAGE_TYPE = exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = exports.SEMATTRS_RPC_JSONRPC_VERSION = exports.SEMATTRS_RPC_GRPC_STATUS_CODE = exports.SEMATTRS_RPC_METHOD = exports.SEMATTRS_RPC_SERVICE = exports.SEMATTRS_RPC_SYSTEM = exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = exports.SEMATTRS_MESSAGING_CONSUMER_ID = exports.SEMATTRS_MESSAGING_OPERATION = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = exports.SEMATTRS_MESSAGING_CONVERSATION_ID = exports.SEMATTRS_MESSAGING_MESSAGE_ID = exports.SEMATTRS_MESSAGING_URL = exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = exports.SEMATTRS_MESSAGING_PROTOCOL = exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = void 0;
    exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = exports.FaasDocumentOperationValues = exports.FAASDOCUMENTOPERATIONVALUES_DELETE = exports.FAASDOCUMENTOPERATIONVALUES_EDIT = exports.FAASDOCUMENTOPERATIONVALUES_INSERT = exports.FaasTriggerValues = exports.FAASTRIGGERVALUES_OTHER = exports.FAASTRIGGERVALUES_TIMER = exports.FAASTRIGGERVALUES_PUBSUB = exports.FAASTRIGGERVALUES_HTTP = exports.FAASTRIGGERVALUES_DATASOURCE = exports.DbCassandraConsistencyLevelValues = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = exports.DbSystemValues = exports.DBSYSTEMVALUES_COCKROACHDB = exports.DBSYSTEMVALUES_MEMCACHED = exports.DBSYSTEMVALUES_ELASTICSEARCH = exports.DBSYSTEMVALUES_GEODE = exports.DBSYSTEMVALUES_NEO4J = exports.DBSYSTEMVALUES_DYNAMODB = exports.DBSYSTEMVALUES_COSMOSDB = exports.DBSYSTEMVALUES_COUCHDB = exports.DBSYSTEMVALUES_COUCHBASE = exports.DBSYSTEMVALUES_REDIS = exports.DBSYSTEMVALUES_MONGODB = exports.DBSYSTEMVALUES_HBASE = exports.DBSYSTEMVALUES_CASSANDRA = exports.DBSYSTEMVALUES_COLDFUSION = exports.DBSYSTEMVALUES_H2 = exports.DBSYSTEMVALUES_VERTICA = exports.DBSYSTEMVALUES_TERADATA = exports.DBSYSTEMVALUES_SYBASE = exports.DBSYSTEMVALUES_SQLITE = exports.DBSYSTEMVALUES_POINTBASE = exports.DBSYSTEMVALUES_PERVASIVE = exports.DBSYSTEMVALUES_NETEZZA = exports.DBSYSTEMVALUES_MARIADB = exports.DBSYSTEMVALUES_INTERBASE = exports.DBSYSTEMVALUES_INSTANTDB = exports.DBSYSTEMVALUES_INFORMIX = void 0;
    exports.MESSAGINGOPERATIONVALUES_RECEIVE = exports.MessagingDestinationKindValues = exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = exports.HttpFlavorValues = exports.HTTPFLAVORVALUES_QUIC = exports.HTTPFLAVORVALUES_SPDY = exports.HTTPFLAVORVALUES_HTTP_2_0 = exports.HTTPFLAVORVALUES_HTTP_1_1 = exports.HTTPFLAVORVALUES_HTTP_1_0 = exports.NetHostConnectionSubtypeValues = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = exports.NetHostConnectionTypeValues = exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = exports.NETHOSTCONNECTIONTYPEVALUES_CELL = exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = exports.NetTransportValues = exports.NETTRANSPORTVALUES_OTHER = exports.NETTRANSPORTVALUES_INPROC = exports.NETTRANSPORTVALUES_PIPE = exports.NETTRANSPORTVALUES_UNIX = exports.NETTRANSPORTVALUES_IP = exports.NETTRANSPORTVALUES_IP_UDP = exports.NETTRANSPORTVALUES_IP_TCP = exports.FaasInvokedProviderValues = exports.FAASINVOKEDPROVIDERVALUES_GCP = exports.FAASINVOKEDPROVIDERVALUES_AZURE = exports.FAASINVOKEDPROVIDERVALUES_AWS = void 0;
    exports.MessageTypeValues = exports.MESSAGETYPEVALUES_RECEIVED = exports.MESSAGETYPEVALUES_SENT = exports.RpcGrpcStatusCodeValues = exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = exports.RPCGRPCSTATUSCODEVALUES_ABORTED = exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = exports.RPCGRPCSTATUSCODEVALUES_OK = exports.MessagingOperationValues = exports.MESSAGINGOPERATIONVALUES_PROCESS = void 0;
    var utils_1 = require_utils7();
    var TMP_AWS_LAMBDA_INVOKED_ARN2 = "aws.lambda.invoked_arn";
    var TMP_DB_SYSTEM2 = "db.system";
    var TMP_DB_CONNECTION_STRING2 = "db.connection_string";
    var TMP_DB_USER2 = "db.user";
    var TMP_DB_JDBC_DRIVER_CLASSNAME2 = "db.jdbc.driver_classname";
    var TMP_DB_NAME2 = "db.name";
    var TMP_DB_STATEMENT2 = "db.statement";
    var TMP_DB_OPERATION2 = "db.operation";
    var TMP_DB_MSSQL_INSTANCE_NAME2 = "db.mssql.instance_name";
    var TMP_DB_CASSANDRA_KEYSPACE2 = "db.cassandra.keyspace";
    var TMP_DB_CASSANDRA_PAGE_SIZE2 = "db.cassandra.page_size";
    var TMP_DB_CASSANDRA_CONSISTENCY_LEVEL2 = "db.cassandra.consistency_level";
    var TMP_DB_CASSANDRA_TABLE2 = "db.cassandra.table";
    var TMP_DB_CASSANDRA_IDEMPOTENCE2 = "db.cassandra.idempotence";
    var TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT2 = "db.cassandra.speculative_execution_count";
    var TMP_DB_CASSANDRA_COORDINATOR_ID2 = "db.cassandra.coordinator.id";
    var TMP_DB_CASSANDRA_COORDINATOR_DC2 = "db.cassandra.coordinator.dc";
    var TMP_DB_HBASE_NAMESPACE2 = "db.hbase.namespace";
    var TMP_DB_REDIS_DATABASE_INDEX2 = "db.redis.database_index";
    var TMP_DB_MONGODB_COLLECTION2 = "db.mongodb.collection";
    var TMP_DB_SQL_TABLE2 = "db.sql.table";
    var TMP_EXCEPTION_TYPE2 = "exception.type";
    var TMP_EXCEPTION_MESSAGE2 = "exception.message";
    var TMP_EXCEPTION_STACKTRACE2 = "exception.stacktrace";
    var TMP_EXCEPTION_ESCAPED2 = "exception.escaped";
    var TMP_FAAS_TRIGGER2 = "faas.trigger";
    var TMP_FAAS_EXECUTION2 = "faas.execution";
    var TMP_FAAS_DOCUMENT_COLLECTION2 = "faas.document.collection";
    var TMP_FAAS_DOCUMENT_OPERATION2 = "faas.document.operation";
    var TMP_FAAS_DOCUMENT_TIME2 = "faas.document.time";
    var TMP_FAAS_DOCUMENT_NAME2 = "faas.document.name";
    var TMP_FAAS_TIME2 = "faas.time";
    var TMP_FAAS_CRON2 = "faas.cron";
    var TMP_FAAS_COLDSTART2 = "faas.coldstart";
    var TMP_FAAS_INVOKED_NAME2 = "faas.invoked_name";
    var TMP_FAAS_INVOKED_PROVIDER2 = "faas.invoked_provider";
    var TMP_FAAS_INVOKED_REGION2 = "faas.invoked_region";
    var TMP_NET_TRANSPORT2 = "net.transport";
    var TMP_NET_PEER_IP2 = "net.peer.ip";
    var TMP_NET_PEER_PORT2 = "net.peer.port";
    var TMP_NET_PEER_NAME2 = "net.peer.name";
    var TMP_NET_HOST_IP2 = "net.host.ip";
    var TMP_NET_HOST_PORT2 = "net.host.port";
    var TMP_NET_HOST_NAME2 = "net.host.name";
    var TMP_NET_HOST_CONNECTION_TYPE2 = "net.host.connection.type";
    var TMP_NET_HOST_CONNECTION_SUBTYPE2 = "net.host.connection.subtype";
    var TMP_NET_HOST_CARRIER_NAME2 = "net.host.carrier.name";
    var TMP_NET_HOST_CARRIER_MCC2 = "net.host.carrier.mcc";
    var TMP_NET_HOST_CARRIER_MNC2 = "net.host.carrier.mnc";
    var TMP_NET_HOST_CARRIER_ICC2 = "net.host.carrier.icc";
    var TMP_PEER_SERVICE2 = "peer.service";
    var TMP_ENDUSER_ID2 = "enduser.id";
    var TMP_ENDUSER_ROLE2 = "enduser.role";
    var TMP_ENDUSER_SCOPE2 = "enduser.scope";
    var TMP_THREAD_ID2 = "thread.id";
    var TMP_THREAD_NAME2 = "thread.name";
    var TMP_CODE_FUNCTION2 = "code.function";
    var TMP_CODE_NAMESPACE2 = "code.namespace";
    var TMP_CODE_FILEPATH2 = "code.filepath";
    var TMP_CODE_LINENO2 = "code.lineno";
    var TMP_HTTP_METHOD2 = "http.method";
    var TMP_HTTP_URL2 = "http.url";
    var TMP_HTTP_TARGET2 = "http.target";
    var TMP_HTTP_HOST2 = "http.host";
    var TMP_HTTP_SCHEME2 = "http.scheme";
    var TMP_HTTP_STATUS_CODE2 = "http.status_code";
    var TMP_HTTP_FLAVOR2 = "http.flavor";
    var TMP_HTTP_USER_AGENT2 = "http.user_agent";
    var TMP_HTTP_REQUEST_CONTENT_LENGTH2 = "http.request_content_length";
    var TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED2 = "http.request_content_length_uncompressed";
    var TMP_HTTP_RESPONSE_CONTENT_LENGTH2 = "http.response_content_length";
    var TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2 = "http.response_content_length_uncompressed";
    var TMP_HTTP_SERVER_NAME2 = "http.server_name";
    var TMP_HTTP_ROUTE2 = "http.route";
    var TMP_HTTP_CLIENT_IP2 = "http.client_ip";
    var TMP_AWS_DYNAMODB_TABLE_NAMES2 = "aws.dynamodb.table_names";
    var TMP_AWS_DYNAMODB_CONSUMED_CAPACITY2 = "aws.dynamodb.consumed_capacity";
    var TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS2 = "aws.dynamodb.item_collection_metrics";
    var TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY2 = "aws.dynamodb.provisioned_read_capacity";
    var TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY2 = "aws.dynamodb.provisioned_write_capacity";
    var TMP_AWS_DYNAMODB_CONSISTENT_READ2 = "aws.dynamodb.consistent_read";
    var TMP_AWS_DYNAMODB_PROJECTION2 = "aws.dynamodb.projection";
    var TMP_AWS_DYNAMODB_LIMIT2 = "aws.dynamodb.limit";
    var TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET2 = "aws.dynamodb.attributes_to_get";
    var TMP_AWS_DYNAMODB_INDEX_NAME2 = "aws.dynamodb.index_name";
    var TMP_AWS_DYNAMODB_SELECT2 = "aws.dynamodb.select";
    var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES2 = "aws.dynamodb.global_secondary_indexes";
    var TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES2 = "aws.dynamodb.local_secondary_indexes";
    var TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE2 = "aws.dynamodb.exclusive_start_table";
    var TMP_AWS_DYNAMODB_TABLE_COUNT2 = "aws.dynamodb.table_count";
    var TMP_AWS_DYNAMODB_SCAN_FORWARD2 = "aws.dynamodb.scan_forward";
    var TMP_AWS_DYNAMODB_SEGMENT2 = "aws.dynamodb.segment";
    var TMP_AWS_DYNAMODB_TOTAL_SEGMENTS2 = "aws.dynamodb.total_segments";
    var TMP_AWS_DYNAMODB_COUNT2 = "aws.dynamodb.count";
    var TMP_AWS_DYNAMODB_SCANNED_COUNT2 = "aws.dynamodb.scanned_count";
    var TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS2 = "aws.dynamodb.attribute_definitions";
    var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES2 = "aws.dynamodb.global_secondary_index_updates";
    var TMP_MESSAGING_SYSTEM2 = "messaging.system";
    var TMP_MESSAGING_DESTINATION2 = "messaging.destination";
    var TMP_MESSAGING_DESTINATION_KIND2 = "messaging.destination_kind";
    var TMP_MESSAGING_TEMP_DESTINATION2 = "messaging.temp_destination";
    var TMP_MESSAGING_PROTOCOL2 = "messaging.protocol";
    var TMP_MESSAGING_PROTOCOL_VERSION2 = "messaging.protocol_version";
    var TMP_MESSAGING_URL2 = "messaging.url";
    var TMP_MESSAGING_MESSAGE_ID2 = "messaging.message_id";
    var TMP_MESSAGING_CONVERSATION_ID2 = "messaging.conversation_id";
    var TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES2 = "messaging.message_payload_size_bytes";
    var TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES2 = "messaging.message_payload_compressed_size_bytes";
    var TMP_MESSAGING_OPERATION2 = "messaging.operation";
    var TMP_MESSAGING_CONSUMER_ID2 = "messaging.consumer_id";
    var TMP_MESSAGING_RABBITMQ_ROUTING_KEY2 = "messaging.rabbitmq.routing_key";
    var TMP_MESSAGING_KAFKA_MESSAGE_KEY2 = "messaging.kafka.message_key";
    var TMP_MESSAGING_KAFKA_CONSUMER_GROUP2 = "messaging.kafka.consumer_group";
    var TMP_MESSAGING_KAFKA_CLIENT_ID2 = "messaging.kafka.client_id";
    var TMP_MESSAGING_KAFKA_PARTITION2 = "messaging.kafka.partition";
    var TMP_MESSAGING_KAFKA_TOMBSTONE2 = "messaging.kafka.tombstone";
    var TMP_RPC_SYSTEM2 = "rpc.system";
    var TMP_RPC_SERVICE2 = "rpc.service";
    var TMP_RPC_METHOD2 = "rpc.method";
    var TMP_RPC_GRPC_STATUS_CODE2 = "rpc.grpc.status_code";
    var TMP_RPC_JSONRPC_VERSION2 = "rpc.jsonrpc.version";
    var TMP_RPC_JSONRPC_REQUEST_ID2 = "rpc.jsonrpc.request_id";
    var TMP_RPC_JSONRPC_ERROR_CODE2 = "rpc.jsonrpc.error_code";
    var TMP_RPC_JSONRPC_ERROR_MESSAGE2 = "rpc.jsonrpc.error_message";
    var TMP_MESSAGE_TYPE2 = "message.type";
    var TMP_MESSAGE_ID2 = "message.id";
    var TMP_MESSAGE_COMPRESSED_SIZE2 = "message.compressed_size";
    var TMP_MESSAGE_UNCOMPRESSED_SIZE2 = "message.uncompressed_size";
    exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = TMP_AWS_LAMBDA_INVOKED_ARN2;
    exports.SEMATTRS_DB_SYSTEM = TMP_DB_SYSTEM2;
    exports.SEMATTRS_DB_CONNECTION_STRING = TMP_DB_CONNECTION_STRING2;
    exports.SEMATTRS_DB_USER = TMP_DB_USER2;
    exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = TMP_DB_JDBC_DRIVER_CLASSNAME2;
    exports.SEMATTRS_DB_NAME = TMP_DB_NAME2;
    exports.SEMATTRS_DB_STATEMENT = TMP_DB_STATEMENT2;
    exports.SEMATTRS_DB_OPERATION = TMP_DB_OPERATION2;
    exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = TMP_DB_MSSQL_INSTANCE_NAME2;
    exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = TMP_DB_CASSANDRA_KEYSPACE2;
    exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = TMP_DB_CASSANDRA_PAGE_SIZE2;
    exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL2;
    exports.SEMATTRS_DB_CASSANDRA_TABLE = TMP_DB_CASSANDRA_TABLE2;
    exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = TMP_DB_CASSANDRA_IDEMPOTENCE2;
    exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT2;
    exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = TMP_DB_CASSANDRA_COORDINATOR_ID2;
    exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = TMP_DB_CASSANDRA_COORDINATOR_DC2;
    exports.SEMATTRS_DB_HBASE_NAMESPACE = TMP_DB_HBASE_NAMESPACE2;
    exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = TMP_DB_REDIS_DATABASE_INDEX2;
    exports.SEMATTRS_DB_MONGODB_COLLECTION = TMP_DB_MONGODB_COLLECTION2;
    exports.SEMATTRS_DB_SQL_TABLE = TMP_DB_SQL_TABLE2;
    exports.SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE2;
    exports.SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE2;
    exports.SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE2;
    exports.SEMATTRS_EXCEPTION_ESCAPED = TMP_EXCEPTION_ESCAPED2;
    exports.SEMATTRS_FAAS_TRIGGER = TMP_FAAS_TRIGGER2;
    exports.SEMATTRS_FAAS_EXECUTION = TMP_FAAS_EXECUTION2;
    exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = TMP_FAAS_DOCUMENT_COLLECTION2;
    exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = TMP_FAAS_DOCUMENT_OPERATION2;
    exports.SEMATTRS_FAAS_DOCUMENT_TIME = TMP_FAAS_DOCUMENT_TIME2;
    exports.SEMATTRS_FAAS_DOCUMENT_NAME = TMP_FAAS_DOCUMENT_NAME2;
    exports.SEMATTRS_FAAS_TIME = TMP_FAAS_TIME2;
    exports.SEMATTRS_FAAS_CRON = TMP_FAAS_CRON2;
    exports.SEMATTRS_FAAS_COLDSTART = TMP_FAAS_COLDSTART2;
    exports.SEMATTRS_FAAS_INVOKED_NAME = TMP_FAAS_INVOKED_NAME2;
    exports.SEMATTRS_FAAS_INVOKED_PROVIDER = TMP_FAAS_INVOKED_PROVIDER2;
    exports.SEMATTRS_FAAS_INVOKED_REGION = TMP_FAAS_INVOKED_REGION2;
    exports.SEMATTRS_NET_TRANSPORT = TMP_NET_TRANSPORT2;
    exports.SEMATTRS_NET_PEER_IP = TMP_NET_PEER_IP2;
    exports.SEMATTRS_NET_PEER_PORT = TMP_NET_PEER_PORT2;
    exports.SEMATTRS_NET_PEER_NAME = TMP_NET_PEER_NAME2;
    exports.SEMATTRS_NET_HOST_IP = TMP_NET_HOST_IP2;
    exports.SEMATTRS_NET_HOST_PORT = TMP_NET_HOST_PORT2;
    exports.SEMATTRS_NET_HOST_NAME = TMP_NET_HOST_NAME2;
    exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = TMP_NET_HOST_CONNECTION_TYPE2;
    exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = TMP_NET_HOST_CONNECTION_SUBTYPE2;
    exports.SEMATTRS_NET_HOST_CARRIER_NAME = TMP_NET_HOST_CARRIER_NAME2;
    exports.SEMATTRS_NET_HOST_CARRIER_MCC = TMP_NET_HOST_CARRIER_MCC2;
    exports.SEMATTRS_NET_HOST_CARRIER_MNC = TMP_NET_HOST_CARRIER_MNC2;
    exports.SEMATTRS_NET_HOST_CARRIER_ICC = TMP_NET_HOST_CARRIER_ICC2;
    exports.SEMATTRS_PEER_SERVICE = TMP_PEER_SERVICE2;
    exports.SEMATTRS_ENDUSER_ID = TMP_ENDUSER_ID2;
    exports.SEMATTRS_ENDUSER_ROLE = TMP_ENDUSER_ROLE2;
    exports.SEMATTRS_ENDUSER_SCOPE = TMP_ENDUSER_SCOPE2;
    exports.SEMATTRS_THREAD_ID = TMP_THREAD_ID2;
    exports.SEMATTRS_THREAD_NAME = TMP_THREAD_NAME2;
    exports.SEMATTRS_CODE_FUNCTION = TMP_CODE_FUNCTION2;
    exports.SEMATTRS_CODE_NAMESPACE = TMP_CODE_NAMESPACE2;
    exports.SEMATTRS_CODE_FILEPATH = TMP_CODE_FILEPATH2;
    exports.SEMATTRS_CODE_LINENO = TMP_CODE_LINENO2;
    exports.SEMATTRS_HTTP_METHOD = TMP_HTTP_METHOD2;
    exports.SEMATTRS_HTTP_URL = TMP_HTTP_URL2;
    exports.SEMATTRS_HTTP_TARGET = TMP_HTTP_TARGET2;
    exports.SEMATTRS_HTTP_HOST = TMP_HTTP_HOST2;
    exports.SEMATTRS_HTTP_SCHEME = TMP_HTTP_SCHEME2;
    exports.SEMATTRS_HTTP_STATUS_CODE = TMP_HTTP_STATUS_CODE2;
    exports.SEMATTRS_HTTP_FLAVOR = TMP_HTTP_FLAVOR2;
    exports.SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT2;
    exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = TMP_HTTP_REQUEST_CONTENT_LENGTH2;
    exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED2;
    exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = TMP_HTTP_RESPONSE_CONTENT_LENGTH2;
    exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2;
    exports.SEMATTRS_HTTP_SERVER_NAME = TMP_HTTP_SERVER_NAME2;
    exports.SEMATTRS_HTTP_ROUTE = TMP_HTTP_ROUTE2;
    exports.SEMATTRS_HTTP_CLIENT_IP = TMP_HTTP_CLIENT_IP2;
    exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = TMP_AWS_DYNAMODB_TABLE_NAMES2;
    exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY2;
    exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS2;
    exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY2;
    exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY2;
    exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = TMP_AWS_DYNAMODB_CONSISTENT_READ2;
    exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = TMP_AWS_DYNAMODB_PROJECTION2;
    exports.SEMATTRS_AWS_DYNAMODB_LIMIT = TMP_AWS_DYNAMODB_LIMIT2;
    exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET2;
    exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = TMP_AWS_DYNAMODB_INDEX_NAME2;
    exports.SEMATTRS_AWS_DYNAMODB_SELECT = TMP_AWS_DYNAMODB_SELECT2;
    exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES2;
    exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES2;
    exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE2;
    exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = TMP_AWS_DYNAMODB_TABLE_COUNT2;
    exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = TMP_AWS_DYNAMODB_SCAN_FORWARD2;
    exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = TMP_AWS_DYNAMODB_SEGMENT2;
    exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS2;
    exports.SEMATTRS_AWS_DYNAMODB_COUNT = TMP_AWS_DYNAMODB_COUNT2;
    exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = TMP_AWS_DYNAMODB_SCANNED_COUNT2;
    exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS2;
    exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES2;
    exports.SEMATTRS_MESSAGING_SYSTEM = TMP_MESSAGING_SYSTEM2;
    exports.SEMATTRS_MESSAGING_DESTINATION = TMP_MESSAGING_DESTINATION2;
    exports.SEMATTRS_MESSAGING_DESTINATION_KIND = TMP_MESSAGING_DESTINATION_KIND2;
    exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = TMP_MESSAGING_TEMP_DESTINATION2;
    exports.SEMATTRS_MESSAGING_PROTOCOL = TMP_MESSAGING_PROTOCOL2;
    exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = TMP_MESSAGING_PROTOCOL_VERSION2;
    exports.SEMATTRS_MESSAGING_URL = TMP_MESSAGING_URL2;
    exports.SEMATTRS_MESSAGING_MESSAGE_ID = TMP_MESSAGING_MESSAGE_ID2;
    exports.SEMATTRS_MESSAGING_CONVERSATION_ID = TMP_MESSAGING_CONVERSATION_ID2;
    exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES2;
    exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES2;
    exports.SEMATTRS_MESSAGING_OPERATION = TMP_MESSAGING_OPERATION2;
    exports.SEMATTRS_MESSAGING_CONSUMER_ID = TMP_MESSAGING_CONSUMER_ID2;
    exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = TMP_MESSAGING_RABBITMQ_ROUTING_KEY2;
    exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = TMP_MESSAGING_KAFKA_MESSAGE_KEY2;
    exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = TMP_MESSAGING_KAFKA_CONSUMER_GROUP2;
    exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = TMP_MESSAGING_KAFKA_CLIENT_ID2;
    exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = TMP_MESSAGING_KAFKA_PARTITION2;
    exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = TMP_MESSAGING_KAFKA_TOMBSTONE2;
    exports.SEMATTRS_RPC_SYSTEM = TMP_RPC_SYSTEM2;
    exports.SEMATTRS_RPC_SERVICE = TMP_RPC_SERVICE2;
    exports.SEMATTRS_RPC_METHOD = TMP_RPC_METHOD2;
    exports.SEMATTRS_RPC_GRPC_STATUS_CODE = TMP_RPC_GRPC_STATUS_CODE2;
    exports.SEMATTRS_RPC_JSONRPC_VERSION = TMP_RPC_JSONRPC_VERSION2;
    exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = TMP_RPC_JSONRPC_REQUEST_ID2;
    exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = TMP_RPC_JSONRPC_ERROR_CODE2;
    exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = TMP_RPC_JSONRPC_ERROR_MESSAGE2;
    exports.SEMATTRS_MESSAGE_TYPE = TMP_MESSAGE_TYPE2;
    exports.SEMATTRS_MESSAGE_ID = TMP_MESSAGE_ID2;
    exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = TMP_MESSAGE_COMPRESSED_SIZE2;
    exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = TMP_MESSAGE_UNCOMPRESSED_SIZE2;
    exports.SemanticAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_AWS_LAMBDA_INVOKED_ARN2,
      TMP_DB_SYSTEM2,
      TMP_DB_CONNECTION_STRING2,
      TMP_DB_USER2,
      TMP_DB_JDBC_DRIVER_CLASSNAME2,
      TMP_DB_NAME2,
      TMP_DB_STATEMENT2,
      TMP_DB_OPERATION2,
      TMP_DB_MSSQL_INSTANCE_NAME2,
      TMP_DB_CASSANDRA_KEYSPACE2,
      TMP_DB_CASSANDRA_PAGE_SIZE2,
      TMP_DB_CASSANDRA_CONSISTENCY_LEVEL2,
      TMP_DB_CASSANDRA_TABLE2,
      TMP_DB_CASSANDRA_IDEMPOTENCE2,
      TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT2,
      TMP_DB_CASSANDRA_COORDINATOR_ID2,
      TMP_DB_CASSANDRA_COORDINATOR_DC2,
      TMP_DB_HBASE_NAMESPACE2,
      TMP_DB_REDIS_DATABASE_INDEX2,
      TMP_DB_MONGODB_COLLECTION2,
      TMP_DB_SQL_TABLE2,
      TMP_EXCEPTION_TYPE2,
      TMP_EXCEPTION_MESSAGE2,
      TMP_EXCEPTION_STACKTRACE2,
      TMP_EXCEPTION_ESCAPED2,
      TMP_FAAS_TRIGGER2,
      TMP_FAAS_EXECUTION2,
      TMP_FAAS_DOCUMENT_COLLECTION2,
      TMP_FAAS_DOCUMENT_OPERATION2,
      TMP_FAAS_DOCUMENT_TIME2,
      TMP_FAAS_DOCUMENT_NAME2,
      TMP_FAAS_TIME2,
      TMP_FAAS_CRON2,
      TMP_FAAS_COLDSTART2,
      TMP_FAAS_INVOKED_NAME2,
      TMP_FAAS_INVOKED_PROVIDER2,
      TMP_FAAS_INVOKED_REGION2,
      TMP_NET_TRANSPORT2,
      TMP_NET_PEER_IP2,
      TMP_NET_PEER_PORT2,
      TMP_NET_PEER_NAME2,
      TMP_NET_HOST_IP2,
      TMP_NET_HOST_PORT2,
      TMP_NET_HOST_NAME2,
      TMP_NET_HOST_CONNECTION_TYPE2,
      TMP_NET_HOST_CONNECTION_SUBTYPE2,
      TMP_NET_HOST_CARRIER_NAME2,
      TMP_NET_HOST_CARRIER_MCC2,
      TMP_NET_HOST_CARRIER_MNC2,
      TMP_NET_HOST_CARRIER_ICC2,
      TMP_PEER_SERVICE2,
      TMP_ENDUSER_ID2,
      TMP_ENDUSER_ROLE2,
      TMP_ENDUSER_SCOPE2,
      TMP_THREAD_ID2,
      TMP_THREAD_NAME2,
      TMP_CODE_FUNCTION2,
      TMP_CODE_NAMESPACE2,
      TMP_CODE_FILEPATH2,
      TMP_CODE_LINENO2,
      TMP_HTTP_METHOD2,
      TMP_HTTP_URL2,
      TMP_HTTP_TARGET2,
      TMP_HTTP_HOST2,
      TMP_HTTP_SCHEME2,
      TMP_HTTP_STATUS_CODE2,
      TMP_HTTP_FLAVOR2,
      TMP_HTTP_USER_AGENT2,
      TMP_HTTP_REQUEST_CONTENT_LENGTH2,
      TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED2,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH2,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2,
      TMP_HTTP_SERVER_NAME2,
      TMP_HTTP_ROUTE2,
      TMP_HTTP_CLIENT_IP2,
      TMP_AWS_DYNAMODB_TABLE_NAMES2,
      TMP_AWS_DYNAMODB_CONSUMED_CAPACITY2,
      TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS2,
      TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY2,
      TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY2,
      TMP_AWS_DYNAMODB_CONSISTENT_READ2,
      TMP_AWS_DYNAMODB_PROJECTION2,
      TMP_AWS_DYNAMODB_LIMIT2,
      TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET2,
      TMP_AWS_DYNAMODB_INDEX_NAME2,
      TMP_AWS_DYNAMODB_SELECT2,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES2,
      TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES2,
      TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE2,
      TMP_AWS_DYNAMODB_TABLE_COUNT2,
      TMP_AWS_DYNAMODB_SCAN_FORWARD2,
      TMP_AWS_DYNAMODB_SEGMENT2,
      TMP_AWS_DYNAMODB_TOTAL_SEGMENTS2,
      TMP_AWS_DYNAMODB_COUNT2,
      TMP_AWS_DYNAMODB_SCANNED_COUNT2,
      TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS2,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES2,
      TMP_MESSAGING_SYSTEM2,
      TMP_MESSAGING_DESTINATION2,
      TMP_MESSAGING_DESTINATION_KIND2,
      TMP_MESSAGING_TEMP_DESTINATION2,
      TMP_MESSAGING_PROTOCOL2,
      TMP_MESSAGING_PROTOCOL_VERSION2,
      TMP_MESSAGING_URL2,
      TMP_MESSAGING_MESSAGE_ID2,
      TMP_MESSAGING_CONVERSATION_ID2,
      TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES2,
      TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES2,
      TMP_MESSAGING_OPERATION2,
      TMP_MESSAGING_CONSUMER_ID2,
      TMP_MESSAGING_RABBITMQ_ROUTING_KEY2,
      TMP_MESSAGING_KAFKA_MESSAGE_KEY2,
      TMP_MESSAGING_KAFKA_CONSUMER_GROUP2,
      TMP_MESSAGING_KAFKA_CLIENT_ID2,
      TMP_MESSAGING_KAFKA_PARTITION2,
      TMP_MESSAGING_KAFKA_TOMBSTONE2,
      TMP_RPC_SYSTEM2,
      TMP_RPC_SERVICE2,
      TMP_RPC_METHOD2,
      TMP_RPC_GRPC_STATUS_CODE2,
      TMP_RPC_JSONRPC_VERSION2,
      TMP_RPC_JSONRPC_REQUEST_ID2,
      TMP_RPC_JSONRPC_ERROR_CODE2,
      TMP_RPC_JSONRPC_ERROR_MESSAGE2,
      TMP_MESSAGE_TYPE2,
      TMP_MESSAGE_ID2,
      TMP_MESSAGE_COMPRESSED_SIZE2,
      TMP_MESSAGE_UNCOMPRESSED_SIZE2
    ]);
    var TMP_DBSYSTEMVALUES_OTHER_SQL2 = "other_sql";
    var TMP_DBSYSTEMVALUES_MSSQL2 = "mssql";
    var TMP_DBSYSTEMVALUES_MYSQL2 = "mysql";
    var TMP_DBSYSTEMVALUES_ORACLE2 = "oracle";
    var TMP_DBSYSTEMVALUES_DB22 = "db2";
    var TMP_DBSYSTEMVALUES_POSTGRESQL2 = "postgresql";
    var TMP_DBSYSTEMVALUES_REDSHIFT2 = "redshift";
    var TMP_DBSYSTEMVALUES_HIVE2 = "hive";
    var TMP_DBSYSTEMVALUES_CLOUDSCAPE2 = "cloudscape";
    var TMP_DBSYSTEMVALUES_HSQLDB2 = "hsqldb";
    var TMP_DBSYSTEMVALUES_PROGRESS2 = "progress";
    var TMP_DBSYSTEMVALUES_MAXDB2 = "maxdb";
    var TMP_DBSYSTEMVALUES_HANADB2 = "hanadb";
    var TMP_DBSYSTEMVALUES_INGRES2 = "ingres";
    var TMP_DBSYSTEMVALUES_FIRSTSQL2 = "firstsql";
    var TMP_DBSYSTEMVALUES_EDB2 = "edb";
    var TMP_DBSYSTEMVALUES_CACHE2 = "cache";
    var TMP_DBSYSTEMVALUES_ADABAS2 = "adabas";
    var TMP_DBSYSTEMVALUES_FIREBIRD2 = "firebird";
    var TMP_DBSYSTEMVALUES_DERBY2 = "derby";
    var TMP_DBSYSTEMVALUES_FILEMAKER2 = "filemaker";
    var TMP_DBSYSTEMVALUES_INFORMIX2 = "informix";
    var TMP_DBSYSTEMVALUES_INSTANTDB2 = "instantdb";
    var TMP_DBSYSTEMVALUES_INTERBASE2 = "interbase";
    var TMP_DBSYSTEMVALUES_MARIADB2 = "mariadb";
    var TMP_DBSYSTEMVALUES_NETEZZA2 = "netezza";
    var TMP_DBSYSTEMVALUES_PERVASIVE2 = "pervasive";
    var TMP_DBSYSTEMVALUES_POINTBASE2 = "pointbase";
    var TMP_DBSYSTEMVALUES_SQLITE2 = "sqlite";
    var TMP_DBSYSTEMVALUES_SYBASE2 = "sybase";
    var TMP_DBSYSTEMVALUES_TERADATA2 = "teradata";
    var TMP_DBSYSTEMVALUES_VERTICA2 = "vertica";
    var TMP_DBSYSTEMVALUES_H22 = "h2";
    var TMP_DBSYSTEMVALUES_COLDFUSION2 = "coldfusion";
    var TMP_DBSYSTEMVALUES_CASSANDRA2 = "cassandra";
    var TMP_DBSYSTEMVALUES_HBASE2 = "hbase";
    var TMP_DBSYSTEMVALUES_MONGODB2 = "mongodb";
    var TMP_DBSYSTEMVALUES_REDIS2 = "redis";
    var TMP_DBSYSTEMVALUES_COUCHBASE2 = "couchbase";
    var TMP_DBSYSTEMVALUES_COUCHDB2 = "couchdb";
    var TMP_DBSYSTEMVALUES_COSMOSDB2 = "cosmosdb";
    var TMP_DBSYSTEMVALUES_DYNAMODB2 = "dynamodb";
    var TMP_DBSYSTEMVALUES_NEO4J2 = "neo4j";
    var TMP_DBSYSTEMVALUES_GEODE2 = "geode";
    var TMP_DBSYSTEMVALUES_ELASTICSEARCH2 = "elasticsearch";
    var TMP_DBSYSTEMVALUES_MEMCACHED2 = "memcached";
    var TMP_DBSYSTEMVALUES_COCKROACHDB2 = "cockroachdb";
    exports.DBSYSTEMVALUES_OTHER_SQL = TMP_DBSYSTEMVALUES_OTHER_SQL2;
    exports.DBSYSTEMVALUES_MSSQL = TMP_DBSYSTEMVALUES_MSSQL2;
    exports.DBSYSTEMVALUES_MYSQL = TMP_DBSYSTEMVALUES_MYSQL2;
    exports.DBSYSTEMVALUES_ORACLE = TMP_DBSYSTEMVALUES_ORACLE2;
    exports.DBSYSTEMVALUES_DB2 = TMP_DBSYSTEMVALUES_DB22;
    exports.DBSYSTEMVALUES_POSTGRESQL = TMP_DBSYSTEMVALUES_POSTGRESQL2;
    exports.DBSYSTEMVALUES_REDSHIFT = TMP_DBSYSTEMVALUES_REDSHIFT2;
    exports.DBSYSTEMVALUES_HIVE = TMP_DBSYSTEMVALUES_HIVE2;
    exports.DBSYSTEMVALUES_CLOUDSCAPE = TMP_DBSYSTEMVALUES_CLOUDSCAPE2;
    exports.DBSYSTEMVALUES_HSQLDB = TMP_DBSYSTEMVALUES_HSQLDB2;
    exports.DBSYSTEMVALUES_PROGRESS = TMP_DBSYSTEMVALUES_PROGRESS2;
    exports.DBSYSTEMVALUES_MAXDB = TMP_DBSYSTEMVALUES_MAXDB2;
    exports.DBSYSTEMVALUES_HANADB = TMP_DBSYSTEMVALUES_HANADB2;
    exports.DBSYSTEMVALUES_INGRES = TMP_DBSYSTEMVALUES_INGRES2;
    exports.DBSYSTEMVALUES_FIRSTSQL = TMP_DBSYSTEMVALUES_FIRSTSQL2;
    exports.DBSYSTEMVALUES_EDB = TMP_DBSYSTEMVALUES_EDB2;
    exports.DBSYSTEMVALUES_CACHE = TMP_DBSYSTEMVALUES_CACHE2;
    exports.DBSYSTEMVALUES_ADABAS = TMP_DBSYSTEMVALUES_ADABAS2;
    exports.DBSYSTEMVALUES_FIREBIRD = TMP_DBSYSTEMVALUES_FIREBIRD2;
    exports.DBSYSTEMVALUES_DERBY = TMP_DBSYSTEMVALUES_DERBY2;
    exports.DBSYSTEMVALUES_FILEMAKER = TMP_DBSYSTEMVALUES_FILEMAKER2;
    exports.DBSYSTEMVALUES_INFORMIX = TMP_DBSYSTEMVALUES_INFORMIX2;
    exports.DBSYSTEMVALUES_INSTANTDB = TMP_DBSYSTEMVALUES_INSTANTDB2;
    exports.DBSYSTEMVALUES_INTERBASE = TMP_DBSYSTEMVALUES_INTERBASE2;
    exports.DBSYSTEMVALUES_MARIADB = TMP_DBSYSTEMVALUES_MARIADB2;
    exports.DBSYSTEMVALUES_NETEZZA = TMP_DBSYSTEMVALUES_NETEZZA2;
    exports.DBSYSTEMVALUES_PERVASIVE = TMP_DBSYSTEMVALUES_PERVASIVE2;
    exports.DBSYSTEMVALUES_POINTBASE = TMP_DBSYSTEMVALUES_POINTBASE2;
    exports.DBSYSTEMVALUES_SQLITE = TMP_DBSYSTEMVALUES_SQLITE2;
    exports.DBSYSTEMVALUES_SYBASE = TMP_DBSYSTEMVALUES_SYBASE2;
    exports.DBSYSTEMVALUES_TERADATA = TMP_DBSYSTEMVALUES_TERADATA2;
    exports.DBSYSTEMVALUES_VERTICA = TMP_DBSYSTEMVALUES_VERTICA2;
    exports.DBSYSTEMVALUES_H2 = TMP_DBSYSTEMVALUES_H22;
    exports.DBSYSTEMVALUES_COLDFUSION = TMP_DBSYSTEMVALUES_COLDFUSION2;
    exports.DBSYSTEMVALUES_CASSANDRA = TMP_DBSYSTEMVALUES_CASSANDRA2;
    exports.DBSYSTEMVALUES_HBASE = TMP_DBSYSTEMVALUES_HBASE2;
    exports.DBSYSTEMVALUES_MONGODB = TMP_DBSYSTEMVALUES_MONGODB2;
    exports.DBSYSTEMVALUES_REDIS = TMP_DBSYSTEMVALUES_REDIS2;
    exports.DBSYSTEMVALUES_COUCHBASE = TMP_DBSYSTEMVALUES_COUCHBASE2;
    exports.DBSYSTEMVALUES_COUCHDB = TMP_DBSYSTEMVALUES_COUCHDB2;
    exports.DBSYSTEMVALUES_COSMOSDB = TMP_DBSYSTEMVALUES_COSMOSDB2;
    exports.DBSYSTEMVALUES_DYNAMODB = TMP_DBSYSTEMVALUES_DYNAMODB2;
    exports.DBSYSTEMVALUES_NEO4J = TMP_DBSYSTEMVALUES_NEO4J2;
    exports.DBSYSTEMVALUES_GEODE = TMP_DBSYSTEMVALUES_GEODE2;
    exports.DBSYSTEMVALUES_ELASTICSEARCH = TMP_DBSYSTEMVALUES_ELASTICSEARCH2;
    exports.DBSYSTEMVALUES_MEMCACHED = TMP_DBSYSTEMVALUES_MEMCACHED2;
    exports.DBSYSTEMVALUES_COCKROACHDB = TMP_DBSYSTEMVALUES_COCKROACHDB2;
    exports.DbSystemValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_DBSYSTEMVALUES_OTHER_SQL2,
      TMP_DBSYSTEMVALUES_MSSQL2,
      TMP_DBSYSTEMVALUES_MYSQL2,
      TMP_DBSYSTEMVALUES_ORACLE2,
      TMP_DBSYSTEMVALUES_DB22,
      TMP_DBSYSTEMVALUES_POSTGRESQL2,
      TMP_DBSYSTEMVALUES_REDSHIFT2,
      TMP_DBSYSTEMVALUES_HIVE2,
      TMP_DBSYSTEMVALUES_CLOUDSCAPE2,
      TMP_DBSYSTEMVALUES_HSQLDB2,
      TMP_DBSYSTEMVALUES_PROGRESS2,
      TMP_DBSYSTEMVALUES_MAXDB2,
      TMP_DBSYSTEMVALUES_HANADB2,
      TMP_DBSYSTEMVALUES_INGRES2,
      TMP_DBSYSTEMVALUES_FIRSTSQL2,
      TMP_DBSYSTEMVALUES_EDB2,
      TMP_DBSYSTEMVALUES_CACHE2,
      TMP_DBSYSTEMVALUES_ADABAS2,
      TMP_DBSYSTEMVALUES_FIREBIRD2,
      TMP_DBSYSTEMVALUES_DERBY2,
      TMP_DBSYSTEMVALUES_FILEMAKER2,
      TMP_DBSYSTEMVALUES_INFORMIX2,
      TMP_DBSYSTEMVALUES_INSTANTDB2,
      TMP_DBSYSTEMVALUES_INTERBASE2,
      TMP_DBSYSTEMVALUES_MARIADB2,
      TMP_DBSYSTEMVALUES_NETEZZA2,
      TMP_DBSYSTEMVALUES_PERVASIVE2,
      TMP_DBSYSTEMVALUES_POINTBASE2,
      TMP_DBSYSTEMVALUES_SQLITE2,
      TMP_DBSYSTEMVALUES_SYBASE2,
      TMP_DBSYSTEMVALUES_TERADATA2,
      TMP_DBSYSTEMVALUES_VERTICA2,
      TMP_DBSYSTEMVALUES_H22,
      TMP_DBSYSTEMVALUES_COLDFUSION2,
      TMP_DBSYSTEMVALUES_CASSANDRA2,
      TMP_DBSYSTEMVALUES_HBASE2,
      TMP_DBSYSTEMVALUES_MONGODB2,
      TMP_DBSYSTEMVALUES_REDIS2,
      TMP_DBSYSTEMVALUES_COUCHBASE2,
      TMP_DBSYSTEMVALUES_COUCHDB2,
      TMP_DBSYSTEMVALUES_COSMOSDB2,
      TMP_DBSYSTEMVALUES_DYNAMODB2,
      TMP_DBSYSTEMVALUES_NEO4J2,
      TMP_DBSYSTEMVALUES_GEODE2,
      TMP_DBSYSTEMVALUES_ELASTICSEARCH2,
      TMP_DBSYSTEMVALUES_MEMCACHED2,
      TMP_DBSYSTEMVALUES_COCKROACHDB2
    ]);
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL2 = "all";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM2 = "each_quorum";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM2 = "quorum";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM2 = "local_quorum";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE2 = "one";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO2 = "two";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE2 = "three";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE2 = "local_one";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY2 = "any";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL2 = "serial";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL2 = "local_serial";
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL2;
    exports.DbCassandraConsistencyLevelValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL2
    ]);
    var TMP_FAASTRIGGERVALUES_DATASOURCE2 = "datasource";
    var TMP_FAASTRIGGERVALUES_HTTP2 = "http";
    var TMP_FAASTRIGGERVALUES_PUBSUB2 = "pubsub";
    var TMP_FAASTRIGGERVALUES_TIMER2 = "timer";
    var TMP_FAASTRIGGERVALUES_OTHER2 = "other";
    exports.FAASTRIGGERVALUES_DATASOURCE = TMP_FAASTRIGGERVALUES_DATASOURCE2;
    exports.FAASTRIGGERVALUES_HTTP = TMP_FAASTRIGGERVALUES_HTTP2;
    exports.FAASTRIGGERVALUES_PUBSUB = TMP_FAASTRIGGERVALUES_PUBSUB2;
    exports.FAASTRIGGERVALUES_TIMER = TMP_FAASTRIGGERVALUES_TIMER2;
    exports.FAASTRIGGERVALUES_OTHER = TMP_FAASTRIGGERVALUES_OTHER2;
    exports.FaasTriggerValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_FAASTRIGGERVALUES_DATASOURCE2,
      TMP_FAASTRIGGERVALUES_HTTP2,
      TMP_FAASTRIGGERVALUES_PUBSUB2,
      TMP_FAASTRIGGERVALUES_TIMER2,
      TMP_FAASTRIGGERVALUES_OTHER2
    ]);
    var TMP_FAASDOCUMENTOPERATIONVALUES_INSERT2 = "insert";
    var TMP_FAASDOCUMENTOPERATIONVALUES_EDIT2 = "edit";
    var TMP_FAASDOCUMENTOPERATIONVALUES_DELETE2 = "delete";
    exports.FAASDOCUMENTOPERATIONVALUES_INSERT = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT2;
    exports.FAASDOCUMENTOPERATIONVALUES_EDIT = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT2;
    exports.FAASDOCUMENTOPERATIONVALUES_DELETE = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE2;
    exports.FaasDocumentOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_FAASDOCUMENTOPERATIONVALUES_INSERT2,
      TMP_FAASDOCUMENTOPERATIONVALUES_EDIT2,
      TMP_FAASDOCUMENTOPERATIONVALUES_DELETE2
    ]);
    var TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD2 = "alibaba_cloud";
    var TMP_FAASINVOKEDPROVIDERVALUES_AWS2 = "aws";
    var TMP_FAASINVOKEDPROVIDERVALUES_AZURE2 = "azure";
    var TMP_FAASINVOKEDPROVIDERVALUES_GCP2 = "gcp";
    exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD2;
    exports.FAASINVOKEDPROVIDERVALUES_AWS = TMP_FAASINVOKEDPROVIDERVALUES_AWS2;
    exports.FAASINVOKEDPROVIDERVALUES_AZURE = TMP_FAASINVOKEDPROVIDERVALUES_AZURE2;
    exports.FAASINVOKEDPROVIDERVALUES_GCP = TMP_FAASINVOKEDPROVIDERVALUES_GCP2;
    exports.FaasInvokedProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD2,
      TMP_FAASINVOKEDPROVIDERVALUES_AWS2,
      TMP_FAASINVOKEDPROVIDERVALUES_AZURE2,
      TMP_FAASINVOKEDPROVIDERVALUES_GCP2
    ]);
    var TMP_NETTRANSPORTVALUES_IP_TCP2 = "ip_tcp";
    var TMP_NETTRANSPORTVALUES_IP_UDP2 = "ip_udp";
    var TMP_NETTRANSPORTVALUES_IP2 = "ip";
    var TMP_NETTRANSPORTVALUES_UNIX2 = "unix";
    var TMP_NETTRANSPORTVALUES_PIPE2 = "pipe";
    var TMP_NETTRANSPORTVALUES_INPROC2 = "inproc";
    var TMP_NETTRANSPORTVALUES_OTHER2 = "other";
    exports.NETTRANSPORTVALUES_IP_TCP = TMP_NETTRANSPORTVALUES_IP_TCP2;
    exports.NETTRANSPORTVALUES_IP_UDP = TMP_NETTRANSPORTVALUES_IP_UDP2;
    exports.NETTRANSPORTVALUES_IP = TMP_NETTRANSPORTVALUES_IP2;
    exports.NETTRANSPORTVALUES_UNIX = TMP_NETTRANSPORTVALUES_UNIX2;
    exports.NETTRANSPORTVALUES_PIPE = TMP_NETTRANSPORTVALUES_PIPE2;
    exports.NETTRANSPORTVALUES_INPROC = TMP_NETTRANSPORTVALUES_INPROC2;
    exports.NETTRANSPORTVALUES_OTHER = TMP_NETTRANSPORTVALUES_OTHER2;
    exports.NetTransportValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_NETTRANSPORTVALUES_IP_TCP2,
      TMP_NETTRANSPORTVALUES_IP_UDP2,
      TMP_NETTRANSPORTVALUES_IP2,
      TMP_NETTRANSPORTVALUES_UNIX2,
      TMP_NETTRANSPORTVALUES_PIPE2,
      TMP_NETTRANSPORTVALUES_INPROC2,
      TMP_NETTRANSPORTVALUES_OTHER2
    ]);
    var TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI2 = "wifi";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED2 = "wired";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_CELL2 = "cell";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE2 = "unavailable";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN2 = "unknown";
    exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI2;
    exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED2;
    exports.NETHOSTCONNECTIONTYPEVALUES_CELL = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL2;
    exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE2;
    exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN2;
    exports.NetHostConnectionTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI2,
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED2,
      TMP_NETHOSTCONNECTIONTYPEVALUES_CELL2,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE2,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN2
    ]);
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS2 = "gprs";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE2 = "edge";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS2 = "umts";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2 = "cdma";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_02 = "evdo_0";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A2 = "evdo_a";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT2 = "cdma2000_1xrtt";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA2 = "hsdpa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA2 = "hsupa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA2 = "hspa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN2 = "iden";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B2 = "evdo_b";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE2 = "lte";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD2 = "ehrpd";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP2 = "hspap";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM2 = "gsm";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA2 = "td_scdma";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN2 = "iwlan";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR2 = "nr";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA2 = "nrnsa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA2 = "lte_ca";
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_02;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA2;
    exports.NetHostConnectionSubtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_02,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA2
    ]);
    var TMP_HTTPFLAVORVALUES_HTTP_1_02 = "1.0";
    var TMP_HTTPFLAVORVALUES_HTTP_1_12 = "1.1";
    var TMP_HTTPFLAVORVALUES_HTTP_2_02 = "2.0";
    var TMP_HTTPFLAVORVALUES_SPDY2 = "SPDY";
    var TMP_HTTPFLAVORVALUES_QUIC2 = "QUIC";
    exports.HTTPFLAVORVALUES_HTTP_1_0 = TMP_HTTPFLAVORVALUES_HTTP_1_02;
    exports.HTTPFLAVORVALUES_HTTP_1_1 = TMP_HTTPFLAVORVALUES_HTTP_1_12;
    exports.HTTPFLAVORVALUES_HTTP_2_0 = TMP_HTTPFLAVORVALUES_HTTP_2_02;
    exports.HTTPFLAVORVALUES_SPDY = TMP_HTTPFLAVORVALUES_SPDY2;
    exports.HTTPFLAVORVALUES_QUIC = TMP_HTTPFLAVORVALUES_QUIC2;
    exports.HttpFlavorValues = {
      HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_02,
      HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_12,
      HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_02,
      SPDY: TMP_HTTPFLAVORVALUES_SPDY2,
      QUIC: TMP_HTTPFLAVORVALUES_QUIC2
    };
    var TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE2 = "queue";
    var TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC2 = "topic";
    exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE2;
    exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC2;
    exports.MessagingDestinationKindValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE2,
      TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC2
    ]);
    var TMP_MESSAGINGOPERATIONVALUES_RECEIVE2 = "receive";
    var TMP_MESSAGINGOPERATIONVALUES_PROCESS2 = "process";
    exports.MESSAGINGOPERATIONVALUES_RECEIVE = TMP_MESSAGINGOPERATIONVALUES_RECEIVE2;
    exports.MESSAGINGOPERATIONVALUES_PROCESS = TMP_MESSAGINGOPERATIONVALUES_PROCESS2;
    exports.MessagingOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_MESSAGINGOPERATIONVALUES_RECEIVE2,
      TMP_MESSAGINGOPERATIONVALUES_PROCESS2
    ]);
    var TMP_RPCGRPCSTATUSCODEVALUES_OK2 = 0;
    var TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED2 = 1;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN2 = 2;
    var TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT2 = 3;
    var TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED2 = 4;
    var TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND2 = 5;
    var TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS2 = 6;
    var TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED2 = 7;
    var TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED2 = 8;
    var TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION2 = 9;
    var TMP_RPCGRPCSTATUSCODEVALUES_ABORTED2 = 10;
    var TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE2 = 11;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED2 = 12;
    var TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL2 = 13;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE2 = 14;
    var TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS2 = 15;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED2 = 16;
    exports.RPCGRPCSTATUSCODEVALUES_OK = TMP_RPCGRPCSTATUSCODEVALUES_OK2;
    exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED2;
    exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN2;
    exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT2;
    exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED2;
    exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND2;
    exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS2;
    exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED2;
    exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED2;
    exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION2;
    exports.RPCGRPCSTATUSCODEVALUES_ABORTED = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED2;
    exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE2;
    exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED2;
    exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL2;
    exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE2;
    exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS2;
    exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED2;
    exports.RpcGrpcStatusCodeValues = {
      OK: TMP_RPCGRPCSTATUSCODEVALUES_OK2,
      CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED2,
      UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN2,
      INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT2,
      DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED2,
      NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND2,
      ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS2,
      PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED2,
      RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED2,
      FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION2,
      ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED2,
      OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE2,
      UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED2,
      INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL2,
      UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE2,
      DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS2,
      UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED2
    };
    var TMP_MESSAGETYPEVALUES_SENT2 = "SENT";
    var TMP_MESSAGETYPEVALUES_RECEIVED2 = "RECEIVED";
    exports.MESSAGETYPEVALUES_SENT = TMP_MESSAGETYPEVALUES_SENT2;
    exports.MESSAGETYPEVALUES_RECEIVED = TMP_MESSAGETYPEVALUES_RECEIVED2;
    exports.MessageTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_MESSAGETYPEVALUES_SENT2,
      TMP_MESSAGETYPEVALUES_RECEIVED2
    ]);
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js
var require_trace2 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_SemanticAttributes2(), exports);
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js
var require_SemanticResourceAttributes2 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SEMRESATTRS_K8S_STATEFULSET_NAME = exports.SEMRESATTRS_K8S_STATEFULSET_UID = exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = exports.SEMRESATTRS_K8S_REPLICASET_NAME = exports.SEMRESATTRS_K8S_REPLICASET_UID = exports.SEMRESATTRS_K8S_CONTAINER_NAME = exports.SEMRESATTRS_K8S_POD_NAME = exports.SEMRESATTRS_K8S_POD_UID = exports.SEMRESATTRS_K8S_NAMESPACE_NAME = exports.SEMRESATTRS_K8S_NODE_UID = exports.SEMRESATTRS_K8S_NODE_NAME = exports.SEMRESATTRS_K8S_CLUSTER_NAME = exports.SEMRESATTRS_HOST_IMAGE_VERSION = exports.SEMRESATTRS_HOST_IMAGE_ID = exports.SEMRESATTRS_HOST_IMAGE_NAME = exports.SEMRESATTRS_HOST_ARCH = exports.SEMRESATTRS_HOST_TYPE = exports.SEMRESATTRS_HOST_NAME = exports.SEMRESATTRS_HOST_ID = exports.SEMRESATTRS_FAAS_MAX_MEMORY = exports.SEMRESATTRS_FAAS_INSTANCE = exports.SEMRESATTRS_FAAS_VERSION = exports.SEMRESATTRS_FAAS_ID = exports.SEMRESATTRS_FAAS_NAME = exports.SEMRESATTRS_DEVICE_MODEL_NAME = exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = exports.SEMRESATTRS_DEVICE_ID = exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = exports.SEMRESATTRS_CONTAINER_RUNTIME = exports.SEMRESATTRS_CONTAINER_ID = exports.SEMRESATTRS_CONTAINER_NAME = exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = exports.SEMRESATTRS_AWS_ECS_TASK_ARN = exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = exports.SEMRESATTRS_CLOUD_PLATFORM = exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = exports.SEMRESATTRS_CLOUD_REGION = exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = exports.SEMRESATTRS_CLOUD_PROVIDER = void 0;
    exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = exports.CLOUDPLATFORMVALUES_AZURE_AKS = exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = exports.CLOUDPLATFORMVALUES_AZURE_VM = exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = exports.CLOUDPLATFORMVALUES_AWS_EKS = exports.CLOUDPLATFORMVALUES_AWS_ECS = exports.CLOUDPLATFORMVALUES_AWS_EC2 = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = exports.CloudProviderValues = exports.CLOUDPROVIDERVALUES_GCP = exports.CLOUDPROVIDERVALUES_AZURE = exports.CLOUDPROVIDERVALUES_AWS = exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = exports.SemanticResourceAttributes = exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = exports.SEMRESATTRS_WEBENGINE_VERSION = exports.SEMRESATTRS_WEBENGINE_NAME = exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = exports.SEMRESATTRS_TELEMETRY_SDK_NAME = exports.SEMRESATTRS_SERVICE_VERSION = exports.SEMRESATTRS_SERVICE_INSTANCE_ID = exports.SEMRESATTRS_SERVICE_NAMESPACE = exports.SEMRESATTRS_SERVICE_NAME = exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = exports.SEMRESATTRS_PROCESS_OWNER = exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = exports.SEMRESATTRS_PROCESS_COMMAND_LINE = exports.SEMRESATTRS_PROCESS_COMMAND = exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = exports.SEMRESATTRS_PROCESS_PID = exports.SEMRESATTRS_OS_VERSION = exports.SEMRESATTRS_OS_NAME = exports.SEMRESATTRS_OS_DESCRIPTION = exports.SEMRESATTRS_OS_TYPE = exports.SEMRESATTRS_K8S_CRONJOB_NAME = exports.SEMRESATTRS_K8S_CRONJOB_UID = exports.SEMRESATTRS_K8S_JOB_NAME = exports.SEMRESATTRS_K8S_JOB_UID = exports.SEMRESATTRS_K8S_DAEMONSET_NAME = exports.SEMRESATTRS_K8S_DAEMONSET_UID = void 0;
    exports.TelemetrySdkLanguageValues = exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = exports.TELEMETRYSDKLANGUAGEVALUES_PHP = exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = exports.TELEMETRYSDKLANGUAGEVALUES_GO = exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = exports.TELEMETRYSDKLANGUAGEVALUES_CPP = exports.OsTypeValues = exports.OSTYPEVALUES_Z_OS = exports.OSTYPEVALUES_SOLARIS = exports.OSTYPEVALUES_AIX = exports.OSTYPEVALUES_HPUX = exports.OSTYPEVALUES_DRAGONFLYBSD = exports.OSTYPEVALUES_OPENBSD = exports.OSTYPEVALUES_NETBSD = exports.OSTYPEVALUES_FREEBSD = exports.OSTYPEVALUES_DARWIN = exports.OSTYPEVALUES_LINUX = exports.OSTYPEVALUES_WINDOWS = exports.HostArchValues = exports.HOSTARCHVALUES_X86 = exports.HOSTARCHVALUES_PPC64 = exports.HOSTARCHVALUES_PPC32 = exports.HOSTARCHVALUES_IA64 = exports.HOSTARCHVALUES_ARM64 = exports.HOSTARCHVALUES_ARM32 = exports.HOSTARCHVALUES_AMD64 = exports.AwsEcsLaunchtypeValues = exports.AWSECSLAUNCHTYPEVALUES_FARGATE = exports.AWSECSLAUNCHTYPEVALUES_EC2 = exports.CloudPlatformValues = exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = void 0;
    var utils_1 = require_utils7();
    var TMP_CLOUD_PROVIDER2 = "cloud.provider";
    var TMP_CLOUD_ACCOUNT_ID2 = "cloud.account.id";
    var TMP_CLOUD_REGION2 = "cloud.region";
    var TMP_CLOUD_AVAILABILITY_ZONE2 = "cloud.availability_zone";
    var TMP_CLOUD_PLATFORM2 = "cloud.platform";
    var TMP_AWS_ECS_CONTAINER_ARN2 = "aws.ecs.container.arn";
    var TMP_AWS_ECS_CLUSTER_ARN2 = "aws.ecs.cluster.arn";
    var TMP_AWS_ECS_LAUNCHTYPE2 = "aws.ecs.launchtype";
    var TMP_AWS_ECS_TASK_ARN2 = "aws.ecs.task.arn";
    var TMP_AWS_ECS_TASK_FAMILY2 = "aws.ecs.task.family";
    var TMP_AWS_ECS_TASK_REVISION2 = "aws.ecs.task.revision";
    var TMP_AWS_EKS_CLUSTER_ARN2 = "aws.eks.cluster.arn";
    var TMP_AWS_LOG_GROUP_NAMES2 = "aws.log.group.names";
    var TMP_AWS_LOG_GROUP_ARNS2 = "aws.log.group.arns";
    var TMP_AWS_LOG_STREAM_NAMES2 = "aws.log.stream.names";
    var TMP_AWS_LOG_STREAM_ARNS2 = "aws.log.stream.arns";
    var TMP_CONTAINER_NAME2 = "container.name";
    var TMP_CONTAINER_ID2 = "container.id";
    var TMP_CONTAINER_RUNTIME2 = "container.runtime";
    var TMP_CONTAINER_IMAGE_NAME2 = "container.image.name";
    var TMP_CONTAINER_IMAGE_TAG2 = "container.image.tag";
    var TMP_DEPLOYMENT_ENVIRONMENT2 = "deployment.environment";
    var TMP_DEVICE_ID2 = "device.id";
    var TMP_DEVICE_MODEL_IDENTIFIER2 = "device.model.identifier";
    var TMP_DEVICE_MODEL_NAME2 = "device.model.name";
    var TMP_FAAS_NAME2 = "faas.name";
    var TMP_FAAS_ID2 = "faas.id";
    var TMP_FAAS_VERSION2 = "faas.version";
    var TMP_FAAS_INSTANCE2 = "faas.instance";
    var TMP_FAAS_MAX_MEMORY2 = "faas.max_memory";
    var TMP_HOST_ID2 = "host.id";
    var TMP_HOST_NAME2 = "host.name";
    var TMP_HOST_TYPE2 = "host.type";
    var TMP_HOST_ARCH2 = "host.arch";
    var TMP_HOST_IMAGE_NAME2 = "host.image.name";
    var TMP_HOST_IMAGE_ID2 = "host.image.id";
    var TMP_HOST_IMAGE_VERSION2 = "host.image.version";
    var TMP_K8S_CLUSTER_NAME2 = "k8s.cluster.name";
    var TMP_K8S_NODE_NAME2 = "k8s.node.name";
    var TMP_K8S_NODE_UID2 = "k8s.node.uid";
    var TMP_K8S_NAMESPACE_NAME2 = "k8s.namespace.name";
    var TMP_K8S_POD_UID2 = "k8s.pod.uid";
    var TMP_K8S_POD_NAME2 = "k8s.pod.name";
    var TMP_K8S_CONTAINER_NAME2 = "k8s.container.name";
    var TMP_K8S_REPLICASET_UID2 = "k8s.replicaset.uid";
    var TMP_K8S_REPLICASET_NAME2 = "k8s.replicaset.name";
    var TMP_K8S_DEPLOYMENT_UID2 = "k8s.deployment.uid";
    var TMP_K8S_DEPLOYMENT_NAME2 = "k8s.deployment.name";
    var TMP_K8S_STATEFULSET_UID2 = "k8s.statefulset.uid";
    var TMP_K8S_STATEFULSET_NAME2 = "k8s.statefulset.name";
    var TMP_K8S_DAEMONSET_UID2 = "k8s.daemonset.uid";
    var TMP_K8S_DAEMONSET_NAME2 = "k8s.daemonset.name";
    var TMP_K8S_JOB_UID2 = "k8s.job.uid";
    var TMP_K8S_JOB_NAME2 = "k8s.job.name";
    var TMP_K8S_CRONJOB_UID2 = "k8s.cronjob.uid";
    var TMP_K8S_CRONJOB_NAME2 = "k8s.cronjob.name";
    var TMP_OS_TYPE2 = "os.type";
    var TMP_OS_DESCRIPTION2 = "os.description";
    var TMP_OS_NAME2 = "os.name";
    var TMP_OS_VERSION2 = "os.version";
    var TMP_PROCESS_PID2 = "process.pid";
    var TMP_PROCESS_EXECUTABLE_NAME2 = "process.executable.name";
    var TMP_PROCESS_EXECUTABLE_PATH2 = "process.executable.path";
    var TMP_PROCESS_COMMAND2 = "process.command";
    var TMP_PROCESS_COMMAND_LINE2 = "process.command_line";
    var TMP_PROCESS_COMMAND_ARGS2 = "process.command_args";
    var TMP_PROCESS_OWNER2 = "process.owner";
    var TMP_PROCESS_RUNTIME_NAME2 = "process.runtime.name";
    var TMP_PROCESS_RUNTIME_VERSION2 = "process.runtime.version";
    var TMP_PROCESS_RUNTIME_DESCRIPTION2 = "process.runtime.description";
    var TMP_SERVICE_NAME2 = "service.name";
    var TMP_SERVICE_NAMESPACE2 = "service.namespace";
    var TMP_SERVICE_INSTANCE_ID2 = "service.instance.id";
    var TMP_SERVICE_VERSION2 = "service.version";
    var TMP_TELEMETRY_SDK_NAME2 = "telemetry.sdk.name";
    var TMP_TELEMETRY_SDK_LANGUAGE2 = "telemetry.sdk.language";
    var TMP_TELEMETRY_SDK_VERSION2 = "telemetry.sdk.version";
    var TMP_TELEMETRY_AUTO_VERSION2 = "telemetry.auto.version";
    var TMP_WEBENGINE_NAME2 = "webengine.name";
    var TMP_WEBENGINE_VERSION2 = "webengine.version";
    var TMP_WEBENGINE_DESCRIPTION2 = "webengine.description";
    exports.SEMRESATTRS_CLOUD_PROVIDER = TMP_CLOUD_PROVIDER2;
    exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = TMP_CLOUD_ACCOUNT_ID2;
    exports.SEMRESATTRS_CLOUD_REGION = TMP_CLOUD_REGION2;
    exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = TMP_CLOUD_AVAILABILITY_ZONE2;
    exports.SEMRESATTRS_CLOUD_PLATFORM = TMP_CLOUD_PLATFORM2;
    exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = TMP_AWS_ECS_CONTAINER_ARN2;
    exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = TMP_AWS_ECS_CLUSTER_ARN2;
    exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = TMP_AWS_ECS_LAUNCHTYPE2;
    exports.SEMRESATTRS_AWS_ECS_TASK_ARN = TMP_AWS_ECS_TASK_ARN2;
    exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = TMP_AWS_ECS_TASK_FAMILY2;
    exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = TMP_AWS_ECS_TASK_REVISION2;
    exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = TMP_AWS_EKS_CLUSTER_ARN2;
    exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = TMP_AWS_LOG_GROUP_NAMES2;
    exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = TMP_AWS_LOG_GROUP_ARNS2;
    exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = TMP_AWS_LOG_STREAM_NAMES2;
    exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = TMP_AWS_LOG_STREAM_ARNS2;
    exports.SEMRESATTRS_CONTAINER_NAME = TMP_CONTAINER_NAME2;
    exports.SEMRESATTRS_CONTAINER_ID = TMP_CONTAINER_ID2;
    exports.SEMRESATTRS_CONTAINER_RUNTIME = TMP_CONTAINER_RUNTIME2;
    exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = TMP_CONTAINER_IMAGE_NAME2;
    exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = TMP_CONTAINER_IMAGE_TAG2;
    exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = TMP_DEPLOYMENT_ENVIRONMENT2;
    exports.SEMRESATTRS_DEVICE_ID = TMP_DEVICE_ID2;
    exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = TMP_DEVICE_MODEL_IDENTIFIER2;
    exports.SEMRESATTRS_DEVICE_MODEL_NAME = TMP_DEVICE_MODEL_NAME2;
    exports.SEMRESATTRS_FAAS_NAME = TMP_FAAS_NAME2;
    exports.SEMRESATTRS_FAAS_ID = TMP_FAAS_ID2;
    exports.SEMRESATTRS_FAAS_VERSION = TMP_FAAS_VERSION2;
    exports.SEMRESATTRS_FAAS_INSTANCE = TMP_FAAS_INSTANCE2;
    exports.SEMRESATTRS_FAAS_MAX_MEMORY = TMP_FAAS_MAX_MEMORY2;
    exports.SEMRESATTRS_HOST_ID = TMP_HOST_ID2;
    exports.SEMRESATTRS_HOST_NAME = TMP_HOST_NAME2;
    exports.SEMRESATTRS_HOST_TYPE = TMP_HOST_TYPE2;
    exports.SEMRESATTRS_HOST_ARCH = TMP_HOST_ARCH2;
    exports.SEMRESATTRS_HOST_IMAGE_NAME = TMP_HOST_IMAGE_NAME2;
    exports.SEMRESATTRS_HOST_IMAGE_ID = TMP_HOST_IMAGE_ID2;
    exports.SEMRESATTRS_HOST_IMAGE_VERSION = TMP_HOST_IMAGE_VERSION2;
    exports.SEMRESATTRS_K8S_CLUSTER_NAME = TMP_K8S_CLUSTER_NAME2;
    exports.SEMRESATTRS_K8S_NODE_NAME = TMP_K8S_NODE_NAME2;
    exports.SEMRESATTRS_K8S_NODE_UID = TMP_K8S_NODE_UID2;
    exports.SEMRESATTRS_K8S_NAMESPACE_NAME = TMP_K8S_NAMESPACE_NAME2;
    exports.SEMRESATTRS_K8S_POD_UID = TMP_K8S_POD_UID2;
    exports.SEMRESATTRS_K8S_POD_NAME = TMP_K8S_POD_NAME2;
    exports.SEMRESATTRS_K8S_CONTAINER_NAME = TMP_K8S_CONTAINER_NAME2;
    exports.SEMRESATTRS_K8S_REPLICASET_UID = TMP_K8S_REPLICASET_UID2;
    exports.SEMRESATTRS_K8S_REPLICASET_NAME = TMP_K8S_REPLICASET_NAME2;
    exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = TMP_K8S_DEPLOYMENT_UID2;
    exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = TMP_K8S_DEPLOYMENT_NAME2;
    exports.SEMRESATTRS_K8S_STATEFULSET_UID = TMP_K8S_STATEFULSET_UID2;
    exports.SEMRESATTRS_K8S_STATEFULSET_NAME = TMP_K8S_STATEFULSET_NAME2;
    exports.SEMRESATTRS_K8S_DAEMONSET_UID = TMP_K8S_DAEMONSET_UID2;
    exports.SEMRESATTRS_K8S_DAEMONSET_NAME = TMP_K8S_DAEMONSET_NAME2;
    exports.SEMRESATTRS_K8S_JOB_UID = TMP_K8S_JOB_UID2;
    exports.SEMRESATTRS_K8S_JOB_NAME = TMP_K8S_JOB_NAME2;
    exports.SEMRESATTRS_K8S_CRONJOB_UID = TMP_K8S_CRONJOB_UID2;
    exports.SEMRESATTRS_K8S_CRONJOB_NAME = TMP_K8S_CRONJOB_NAME2;
    exports.SEMRESATTRS_OS_TYPE = TMP_OS_TYPE2;
    exports.SEMRESATTRS_OS_DESCRIPTION = TMP_OS_DESCRIPTION2;
    exports.SEMRESATTRS_OS_NAME = TMP_OS_NAME2;
    exports.SEMRESATTRS_OS_VERSION = TMP_OS_VERSION2;
    exports.SEMRESATTRS_PROCESS_PID = TMP_PROCESS_PID2;
    exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = TMP_PROCESS_EXECUTABLE_NAME2;
    exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = TMP_PROCESS_EXECUTABLE_PATH2;
    exports.SEMRESATTRS_PROCESS_COMMAND = TMP_PROCESS_COMMAND2;
    exports.SEMRESATTRS_PROCESS_COMMAND_LINE = TMP_PROCESS_COMMAND_LINE2;
    exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = TMP_PROCESS_COMMAND_ARGS2;
    exports.SEMRESATTRS_PROCESS_OWNER = TMP_PROCESS_OWNER2;
    exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME2;
    exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = TMP_PROCESS_RUNTIME_VERSION2;
    exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = TMP_PROCESS_RUNTIME_DESCRIPTION2;
    exports.SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME2;
    exports.SEMRESATTRS_SERVICE_NAMESPACE = TMP_SERVICE_NAMESPACE2;
    exports.SEMRESATTRS_SERVICE_INSTANCE_ID = TMP_SERVICE_INSTANCE_ID2;
    exports.SEMRESATTRS_SERVICE_VERSION = TMP_SERVICE_VERSION2;
    exports.SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME2;
    exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE2;
    exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION2;
    exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = TMP_TELEMETRY_AUTO_VERSION2;
    exports.SEMRESATTRS_WEBENGINE_NAME = TMP_WEBENGINE_NAME2;
    exports.SEMRESATTRS_WEBENGINE_VERSION = TMP_WEBENGINE_VERSION2;
    exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = TMP_WEBENGINE_DESCRIPTION2;
    exports.SemanticResourceAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_CLOUD_PROVIDER2,
      TMP_CLOUD_ACCOUNT_ID2,
      TMP_CLOUD_REGION2,
      TMP_CLOUD_AVAILABILITY_ZONE2,
      TMP_CLOUD_PLATFORM2,
      TMP_AWS_ECS_CONTAINER_ARN2,
      TMP_AWS_ECS_CLUSTER_ARN2,
      TMP_AWS_ECS_LAUNCHTYPE2,
      TMP_AWS_ECS_TASK_ARN2,
      TMP_AWS_ECS_TASK_FAMILY2,
      TMP_AWS_ECS_TASK_REVISION2,
      TMP_AWS_EKS_CLUSTER_ARN2,
      TMP_AWS_LOG_GROUP_NAMES2,
      TMP_AWS_LOG_GROUP_ARNS2,
      TMP_AWS_LOG_STREAM_NAMES2,
      TMP_AWS_LOG_STREAM_ARNS2,
      TMP_CONTAINER_NAME2,
      TMP_CONTAINER_ID2,
      TMP_CONTAINER_RUNTIME2,
      TMP_CONTAINER_IMAGE_NAME2,
      TMP_CONTAINER_IMAGE_TAG2,
      TMP_DEPLOYMENT_ENVIRONMENT2,
      TMP_DEVICE_ID2,
      TMP_DEVICE_MODEL_IDENTIFIER2,
      TMP_DEVICE_MODEL_NAME2,
      TMP_FAAS_NAME2,
      TMP_FAAS_ID2,
      TMP_FAAS_VERSION2,
      TMP_FAAS_INSTANCE2,
      TMP_FAAS_MAX_MEMORY2,
      TMP_HOST_ID2,
      TMP_HOST_NAME2,
      TMP_HOST_TYPE2,
      TMP_HOST_ARCH2,
      TMP_HOST_IMAGE_NAME2,
      TMP_HOST_IMAGE_ID2,
      TMP_HOST_IMAGE_VERSION2,
      TMP_K8S_CLUSTER_NAME2,
      TMP_K8S_NODE_NAME2,
      TMP_K8S_NODE_UID2,
      TMP_K8S_NAMESPACE_NAME2,
      TMP_K8S_POD_UID2,
      TMP_K8S_POD_NAME2,
      TMP_K8S_CONTAINER_NAME2,
      TMP_K8S_REPLICASET_UID2,
      TMP_K8S_REPLICASET_NAME2,
      TMP_K8S_DEPLOYMENT_UID2,
      TMP_K8S_DEPLOYMENT_NAME2,
      TMP_K8S_STATEFULSET_UID2,
      TMP_K8S_STATEFULSET_NAME2,
      TMP_K8S_DAEMONSET_UID2,
      TMP_K8S_DAEMONSET_NAME2,
      TMP_K8S_JOB_UID2,
      TMP_K8S_JOB_NAME2,
      TMP_K8S_CRONJOB_UID2,
      TMP_K8S_CRONJOB_NAME2,
      TMP_OS_TYPE2,
      TMP_OS_DESCRIPTION2,
      TMP_OS_NAME2,
      TMP_OS_VERSION2,
      TMP_PROCESS_PID2,
      TMP_PROCESS_EXECUTABLE_NAME2,
      TMP_PROCESS_EXECUTABLE_PATH2,
      TMP_PROCESS_COMMAND2,
      TMP_PROCESS_COMMAND_LINE2,
      TMP_PROCESS_COMMAND_ARGS2,
      TMP_PROCESS_OWNER2,
      TMP_PROCESS_RUNTIME_NAME2,
      TMP_PROCESS_RUNTIME_VERSION2,
      TMP_PROCESS_RUNTIME_DESCRIPTION2,
      TMP_SERVICE_NAME2,
      TMP_SERVICE_NAMESPACE2,
      TMP_SERVICE_INSTANCE_ID2,
      TMP_SERVICE_VERSION2,
      TMP_TELEMETRY_SDK_NAME2,
      TMP_TELEMETRY_SDK_LANGUAGE2,
      TMP_TELEMETRY_SDK_VERSION2,
      TMP_TELEMETRY_AUTO_VERSION2,
      TMP_WEBENGINE_NAME2,
      TMP_WEBENGINE_VERSION2,
      TMP_WEBENGINE_DESCRIPTION2
    ]);
    var TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD2 = "alibaba_cloud";
    var TMP_CLOUDPROVIDERVALUES_AWS2 = "aws";
    var TMP_CLOUDPROVIDERVALUES_AZURE2 = "azure";
    var TMP_CLOUDPROVIDERVALUES_GCP2 = "gcp";
    exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD2;
    exports.CLOUDPROVIDERVALUES_AWS = TMP_CLOUDPROVIDERVALUES_AWS2;
    exports.CLOUDPROVIDERVALUES_AZURE = TMP_CLOUDPROVIDERVALUES_AZURE2;
    exports.CLOUDPROVIDERVALUES_GCP = TMP_CLOUDPROVIDERVALUES_GCP2;
    exports.CloudProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD2,
      TMP_CLOUDPROVIDERVALUES_AWS2,
      TMP_CLOUDPROVIDERVALUES_AZURE2,
      TMP_CLOUDPROVIDERVALUES_GCP2
    ]);
    var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS2 = "alibaba_cloud_ecs";
    var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC2 = "alibaba_cloud_fc";
    var TMP_CLOUDPLATFORMVALUES_AWS_EC22 = "aws_ec2";
    var TMP_CLOUDPLATFORMVALUES_AWS_ECS2 = "aws_ecs";
    var TMP_CLOUDPLATFORMVALUES_AWS_EKS2 = "aws_eks";
    var TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA2 = "aws_lambda";
    var TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK2 = "aws_elastic_beanstalk";
    var TMP_CLOUDPLATFORMVALUES_AZURE_VM2 = "azure_vm";
    var TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES2 = "azure_container_instances";
    var TMP_CLOUDPLATFORMVALUES_AZURE_AKS2 = "azure_aks";
    var TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS2 = "azure_functions";
    var TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE2 = "azure_app_service";
    var TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE2 = "gcp_compute_engine";
    var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN2 = "gcp_cloud_run";
    var TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE2 = "gcp_kubernetes_engine";
    var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS2 = "gcp_cloud_functions";
    var TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE2 = "gcp_app_engine";
    exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS2;
    exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC2;
    exports.CLOUDPLATFORMVALUES_AWS_EC2 = TMP_CLOUDPLATFORMVALUES_AWS_EC22;
    exports.CLOUDPLATFORMVALUES_AWS_ECS = TMP_CLOUDPLATFORMVALUES_AWS_ECS2;
    exports.CLOUDPLATFORMVALUES_AWS_EKS = TMP_CLOUDPLATFORMVALUES_AWS_EKS2;
    exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA2;
    exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK2;
    exports.CLOUDPLATFORMVALUES_AZURE_VM = TMP_CLOUDPLATFORMVALUES_AZURE_VM2;
    exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES2;
    exports.CLOUDPLATFORMVALUES_AZURE_AKS = TMP_CLOUDPLATFORMVALUES_AZURE_AKS2;
    exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS2;
    exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE2;
    exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE2;
    exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN2;
    exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE2;
    exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS2;
    exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE2;
    exports.CloudPlatformValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS2,
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC2,
      TMP_CLOUDPLATFORMVALUES_AWS_EC22,
      TMP_CLOUDPLATFORMVALUES_AWS_ECS2,
      TMP_CLOUDPLATFORMVALUES_AWS_EKS2,
      TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA2,
      TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK2,
      TMP_CLOUDPLATFORMVALUES_AZURE_VM2,
      TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES2,
      TMP_CLOUDPLATFORMVALUES_AZURE_AKS2,
      TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS2,
      TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE2,
      TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE2,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN2,
      TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE2,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS2,
      TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE2
    ]);
    var TMP_AWSECSLAUNCHTYPEVALUES_EC22 = "ec2";
    var TMP_AWSECSLAUNCHTYPEVALUES_FARGATE2 = "fargate";
    exports.AWSECSLAUNCHTYPEVALUES_EC2 = TMP_AWSECSLAUNCHTYPEVALUES_EC22;
    exports.AWSECSLAUNCHTYPEVALUES_FARGATE = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE2;
    exports.AwsEcsLaunchtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_AWSECSLAUNCHTYPEVALUES_EC22,
      TMP_AWSECSLAUNCHTYPEVALUES_FARGATE2
    ]);
    var TMP_HOSTARCHVALUES_AMD642 = "amd64";
    var TMP_HOSTARCHVALUES_ARM322 = "arm32";
    var TMP_HOSTARCHVALUES_ARM642 = "arm64";
    var TMP_HOSTARCHVALUES_IA642 = "ia64";
    var TMP_HOSTARCHVALUES_PPC322 = "ppc32";
    var TMP_HOSTARCHVALUES_PPC642 = "ppc64";
    var TMP_HOSTARCHVALUES_X862 = "x86";
    exports.HOSTARCHVALUES_AMD64 = TMP_HOSTARCHVALUES_AMD642;
    exports.HOSTARCHVALUES_ARM32 = TMP_HOSTARCHVALUES_ARM322;
    exports.HOSTARCHVALUES_ARM64 = TMP_HOSTARCHVALUES_ARM642;
    exports.HOSTARCHVALUES_IA64 = TMP_HOSTARCHVALUES_IA642;
    exports.HOSTARCHVALUES_PPC32 = TMP_HOSTARCHVALUES_PPC322;
    exports.HOSTARCHVALUES_PPC64 = TMP_HOSTARCHVALUES_PPC642;
    exports.HOSTARCHVALUES_X86 = TMP_HOSTARCHVALUES_X862;
    exports.HostArchValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_HOSTARCHVALUES_AMD642,
      TMP_HOSTARCHVALUES_ARM322,
      TMP_HOSTARCHVALUES_ARM642,
      TMP_HOSTARCHVALUES_IA642,
      TMP_HOSTARCHVALUES_PPC322,
      TMP_HOSTARCHVALUES_PPC642,
      TMP_HOSTARCHVALUES_X862
    ]);
    var TMP_OSTYPEVALUES_WINDOWS2 = "windows";
    var TMP_OSTYPEVALUES_LINUX2 = "linux";
    var TMP_OSTYPEVALUES_DARWIN2 = "darwin";
    var TMP_OSTYPEVALUES_FREEBSD2 = "freebsd";
    var TMP_OSTYPEVALUES_NETBSD2 = "netbsd";
    var TMP_OSTYPEVALUES_OPENBSD2 = "openbsd";
    var TMP_OSTYPEVALUES_DRAGONFLYBSD2 = "dragonflybsd";
    var TMP_OSTYPEVALUES_HPUX2 = "hpux";
    var TMP_OSTYPEVALUES_AIX2 = "aix";
    var TMP_OSTYPEVALUES_SOLARIS2 = "solaris";
    var TMP_OSTYPEVALUES_Z_OS2 = "z_os";
    exports.OSTYPEVALUES_WINDOWS = TMP_OSTYPEVALUES_WINDOWS2;
    exports.OSTYPEVALUES_LINUX = TMP_OSTYPEVALUES_LINUX2;
    exports.OSTYPEVALUES_DARWIN = TMP_OSTYPEVALUES_DARWIN2;
    exports.OSTYPEVALUES_FREEBSD = TMP_OSTYPEVALUES_FREEBSD2;
    exports.OSTYPEVALUES_NETBSD = TMP_OSTYPEVALUES_NETBSD2;
    exports.OSTYPEVALUES_OPENBSD = TMP_OSTYPEVALUES_OPENBSD2;
    exports.OSTYPEVALUES_DRAGONFLYBSD = TMP_OSTYPEVALUES_DRAGONFLYBSD2;
    exports.OSTYPEVALUES_HPUX = TMP_OSTYPEVALUES_HPUX2;
    exports.OSTYPEVALUES_AIX = TMP_OSTYPEVALUES_AIX2;
    exports.OSTYPEVALUES_SOLARIS = TMP_OSTYPEVALUES_SOLARIS2;
    exports.OSTYPEVALUES_Z_OS = TMP_OSTYPEVALUES_Z_OS2;
    exports.OsTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_OSTYPEVALUES_WINDOWS2,
      TMP_OSTYPEVALUES_LINUX2,
      TMP_OSTYPEVALUES_DARWIN2,
      TMP_OSTYPEVALUES_FREEBSD2,
      TMP_OSTYPEVALUES_NETBSD2,
      TMP_OSTYPEVALUES_OPENBSD2,
      TMP_OSTYPEVALUES_DRAGONFLYBSD2,
      TMP_OSTYPEVALUES_HPUX2,
      TMP_OSTYPEVALUES_AIX2,
      TMP_OSTYPEVALUES_SOLARIS2,
      TMP_OSTYPEVALUES_Z_OS2
    ]);
    var TMP_TELEMETRYSDKLANGUAGEVALUES_CPP2 = "cpp";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET2 = "dotnet";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG2 = "erlang";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_GO2 = "go";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA2 = "java";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS2 = "nodejs";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_PHP2 = "php";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON2 = "python";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY2 = "ruby";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS2 = "webjs";
    exports.TELEMETRYSDKLANGUAGEVALUES_CPP = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP2;
    exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET2;
    exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG2;
    exports.TELEMETRYSDKLANGUAGEVALUES_GO = TMP_TELEMETRYSDKLANGUAGEVALUES_GO2;
    exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA2;
    exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS2;
    exports.TELEMETRYSDKLANGUAGEVALUES_PHP = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP2;
    exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON2;
    exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY2;
    exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS2;
    exports.TelemetrySdkLanguageValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_TELEMETRYSDKLANGUAGEVALUES_CPP2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_GO2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PHP2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS2
    ]);
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js
var require_resource2 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_SemanticResourceAttributes2(), exports);
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/src/index.js
var require_src6 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_trace2(), exports);
    __exportStar(require_resource2(), exports);
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js
var require_sdk_info3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDK_INFO = void 0;
    var version_1 = require_version3();
    var semantic_conventions_1 = require_src6();
    exports.SDK_INFO = {
      [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_NAME]: "opentelemetry",
      [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_NAME]: "node",
      [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE]: semantic_conventions_1.TelemetrySdkLanguageValues.NODEJS,
      [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_VERSION]: version_1.VERSION
    };
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js
var require_timer_util3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unrefTimer = void 0;
    function unrefTimer(timer) {
      timer.unref();
    }
    exports.unrefTimer = unrefTimer;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/index.js
var require_node6 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnv = exports.getEnvWithoutDefaults = void 0;
    var environment_1 = require_environment6();
    Object.defineProperty(exports, "getEnvWithoutDefaults", { enumerable: true, get: function() {
      return environment_1.getEnvWithoutDefaults;
    } });
    Object.defineProperty(exports, "getEnv", { enumerable: true, get: function() {
      return environment_1.getEnv;
    } });
    __exportStar(require_globalThis3(), exports);
    __exportStar(require_hex_to_base643(), exports);
    __exportStar(require_RandomIdGenerator4(), exports);
    __exportStar(require_performance3(), exports);
    __exportStar(require_sdk_info3(), exports);
    __exportStar(require_timer_util3(), exports);
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/platform/index.js
var require_platform6 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/platform/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_node6(), exports);
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/common/time.js
var require_time3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/common/time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addHrTimes = exports.isTimeInput = exports.isTimeInputHrTime = exports.hrTimeToMicroseconds = exports.hrTimeToMilliseconds = exports.hrTimeToNanoseconds = exports.hrTimeToTimeStamp = exports.hrTimeDuration = exports.timeInputToHrTime = exports.hrTime = exports.getTimeOrigin = exports.millisToHrTime = void 0;
    var platform_1 = require_platform6();
    var NANOSECOND_DIGITS = 9;
    var NANOSECOND_DIGITS_IN_MILLIS = 6;
    var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
    var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
    function millisToHrTime(epochMillis) {
      const epochSeconds = epochMillis / 1e3;
      const seconds = Math.trunc(epochSeconds);
      const nanos = Math.round(epochMillis % 1e3 * MILLISECONDS_TO_NANOSECONDS);
      return [seconds, nanos];
    }
    exports.millisToHrTime = millisToHrTime;
    function getTimeOrigin() {
      let timeOrigin = platform_1.otperformance.timeOrigin;
      if (typeof timeOrigin !== "number") {
        const perf = platform_1.otperformance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
      }
      return timeOrigin;
    }
    exports.getTimeOrigin = getTimeOrigin;
    function hrTime(performanceNow) {
      const timeOrigin = millisToHrTime(getTimeOrigin());
      const now = millisToHrTime(typeof performanceNow === "number" ? performanceNow : platform_1.otperformance.now());
      return addHrTimes(timeOrigin, now);
    }
    exports.hrTime = hrTime;
    function timeInputToHrTime(time) {
      if (isTimeInputHrTime(time)) {
        return time;
      } else if (typeof time === "number") {
        if (time < getTimeOrigin()) {
          return hrTime(time);
        } else {
          return millisToHrTime(time);
        }
      } else if (time instanceof Date) {
        return millisToHrTime(time.getTime());
      } else {
        throw TypeError("Invalid input type");
      }
    }
    exports.timeInputToHrTime = timeInputToHrTime;
    function hrTimeDuration(startTime, endTime) {
      let seconds = endTime[0] - startTime[0];
      let nanos = endTime[1] - startTime[1];
      if (nanos < 0) {
        seconds -= 1;
        nanos += SECOND_TO_NANOSECONDS;
      }
      return [seconds, nanos];
    }
    exports.hrTimeDuration = hrTimeDuration;
    function hrTimeToTimeStamp(time) {
      const precision = NANOSECOND_DIGITS;
      const tmp = `${"0".repeat(precision)}${time[1]}Z`;
      const nanoString = tmp.substr(tmp.length - precision - 1);
      const date = new Date(time[0] * 1e3).toISOString();
      return date.replace("000Z", nanoString);
    }
    exports.hrTimeToTimeStamp = hrTimeToTimeStamp;
    function hrTimeToNanoseconds(time) {
      return time[0] * SECOND_TO_NANOSECONDS + time[1];
    }
    exports.hrTimeToNanoseconds = hrTimeToNanoseconds;
    function hrTimeToMilliseconds(time) {
      return time[0] * 1e3 + time[1] / 1e6;
    }
    exports.hrTimeToMilliseconds = hrTimeToMilliseconds;
    function hrTimeToMicroseconds(time) {
      return time[0] * 1e6 + time[1] / 1e3;
    }
    exports.hrTimeToMicroseconds = hrTimeToMicroseconds;
    function isTimeInputHrTime(value) {
      return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
    }
    exports.isTimeInputHrTime = isTimeInputHrTime;
    function isTimeInput(value) {
      return isTimeInputHrTime(value) || typeof value === "number" || value instanceof Date;
    }
    exports.isTimeInput = isTimeInput;
    function addHrTimes(time1, time2) {
      const out = [time1[0] + time2[0], time1[1] + time2[1]];
      if (out[1] >= SECOND_TO_NANOSECONDS) {
        out[1] -= SECOND_TO_NANOSECONDS;
        out[0] += 1;
      }
      return out;
    }
    exports.addHrTimes = addHrTimes;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/common/types.js
var require_types2 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/common/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/ExportResult.js
var require_ExportResult3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/ExportResult.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExportResultCode = void 0;
    var ExportResultCode;
    (function(ExportResultCode2) {
      ExportResultCode2[ExportResultCode2["SUCCESS"] = 0] = "SUCCESS";
      ExportResultCode2[ExportResultCode2["FAILED"] = 1] = "FAILED";
    })(ExportResultCode = exports.ExportResultCode || (exports.ExportResultCode = {}));
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/propagation/composite.js
var require_composite3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/propagation/composite.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompositePropagator = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var CompositePropagator = class {
      /**
       * Construct a composite propagator from a list of propagators.
       *
       * @param [config] Configuration object for composite propagator
       */
      constructor(config = {}) {
        var _a12;
        this._propagators = (_a12 = config.propagators) !== null && _a12 !== void 0 ? _a12 : [];
        this._fields = Array.from(new Set(this._propagators.map((p2) => typeof p2.fields === "function" ? p2.fields() : []).reduce((x2, y2) => x2.concat(y2), [])));
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same carrier key, the propagator later in the list
       * will "win".
       *
       * @param context Context to inject
       * @param carrier Carrier into which context will be injected
       */
      inject(context3, carrier, setter) {
        for (const propagator of this._propagators) {
          try {
            propagator.inject(context3, carrier, setter);
          } catch (err) {
            api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
          }
        }
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same context key, the propagator later in the list
       * will "win".
       *
       * @param context Context to add values to
       * @param carrier Carrier from which to extract context
       */
      extract(context3, carrier, getter) {
        return this._propagators.reduce((ctx, propagator) => {
          try {
            return propagator.extract(ctx, carrier, getter);
          } catch (err) {
            api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
          }
          return ctx;
        }, context3);
      }
      fields() {
        return this._fields.slice();
      }
    };
    exports.CompositePropagator = CompositePropagator;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/internal/validators.js
var require_validators3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/internal/validators.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateValue = exports.validateKey = void 0;
    var VALID_KEY_CHAR_RANGE2 = "[_0-9a-z-*/]";
    var VALID_KEY2 = `[a-z]${VALID_KEY_CHAR_RANGE2}{0,255}`;
    var VALID_VENDOR_KEY2 = `[a-z0-9]${VALID_KEY_CHAR_RANGE2}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE2}{0,13}`;
    var VALID_KEY_REGEX2 = new RegExp(`^(?:${VALID_KEY2}|${VALID_VENDOR_KEY2})$`);
    var VALID_VALUE_BASE_REGEX2 = /^[ -~]{0,255}[!-~]$/;
    var INVALID_VALUE_COMMA_EQUAL_REGEX2 = /,|=/;
    function validateKey2(key) {
      return VALID_KEY_REGEX2.test(key);
    }
    exports.validateKey = validateKey2;
    function validateValue2(value) {
      return VALID_VALUE_BASE_REGEX2.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX2.test(value);
    }
    exports.validateValue = validateValue2;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/trace/TraceState.js
var require_TraceState3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/trace/TraceState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TraceState = void 0;
    var validators_1 = require_validators3();
    var MAX_TRACE_STATE_ITEMS2 = 32;
    var MAX_TRACE_STATE_LEN2 = 512;
    var LIST_MEMBERS_SEPARATOR2 = ",";
    var LIST_MEMBER_KEY_VALUE_SPLITTER2 = "=";
    var TraceState = class _TraceState {
      constructor(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      set(key, value) {
        const traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      }
      unset(key) {
        const traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      }
      get(key) {
        return this._internalState.get(key);
      }
      serialize() {
        return this._keys().reduce((agg, key) => {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER2 + this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR2);
      }
      _parse(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN2)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR2).reverse().reduce((agg, part) => {
          const listMember = part.trim();
          const i2 = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER2);
          if (i2 !== -1) {
            const key = listMember.slice(0, i2);
            const value = listMember.slice(i2 + 1, part.length);
            if ((0, validators_1.validateKey)(key) && (0, validators_1.validateValue)(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS2) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS2));
        }
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        const traceState = new _TraceState();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      }
    };
    exports.TraceState = TraceState;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js
var require_W3CTraceContextPropagator3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.W3CTraceContextPropagator = exports.parseTraceParent = exports.TRACE_STATE_HEADER = exports.TRACE_PARENT_HEADER = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing3();
    var TraceState_1 = require_TraceState3();
    exports.TRACE_PARENT_HEADER = "traceparent";
    exports.TRACE_STATE_HEADER = "tracestate";
    var VERSION2 = "00";
    var VERSION_PART = "(?!ff)[\\da-f]{2}";
    var TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}";
    var PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}";
    var FLAGS_PART = "[\\da-f]{2}";
    var TRACE_PARENT_REGEX = new RegExp(`^\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\s?$`);
    function parseTraceParent(traceParent) {
      const match4 = TRACE_PARENT_REGEX.exec(traceParent);
      if (!match4)
        return null;
      if (match4[1] === "00" && match4[5])
        return null;
      return {
        traceId: match4[2],
        spanId: match4[3],
        traceFlags: parseInt(match4[4], 16)
      };
    }
    exports.parseTraceParent = parseTraceParent;
    var W3CTraceContextPropagator = class {
      inject(context3, carrier, setter) {
        const spanContext = api_1.trace.getSpanContext(context3);
        if (!spanContext || (0, suppress_tracing_1.isTracingSuppressed)(context3) || !(0, api_1.isSpanContextValid)(spanContext))
          return;
        const traceParent = `${VERSION2}-${spanContext.traceId}-${spanContext.spanId}-0${Number(spanContext.traceFlags || api_1.TraceFlags.NONE).toString(16)}`;
        setter.set(carrier, exports.TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) {
          setter.set(carrier, exports.TRACE_STATE_HEADER, spanContext.traceState.serialize());
        }
      }
      extract(context3, carrier, getter) {
        const traceParentHeader = getter.get(carrier, exports.TRACE_PARENT_HEADER);
        if (!traceParentHeader)
          return context3;
        const traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
        if (typeof traceParent !== "string")
          return context3;
        const spanContext = parseTraceParent(traceParent);
        if (!spanContext)
          return context3;
        spanContext.isRemote = true;
        const traceStateHeader = getter.get(carrier, exports.TRACE_STATE_HEADER);
        if (traceStateHeader) {
          const state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
          spanContext.traceState = new TraceState_1.TraceState(typeof state === "string" ? state : void 0);
        }
        return api_1.trace.setSpanContext(context3, spanContext);
      }
      fields() {
        return [exports.TRACE_PARENT_HEADER, exports.TRACE_STATE_HEADER];
      }
    };
    exports.W3CTraceContextPropagator = W3CTraceContextPropagator;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/trace/IdGenerator.js
var require_IdGenerator2 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/trace/IdGenerator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js
var require_rpc_metadata3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRPCMetadata = exports.deleteRPCMetadata = exports.setRPCMetadata = exports.RPCType = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var RPC_METADATA_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key RPC_METADATA");
    var RPCType;
    (function(RPCType2) {
      RPCType2["HTTP"] = "http";
    })(RPCType = exports.RPCType || (exports.RPCType = {}));
    function setRPCMetadata(context3, meta) {
      return context3.setValue(RPC_METADATA_KEY, meta);
    }
    exports.setRPCMetadata = setRPCMetadata;
    function deleteRPCMetadata(context3) {
      return context3.deleteValue(RPC_METADATA_KEY);
    }
    exports.deleteRPCMetadata = deleteRPCMetadata;
    function getRPCMetadata(context3) {
      return context3.getValue(RPC_METADATA_KEY);
    }
    exports.getRPCMetadata = getRPCMetadata;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js
var require_AlwaysOffSampler4 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AlwaysOffSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var AlwaysOffSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return "AlwaysOffSampler";
      }
    };
    exports.AlwaysOffSampler = AlwaysOffSampler;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js
var require_AlwaysOnSampler4 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AlwaysOnSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var AlwaysOnSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.RECORD_AND_SAMPLED
        };
      }
      toString() {
        return "AlwaysOnSampler";
      }
    };
    exports.AlwaysOnSampler = AlwaysOnSampler;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js
var require_ParentBasedSampler4 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParentBasedSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var global_error_handler_1 = require_global_error_handler3();
    var AlwaysOffSampler_1 = require_AlwaysOffSampler4();
    var AlwaysOnSampler_1 = require_AlwaysOnSampler4();
    var ParentBasedSampler = class {
      constructor(config) {
        var _a12, _b5, _c4, _d4;
        this._root = config.root;
        if (!this._root) {
          (0, global_error_handler_1.globalErrorHandler)(new Error("ParentBasedSampler must have a root sampler configured"));
          this._root = new AlwaysOnSampler_1.AlwaysOnSampler();
        }
        this._remoteParentSampled = (_a12 = config.remoteParentSampled) !== null && _a12 !== void 0 ? _a12 : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._remoteParentNotSampled = (_b5 = config.remoteParentNotSampled) !== null && _b5 !== void 0 ? _b5 : new AlwaysOffSampler_1.AlwaysOffSampler();
        this._localParentSampled = (_c4 = config.localParentSampled) !== null && _c4 !== void 0 ? _c4 : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._localParentNotSampled = (_d4 = config.localParentNotSampled) !== null && _d4 !== void 0 ? _d4 : new AlwaysOffSampler_1.AlwaysOffSampler();
      }
      shouldSample(context3, traceId, spanName, spanKind, attributes, links) {
        const parentContext = api_1.trace.getSpanContext(context3);
        if (!parentContext || !(0, api_1.isSpanContextValid)(parentContext)) {
          return this._root.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
          if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
            return this._remoteParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
          }
          return this._remoteParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
          return this._localParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
      }
      toString() {
        return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
      }
    };
    exports.ParentBasedSampler = ParentBasedSampler;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js
var require_TraceIdRatioBasedSampler4 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TraceIdRatioBasedSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var TraceIdRatioBasedSampler = class {
      constructor(_ratio = 0) {
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 4294967295);
      }
      shouldSample(context3, traceId) {
        return {
          decision: (0, api_1.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? api_1.SamplingDecision.RECORD_AND_SAMPLED : api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return `TraceIdRatioBased{${this._ratio}}`;
      }
      _normalize(ratio) {
        if (typeof ratio !== "number" || isNaN(ratio))
          return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
      }
      _accumulate(traceId) {
        let accumulation = 0;
        for (let i2 = 0; i2 < traceId.length / 8; i2++) {
          const pos = i2 * 8;
          const part = parseInt(traceId.slice(pos, pos + 8), 16);
          accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
      }
    };
    exports.TraceIdRatioBasedSampler = TraceIdRatioBasedSampler;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js
var require_lodash_merge3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isPlainObject = void 0;
    var objectTag = "[object Object]";
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    var objectCtorString = funcToString.call(Object);
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    var nativeObjectToString = objectProto.toString;
    function overArg(func2, transform) {
      return function(arg) {
        return func2(transform(arg));
      };
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
        return false;
      }
      const proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      const Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
    }
    exports.isPlainObject = isPlainObject;
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function getRawTag(value) {
      const isOwn = hasOwnProperty2.call(value, symToStringTag), tag2 = value[symToStringTag];
      let unmasked = false;
      try {
        value[symToStringTag] = void 0;
        unmasked = true;
      } catch (e2) {
      }
      const result4 = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag2;
        } else {
          delete value[symToStringTag];
        }
      }
      return result4;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/utils/merge.js
var require_merge3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/utils/merge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = void 0;
    var lodash_merge_1 = require_lodash_merge3();
    var MAX_LEVEL = 20;
    function merge5(...args) {
      let result4 = args.shift();
      const objects = /* @__PURE__ */ new WeakMap();
      while (args.length > 0) {
        result4 = mergeTwoObjects(result4, args.shift(), 0, objects);
      }
      return result4;
    }
    exports.merge = merge5;
    function takeValue(value) {
      if (isArray(value)) {
        return value.slice();
      }
      return value;
    }
    function mergeTwoObjects(one, two, level = 0, objects) {
      let result4;
      if (level > MAX_LEVEL) {
        return void 0;
      }
      level++;
      if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {
        result4 = takeValue(two);
      } else if (isArray(one)) {
        result4 = one.slice();
        if (isArray(two)) {
          for (let i2 = 0, j2 = two.length; i2 < j2; i2++) {
            result4.push(takeValue(two[i2]));
          }
        } else if (isObject(two)) {
          const keys4 = Object.keys(two);
          for (let i2 = 0, j2 = keys4.length; i2 < j2; i2++) {
            const key = keys4[i2];
            result4[key] = takeValue(two[key]);
          }
        }
      } else if (isObject(one)) {
        if (isObject(two)) {
          if (!shouldMerge(one, two)) {
            return two;
          }
          result4 = Object.assign({}, one);
          const keys4 = Object.keys(two);
          for (let i2 = 0, j2 = keys4.length; i2 < j2; i2++) {
            const key = keys4[i2];
            const twoValue = two[key];
            if (isPrimitive(twoValue)) {
              if (typeof twoValue === "undefined") {
                delete result4[key];
              } else {
                result4[key] = twoValue;
              }
            } else {
              const obj1 = result4[key];
              const obj2 = twoValue;
              if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {
                delete result4[key];
              } else {
                if (isObject(obj1) && isObject(obj2)) {
                  const arr1 = objects.get(obj1) || [];
                  const arr2 = objects.get(obj2) || [];
                  arr1.push({ obj: one, key });
                  arr2.push({ obj: two, key });
                  objects.set(obj1, arr1);
                  objects.set(obj2, arr2);
                }
                result4[key] = mergeTwoObjects(result4[key], twoValue, level, objects);
              }
            }
          }
        } else {
          result4 = two;
        }
      }
      return result4;
    }
    function wasObjectReferenced(obj, key, objects) {
      const arr = objects.get(obj[key]) || [];
      for (let i2 = 0, j2 = arr.length; i2 < j2; i2++) {
        const info = arr[i2];
        if (info.key === key && info.obj === obj) {
          return true;
        }
      }
      return false;
    }
    function isArray(value) {
      return Array.isArray(value);
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isObject(value) {
      return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === "object";
    }
    function isPrimitive(value) {
      return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "undefined" || value instanceof Date || value instanceof RegExp || value === null;
    }
    function shouldMerge(one, two) {
      if (!(0, lodash_merge_1.isPlainObject)(one) || !(0, lodash_merge_1.isPlainObject)(two)) {
        return false;
      }
      return true;
    }
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/utils/timeout.js
var require_timeout3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/utils/timeout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callWithTimeout = exports.TimeoutError = void 0;
    var TimeoutError = class _TimeoutError extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, _TimeoutError.prototype);
      }
    };
    exports.TimeoutError = TimeoutError;
    function callWithTimeout(promise2, timeout4) {
      let timeoutHandle;
      const timeoutPromise = new Promise(function timeoutFunction(_resolve, reject3) {
        timeoutHandle = setTimeout(function timeoutHandler() {
          reject3(new TimeoutError("Operation timed out."));
        }, timeout4);
      });
      return Promise.race([promise2, timeoutPromise]).then((result4) => {
        clearTimeout(timeoutHandle);
        return result4;
      }, (reason) => {
        clearTimeout(timeoutHandle);
        throw reason;
      });
    }
    exports.callWithTimeout = callWithTimeout;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/utils/url.js
var require_url3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/utils/url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isUrlIgnored = exports.urlMatches = void 0;
    function urlMatches(url, urlToMatch) {
      if (typeof urlToMatch === "string") {
        return url === urlToMatch;
      } else {
        return !!url.match(urlToMatch);
      }
    }
    exports.urlMatches = urlMatches;
    function isUrlIgnored(url, ignoredUrls) {
      if (!ignoredUrls) {
        return false;
      }
      for (const ignoreUrl of ignoredUrls) {
        if (urlMatches(url, ignoreUrl)) {
          return true;
        }
      }
      return false;
    }
    exports.isUrlIgnored = isUrlIgnored;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/utils/wrap.js
var require_wrap3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/utils/wrap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isWrapped = void 0;
    function isWrapped(func2) {
      return typeof func2 === "function" && typeof func2.__original === "function" && typeof func2.__unwrap === "function" && func2.__wrapped === true;
    }
    exports.isWrapped = isWrapped;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/utils/promise.js
var require_promise3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/utils/promise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Deferred = void 0;
    var Deferred = class {
      constructor() {
        this._promise = new Promise((resolve, reject3) => {
          this._resolve = resolve;
          this._reject = reject3;
        });
      }
      get promise() {
        return this._promise;
      }
      resolve(val) {
        this._resolve(val);
      }
      reject(err) {
        this._reject(err);
      }
    };
    exports.Deferred = Deferred;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/utils/callback.js
var require_callback3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/utils/callback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BindOnceFuture = void 0;
    var promise_1 = require_promise3();
    var BindOnceFuture = class {
      constructor(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new promise_1.Deferred();
      }
      get isCalled() {
        return this._isCalled;
      }
      get promise() {
        return this._deferred.promise;
      }
      call(...args) {
        if (!this._isCalled) {
          this._isCalled = true;
          try {
            Promise.resolve(this._callback.call(this._that, ...args)).then((val) => this._deferred.resolve(val), (err) => this._deferred.reject(err));
          } catch (err) {
            this._deferred.reject(err);
          }
        }
        return this._deferred.promise;
      }
    };
    exports.BindOnceFuture = BindOnceFuture;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/internal/exporter.js
var require_exporter3 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/internal/exporter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._export = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing3();
    function _export(exporter, arg) {
      return new Promise((resolve) => {
        api_1.context.with((0, suppress_tracing_1.suppressTracing)(api_1.context.active()), () => {
          exporter.export(arg, (result4) => {
            resolve(result4);
          });
        });
      });
    }
    exports._export = _export;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/index.js
var require_src7 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/node_modules/@opentelemetry/core/build/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.internal = exports.baggageUtils = void 0;
    __exportStar(require_W3CBaggagePropagator3(), exports);
    __exportStar(require_anchored_clock3(), exports);
    __exportStar(require_attributes3(), exports);
    __exportStar(require_global_error_handler3(), exports);
    __exportStar(require_logging_error_handler3(), exports);
    __exportStar(require_time3(), exports);
    __exportStar(require_types2(), exports);
    __exportStar(require_hex_to_binary3(), exports);
    __exportStar(require_ExportResult3(), exports);
    exports.baggageUtils = require_utils6();
    __exportStar(require_platform6(), exports);
    __exportStar(require_composite3(), exports);
    __exportStar(require_W3CTraceContextPropagator3(), exports);
    __exportStar(require_IdGenerator2(), exports);
    __exportStar(require_rpc_metadata3(), exports);
    __exportStar(require_AlwaysOffSampler4(), exports);
    __exportStar(require_AlwaysOnSampler4(), exports);
    __exportStar(require_ParentBasedSampler4(), exports);
    __exportStar(require_TraceIdRatioBasedSampler4(), exports);
    __exportStar(require_suppress_tracing3(), exports);
    __exportStar(require_TraceState3(), exports);
    __exportStar(require_environment5(), exports);
    __exportStar(require_merge3(), exports);
    __exportStar(require_sampling3(), exports);
    __exportStar(require_timeout3(), exports);
    __exportStar(require_url3(), exports);
    __exportStar(require_wrap3(), exports);
    __exportStar(require_callback3(), exports);
    __exportStar(require_version3(), exports);
    var exporter_1 = require_exporter3();
    exports.internal = {
      _export: exporter_1._export
    };
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js
var require_suppress_tracing4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTracingSuppressed = exports.unsuppressTracing = exports.suppressTracing = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var SUPPRESS_TRACING_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
    function suppressTracing(context3) {
      return context3.setValue(SUPPRESS_TRACING_KEY, true);
    }
    exports.suppressTracing = suppressTracing;
    function unsuppressTracing(context3) {
      return context3.deleteValue(SUPPRESS_TRACING_KEY);
    }
    exports.unsuppressTracing = unsuppressTracing;
    function isTracingSuppressed(context3) {
      return context3.getValue(SUPPRESS_TRACING_KEY) === true;
    }
    exports.isTracingSuppressed = isTracingSuppressed;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/baggage/constants.js
var require_constants4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/baggage/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BAGGAGE_MAX_TOTAL_LENGTH = exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = exports.BAGGAGE_HEADER = exports.BAGGAGE_ITEMS_SEPARATOR = exports.BAGGAGE_PROPERTIES_SEPARATOR = exports.BAGGAGE_KEY_PAIR_SEPARATOR = void 0;
    exports.BAGGAGE_KEY_PAIR_SEPARATOR = "=";
    exports.BAGGAGE_PROPERTIES_SEPARATOR = ";";
    exports.BAGGAGE_ITEMS_SEPARATOR = ",";
    exports.BAGGAGE_HEADER = "baggage";
    exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
    exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
    exports.BAGGAGE_MAX_TOTAL_LENGTH = 8192;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/baggage/utils.js
var require_utils8 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/baggage/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseKeyPairsIntoRecord = exports.parsePairKeyValue = exports.getKeyPairs = exports.serializeKeyPairs = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var constants_1 = require_constants4();
    function serializeKeyPairs(keyPairs) {
      return keyPairs.reduce((hValue, current) => {
        const value = `${hValue}${hValue !== "" ? constants_1.BAGGAGE_ITEMS_SEPARATOR : ""}${current}`;
        return value.length > constants_1.BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
      }, "");
    }
    exports.serializeKeyPairs = serializeKeyPairs;
    function getKeyPairs(baggage) {
      return baggage.getAllEntries().map(([key, value]) => {
        let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;
        if (value.metadata !== void 0) {
          entry += constants_1.BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
        }
        return entry;
      });
    }
    exports.getKeyPairs = getKeyPairs;
    function parsePairKeyValue(entry) {
      const valueProps = entry.split(constants_1.BAGGAGE_PROPERTIES_SEPARATOR);
      if (valueProps.length <= 0)
        return;
      const keyPairPart = valueProps.shift();
      if (!keyPairPart)
        return;
      const separatorIndex = keyPairPart.indexOf(constants_1.BAGGAGE_KEY_PAIR_SEPARATOR);
      if (separatorIndex <= 0)
        return;
      const key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
      const value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
      let metadata;
      if (valueProps.length > 0) {
        metadata = (0, api_1.baggageEntryMetadataFromString)(valueProps.join(constants_1.BAGGAGE_PROPERTIES_SEPARATOR));
      }
      return { key, value, metadata };
    }
    exports.parsePairKeyValue = parsePairKeyValue;
    function parseKeyPairsIntoRecord(value) {
      if (typeof value !== "string" || value.length === 0)
        return {};
      return value.split(constants_1.BAGGAGE_ITEMS_SEPARATOR).map((entry) => {
        return parsePairKeyValue(entry);
      }).filter((keyPair) => keyPair !== void 0 && keyPair.value.length > 0).reduce((headers, keyPair) => {
        headers[keyPair.key] = keyPair.value;
        return headers;
      }, {});
    }
    exports.parseKeyPairsIntoRecord = parseKeyPairsIntoRecord;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js
var require_W3CBaggagePropagator4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.W3CBaggagePropagator = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing4();
    var constants_1 = require_constants4();
    var utils_1 = require_utils8();
    var W3CBaggagePropagator = class {
      inject(context3, carrier, setter) {
        const baggage = api_1.propagation.getBaggage(context3);
        if (!baggage || (0, suppress_tracing_1.isTracingSuppressed)(context3))
          return;
        const keyPairs = (0, utils_1.getKeyPairs)(baggage).filter((pair) => {
          return pair.length <= constants_1.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
        }).slice(0, constants_1.BAGGAGE_MAX_NAME_VALUE_PAIRS);
        const headerValue = (0, utils_1.serializeKeyPairs)(keyPairs);
        if (headerValue.length > 0) {
          setter.set(carrier, constants_1.BAGGAGE_HEADER, headerValue);
        }
      }
      extract(context3, carrier, getter) {
        const headerValue = getter.get(carrier, constants_1.BAGGAGE_HEADER);
        const baggageString = Array.isArray(headerValue) ? headerValue.join(constants_1.BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString)
          return context3;
        const baggage = {};
        if (baggageString.length === 0) {
          return context3;
        }
        const pairs = baggageString.split(constants_1.BAGGAGE_ITEMS_SEPARATOR);
        pairs.forEach((entry) => {
          const keyPair = (0, utils_1.parsePairKeyValue)(entry);
          if (keyPair) {
            const baggageEntry = { value: keyPair.value };
            if (keyPair.metadata) {
              baggageEntry.metadata = keyPair.metadata;
            }
            baggage[keyPair.key] = baggageEntry;
          }
        });
        if (Object.entries(baggage).length === 0) {
          return context3;
        }
        return api_1.propagation.setBaggage(context3, api_1.propagation.createBaggage(baggage));
      }
      fields() {
        return [constants_1.BAGGAGE_HEADER];
      }
    };
    exports.W3CBaggagePropagator = W3CBaggagePropagator;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/common/anchored-clock.js
var require_anchored_clock4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/common/anchored-clock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnchoredClock = void 0;
    var AnchoredClock = class {
      /**
       * Create a new AnchoredClock anchored to the current time returned by systemClock.
       *
       * @param systemClock should be a clock that returns the number of milliseconds since January 1 1970 such as Date
       * @param monotonicClock should be a clock that counts milliseconds monotonically such as window.performance or perf_hooks.performance
       */
      constructor(systemClock, monotonicClock) {
        this._monotonicClock = monotonicClock;
        this._epochMillis = systemClock.now();
        this._performanceMillis = monotonicClock.now();
      }
      /**
       * Returns the current time by adding the number of milliseconds since the
       * AnchoredClock was created to the creation epoch time
       */
      now() {
        const delta = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + delta;
      }
    };
    exports.AnchoredClock = AnchoredClock;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/common/attributes.js
var require_attributes4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/common/attributes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAttributeValue = exports.isAttributeKey = exports.sanitizeAttributes = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    function sanitizeAttributes(attributes) {
      const out = {};
      if (typeof attributes !== "object" || attributes == null) {
        return out;
      }
      for (const [key, val] of Object.entries(attributes)) {
        if (!isAttributeKey(key)) {
          api_1.diag.warn(`Invalid attribute key: ${key}`);
          continue;
        }
        if (!isAttributeValue(val)) {
          api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
          continue;
        }
        if (Array.isArray(val)) {
          out[key] = val.slice();
        } else {
          out[key] = val;
        }
      }
      return out;
    }
    exports.sanitizeAttributes = sanitizeAttributes;
    function isAttributeKey(key) {
      return typeof key === "string" && key.length > 0;
    }
    exports.isAttributeKey = isAttributeKey;
    function isAttributeValue(val) {
      if (val == null) {
        return true;
      }
      if (Array.isArray(val)) {
        return isHomogeneousAttributeValueArray(val);
      }
      return isValidPrimitiveAttributeValue(val);
    }
    exports.isAttributeValue = isAttributeValue;
    function isHomogeneousAttributeValueArray(arr) {
      let type;
      for (const element of arr) {
        if (element == null)
          continue;
        if (!type) {
          if (isValidPrimitiveAttributeValue(element)) {
            type = typeof element;
            continue;
          }
          return false;
        }
        if (typeof element === type) {
          continue;
        }
        return false;
      }
      return true;
    }
    function isValidPrimitiveAttributeValue(val) {
      switch (typeof val) {
        case "number":
        case "boolean":
        case "string":
          return true;
      }
      return false;
    }
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js
var require_logging_error_handler4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loggingErrorHandler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    function loggingErrorHandler() {
      return (ex) => {
        api_1.diag.error(stringifyException(ex));
      };
    }
    exports.loggingErrorHandler = loggingErrorHandler;
    function stringifyException(ex) {
      if (typeof ex === "string") {
        return ex;
      } else {
        return JSON.stringify(flattenException(ex));
      }
    }
    function flattenException(ex) {
      const result4 = {};
      let current = ex;
      while (current !== null) {
        Object.getOwnPropertyNames(current).forEach((propertyName) => {
          if (result4[propertyName])
            return;
          const value = current[propertyName];
          if (value) {
            result4[propertyName] = String(value);
          }
        });
        current = Object.getPrototypeOf(current);
      }
      return result4;
    }
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/common/global-error-handler.js
var require_global_error_handler4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/common/global-error-handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.globalErrorHandler = exports.setGlobalErrorHandler = void 0;
    var logging_error_handler_1 = require_logging_error_handler4();
    var delegateHandler = (0, logging_error_handler_1.loggingErrorHandler)();
    function setGlobalErrorHandler(handler) {
      delegateHandler = handler;
    }
    exports.setGlobalErrorHandler = setGlobalErrorHandler;
    function globalErrorHandler(ex) {
      try {
        delegateHandler(ex);
      } catch (_a12) {
      }
    }
    exports.globalErrorHandler = globalErrorHandler;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/utils/sampling.js
var require_sampling4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/utils/sampling.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TracesSamplerValues = void 0;
    var TracesSamplerValues;
    (function(TracesSamplerValues2) {
      TracesSamplerValues2["AlwaysOff"] = "always_off";
      TracesSamplerValues2["AlwaysOn"] = "always_on";
      TracesSamplerValues2["ParentBasedAlwaysOff"] = "parentbased_always_off";
      TracesSamplerValues2["ParentBasedAlwaysOn"] = "parentbased_always_on";
      TracesSamplerValues2["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
      TracesSamplerValues2["TraceIdRatio"] = "traceidratio";
    })(TracesSamplerValues = exports.TracesSamplerValues || (exports.TracesSamplerValues = {}));
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/utils/environment.js
var require_environment7 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/utils/environment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseEnvironment = exports.DEFAULT_ENVIRONMENT = exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var sampling_1 = require_sampling4();
    var DEFAULT_LIST_SEPARATOR = ",";
    var ENVIRONMENT_BOOLEAN_KEYS = ["OTEL_SDK_DISABLED"];
    function isEnvVarABoolean(key) {
      return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_NUMBERS_KEYS = [
      "OTEL_BSP_EXPORT_TIMEOUT",
      "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BSP_MAX_QUEUE_SIZE",
      "OTEL_BSP_SCHEDULE_DELAY",
      "OTEL_BLRP_EXPORT_TIMEOUT",
      "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BLRP_MAX_QUEUE_SIZE",
      "OTEL_BLRP_SCHEDULE_DELAY",
      "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_LINK_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT",
      "OTEL_EXPORTER_OTLP_TIMEOUT",
      "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
      "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
      "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT",
      "OTEL_EXPORTER_JAEGER_AGENT_PORT"
    ];
    function isEnvVarANumber(key) {
      return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_LISTS_KEYS = [
      "OTEL_NO_PATCH_MODULES",
      "OTEL_PROPAGATORS"
    ];
    function isEnvVarAList(key) {
      return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
    }
    exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
    exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
    exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
    exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
    exports.DEFAULT_ENVIRONMENT = {
      OTEL_SDK_DISABLED: false,
      CONTAINER_NAME: "",
      ECS_CONTAINER_METADATA_URI_V4: "",
      ECS_CONTAINER_METADATA_URI: "",
      HOSTNAME: "",
      KUBERNETES_SERVICE_HOST: "",
      NAMESPACE: "",
      OTEL_BSP_EXPORT_TIMEOUT: 3e4,
      OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BSP_MAX_QUEUE_SIZE: 2048,
      OTEL_BSP_SCHEDULE_DELAY: 5e3,
      OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
      OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
      OTEL_BLRP_SCHEDULE_DELAY: 5e3,
      OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
      OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
      OTEL_EXPORTER_JAEGER_ENDPOINT: "",
      OTEL_EXPORTER_JAEGER_PASSWORD: "",
      OTEL_EXPORTER_JAEGER_USER: "",
      OTEL_EXPORTER_OTLP_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_HEADERS: "",
      OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
      OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
      OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
      OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
      OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
      OTEL_LOG_LEVEL: api_1.DiagLogLevel.INFO,
      OTEL_NO_PATCH_MODULES: [],
      OTEL_PROPAGATORS: ["tracecontext", "baggage"],
      OTEL_RESOURCE_ATTRIBUTES: "",
      OTEL_SERVICE_NAME: "",
      OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
      OTEL_SPAN_LINK_COUNT_LIMIT: 128,
      OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
      OTEL_TRACES_EXPORTER: "",
      OTEL_TRACES_SAMPLER: sampling_1.TracesSamplerValues.ParentBasedAlwaysOn,
      OTEL_TRACES_SAMPLER_ARG: "",
      OTEL_LOGS_EXPORTER: "",
      OTEL_EXPORTER_OTLP_INSECURE: "",
      OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
      OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
      OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
      OTEL_EXPORTER_OTLP_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative"
    };
    function parseBoolean(key, environment5, values3) {
      if (typeof values3[key] === "undefined") {
        return;
      }
      const value = String(values3[key]);
      environment5[key] = value.toLowerCase() === "true";
    }
    function parseNumber(name, environment5, values3, min2 = -Infinity, max2 = Infinity) {
      if (typeof values3[name] !== "undefined") {
        const value = Number(values3[name]);
        if (!isNaN(value)) {
          if (value < min2) {
            environment5[name] = min2;
          } else if (value > max2) {
            environment5[name] = max2;
          } else {
            environment5[name] = value;
          }
        }
      }
    }
    function parseStringList(name, output, input, separator = DEFAULT_LIST_SEPARATOR) {
      const givenValue = input[name];
      if (typeof givenValue === "string") {
        output[name] = givenValue.split(separator).map((v2) => v2.trim());
      }
    }
    var logLevelMap = {
      ALL: api_1.DiagLogLevel.ALL,
      VERBOSE: api_1.DiagLogLevel.VERBOSE,
      DEBUG: api_1.DiagLogLevel.DEBUG,
      INFO: api_1.DiagLogLevel.INFO,
      WARN: api_1.DiagLogLevel.WARN,
      ERROR: api_1.DiagLogLevel.ERROR,
      NONE: api_1.DiagLogLevel.NONE
    };
    function setLogLevelFromEnv(key, environment5, values3) {
      const value = values3[key];
      if (typeof value === "string") {
        const theLevel = logLevelMap[value.toUpperCase()];
        if (theLevel != null) {
          environment5[key] = theLevel;
        }
      }
    }
    function parseEnvironment(values3) {
      const environment5 = {};
      for (const env in exports.DEFAULT_ENVIRONMENT) {
        const key = env;
        switch (key) {
          case "OTEL_LOG_LEVEL":
            setLogLevelFromEnv(key, environment5, values3);
            break;
          default:
            if (isEnvVarABoolean(key)) {
              parseBoolean(key, environment5, values3);
            } else if (isEnvVarANumber(key)) {
              parseNumber(key, environment5, values3);
            } else if (isEnvVarAList(key)) {
              parseStringList(key, environment5, values3);
            } else {
              const value = values3[key];
              if (typeof value !== "undefined" && value !== null) {
                environment5[key] = String(value);
              }
            }
        }
      }
      return environment5;
    }
    exports.parseEnvironment = parseEnvironment;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/environment.js
var require_environment8 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/environment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnvWithoutDefaults = exports.getEnv = void 0;
    var environment_1 = require_environment7();
    function getEnv() {
      const processEnv = (0, environment_1.parseEnvironment)(process.env);
      return Object.assign({}, environment_1.DEFAULT_ENVIRONMENT, processEnv);
    }
    exports.getEnv = getEnv;
    function getEnvWithoutDefaults() {
      return (0, environment_1.parseEnvironment)(process.env);
    }
    exports.getEnvWithoutDefaults = getEnvWithoutDefaults;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js
var require_globalThis4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._globalThis = void 0;
    exports._globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/common/hex-to-binary.js
var require_hex_to_binary4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/common/hex-to-binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hexToBinary = void 0;
    function intValue(charCode) {
      if (charCode >= 48 && charCode <= 57) {
        return charCode - 48;
      }
      if (charCode >= 97 && charCode <= 102) {
        return charCode - 87;
      }
      return charCode - 55;
    }
    function hexToBinary(hexStr) {
      const buf = new Uint8Array(hexStr.length / 2);
      let offset = 0;
      for (let i2 = 0; i2 < hexStr.length; i2 += 2) {
        const hi = intValue(hexStr.charCodeAt(i2));
        const lo = intValue(hexStr.charCodeAt(i2 + 1));
        buf[offset++] = hi << 4 | lo;
      }
      return buf;
    }
    exports.hexToBinary = hexToBinary;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js
var require_hex_to_base644 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hexToBase64 = void 0;
    var hex_to_binary_1 = require_hex_to_binary4();
    function hexToBase64(hexStr) {
      return Buffer.from((0, hex_to_binary_1.hexToBinary)(hexStr)).toString("base64");
    }
    exports.hexToBase64 = hexToBase64;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js
var require_RandomIdGenerator5 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RandomIdGenerator = void 0;
    var SPAN_ID_BYTES = 8;
    var TRACE_ID_BYTES = 16;
    var RandomIdGenerator = class {
      constructor() {
        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
        this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
      }
    };
    exports.RandomIdGenerator = RandomIdGenerator;
    var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
    function getIdGenerator(bytes) {
      return function generateId() {
        for (let i2 = 0; i2 < bytes / 4; i2++) {
          SHARED_BUFFER.writeUInt32BE(Math.random() * 2 ** 32 >>> 0, i2 * 4);
        }
        for (let i2 = 0; i2 < bytes; i2++) {
          if (SHARED_BUFFER[i2] > 0) {
            break;
          } else if (i2 === bytes - 1) {
            SHARED_BUFFER[bytes - 1] = 1;
          }
        }
        return SHARED_BUFFER.toString("hex", 0, bytes);
      };
    }
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/performance.js
var require_performance4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/performance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.otperformance = void 0;
    var perf_hooks_1 = __require("perf_hooks");
    exports.otperformance = perf_hooks_1.performance;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/version.js
var require_version4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VERSION = void 0;
    exports.VERSION = "1.24.1";
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/src/internal/utils.js
var require_utils9 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/src/internal/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConstMap = void 0;
    // @__NO_SIDE_EFFECTS__
    function createConstMap2(values3) {
      let res = {};
      const len = values3.length;
      for (let lp = 0; lp < len; lp++) {
        const val = values3[lp];
        if (val) {
          res[String(val).toUpperCase().replace(/[-.]/g, "_")] = val;
        }
      }
      return res;
    }
    exports.createConstMap = createConstMap2;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js
var require_SemanticAttributes3 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SEMATTRS_NET_HOST_CARRIER_ICC = exports.SEMATTRS_NET_HOST_CARRIER_MNC = exports.SEMATTRS_NET_HOST_CARRIER_MCC = exports.SEMATTRS_NET_HOST_CARRIER_NAME = exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = exports.SEMATTRS_NET_HOST_NAME = exports.SEMATTRS_NET_HOST_PORT = exports.SEMATTRS_NET_HOST_IP = exports.SEMATTRS_NET_PEER_NAME = exports.SEMATTRS_NET_PEER_PORT = exports.SEMATTRS_NET_PEER_IP = exports.SEMATTRS_NET_TRANSPORT = exports.SEMATTRS_FAAS_INVOKED_REGION = exports.SEMATTRS_FAAS_INVOKED_PROVIDER = exports.SEMATTRS_FAAS_INVOKED_NAME = exports.SEMATTRS_FAAS_COLDSTART = exports.SEMATTRS_FAAS_CRON = exports.SEMATTRS_FAAS_TIME = exports.SEMATTRS_FAAS_DOCUMENT_NAME = exports.SEMATTRS_FAAS_DOCUMENT_TIME = exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = exports.SEMATTRS_FAAS_EXECUTION = exports.SEMATTRS_FAAS_TRIGGER = exports.SEMATTRS_EXCEPTION_ESCAPED = exports.SEMATTRS_EXCEPTION_STACKTRACE = exports.SEMATTRS_EXCEPTION_MESSAGE = exports.SEMATTRS_EXCEPTION_TYPE = exports.SEMATTRS_DB_SQL_TABLE = exports.SEMATTRS_DB_MONGODB_COLLECTION = exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = exports.SEMATTRS_DB_HBASE_NAMESPACE = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = exports.SEMATTRS_DB_CASSANDRA_TABLE = exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = exports.SEMATTRS_DB_OPERATION = exports.SEMATTRS_DB_STATEMENT = exports.SEMATTRS_DB_NAME = exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = exports.SEMATTRS_DB_USER = exports.SEMATTRS_DB_CONNECTION_STRING = exports.SEMATTRS_DB_SYSTEM = exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = void 0;
    exports.SEMATTRS_MESSAGING_DESTINATION_KIND = exports.SEMATTRS_MESSAGING_DESTINATION = exports.SEMATTRS_MESSAGING_SYSTEM = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = exports.SEMATTRS_AWS_DYNAMODB_COUNT = exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_SELECT = exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = exports.SEMATTRS_AWS_DYNAMODB_LIMIT = exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = exports.SEMATTRS_HTTP_CLIENT_IP = exports.SEMATTRS_HTTP_ROUTE = exports.SEMATTRS_HTTP_SERVER_NAME = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = exports.SEMATTRS_HTTP_USER_AGENT = exports.SEMATTRS_HTTP_FLAVOR = exports.SEMATTRS_HTTP_STATUS_CODE = exports.SEMATTRS_HTTP_SCHEME = exports.SEMATTRS_HTTP_HOST = exports.SEMATTRS_HTTP_TARGET = exports.SEMATTRS_HTTP_URL = exports.SEMATTRS_HTTP_METHOD = exports.SEMATTRS_CODE_LINENO = exports.SEMATTRS_CODE_FILEPATH = exports.SEMATTRS_CODE_NAMESPACE = exports.SEMATTRS_CODE_FUNCTION = exports.SEMATTRS_THREAD_NAME = exports.SEMATTRS_THREAD_ID = exports.SEMATTRS_ENDUSER_SCOPE = exports.SEMATTRS_ENDUSER_ROLE = exports.SEMATTRS_ENDUSER_ID = exports.SEMATTRS_PEER_SERVICE = void 0;
    exports.DBSYSTEMVALUES_FILEMAKER = exports.DBSYSTEMVALUES_DERBY = exports.DBSYSTEMVALUES_FIREBIRD = exports.DBSYSTEMVALUES_ADABAS = exports.DBSYSTEMVALUES_CACHE = exports.DBSYSTEMVALUES_EDB = exports.DBSYSTEMVALUES_FIRSTSQL = exports.DBSYSTEMVALUES_INGRES = exports.DBSYSTEMVALUES_HANADB = exports.DBSYSTEMVALUES_MAXDB = exports.DBSYSTEMVALUES_PROGRESS = exports.DBSYSTEMVALUES_HSQLDB = exports.DBSYSTEMVALUES_CLOUDSCAPE = exports.DBSYSTEMVALUES_HIVE = exports.DBSYSTEMVALUES_REDSHIFT = exports.DBSYSTEMVALUES_POSTGRESQL = exports.DBSYSTEMVALUES_DB2 = exports.DBSYSTEMVALUES_ORACLE = exports.DBSYSTEMVALUES_MYSQL = exports.DBSYSTEMVALUES_MSSQL = exports.DBSYSTEMVALUES_OTHER_SQL = exports.SemanticAttributes = exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_ID = exports.SEMATTRS_MESSAGE_TYPE = exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = exports.SEMATTRS_RPC_JSONRPC_VERSION = exports.SEMATTRS_RPC_GRPC_STATUS_CODE = exports.SEMATTRS_RPC_METHOD = exports.SEMATTRS_RPC_SERVICE = exports.SEMATTRS_RPC_SYSTEM = exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = exports.SEMATTRS_MESSAGING_CONSUMER_ID = exports.SEMATTRS_MESSAGING_OPERATION = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = exports.SEMATTRS_MESSAGING_CONVERSATION_ID = exports.SEMATTRS_MESSAGING_MESSAGE_ID = exports.SEMATTRS_MESSAGING_URL = exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = exports.SEMATTRS_MESSAGING_PROTOCOL = exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = void 0;
    exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = exports.FaasDocumentOperationValues = exports.FAASDOCUMENTOPERATIONVALUES_DELETE = exports.FAASDOCUMENTOPERATIONVALUES_EDIT = exports.FAASDOCUMENTOPERATIONVALUES_INSERT = exports.FaasTriggerValues = exports.FAASTRIGGERVALUES_OTHER = exports.FAASTRIGGERVALUES_TIMER = exports.FAASTRIGGERVALUES_PUBSUB = exports.FAASTRIGGERVALUES_HTTP = exports.FAASTRIGGERVALUES_DATASOURCE = exports.DbCassandraConsistencyLevelValues = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = exports.DbSystemValues = exports.DBSYSTEMVALUES_COCKROACHDB = exports.DBSYSTEMVALUES_MEMCACHED = exports.DBSYSTEMVALUES_ELASTICSEARCH = exports.DBSYSTEMVALUES_GEODE = exports.DBSYSTEMVALUES_NEO4J = exports.DBSYSTEMVALUES_DYNAMODB = exports.DBSYSTEMVALUES_COSMOSDB = exports.DBSYSTEMVALUES_COUCHDB = exports.DBSYSTEMVALUES_COUCHBASE = exports.DBSYSTEMVALUES_REDIS = exports.DBSYSTEMVALUES_MONGODB = exports.DBSYSTEMVALUES_HBASE = exports.DBSYSTEMVALUES_CASSANDRA = exports.DBSYSTEMVALUES_COLDFUSION = exports.DBSYSTEMVALUES_H2 = exports.DBSYSTEMVALUES_VERTICA = exports.DBSYSTEMVALUES_TERADATA = exports.DBSYSTEMVALUES_SYBASE = exports.DBSYSTEMVALUES_SQLITE = exports.DBSYSTEMVALUES_POINTBASE = exports.DBSYSTEMVALUES_PERVASIVE = exports.DBSYSTEMVALUES_NETEZZA = exports.DBSYSTEMVALUES_MARIADB = exports.DBSYSTEMVALUES_INTERBASE = exports.DBSYSTEMVALUES_INSTANTDB = exports.DBSYSTEMVALUES_INFORMIX = void 0;
    exports.MESSAGINGOPERATIONVALUES_RECEIVE = exports.MessagingDestinationKindValues = exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = exports.HttpFlavorValues = exports.HTTPFLAVORVALUES_QUIC = exports.HTTPFLAVORVALUES_SPDY = exports.HTTPFLAVORVALUES_HTTP_2_0 = exports.HTTPFLAVORVALUES_HTTP_1_1 = exports.HTTPFLAVORVALUES_HTTP_1_0 = exports.NetHostConnectionSubtypeValues = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = exports.NetHostConnectionTypeValues = exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = exports.NETHOSTCONNECTIONTYPEVALUES_CELL = exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = exports.NetTransportValues = exports.NETTRANSPORTVALUES_OTHER = exports.NETTRANSPORTVALUES_INPROC = exports.NETTRANSPORTVALUES_PIPE = exports.NETTRANSPORTVALUES_UNIX = exports.NETTRANSPORTVALUES_IP = exports.NETTRANSPORTVALUES_IP_UDP = exports.NETTRANSPORTVALUES_IP_TCP = exports.FaasInvokedProviderValues = exports.FAASINVOKEDPROVIDERVALUES_GCP = exports.FAASINVOKEDPROVIDERVALUES_AZURE = exports.FAASINVOKEDPROVIDERVALUES_AWS = void 0;
    exports.MessageTypeValues = exports.MESSAGETYPEVALUES_RECEIVED = exports.MESSAGETYPEVALUES_SENT = exports.RpcGrpcStatusCodeValues = exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = exports.RPCGRPCSTATUSCODEVALUES_ABORTED = exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = exports.RPCGRPCSTATUSCODEVALUES_OK = exports.MessagingOperationValues = exports.MESSAGINGOPERATIONVALUES_PROCESS = void 0;
    var utils_1 = require_utils9();
    var TMP_AWS_LAMBDA_INVOKED_ARN2 = "aws.lambda.invoked_arn";
    var TMP_DB_SYSTEM2 = "db.system";
    var TMP_DB_CONNECTION_STRING2 = "db.connection_string";
    var TMP_DB_USER2 = "db.user";
    var TMP_DB_JDBC_DRIVER_CLASSNAME2 = "db.jdbc.driver_classname";
    var TMP_DB_NAME2 = "db.name";
    var TMP_DB_STATEMENT2 = "db.statement";
    var TMP_DB_OPERATION2 = "db.operation";
    var TMP_DB_MSSQL_INSTANCE_NAME2 = "db.mssql.instance_name";
    var TMP_DB_CASSANDRA_KEYSPACE2 = "db.cassandra.keyspace";
    var TMP_DB_CASSANDRA_PAGE_SIZE2 = "db.cassandra.page_size";
    var TMP_DB_CASSANDRA_CONSISTENCY_LEVEL2 = "db.cassandra.consistency_level";
    var TMP_DB_CASSANDRA_TABLE2 = "db.cassandra.table";
    var TMP_DB_CASSANDRA_IDEMPOTENCE2 = "db.cassandra.idempotence";
    var TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT2 = "db.cassandra.speculative_execution_count";
    var TMP_DB_CASSANDRA_COORDINATOR_ID2 = "db.cassandra.coordinator.id";
    var TMP_DB_CASSANDRA_COORDINATOR_DC2 = "db.cassandra.coordinator.dc";
    var TMP_DB_HBASE_NAMESPACE2 = "db.hbase.namespace";
    var TMP_DB_REDIS_DATABASE_INDEX2 = "db.redis.database_index";
    var TMP_DB_MONGODB_COLLECTION2 = "db.mongodb.collection";
    var TMP_DB_SQL_TABLE2 = "db.sql.table";
    var TMP_EXCEPTION_TYPE2 = "exception.type";
    var TMP_EXCEPTION_MESSAGE2 = "exception.message";
    var TMP_EXCEPTION_STACKTRACE2 = "exception.stacktrace";
    var TMP_EXCEPTION_ESCAPED2 = "exception.escaped";
    var TMP_FAAS_TRIGGER2 = "faas.trigger";
    var TMP_FAAS_EXECUTION2 = "faas.execution";
    var TMP_FAAS_DOCUMENT_COLLECTION2 = "faas.document.collection";
    var TMP_FAAS_DOCUMENT_OPERATION2 = "faas.document.operation";
    var TMP_FAAS_DOCUMENT_TIME2 = "faas.document.time";
    var TMP_FAAS_DOCUMENT_NAME2 = "faas.document.name";
    var TMP_FAAS_TIME2 = "faas.time";
    var TMP_FAAS_CRON2 = "faas.cron";
    var TMP_FAAS_COLDSTART2 = "faas.coldstart";
    var TMP_FAAS_INVOKED_NAME2 = "faas.invoked_name";
    var TMP_FAAS_INVOKED_PROVIDER2 = "faas.invoked_provider";
    var TMP_FAAS_INVOKED_REGION2 = "faas.invoked_region";
    var TMP_NET_TRANSPORT2 = "net.transport";
    var TMP_NET_PEER_IP2 = "net.peer.ip";
    var TMP_NET_PEER_PORT2 = "net.peer.port";
    var TMP_NET_PEER_NAME2 = "net.peer.name";
    var TMP_NET_HOST_IP2 = "net.host.ip";
    var TMP_NET_HOST_PORT2 = "net.host.port";
    var TMP_NET_HOST_NAME2 = "net.host.name";
    var TMP_NET_HOST_CONNECTION_TYPE2 = "net.host.connection.type";
    var TMP_NET_HOST_CONNECTION_SUBTYPE2 = "net.host.connection.subtype";
    var TMP_NET_HOST_CARRIER_NAME2 = "net.host.carrier.name";
    var TMP_NET_HOST_CARRIER_MCC2 = "net.host.carrier.mcc";
    var TMP_NET_HOST_CARRIER_MNC2 = "net.host.carrier.mnc";
    var TMP_NET_HOST_CARRIER_ICC2 = "net.host.carrier.icc";
    var TMP_PEER_SERVICE2 = "peer.service";
    var TMP_ENDUSER_ID2 = "enduser.id";
    var TMP_ENDUSER_ROLE2 = "enduser.role";
    var TMP_ENDUSER_SCOPE2 = "enduser.scope";
    var TMP_THREAD_ID2 = "thread.id";
    var TMP_THREAD_NAME2 = "thread.name";
    var TMP_CODE_FUNCTION2 = "code.function";
    var TMP_CODE_NAMESPACE2 = "code.namespace";
    var TMP_CODE_FILEPATH2 = "code.filepath";
    var TMP_CODE_LINENO2 = "code.lineno";
    var TMP_HTTP_METHOD2 = "http.method";
    var TMP_HTTP_URL2 = "http.url";
    var TMP_HTTP_TARGET2 = "http.target";
    var TMP_HTTP_HOST2 = "http.host";
    var TMP_HTTP_SCHEME2 = "http.scheme";
    var TMP_HTTP_STATUS_CODE2 = "http.status_code";
    var TMP_HTTP_FLAVOR2 = "http.flavor";
    var TMP_HTTP_USER_AGENT2 = "http.user_agent";
    var TMP_HTTP_REQUEST_CONTENT_LENGTH2 = "http.request_content_length";
    var TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED2 = "http.request_content_length_uncompressed";
    var TMP_HTTP_RESPONSE_CONTENT_LENGTH2 = "http.response_content_length";
    var TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2 = "http.response_content_length_uncompressed";
    var TMP_HTTP_SERVER_NAME2 = "http.server_name";
    var TMP_HTTP_ROUTE2 = "http.route";
    var TMP_HTTP_CLIENT_IP2 = "http.client_ip";
    var TMP_AWS_DYNAMODB_TABLE_NAMES2 = "aws.dynamodb.table_names";
    var TMP_AWS_DYNAMODB_CONSUMED_CAPACITY2 = "aws.dynamodb.consumed_capacity";
    var TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS2 = "aws.dynamodb.item_collection_metrics";
    var TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY2 = "aws.dynamodb.provisioned_read_capacity";
    var TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY2 = "aws.dynamodb.provisioned_write_capacity";
    var TMP_AWS_DYNAMODB_CONSISTENT_READ2 = "aws.dynamodb.consistent_read";
    var TMP_AWS_DYNAMODB_PROJECTION2 = "aws.dynamodb.projection";
    var TMP_AWS_DYNAMODB_LIMIT2 = "aws.dynamodb.limit";
    var TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET2 = "aws.dynamodb.attributes_to_get";
    var TMP_AWS_DYNAMODB_INDEX_NAME2 = "aws.dynamodb.index_name";
    var TMP_AWS_DYNAMODB_SELECT2 = "aws.dynamodb.select";
    var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES2 = "aws.dynamodb.global_secondary_indexes";
    var TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES2 = "aws.dynamodb.local_secondary_indexes";
    var TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE2 = "aws.dynamodb.exclusive_start_table";
    var TMP_AWS_DYNAMODB_TABLE_COUNT2 = "aws.dynamodb.table_count";
    var TMP_AWS_DYNAMODB_SCAN_FORWARD2 = "aws.dynamodb.scan_forward";
    var TMP_AWS_DYNAMODB_SEGMENT2 = "aws.dynamodb.segment";
    var TMP_AWS_DYNAMODB_TOTAL_SEGMENTS2 = "aws.dynamodb.total_segments";
    var TMP_AWS_DYNAMODB_COUNT2 = "aws.dynamodb.count";
    var TMP_AWS_DYNAMODB_SCANNED_COUNT2 = "aws.dynamodb.scanned_count";
    var TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS2 = "aws.dynamodb.attribute_definitions";
    var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES2 = "aws.dynamodb.global_secondary_index_updates";
    var TMP_MESSAGING_SYSTEM2 = "messaging.system";
    var TMP_MESSAGING_DESTINATION2 = "messaging.destination";
    var TMP_MESSAGING_DESTINATION_KIND2 = "messaging.destination_kind";
    var TMP_MESSAGING_TEMP_DESTINATION2 = "messaging.temp_destination";
    var TMP_MESSAGING_PROTOCOL2 = "messaging.protocol";
    var TMP_MESSAGING_PROTOCOL_VERSION2 = "messaging.protocol_version";
    var TMP_MESSAGING_URL2 = "messaging.url";
    var TMP_MESSAGING_MESSAGE_ID2 = "messaging.message_id";
    var TMP_MESSAGING_CONVERSATION_ID2 = "messaging.conversation_id";
    var TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES2 = "messaging.message_payload_size_bytes";
    var TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES2 = "messaging.message_payload_compressed_size_bytes";
    var TMP_MESSAGING_OPERATION2 = "messaging.operation";
    var TMP_MESSAGING_CONSUMER_ID2 = "messaging.consumer_id";
    var TMP_MESSAGING_RABBITMQ_ROUTING_KEY2 = "messaging.rabbitmq.routing_key";
    var TMP_MESSAGING_KAFKA_MESSAGE_KEY2 = "messaging.kafka.message_key";
    var TMP_MESSAGING_KAFKA_CONSUMER_GROUP2 = "messaging.kafka.consumer_group";
    var TMP_MESSAGING_KAFKA_CLIENT_ID2 = "messaging.kafka.client_id";
    var TMP_MESSAGING_KAFKA_PARTITION2 = "messaging.kafka.partition";
    var TMP_MESSAGING_KAFKA_TOMBSTONE2 = "messaging.kafka.tombstone";
    var TMP_RPC_SYSTEM2 = "rpc.system";
    var TMP_RPC_SERVICE2 = "rpc.service";
    var TMP_RPC_METHOD2 = "rpc.method";
    var TMP_RPC_GRPC_STATUS_CODE2 = "rpc.grpc.status_code";
    var TMP_RPC_JSONRPC_VERSION2 = "rpc.jsonrpc.version";
    var TMP_RPC_JSONRPC_REQUEST_ID2 = "rpc.jsonrpc.request_id";
    var TMP_RPC_JSONRPC_ERROR_CODE2 = "rpc.jsonrpc.error_code";
    var TMP_RPC_JSONRPC_ERROR_MESSAGE2 = "rpc.jsonrpc.error_message";
    var TMP_MESSAGE_TYPE2 = "message.type";
    var TMP_MESSAGE_ID2 = "message.id";
    var TMP_MESSAGE_COMPRESSED_SIZE2 = "message.compressed_size";
    var TMP_MESSAGE_UNCOMPRESSED_SIZE2 = "message.uncompressed_size";
    exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = TMP_AWS_LAMBDA_INVOKED_ARN2;
    exports.SEMATTRS_DB_SYSTEM = TMP_DB_SYSTEM2;
    exports.SEMATTRS_DB_CONNECTION_STRING = TMP_DB_CONNECTION_STRING2;
    exports.SEMATTRS_DB_USER = TMP_DB_USER2;
    exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = TMP_DB_JDBC_DRIVER_CLASSNAME2;
    exports.SEMATTRS_DB_NAME = TMP_DB_NAME2;
    exports.SEMATTRS_DB_STATEMENT = TMP_DB_STATEMENT2;
    exports.SEMATTRS_DB_OPERATION = TMP_DB_OPERATION2;
    exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = TMP_DB_MSSQL_INSTANCE_NAME2;
    exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = TMP_DB_CASSANDRA_KEYSPACE2;
    exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = TMP_DB_CASSANDRA_PAGE_SIZE2;
    exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL2;
    exports.SEMATTRS_DB_CASSANDRA_TABLE = TMP_DB_CASSANDRA_TABLE2;
    exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = TMP_DB_CASSANDRA_IDEMPOTENCE2;
    exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT2;
    exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = TMP_DB_CASSANDRA_COORDINATOR_ID2;
    exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = TMP_DB_CASSANDRA_COORDINATOR_DC2;
    exports.SEMATTRS_DB_HBASE_NAMESPACE = TMP_DB_HBASE_NAMESPACE2;
    exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = TMP_DB_REDIS_DATABASE_INDEX2;
    exports.SEMATTRS_DB_MONGODB_COLLECTION = TMP_DB_MONGODB_COLLECTION2;
    exports.SEMATTRS_DB_SQL_TABLE = TMP_DB_SQL_TABLE2;
    exports.SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE2;
    exports.SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE2;
    exports.SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE2;
    exports.SEMATTRS_EXCEPTION_ESCAPED = TMP_EXCEPTION_ESCAPED2;
    exports.SEMATTRS_FAAS_TRIGGER = TMP_FAAS_TRIGGER2;
    exports.SEMATTRS_FAAS_EXECUTION = TMP_FAAS_EXECUTION2;
    exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = TMP_FAAS_DOCUMENT_COLLECTION2;
    exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = TMP_FAAS_DOCUMENT_OPERATION2;
    exports.SEMATTRS_FAAS_DOCUMENT_TIME = TMP_FAAS_DOCUMENT_TIME2;
    exports.SEMATTRS_FAAS_DOCUMENT_NAME = TMP_FAAS_DOCUMENT_NAME2;
    exports.SEMATTRS_FAAS_TIME = TMP_FAAS_TIME2;
    exports.SEMATTRS_FAAS_CRON = TMP_FAAS_CRON2;
    exports.SEMATTRS_FAAS_COLDSTART = TMP_FAAS_COLDSTART2;
    exports.SEMATTRS_FAAS_INVOKED_NAME = TMP_FAAS_INVOKED_NAME2;
    exports.SEMATTRS_FAAS_INVOKED_PROVIDER = TMP_FAAS_INVOKED_PROVIDER2;
    exports.SEMATTRS_FAAS_INVOKED_REGION = TMP_FAAS_INVOKED_REGION2;
    exports.SEMATTRS_NET_TRANSPORT = TMP_NET_TRANSPORT2;
    exports.SEMATTRS_NET_PEER_IP = TMP_NET_PEER_IP2;
    exports.SEMATTRS_NET_PEER_PORT = TMP_NET_PEER_PORT2;
    exports.SEMATTRS_NET_PEER_NAME = TMP_NET_PEER_NAME2;
    exports.SEMATTRS_NET_HOST_IP = TMP_NET_HOST_IP2;
    exports.SEMATTRS_NET_HOST_PORT = TMP_NET_HOST_PORT2;
    exports.SEMATTRS_NET_HOST_NAME = TMP_NET_HOST_NAME2;
    exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = TMP_NET_HOST_CONNECTION_TYPE2;
    exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = TMP_NET_HOST_CONNECTION_SUBTYPE2;
    exports.SEMATTRS_NET_HOST_CARRIER_NAME = TMP_NET_HOST_CARRIER_NAME2;
    exports.SEMATTRS_NET_HOST_CARRIER_MCC = TMP_NET_HOST_CARRIER_MCC2;
    exports.SEMATTRS_NET_HOST_CARRIER_MNC = TMP_NET_HOST_CARRIER_MNC2;
    exports.SEMATTRS_NET_HOST_CARRIER_ICC = TMP_NET_HOST_CARRIER_ICC2;
    exports.SEMATTRS_PEER_SERVICE = TMP_PEER_SERVICE2;
    exports.SEMATTRS_ENDUSER_ID = TMP_ENDUSER_ID2;
    exports.SEMATTRS_ENDUSER_ROLE = TMP_ENDUSER_ROLE2;
    exports.SEMATTRS_ENDUSER_SCOPE = TMP_ENDUSER_SCOPE2;
    exports.SEMATTRS_THREAD_ID = TMP_THREAD_ID2;
    exports.SEMATTRS_THREAD_NAME = TMP_THREAD_NAME2;
    exports.SEMATTRS_CODE_FUNCTION = TMP_CODE_FUNCTION2;
    exports.SEMATTRS_CODE_NAMESPACE = TMP_CODE_NAMESPACE2;
    exports.SEMATTRS_CODE_FILEPATH = TMP_CODE_FILEPATH2;
    exports.SEMATTRS_CODE_LINENO = TMP_CODE_LINENO2;
    exports.SEMATTRS_HTTP_METHOD = TMP_HTTP_METHOD2;
    exports.SEMATTRS_HTTP_URL = TMP_HTTP_URL2;
    exports.SEMATTRS_HTTP_TARGET = TMP_HTTP_TARGET2;
    exports.SEMATTRS_HTTP_HOST = TMP_HTTP_HOST2;
    exports.SEMATTRS_HTTP_SCHEME = TMP_HTTP_SCHEME2;
    exports.SEMATTRS_HTTP_STATUS_CODE = TMP_HTTP_STATUS_CODE2;
    exports.SEMATTRS_HTTP_FLAVOR = TMP_HTTP_FLAVOR2;
    exports.SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT2;
    exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = TMP_HTTP_REQUEST_CONTENT_LENGTH2;
    exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED2;
    exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = TMP_HTTP_RESPONSE_CONTENT_LENGTH2;
    exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2;
    exports.SEMATTRS_HTTP_SERVER_NAME = TMP_HTTP_SERVER_NAME2;
    exports.SEMATTRS_HTTP_ROUTE = TMP_HTTP_ROUTE2;
    exports.SEMATTRS_HTTP_CLIENT_IP = TMP_HTTP_CLIENT_IP2;
    exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = TMP_AWS_DYNAMODB_TABLE_NAMES2;
    exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY2;
    exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS2;
    exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY2;
    exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY2;
    exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = TMP_AWS_DYNAMODB_CONSISTENT_READ2;
    exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = TMP_AWS_DYNAMODB_PROJECTION2;
    exports.SEMATTRS_AWS_DYNAMODB_LIMIT = TMP_AWS_DYNAMODB_LIMIT2;
    exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET2;
    exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = TMP_AWS_DYNAMODB_INDEX_NAME2;
    exports.SEMATTRS_AWS_DYNAMODB_SELECT = TMP_AWS_DYNAMODB_SELECT2;
    exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES2;
    exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES2;
    exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE2;
    exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = TMP_AWS_DYNAMODB_TABLE_COUNT2;
    exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = TMP_AWS_DYNAMODB_SCAN_FORWARD2;
    exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = TMP_AWS_DYNAMODB_SEGMENT2;
    exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS2;
    exports.SEMATTRS_AWS_DYNAMODB_COUNT = TMP_AWS_DYNAMODB_COUNT2;
    exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = TMP_AWS_DYNAMODB_SCANNED_COUNT2;
    exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS2;
    exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES2;
    exports.SEMATTRS_MESSAGING_SYSTEM = TMP_MESSAGING_SYSTEM2;
    exports.SEMATTRS_MESSAGING_DESTINATION = TMP_MESSAGING_DESTINATION2;
    exports.SEMATTRS_MESSAGING_DESTINATION_KIND = TMP_MESSAGING_DESTINATION_KIND2;
    exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = TMP_MESSAGING_TEMP_DESTINATION2;
    exports.SEMATTRS_MESSAGING_PROTOCOL = TMP_MESSAGING_PROTOCOL2;
    exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = TMP_MESSAGING_PROTOCOL_VERSION2;
    exports.SEMATTRS_MESSAGING_URL = TMP_MESSAGING_URL2;
    exports.SEMATTRS_MESSAGING_MESSAGE_ID = TMP_MESSAGING_MESSAGE_ID2;
    exports.SEMATTRS_MESSAGING_CONVERSATION_ID = TMP_MESSAGING_CONVERSATION_ID2;
    exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES2;
    exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES2;
    exports.SEMATTRS_MESSAGING_OPERATION = TMP_MESSAGING_OPERATION2;
    exports.SEMATTRS_MESSAGING_CONSUMER_ID = TMP_MESSAGING_CONSUMER_ID2;
    exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = TMP_MESSAGING_RABBITMQ_ROUTING_KEY2;
    exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = TMP_MESSAGING_KAFKA_MESSAGE_KEY2;
    exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = TMP_MESSAGING_KAFKA_CONSUMER_GROUP2;
    exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = TMP_MESSAGING_KAFKA_CLIENT_ID2;
    exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = TMP_MESSAGING_KAFKA_PARTITION2;
    exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = TMP_MESSAGING_KAFKA_TOMBSTONE2;
    exports.SEMATTRS_RPC_SYSTEM = TMP_RPC_SYSTEM2;
    exports.SEMATTRS_RPC_SERVICE = TMP_RPC_SERVICE2;
    exports.SEMATTRS_RPC_METHOD = TMP_RPC_METHOD2;
    exports.SEMATTRS_RPC_GRPC_STATUS_CODE = TMP_RPC_GRPC_STATUS_CODE2;
    exports.SEMATTRS_RPC_JSONRPC_VERSION = TMP_RPC_JSONRPC_VERSION2;
    exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = TMP_RPC_JSONRPC_REQUEST_ID2;
    exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = TMP_RPC_JSONRPC_ERROR_CODE2;
    exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = TMP_RPC_JSONRPC_ERROR_MESSAGE2;
    exports.SEMATTRS_MESSAGE_TYPE = TMP_MESSAGE_TYPE2;
    exports.SEMATTRS_MESSAGE_ID = TMP_MESSAGE_ID2;
    exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = TMP_MESSAGE_COMPRESSED_SIZE2;
    exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = TMP_MESSAGE_UNCOMPRESSED_SIZE2;
    exports.SemanticAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_AWS_LAMBDA_INVOKED_ARN2,
      TMP_DB_SYSTEM2,
      TMP_DB_CONNECTION_STRING2,
      TMP_DB_USER2,
      TMP_DB_JDBC_DRIVER_CLASSNAME2,
      TMP_DB_NAME2,
      TMP_DB_STATEMENT2,
      TMP_DB_OPERATION2,
      TMP_DB_MSSQL_INSTANCE_NAME2,
      TMP_DB_CASSANDRA_KEYSPACE2,
      TMP_DB_CASSANDRA_PAGE_SIZE2,
      TMP_DB_CASSANDRA_CONSISTENCY_LEVEL2,
      TMP_DB_CASSANDRA_TABLE2,
      TMP_DB_CASSANDRA_IDEMPOTENCE2,
      TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT2,
      TMP_DB_CASSANDRA_COORDINATOR_ID2,
      TMP_DB_CASSANDRA_COORDINATOR_DC2,
      TMP_DB_HBASE_NAMESPACE2,
      TMP_DB_REDIS_DATABASE_INDEX2,
      TMP_DB_MONGODB_COLLECTION2,
      TMP_DB_SQL_TABLE2,
      TMP_EXCEPTION_TYPE2,
      TMP_EXCEPTION_MESSAGE2,
      TMP_EXCEPTION_STACKTRACE2,
      TMP_EXCEPTION_ESCAPED2,
      TMP_FAAS_TRIGGER2,
      TMP_FAAS_EXECUTION2,
      TMP_FAAS_DOCUMENT_COLLECTION2,
      TMP_FAAS_DOCUMENT_OPERATION2,
      TMP_FAAS_DOCUMENT_TIME2,
      TMP_FAAS_DOCUMENT_NAME2,
      TMP_FAAS_TIME2,
      TMP_FAAS_CRON2,
      TMP_FAAS_COLDSTART2,
      TMP_FAAS_INVOKED_NAME2,
      TMP_FAAS_INVOKED_PROVIDER2,
      TMP_FAAS_INVOKED_REGION2,
      TMP_NET_TRANSPORT2,
      TMP_NET_PEER_IP2,
      TMP_NET_PEER_PORT2,
      TMP_NET_PEER_NAME2,
      TMP_NET_HOST_IP2,
      TMP_NET_HOST_PORT2,
      TMP_NET_HOST_NAME2,
      TMP_NET_HOST_CONNECTION_TYPE2,
      TMP_NET_HOST_CONNECTION_SUBTYPE2,
      TMP_NET_HOST_CARRIER_NAME2,
      TMP_NET_HOST_CARRIER_MCC2,
      TMP_NET_HOST_CARRIER_MNC2,
      TMP_NET_HOST_CARRIER_ICC2,
      TMP_PEER_SERVICE2,
      TMP_ENDUSER_ID2,
      TMP_ENDUSER_ROLE2,
      TMP_ENDUSER_SCOPE2,
      TMP_THREAD_ID2,
      TMP_THREAD_NAME2,
      TMP_CODE_FUNCTION2,
      TMP_CODE_NAMESPACE2,
      TMP_CODE_FILEPATH2,
      TMP_CODE_LINENO2,
      TMP_HTTP_METHOD2,
      TMP_HTTP_URL2,
      TMP_HTTP_TARGET2,
      TMP_HTTP_HOST2,
      TMP_HTTP_SCHEME2,
      TMP_HTTP_STATUS_CODE2,
      TMP_HTTP_FLAVOR2,
      TMP_HTTP_USER_AGENT2,
      TMP_HTTP_REQUEST_CONTENT_LENGTH2,
      TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED2,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH2,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2,
      TMP_HTTP_SERVER_NAME2,
      TMP_HTTP_ROUTE2,
      TMP_HTTP_CLIENT_IP2,
      TMP_AWS_DYNAMODB_TABLE_NAMES2,
      TMP_AWS_DYNAMODB_CONSUMED_CAPACITY2,
      TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS2,
      TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY2,
      TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY2,
      TMP_AWS_DYNAMODB_CONSISTENT_READ2,
      TMP_AWS_DYNAMODB_PROJECTION2,
      TMP_AWS_DYNAMODB_LIMIT2,
      TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET2,
      TMP_AWS_DYNAMODB_INDEX_NAME2,
      TMP_AWS_DYNAMODB_SELECT2,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES2,
      TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES2,
      TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE2,
      TMP_AWS_DYNAMODB_TABLE_COUNT2,
      TMP_AWS_DYNAMODB_SCAN_FORWARD2,
      TMP_AWS_DYNAMODB_SEGMENT2,
      TMP_AWS_DYNAMODB_TOTAL_SEGMENTS2,
      TMP_AWS_DYNAMODB_COUNT2,
      TMP_AWS_DYNAMODB_SCANNED_COUNT2,
      TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS2,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES2,
      TMP_MESSAGING_SYSTEM2,
      TMP_MESSAGING_DESTINATION2,
      TMP_MESSAGING_DESTINATION_KIND2,
      TMP_MESSAGING_TEMP_DESTINATION2,
      TMP_MESSAGING_PROTOCOL2,
      TMP_MESSAGING_PROTOCOL_VERSION2,
      TMP_MESSAGING_URL2,
      TMP_MESSAGING_MESSAGE_ID2,
      TMP_MESSAGING_CONVERSATION_ID2,
      TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES2,
      TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES2,
      TMP_MESSAGING_OPERATION2,
      TMP_MESSAGING_CONSUMER_ID2,
      TMP_MESSAGING_RABBITMQ_ROUTING_KEY2,
      TMP_MESSAGING_KAFKA_MESSAGE_KEY2,
      TMP_MESSAGING_KAFKA_CONSUMER_GROUP2,
      TMP_MESSAGING_KAFKA_CLIENT_ID2,
      TMP_MESSAGING_KAFKA_PARTITION2,
      TMP_MESSAGING_KAFKA_TOMBSTONE2,
      TMP_RPC_SYSTEM2,
      TMP_RPC_SERVICE2,
      TMP_RPC_METHOD2,
      TMP_RPC_GRPC_STATUS_CODE2,
      TMP_RPC_JSONRPC_VERSION2,
      TMP_RPC_JSONRPC_REQUEST_ID2,
      TMP_RPC_JSONRPC_ERROR_CODE2,
      TMP_RPC_JSONRPC_ERROR_MESSAGE2,
      TMP_MESSAGE_TYPE2,
      TMP_MESSAGE_ID2,
      TMP_MESSAGE_COMPRESSED_SIZE2,
      TMP_MESSAGE_UNCOMPRESSED_SIZE2
    ]);
    var TMP_DBSYSTEMVALUES_OTHER_SQL2 = "other_sql";
    var TMP_DBSYSTEMVALUES_MSSQL2 = "mssql";
    var TMP_DBSYSTEMVALUES_MYSQL2 = "mysql";
    var TMP_DBSYSTEMVALUES_ORACLE2 = "oracle";
    var TMP_DBSYSTEMVALUES_DB22 = "db2";
    var TMP_DBSYSTEMVALUES_POSTGRESQL2 = "postgresql";
    var TMP_DBSYSTEMVALUES_REDSHIFT2 = "redshift";
    var TMP_DBSYSTEMVALUES_HIVE2 = "hive";
    var TMP_DBSYSTEMVALUES_CLOUDSCAPE2 = "cloudscape";
    var TMP_DBSYSTEMVALUES_HSQLDB2 = "hsqldb";
    var TMP_DBSYSTEMVALUES_PROGRESS2 = "progress";
    var TMP_DBSYSTEMVALUES_MAXDB2 = "maxdb";
    var TMP_DBSYSTEMVALUES_HANADB2 = "hanadb";
    var TMP_DBSYSTEMVALUES_INGRES2 = "ingres";
    var TMP_DBSYSTEMVALUES_FIRSTSQL2 = "firstsql";
    var TMP_DBSYSTEMVALUES_EDB2 = "edb";
    var TMP_DBSYSTEMVALUES_CACHE2 = "cache";
    var TMP_DBSYSTEMVALUES_ADABAS2 = "adabas";
    var TMP_DBSYSTEMVALUES_FIREBIRD2 = "firebird";
    var TMP_DBSYSTEMVALUES_DERBY2 = "derby";
    var TMP_DBSYSTEMVALUES_FILEMAKER2 = "filemaker";
    var TMP_DBSYSTEMVALUES_INFORMIX2 = "informix";
    var TMP_DBSYSTEMVALUES_INSTANTDB2 = "instantdb";
    var TMP_DBSYSTEMVALUES_INTERBASE2 = "interbase";
    var TMP_DBSYSTEMVALUES_MARIADB2 = "mariadb";
    var TMP_DBSYSTEMVALUES_NETEZZA2 = "netezza";
    var TMP_DBSYSTEMVALUES_PERVASIVE2 = "pervasive";
    var TMP_DBSYSTEMVALUES_POINTBASE2 = "pointbase";
    var TMP_DBSYSTEMVALUES_SQLITE2 = "sqlite";
    var TMP_DBSYSTEMVALUES_SYBASE2 = "sybase";
    var TMP_DBSYSTEMVALUES_TERADATA2 = "teradata";
    var TMP_DBSYSTEMVALUES_VERTICA2 = "vertica";
    var TMP_DBSYSTEMVALUES_H22 = "h2";
    var TMP_DBSYSTEMVALUES_COLDFUSION2 = "coldfusion";
    var TMP_DBSYSTEMVALUES_CASSANDRA2 = "cassandra";
    var TMP_DBSYSTEMVALUES_HBASE2 = "hbase";
    var TMP_DBSYSTEMVALUES_MONGODB2 = "mongodb";
    var TMP_DBSYSTEMVALUES_REDIS2 = "redis";
    var TMP_DBSYSTEMVALUES_COUCHBASE2 = "couchbase";
    var TMP_DBSYSTEMVALUES_COUCHDB2 = "couchdb";
    var TMP_DBSYSTEMVALUES_COSMOSDB2 = "cosmosdb";
    var TMP_DBSYSTEMVALUES_DYNAMODB2 = "dynamodb";
    var TMP_DBSYSTEMVALUES_NEO4J2 = "neo4j";
    var TMP_DBSYSTEMVALUES_GEODE2 = "geode";
    var TMP_DBSYSTEMVALUES_ELASTICSEARCH2 = "elasticsearch";
    var TMP_DBSYSTEMVALUES_MEMCACHED2 = "memcached";
    var TMP_DBSYSTEMVALUES_COCKROACHDB2 = "cockroachdb";
    exports.DBSYSTEMVALUES_OTHER_SQL = TMP_DBSYSTEMVALUES_OTHER_SQL2;
    exports.DBSYSTEMVALUES_MSSQL = TMP_DBSYSTEMVALUES_MSSQL2;
    exports.DBSYSTEMVALUES_MYSQL = TMP_DBSYSTEMVALUES_MYSQL2;
    exports.DBSYSTEMVALUES_ORACLE = TMP_DBSYSTEMVALUES_ORACLE2;
    exports.DBSYSTEMVALUES_DB2 = TMP_DBSYSTEMVALUES_DB22;
    exports.DBSYSTEMVALUES_POSTGRESQL = TMP_DBSYSTEMVALUES_POSTGRESQL2;
    exports.DBSYSTEMVALUES_REDSHIFT = TMP_DBSYSTEMVALUES_REDSHIFT2;
    exports.DBSYSTEMVALUES_HIVE = TMP_DBSYSTEMVALUES_HIVE2;
    exports.DBSYSTEMVALUES_CLOUDSCAPE = TMP_DBSYSTEMVALUES_CLOUDSCAPE2;
    exports.DBSYSTEMVALUES_HSQLDB = TMP_DBSYSTEMVALUES_HSQLDB2;
    exports.DBSYSTEMVALUES_PROGRESS = TMP_DBSYSTEMVALUES_PROGRESS2;
    exports.DBSYSTEMVALUES_MAXDB = TMP_DBSYSTEMVALUES_MAXDB2;
    exports.DBSYSTEMVALUES_HANADB = TMP_DBSYSTEMVALUES_HANADB2;
    exports.DBSYSTEMVALUES_INGRES = TMP_DBSYSTEMVALUES_INGRES2;
    exports.DBSYSTEMVALUES_FIRSTSQL = TMP_DBSYSTEMVALUES_FIRSTSQL2;
    exports.DBSYSTEMVALUES_EDB = TMP_DBSYSTEMVALUES_EDB2;
    exports.DBSYSTEMVALUES_CACHE = TMP_DBSYSTEMVALUES_CACHE2;
    exports.DBSYSTEMVALUES_ADABAS = TMP_DBSYSTEMVALUES_ADABAS2;
    exports.DBSYSTEMVALUES_FIREBIRD = TMP_DBSYSTEMVALUES_FIREBIRD2;
    exports.DBSYSTEMVALUES_DERBY = TMP_DBSYSTEMVALUES_DERBY2;
    exports.DBSYSTEMVALUES_FILEMAKER = TMP_DBSYSTEMVALUES_FILEMAKER2;
    exports.DBSYSTEMVALUES_INFORMIX = TMP_DBSYSTEMVALUES_INFORMIX2;
    exports.DBSYSTEMVALUES_INSTANTDB = TMP_DBSYSTEMVALUES_INSTANTDB2;
    exports.DBSYSTEMVALUES_INTERBASE = TMP_DBSYSTEMVALUES_INTERBASE2;
    exports.DBSYSTEMVALUES_MARIADB = TMP_DBSYSTEMVALUES_MARIADB2;
    exports.DBSYSTEMVALUES_NETEZZA = TMP_DBSYSTEMVALUES_NETEZZA2;
    exports.DBSYSTEMVALUES_PERVASIVE = TMP_DBSYSTEMVALUES_PERVASIVE2;
    exports.DBSYSTEMVALUES_POINTBASE = TMP_DBSYSTEMVALUES_POINTBASE2;
    exports.DBSYSTEMVALUES_SQLITE = TMP_DBSYSTEMVALUES_SQLITE2;
    exports.DBSYSTEMVALUES_SYBASE = TMP_DBSYSTEMVALUES_SYBASE2;
    exports.DBSYSTEMVALUES_TERADATA = TMP_DBSYSTEMVALUES_TERADATA2;
    exports.DBSYSTEMVALUES_VERTICA = TMP_DBSYSTEMVALUES_VERTICA2;
    exports.DBSYSTEMVALUES_H2 = TMP_DBSYSTEMVALUES_H22;
    exports.DBSYSTEMVALUES_COLDFUSION = TMP_DBSYSTEMVALUES_COLDFUSION2;
    exports.DBSYSTEMVALUES_CASSANDRA = TMP_DBSYSTEMVALUES_CASSANDRA2;
    exports.DBSYSTEMVALUES_HBASE = TMP_DBSYSTEMVALUES_HBASE2;
    exports.DBSYSTEMVALUES_MONGODB = TMP_DBSYSTEMVALUES_MONGODB2;
    exports.DBSYSTEMVALUES_REDIS = TMP_DBSYSTEMVALUES_REDIS2;
    exports.DBSYSTEMVALUES_COUCHBASE = TMP_DBSYSTEMVALUES_COUCHBASE2;
    exports.DBSYSTEMVALUES_COUCHDB = TMP_DBSYSTEMVALUES_COUCHDB2;
    exports.DBSYSTEMVALUES_COSMOSDB = TMP_DBSYSTEMVALUES_COSMOSDB2;
    exports.DBSYSTEMVALUES_DYNAMODB = TMP_DBSYSTEMVALUES_DYNAMODB2;
    exports.DBSYSTEMVALUES_NEO4J = TMP_DBSYSTEMVALUES_NEO4J2;
    exports.DBSYSTEMVALUES_GEODE = TMP_DBSYSTEMVALUES_GEODE2;
    exports.DBSYSTEMVALUES_ELASTICSEARCH = TMP_DBSYSTEMVALUES_ELASTICSEARCH2;
    exports.DBSYSTEMVALUES_MEMCACHED = TMP_DBSYSTEMVALUES_MEMCACHED2;
    exports.DBSYSTEMVALUES_COCKROACHDB = TMP_DBSYSTEMVALUES_COCKROACHDB2;
    exports.DbSystemValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_DBSYSTEMVALUES_OTHER_SQL2,
      TMP_DBSYSTEMVALUES_MSSQL2,
      TMP_DBSYSTEMVALUES_MYSQL2,
      TMP_DBSYSTEMVALUES_ORACLE2,
      TMP_DBSYSTEMVALUES_DB22,
      TMP_DBSYSTEMVALUES_POSTGRESQL2,
      TMP_DBSYSTEMVALUES_REDSHIFT2,
      TMP_DBSYSTEMVALUES_HIVE2,
      TMP_DBSYSTEMVALUES_CLOUDSCAPE2,
      TMP_DBSYSTEMVALUES_HSQLDB2,
      TMP_DBSYSTEMVALUES_PROGRESS2,
      TMP_DBSYSTEMVALUES_MAXDB2,
      TMP_DBSYSTEMVALUES_HANADB2,
      TMP_DBSYSTEMVALUES_INGRES2,
      TMP_DBSYSTEMVALUES_FIRSTSQL2,
      TMP_DBSYSTEMVALUES_EDB2,
      TMP_DBSYSTEMVALUES_CACHE2,
      TMP_DBSYSTEMVALUES_ADABAS2,
      TMP_DBSYSTEMVALUES_FIREBIRD2,
      TMP_DBSYSTEMVALUES_DERBY2,
      TMP_DBSYSTEMVALUES_FILEMAKER2,
      TMP_DBSYSTEMVALUES_INFORMIX2,
      TMP_DBSYSTEMVALUES_INSTANTDB2,
      TMP_DBSYSTEMVALUES_INTERBASE2,
      TMP_DBSYSTEMVALUES_MARIADB2,
      TMP_DBSYSTEMVALUES_NETEZZA2,
      TMP_DBSYSTEMVALUES_PERVASIVE2,
      TMP_DBSYSTEMVALUES_POINTBASE2,
      TMP_DBSYSTEMVALUES_SQLITE2,
      TMP_DBSYSTEMVALUES_SYBASE2,
      TMP_DBSYSTEMVALUES_TERADATA2,
      TMP_DBSYSTEMVALUES_VERTICA2,
      TMP_DBSYSTEMVALUES_H22,
      TMP_DBSYSTEMVALUES_COLDFUSION2,
      TMP_DBSYSTEMVALUES_CASSANDRA2,
      TMP_DBSYSTEMVALUES_HBASE2,
      TMP_DBSYSTEMVALUES_MONGODB2,
      TMP_DBSYSTEMVALUES_REDIS2,
      TMP_DBSYSTEMVALUES_COUCHBASE2,
      TMP_DBSYSTEMVALUES_COUCHDB2,
      TMP_DBSYSTEMVALUES_COSMOSDB2,
      TMP_DBSYSTEMVALUES_DYNAMODB2,
      TMP_DBSYSTEMVALUES_NEO4J2,
      TMP_DBSYSTEMVALUES_GEODE2,
      TMP_DBSYSTEMVALUES_ELASTICSEARCH2,
      TMP_DBSYSTEMVALUES_MEMCACHED2,
      TMP_DBSYSTEMVALUES_COCKROACHDB2
    ]);
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL2 = "all";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM2 = "each_quorum";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM2 = "quorum";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM2 = "local_quorum";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE2 = "one";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO2 = "two";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE2 = "three";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE2 = "local_one";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY2 = "any";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL2 = "serial";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL2 = "local_serial";
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL2;
    exports.DbCassandraConsistencyLevelValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL2
    ]);
    var TMP_FAASTRIGGERVALUES_DATASOURCE2 = "datasource";
    var TMP_FAASTRIGGERVALUES_HTTP2 = "http";
    var TMP_FAASTRIGGERVALUES_PUBSUB2 = "pubsub";
    var TMP_FAASTRIGGERVALUES_TIMER2 = "timer";
    var TMP_FAASTRIGGERVALUES_OTHER2 = "other";
    exports.FAASTRIGGERVALUES_DATASOURCE = TMP_FAASTRIGGERVALUES_DATASOURCE2;
    exports.FAASTRIGGERVALUES_HTTP = TMP_FAASTRIGGERVALUES_HTTP2;
    exports.FAASTRIGGERVALUES_PUBSUB = TMP_FAASTRIGGERVALUES_PUBSUB2;
    exports.FAASTRIGGERVALUES_TIMER = TMP_FAASTRIGGERVALUES_TIMER2;
    exports.FAASTRIGGERVALUES_OTHER = TMP_FAASTRIGGERVALUES_OTHER2;
    exports.FaasTriggerValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_FAASTRIGGERVALUES_DATASOURCE2,
      TMP_FAASTRIGGERVALUES_HTTP2,
      TMP_FAASTRIGGERVALUES_PUBSUB2,
      TMP_FAASTRIGGERVALUES_TIMER2,
      TMP_FAASTRIGGERVALUES_OTHER2
    ]);
    var TMP_FAASDOCUMENTOPERATIONVALUES_INSERT2 = "insert";
    var TMP_FAASDOCUMENTOPERATIONVALUES_EDIT2 = "edit";
    var TMP_FAASDOCUMENTOPERATIONVALUES_DELETE2 = "delete";
    exports.FAASDOCUMENTOPERATIONVALUES_INSERT = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT2;
    exports.FAASDOCUMENTOPERATIONVALUES_EDIT = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT2;
    exports.FAASDOCUMENTOPERATIONVALUES_DELETE = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE2;
    exports.FaasDocumentOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_FAASDOCUMENTOPERATIONVALUES_INSERT2,
      TMP_FAASDOCUMENTOPERATIONVALUES_EDIT2,
      TMP_FAASDOCUMENTOPERATIONVALUES_DELETE2
    ]);
    var TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD2 = "alibaba_cloud";
    var TMP_FAASINVOKEDPROVIDERVALUES_AWS2 = "aws";
    var TMP_FAASINVOKEDPROVIDERVALUES_AZURE2 = "azure";
    var TMP_FAASINVOKEDPROVIDERVALUES_GCP2 = "gcp";
    exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD2;
    exports.FAASINVOKEDPROVIDERVALUES_AWS = TMP_FAASINVOKEDPROVIDERVALUES_AWS2;
    exports.FAASINVOKEDPROVIDERVALUES_AZURE = TMP_FAASINVOKEDPROVIDERVALUES_AZURE2;
    exports.FAASINVOKEDPROVIDERVALUES_GCP = TMP_FAASINVOKEDPROVIDERVALUES_GCP2;
    exports.FaasInvokedProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD2,
      TMP_FAASINVOKEDPROVIDERVALUES_AWS2,
      TMP_FAASINVOKEDPROVIDERVALUES_AZURE2,
      TMP_FAASINVOKEDPROVIDERVALUES_GCP2
    ]);
    var TMP_NETTRANSPORTVALUES_IP_TCP2 = "ip_tcp";
    var TMP_NETTRANSPORTVALUES_IP_UDP2 = "ip_udp";
    var TMP_NETTRANSPORTVALUES_IP2 = "ip";
    var TMP_NETTRANSPORTVALUES_UNIX2 = "unix";
    var TMP_NETTRANSPORTVALUES_PIPE2 = "pipe";
    var TMP_NETTRANSPORTVALUES_INPROC2 = "inproc";
    var TMP_NETTRANSPORTVALUES_OTHER2 = "other";
    exports.NETTRANSPORTVALUES_IP_TCP = TMP_NETTRANSPORTVALUES_IP_TCP2;
    exports.NETTRANSPORTVALUES_IP_UDP = TMP_NETTRANSPORTVALUES_IP_UDP2;
    exports.NETTRANSPORTVALUES_IP = TMP_NETTRANSPORTVALUES_IP2;
    exports.NETTRANSPORTVALUES_UNIX = TMP_NETTRANSPORTVALUES_UNIX2;
    exports.NETTRANSPORTVALUES_PIPE = TMP_NETTRANSPORTVALUES_PIPE2;
    exports.NETTRANSPORTVALUES_INPROC = TMP_NETTRANSPORTVALUES_INPROC2;
    exports.NETTRANSPORTVALUES_OTHER = TMP_NETTRANSPORTVALUES_OTHER2;
    exports.NetTransportValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_NETTRANSPORTVALUES_IP_TCP2,
      TMP_NETTRANSPORTVALUES_IP_UDP2,
      TMP_NETTRANSPORTVALUES_IP2,
      TMP_NETTRANSPORTVALUES_UNIX2,
      TMP_NETTRANSPORTVALUES_PIPE2,
      TMP_NETTRANSPORTVALUES_INPROC2,
      TMP_NETTRANSPORTVALUES_OTHER2
    ]);
    var TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI2 = "wifi";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED2 = "wired";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_CELL2 = "cell";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE2 = "unavailable";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN2 = "unknown";
    exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI2;
    exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED2;
    exports.NETHOSTCONNECTIONTYPEVALUES_CELL = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL2;
    exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE2;
    exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN2;
    exports.NetHostConnectionTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI2,
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED2,
      TMP_NETHOSTCONNECTIONTYPEVALUES_CELL2,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE2,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN2
    ]);
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS2 = "gprs";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE2 = "edge";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS2 = "umts";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2 = "cdma";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_02 = "evdo_0";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A2 = "evdo_a";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT2 = "cdma2000_1xrtt";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA2 = "hsdpa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA2 = "hsupa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA2 = "hspa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN2 = "iden";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B2 = "evdo_b";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE2 = "lte";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD2 = "ehrpd";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP2 = "hspap";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM2 = "gsm";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA2 = "td_scdma";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN2 = "iwlan";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR2 = "nr";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA2 = "nrnsa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA2 = "lte_ca";
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_02;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA2;
    exports.NetHostConnectionSubtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_02,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA2
    ]);
    var TMP_HTTPFLAVORVALUES_HTTP_1_02 = "1.0";
    var TMP_HTTPFLAVORVALUES_HTTP_1_12 = "1.1";
    var TMP_HTTPFLAVORVALUES_HTTP_2_02 = "2.0";
    var TMP_HTTPFLAVORVALUES_SPDY2 = "SPDY";
    var TMP_HTTPFLAVORVALUES_QUIC2 = "QUIC";
    exports.HTTPFLAVORVALUES_HTTP_1_0 = TMP_HTTPFLAVORVALUES_HTTP_1_02;
    exports.HTTPFLAVORVALUES_HTTP_1_1 = TMP_HTTPFLAVORVALUES_HTTP_1_12;
    exports.HTTPFLAVORVALUES_HTTP_2_0 = TMP_HTTPFLAVORVALUES_HTTP_2_02;
    exports.HTTPFLAVORVALUES_SPDY = TMP_HTTPFLAVORVALUES_SPDY2;
    exports.HTTPFLAVORVALUES_QUIC = TMP_HTTPFLAVORVALUES_QUIC2;
    exports.HttpFlavorValues = {
      HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_02,
      HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_12,
      HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_02,
      SPDY: TMP_HTTPFLAVORVALUES_SPDY2,
      QUIC: TMP_HTTPFLAVORVALUES_QUIC2
    };
    var TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE2 = "queue";
    var TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC2 = "topic";
    exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE2;
    exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC2;
    exports.MessagingDestinationKindValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE2,
      TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC2
    ]);
    var TMP_MESSAGINGOPERATIONVALUES_RECEIVE2 = "receive";
    var TMP_MESSAGINGOPERATIONVALUES_PROCESS2 = "process";
    exports.MESSAGINGOPERATIONVALUES_RECEIVE = TMP_MESSAGINGOPERATIONVALUES_RECEIVE2;
    exports.MESSAGINGOPERATIONVALUES_PROCESS = TMP_MESSAGINGOPERATIONVALUES_PROCESS2;
    exports.MessagingOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_MESSAGINGOPERATIONVALUES_RECEIVE2,
      TMP_MESSAGINGOPERATIONVALUES_PROCESS2
    ]);
    var TMP_RPCGRPCSTATUSCODEVALUES_OK2 = 0;
    var TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED2 = 1;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN2 = 2;
    var TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT2 = 3;
    var TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED2 = 4;
    var TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND2 = 5;
    var TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS2 = 6;
    var TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED2 = 7;
    var TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED2 = 8;
    var TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION2 = 9;
    var TMP_RPCGRPCSTATUSCODEVALUES_ABORTED2 = 10;
    var TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE2 = 11;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED2 = 12;
    var TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL2 = 13;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE2 = 14;
    var TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS2 = 15;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED2 = 16;
    exports.RPCGRPCSTATUSCODEVALUES_OK = TMP_RPCGRPCSTATUSCODEVALUES_OK2;
    exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED2;
    exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN2;
    exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT2;
    exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED2;
    exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND2;
    exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS2;
    exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED2;
    exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED2;
    exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION2;
    exports.RPCGRPCSTATUSCODEVALUES_ABORTED = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED2;
    exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE2;
    exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED2;
    exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL2;
    exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE2;
    exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS2;
    exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED2;
    exports.RpcGrpcStatusCodeValues = {
      OK: TMP_RPCGRPCSTATUSCODEVALUES_OK2,
      CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED2,
      UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN2,
      INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT2,
      DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED2,
      NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND2,
      ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS2,
      PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED2,
      RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED2,
      FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION2,
      ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED2,
      OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE2,
      UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED2,
      INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL2,
      UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE2,
      DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS2,
      UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED2
    };
    var TMP_MESSAGETYPEVALUES_SENT2 = "SENT";
    var TMP_MESSAGETYPEVALUES_RECEIVED2 = "RECEIVED";
    exports.MESSAGETYPEVALUES_SENT = TMP_MESSAGETYPEVALUES_SENT2;
    exports.MESSAGETYPEVALUES_RECEIVED = TMP_MESSAGETYPEVALUES_RECEIVED2;
    exports.MessageTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_MESSAGETYPEVALUES_SENT2,
      TMP_MESSAGETYPEVALUES_RECEIVED2
    ]);
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js
var require_trace3 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_SemanticAttributes3(), exports);
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js
var require_SemanticResourceAttributes3 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SEMRESATTRS_K8S_STATEFULSET_NAME = exports.SEMRESATTRS_K8S_STATEFULSET_UID = exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = exports.SEMRESATTRS_K8S_REPLICASET_NAME = exports.SEMRESATTRS_K8S_REPLICASET_UID = exports.SEMRESATTRS_K8S_CONTAINER_NAME = exports.SEMRESATTRS_K8S_POD_NAME = exports.SEMRESATTRS_K8S_POD_UID = exports.SEMRESATTRS_K8S_NAMESPACE_NAME = exports.SEMRESATTRS_K8S_NODE_UID = exports.SEMRESATTRS_K8S_NODE_NAME = exports.SEMRESATTRS_K8S_CLUSTER_NAME = exports.SEMRESATTRS_HOST_IMAGE_VERSION = exports.SEMRESATTRS_HOST_IMAGE_ID = exports.SEMRESATTRS_HOST_IMAGE_NAME = exports.SEMRESATTRS_HOST_ARCH = exports.SEMRESATTRS_HOST_TYPE = exports.SEMRESATTRS_HOST_NAME = exports.SEMRESATTRS_HOST_ID = exports.SEMRESATTRS_FAAS_MAX_MEMORY = exports.SEMRESATTRS_FAAS_INSTANCE = exports.SEMRESATTRS_FAAS_VERSION = exports.SEMRESATTRS_FAAS_ID = exports.SEMRESATTRS_FAAS_NAME = exports.SEMRESATTRS_DEVICE_MODEL_NAME = exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = exports.SEMRESATTRS_DEVICE_ID = exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = exports.SEMRESATTRS_CONTAINER_RUNTIME = exports.SEMRESATTRS_CONTAINER_ID = exports.SEMRESATTRS_CONTAINER_NAME = exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = exports.SEMRESATTRS_AWS_ECS_TASK_ARN = exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = exports.SEMRESATTRS_CLOUD_PLATFORM = exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = exports.SEMRESATTRS_CLOUD_REGION = exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = exports.SEMRESATTRS_CLOUD_PROVIDER = void 0;
    exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = exports.CLOUDPLATFORMVALUES_AZURE_AKS = exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = exports.CLOUDPLATFORMVALUES_AZURE_VM = exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = exports.CLOUDPLATFORMVALUES_AWS_EKS = exports.CLOUDPLATFORMVALUES_AWS_ECS = exports.CLOUDPLATFORMVALUES_AWS_EC2 = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = exports.CloudProviderValues = exports.CLOUDPROVIDERVALUES_GCP = exports.CLOUDPROVIDERVALUES_AZURE = exports.CLOUDPROVIDERVALUES_AWS = exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = exports.SemanticResourceAttributes = exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = exports.SEMRESATTRS_WEBENGINE_VERSION = exports.SEMRESATTRS_WEBENGINE_NAME = exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = exports.SEMRESATTRS_TELEMETRY_SDK_NAME = exports.SEMRESATTRS_SERVICE_VERSION = exports.SEMRESATTRS_SERVICE_INSTANCE_ID = exports.SEMRESATTRS_SERVICE_NAMESPACE = exports.SEMRESATTRS_SERVICE_NAME = exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = exports.SEMRESATTRS_PROCESS_OWNER = exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = exports.SEMRESATTRS_PROCESS_COMMAND_LINE = exports.SEMRESATTRS_PROCESS_COMMAND = exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = exports.SEMRESATTRS_PROCESS_PID = exports.SEMRESATTRS_OS_VERSION = exports.SEMRESATTRS_OS_NAME = exports.SEMRESATTRS_OS_DESCRIPTION = exports.SEMRESATTRS_OS_TYPE = exports.SEMRESATTRS_K8S_CRONJOB_NAME = exports.SEMRESATTRS_K8S_CRONJOB_UID = exports.SEMRESATTRS_K8S_JOB_NAME = exports.SEMRESATTRS_K8S_JOB_UID = exports.SEMRESATTRS_K8S_DAEMONSET_NAME = exports.SEMRESATTRS_K8S_DAEMONSET_UID = void 0;
    exports.TelemetrySdkLanguageValues = exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = exports.TELEMETRYSDKLANGUAGEVALUES_PHP = exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = exports.TELEMETRYSDKLANGUAGEVALUES_GO = exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = exports.TELEMETRYSDKLANGUAGEVALUES_CPP = exports.OsTypeValues = exports.OSTYPEVALUES_Z_OS = exports.OSTYPEVALUES_SOLARIS = exports.OSTYPEVALUES_AIX = exports.OSTYPEVALUES_HPUX = exports.OSTYPEVALUES_DRAGONFLYBSD = exports.OSTYPEVALUES_OPENBSD = exports.OSTYPEVALUES_NETBSD = exports.OSTYPEVALUES_FREEBSD = exports.OSTYPEVALUES_DARWIN = exports.OSTYPEVALUES_LINUX = exports.OSTYPEVALUES_WINDOWS = exports.HostArchValues = exports.HOSTARCHVALUES_X86 = exports.HOSTARCHVALUES_PPC64 = exports.HOSTARCHVALUES_PPC32 = exports.HOSTARCHVALUES_IA64 = exports.HOSTARCHVALUES_ARM64 = exports.HOSTARCHVALUES_ARM32 = exports.HOSTARCHVALUES_AMD64 = exports.AwsEcsLaunchtypeValues = exports.AWSECSLAUNCHTYPEVALUES_FARGATE = exports.AWSECSLAUNCHTYPEVALUES_EC2 = exports.CloudPlatformValues = exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = void 0;
    var utils_1 = require_utils9();
    var TMP_CLOUD_PROVIDER2 = "cloud.provider";
    var TMP_CLOUD_ACCOUNT_ID2 = "cloud.account.id";
    var TMP_CLOUD_REGION2 = "cloud.region";
    var TMP_CLOUD_AVAILABILITY_ZONE2 = "cloud.availability_zone";
    var TMP_CLOUD_PLATFORM2 = "cloud.platform";
    var TMP_AWS_ECS_CONTAINER_ARN2 = "aws.ecs.container.arn";
    var TMP_AWS_ECS_CLUSTER_ARN2 = "aws.ecs.cluster.arn";
    var TMP_AWS_ECS_LAUNCHTYPE2 = "aws.ecs.launchtype";
    var TMP_AWS_ECS_TASK_ARN2 = "aws.ecs.task.arn";
    var TMP_AWS_ECS_TASK_FAMILY2 = "aws.ecs.task.family";
    var TMP_AWS_ECS_TASK_REVISION2 = "aws.ecs.task.revision";
    var TMP_AWS_EKS_CLUSTER_ARN2 = "aws.eks.cluster.arn";
    var TMP_AWS_LOG_GROUP_NAMES2 = "aws.log.group.names";
    var TMP_AWS_LOG_GROUP_ARNS2 = "aws.log.group.arns";
    var TMP_AWS_LOG_STREAM_NAMES2 = "aws.log.stream.names";
    var TMP_AWS_LOG_STREAM_ARNS2 = "aws.log.stream.arns";
    var TMP_CONTAINER_NAME2 = "container.name";
    var TMP_CONTAINER_ID2 = "container.id";
    var TMP_CONTAINER_RUNTIME2 = "container.runtime";
    var TMP_CONTAINER_IMAGE_NAME2 = "container.image.name";
    var TMP_CONTAINER_IMAGE_TAG2 = "container.image.tag";
    var TMP_DEPLOYMENT_ENVIRONMENT2 = "deployment.environment";
    var TMP_DEVICE_ID2 = "device.id";
    var TMP_DEVICE_MODEL_IDENTIFIER2 = "device.model.identifier";
    var TMP_DEVICE_MODEL_NAME2 = "device.model.name";
    var TMP_FAAS_NAME2 = "faas.name";
    var TMP_FAAS_ID2 = "faas.id";
    var TMP_FAAS_VERSION2 = "faas.version";
    var TMP_FAAS_INSTANCE2 = "faas.instance";
    var TMP_FAAS_MAX_MEMORY2 = "faas.max_memory";
    var TMP_HOST_ID2 = "host.id";
    var TMP_HOST_NAME2 = "host.name";
    var TMP_HOST_TYPE2 = "host.type";
    var TMP_HOST_ARCH2 = "host.arch";
    var TMP_HOST_IMAGE_NAME2 = "host.image.name";
    var TMP_HOST_IMAGE_ID2 = "host.image.id";
    var TMP_HOST_IMAGE_VERSION2 = "host.image.version";
    var TMP_K8S_CLUSTER_NAME2 = "k8s.cluster.name";
    var TMP_K8S_NODE_NAME2 = "k8s.node.name";
    var TMP_K8S_NODE_UID2 = "k8s.node.uid";
    var TMP_K8S_NAMESPACE_NAME2 = "k8s.namespace.name";
    var TMP_K8S_POD_UID2 = "k8s.pod.uid";
    var TMP_K8S_POD_NAME2 = "k8s.pod.name";
    var TMP_K8S_CONTAINER_NAME2 = "k8s.container.name";
    var TMP_K8S_REPLICASET_UID2 = "k8s.replicaset.uid";
    var TMP_K8S_REPLICASET_NAME2 = "k8s.replicaset.name";
    var TMP_K8S_DEPLOYMENT_UID2 = "k8s.deployment.uid";
    var TMP_K8S_DEPLOYMENT_NAME2 = "k8s.deployment.name";
    var TMP_K8S_STATEFULSET_UID2 = "k8s.statefulset.uid";
    var TMP_K8S_STATEFULSET_NAME2 = "k8s.statefulset.name";
    var TMP_K8S_DAEMONSET_UID2 = "k8s.daemonset.uid";
    var TMP_K8S_DAEMONSET_NAME2 = "k8s.daemonset.name";
    var TMP_K8S_JOB_UID2 = "k8s.job.uid";
    var TMP_K8S_JOB_NAME2 = "k8s.job.name";
    var TMP_K8S_CRONJOB_UID2 = "k8s.cronjob.uid";
    var TMP_K8S_CRONJOB_NAME2 = "k8s.cronjob.name";
    var TMP_OS_TYPE2 = "os.type";
    var TMP_OS_DESCRIPTION2 = "os.description";
    var TMP_OS_NAME2 = "os.name";
    var TMP_OS_VERSION2 = "os.version";
    var TMP_PROCESS_PID2 = "process.pid";
    var TMP_PROCESS_EXECUTABLE_NAME2 = "process.executable.name";
    var TMP_PROCESS_EXECUTABLE_PATH2 = "process.executable.path";
    var TMP_PROCESS_COMMAND2 = "process.command";
    var TMP_PROCESS_COMMAND_LINE2 = "process.command_line";
    var TMP_PROCESS_COMMAND_ARGS2 = "process.command_args";
    var TMP_PROCESS_OWNER2 = "process.owner";
    var TMP_PROCESS_RUNTIME_NAME2 = "process.runtime.name";
    var TMP_PROCESS_RUNTIME_VERSION2 = "process.runtime.version";
    var TMP_PROCESS_RUNTIME_DESCRIPTION2 = "process.runtime.description";
    var TMP_SERVICE_NAME2 = "service.name";
    var TMP_SERVICE_NAMESPACE2 = "service.namespace";
    var TMP_SERVICE_INSTANCE_ID2 = "service.instance.id";
    var TMP_SERVICE_VERSION2 = "service.version";
    var TMP_TELEMETRY_SDK_NAME2 = "telemetry.sdk.name";
    var TMP_TELEMETRY_SDK_LANGUAGE2 = "telemetry.sdk.language";
    var TMP_TELEMETRY_SDK_VERSION2 = "telemetry.sdk.version";
    var TMP_TELEMETRY_AUTO_VERSION2 = "telemetry.auto.version";
    var TMP_WEBENGINE_NAME2 = "webengine.name";
    var TMP_WEBENGINE_VERSION2 = "webengine.version";
    var TMP_WEBENGINE_DESCRIPTION2 = "webengine.description";
    exports.SEMRESATTRS_CLOUD_PROVIDER = TMP_CLOUD_PROVIDER2;
    exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = TMP_CLOUD_ACCOUNT_ID2;
    exports.SEMRESATTRS_CLOUD_REGION = TMP_CLOUD_REGION2;
    exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = TMP_CLOUD_AVAILABILITY_ZONE2;
    exports.SEMRESATTRS_CLOUD_PLATFORM = TMP_CLOUD_PLATFORM2;
    exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = TMP_AWS_ECS_CONTAINER_ARN2;
    exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = TMP_AWS_ECS_CLUSTER_ARN2;
    exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = TMP_AWS_ECS_LAUNCHTYPE2;
    exports.SEMRESATTRS_AWS_ECS_TASK_ARN = TMP_AWS_ECS_TASK_ARN2;
    exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = TMP_AWS_ECS_TASK_FAMILY2;
    exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = TMP_AWS_ECS_TASK_REVISION2;
    exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = TMP_AWS_EKS_CLUSTER_ARN2;
    exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = TMP_AWS_LOG_GROUP_NAMES2;
    exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = TMP_AWS_LOG_GROUP_ARNS2;
    exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = TMP_AWS_LOG_STREAM_NAMES2;
    exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = TMP_AWS_LOG_STREAM_ARNS2;
    exports.SEMRESATTRS_CONTAINER_NAME = TMP_CONTAINER_NAME2;
    exports.SEMRESATTRS_CONTAINER_ID = TMP_CONTAINER_ID2;
    exports.SEMRESATTRS_CONTAINER_RUNTIME = TMP_CONTAINER_RUNTIME2;
    exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = TMP_CONTAINER_IMAGE_NAME2;
    exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = TMP_CONTAINER_IMAGE_TAG2;
    exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = TMP_DEPLOYMENT_ENVIRONMENT2;
    exports.SEMRESATTRS_DEVICE_ID = TMP_DEVICE_ID2;
    exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = TMP_DEVICE_MODEL_IDENTIFIER2;
    exports.SEMRESATTRS_DEVICE_MODEL_NAME = TMP_DEVICE_MODEL_NAME2;
    exports.SEMRESATTRS_FAAS_NAME = TMP_FAAS_NAME2;
    exports.SEMRESATTRS_FAAS_ID = TMP_FAAS_ID2;
    exports.SEMRESATTRS_FAAS_VERSION = TMP_FAAS_VERSION2;
    exports.SEMRESATTRS_FAAS_INSTANCE = TMP_FAAS_INSTANCE2;
    exports.SEMRESATTRS_FAAS_MAX_MEMORY = TMP_FAAS_MAX_MEMORY2;
    exports.SEMRESATTRS_HOST_ID = TMP_HOST_ID2;
    exports.SEMRESATTRS_HOST_NAME = TMP_HOST_NAME2;
    exports.SEMRESATTRS_HOST_TYPE = TMP_HOST_TYPE2;
    exports.SEMRESATTRS_HOST_ARCH = TMP_HOST_ARCH2;
    exports.SEMRESATTRS_HOST_IMAGE_NAME = TMP_HOST_IMAGE_NAME2;
    exports.SEMRESATTRS_HOST_IMAGE_ID = TMP_HOST_IMAGE_ID2;
    exports.SEMRESATTRS_HOST_IMAGE_VERSION = TMP_HOST_IMAGE_VERSION2;
    exports.SEMRESATTRS_K8S_CLUSTER_NAME = TMP_K8S_CLUSTER_NAME2;
    exports.SEMRESATTRS_K8S_NODE_NAME = TMP_K8S_NODE_NAME2;
    exports.SEMRESATTRS_K8S_NODE_UID = TMP_K8S_NODE_UID2;
    exports.SEMRESATTRS_K8S_NAMESPACE_NAME = TMP_K8S_NAMESPACE_NAME2;
    exports.SEMRESATTRS_K8S_POD_UID = TMP_K8S_POD_UID2;
    exports.SEMRESATTRS_K8S_POD_NAME = TMP_K8S_POD_NAME2;
    exports.SEMRESATTRS_K8S_CONTAINER_NAME = TMP_K8S_CONTAINER_NAME2;
    exports.SEMRESATTRS_K8S_REPLICASET_UID = TMP_K8S_REPLICASET_UID2;
    exports.SEMRESATTRS_K8S_REPLICASET_NAME = TMP_K8S_REPLICASET_NAME2;
    exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = TMP_K8S_DEPLOYMENT_UID2;
    exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = TMP_K8S_DEPLOYMENT_NAME2;
    exports.SEMRESATTRS_K8S_STATEFULSET_UID = TMP_K8S_STATEFULSET_UID2;
    exports.SEMRESATTRS_K8S_STATEFULSET_NAME = TMP_K8S_STATEFULSET_NAME2;
    exports.SEMRESATTRS_K8S_DAEMONSET_UID = TMP_K8S_DAEMONSET_UID2;
    exports.SEMRESATTRS_K8S_DAEMONSET_NAME = TMP_K8S_DAEMONSET_NAME2;
    exports.SEMRESATTRS_K8S_JOB_UID = TMP_K8S_JOB_UID2;
    exports.SEMRESATTRS_K8S_JOB_NAME = TMP_K8S_JOB_NAME2;
    exports.SEMRESATTRS_K8S_CRONJOB_UID = TMP_K8S_CRONJOB_UID2;
    exports.SEMRESATTRS_K8S_CRONJOB_NAME = TMP_K8S_CRONJOB_NAME2;
    exports.SEMRESATTRS_OS_TYPE = TMP_OS_TYPE2;
    exports.SEMRESATTRS_OS_DESCRIPTION = TMP_OS_DESCRIPTION2;
    exports.SEMRESATTRS_OS_NAME = TMP_OS_NAME2;
    exports.SEMRESATTRS_OS_VERSION = TMP_OS_VERSION2;
    exports.SEMRESATTRS_PROCESS_PID = TMP_PROCESS_PID2;
    exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = TMP_PROCESS_EXECUTABLE_NAME2;
    exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = TMP_PROCESS_EXECUTABLE_PATH2;
    exports.SEMRESATTRS_PROCESS_COMMAND = TMP_PROCESS_COMMAND2;
    exports.SEMRESATTRS_PROCESS_COMMAND_LINE = TMP_PROCESS_COMMAND_LINE2;
    exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = TMP_PROCESS_COMMAND_ARGS2;
    exports.SEMRESATTRS_PROCESS_OWNER = TMP_PROCESS_OWNER2;
    exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME2;
    exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = TMP_PROCESS_RUNTIME_VERSION2;
    exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = TMP_PROCESS_RUNTIME_DESCRIPTION2;
    exports.SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME2;
    exports.SEMRESATTRS_SERVICE_NAMESPACE = TMP_SERVICE_NAMESPACE2;
    exports.SEMRESATTRS_SERVICE_INSTANCE_ID = TMP_SERVICE_INSTANCE_ID2;
    exports.SEMRESATTRS_SERVICE_VERSION = TMP_SERVICE_VERSION2;
    exports.SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME2;
    exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE2;
    exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION2;
    exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = TMP_TELEMETRY_AUTO_VERSION2;
    exports.SEMRESATTRS_WEBENGINE_NAME = TMP_WEBENGINE_NAME2;
    exports.SEMRESATTRS_WEBENGINE_VERSION = TMP_WEBENGINE_VERSION2;
    exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = TMP_WEBENGINE_DESCRIPTION2;
    exports.SemanticResourceAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_CLOUD_PROVIDER2,
      TMP_CLOUD_ACCOUNT_ID2,
      TMP_CLOUD_REGION2,
      TMP_CLOUD_AVAILABILITY_ZONE2,
      TMP_CLOUD_PLATFORM2,
      TMP_AWS_ECS_CONTAINER_ARN2,
      TMP_AWS_ECS_CLUSTER_ARN2,
      TMP_AWS_ECS_LAUNCHTYPE2,
      TMP_AWS_ECS_TASK_ARN2,
      TMP_AWS_ECS_TASK_FAMILY2,
      TMP_AWS_ECS_TASK_REVISION2,
      TMP_AWS_EKS_CLUSTER_ARN2,
      TMP_AWS_LOG_GROUP_NAMES2,
      TMP_AWS_LOG_GROUP_ARNS2,
      TMP_AWS_LOG_STREAM_NAMES2,
      TMP_AWS_LOG_STREAM_ARNS2,
      TMP_CONTAINER_NAME2,
      TMP_CONTAINER_ID2,
      TMP_CONTAINER_RUNTIME2,
      TMP_CONTAINER_IMAGE_NAME2,
      TMP_CONTAINER_IMAGE_TAG2,
      TMP_DEPLOYMENT_ENVIRONMENT2,
      TMP_DEVICE_ID2,
      TMP_DEVICE_MODEL_IDENTIFIER2,
      TMP_DEVICE_MODEL_NAME2,
      TMP_FAAS_NAME2,
      TMP_FAAS_ID2,
      TMP_FAAS_VERSION2,
      TMP_FAAS_INSTANCE2,
      TMP_FAAS_MAX_MEMORY2,
      TMP_HOST_ID2,
      TMP_HOST_NAME2,
      TMP_HOST_TYPE2,
      TMP_HOST_ARCH2,
      TMP_HOST_IMAGE_NAME2,
      TMP_HOST_IMAGE_ID2,
      TMP_HOST_IMAGE_VERSION2,
      TMP_K8S_CLUSTER_NAME2,
      TMP_K8S_NODE_NAME2,
      TMP_K8S_NODE_UID2,
      TMP_K8S_NAMESPACE_NAME2,
      TMP_K8S_POD_UID2,
      TMP_K8S_POD_NAME2,
      TMP_K8S_CONTAINER_NAME2,
      TMP_K8S_REPLICASET_UID2,
      TMP_K8S_REPLICASET_NAME2,
      TMP_K8S_DEPLOYMENT_UID2,
      TMP_K8S_DEPLOYMENT_NAME2,
      TMP_K8S_STATEFULSET_UID2,
      TMP_K8S_STATEFULSET_NAME2,
      TMP_K8S_DAEMONSET_UID2,
      TMP_K8S_DAEMONSET_NAME2,
      TMP_K8S_JOB_UID2,
      TMP_K8S_JOB_NAME2,
      TMP_K8S_CRONJOB_UID2,
      TMP_K8S_CRONJOB_NAME2,
      TMP_OS_TYPE2,
      TMP_OS_DESCRIPTION2,
      TMP_OS_NAME2,
      TMP_OS_VERSION2,
      TMP_PROCESS_PID2,
      TMP_PROCESS_EXECUTABLE_NAME2,
      TMP_PROCESS_EXECUTABLE_PATH2,
      TMP_PROCESS_COMMAND2,
      TMP_PROCESS_COMMAND_LINE2,
      TMP_PROCESS_COMMAND_ARGS2,
      TMP_PROCESS_OWNER2,
      TMP_PROCESS_RUNTIME_NAME2,
      TMP_PROCESS_RUNTIME_VERSION2,
      TMP_PROCESS_RUNTIME_DESCRIPTION2,
      TMP_SERVICE_NAME2,
      TMP_SERVICE_NAMESPACE2,
      TMP_SERVICE_INSTANCE_ID2,
      TMP_SERVICE_VERSION2,
      TMP_TELEMETRY_SDK_NAME2,
      TMP_TELEMETRY_SDK_LANGUAGE2,
      TMP_TELEMETRY_SDK_VERSION2,
      TMP_TELEMETRY_AUTO_VERSION2,
      TMP_WEBENGINE_NAME2,
      TMP_WEBENGINE_VERSION2,
      TMP_WEBENGINE_DESCRIPTION2
    ]);
    var TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD2 = "alibaba_cloud";
    var TMP_CLOUDPROVIDERVALUES_AWS2 = "aws";
    var TMP_CLOUDPROVIDERVALUES_AZURE2 = "azure";
    var TMP_CLOUDPROVIDERVALUES_GCP2 = "gcp";
    exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD2;
    exports.CLOUDPROVIDERVALUES_AWS = TMP_CLOUDPROVIDERVALUES_AWS2;
    exports.CLOUDPROVIDERVALUES_AZURE = TMP_CLOUDPROVIDERVALUES_AZURE2;
    exports.CLOUDPROVIDERVALUES_GCP = TMP_CLOUDPROVIDERVALUES_GCP2;
    exports.CloudProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD2,
      TMP_CLOUDPROVIDERVALUES_AWS2,
      TMP_CLOUDPROVIDERVALUES_AZURE2,
      TMP_CLOUDPROVIDERVALUES_GCP2
    ]);
    var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS2 = "alibaba_cloud_ecs";
    var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC2 = "alibaba_cloud_fc";
    var TMP_CLOUDPLATFORMVALUES_AWS_EC22 = "aws_ec2";
    var TMP_CLOUDPLATFORMVALUES_AWS_ECS2 = "aws_ecs";
    var TMP_CLOUDPLATFORMVALUES_AWS_EKS2 = "aws_eks";
    var TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA2 = "aws_lambda";
    var TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK2 = "aws_elastic_beanstalk";
    var TMP_CLOUDPLATFORMVALUES_AZURE_VM2 = "azure_vm";
    var TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES2 = "azure_container_instances";
    var TMP_CLOUDPLATFORMVALUES_AZURE_AKS2 = "azure_aks";
    var TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS2 = "azure_functions";
    var TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE2 = "azure_app_service";
    var TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE2 = "gcp_compute_engine";
    var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN2 = "gcp_cloud_run";
    var TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE2 = "gcp_kubernetes_engine";
    var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS2 = "gcp_cloud_functions";
    var TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE2 = "gcp_app_engine";
    exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS2;
    exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC2;
    exports.CLOUDPLATFORMVALUES_AWS_EC2 = TMP_CLOUDPLATFORMVALUES_AWS_EC22;
    exports.CLOUDPLATFORMVALUES_AWS_ECS = TMP_CLOUDPLATFORMVALUES_AWS_ECS2;
    exports.CLOUDPLATFORMVALUES_AWS_EKS = TMP_CLOUDPLATFORMVALUES_AWS_EKS2;
    exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA2;
    exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK2;
    exports.CLOUDPLATFORMVALUES_AZURE_VM = TMP_CLOUDPLATFORMVALUES_AZURE_VM2;
    exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES2;
    exports.CLOUDPLATFORMVALUES_AZURE_AKS = TMP_CLOUDPLATFORMVALUES_AZURE_AKS2;
    exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS2;
    exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE2;
    exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE2;
    exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN2;
    exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE2;
    exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS2;
    exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE2;
    exports.CloudPlatformValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS2,
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC2,
      TMP_CLOUDPLATFORMVALUES_AWS_EC22,
      TMP_CLOUDPLATFORMVALUES_AWS_ECS2,
      TMP_CLOUDPLATFORMVALUES_AWS_EKS2,
      TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA2,
      TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK2,
      TMP_CLOUDPLATFORMVALUES_AZURE_VM2,
      TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES2,
      TMP_CLOUDPLATFORMVALUES_AZURE_AKS2,
      TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS2,
      TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE2,
      TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE2,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN2,
      TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE2,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS2,
      TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE2
    ]);
    var TMP_AWSECSLAUNCHTYPEVALUES_EC22 = "ec2";
    var TMP_AWSECSLAUNCHTYPEVALUES_FARGATE2 = "fargate";
    exports.AWSECSLAUNCHTYPEVALUES_EC2 = TMP_AWSECSLAUNCHTYPEVALUES_EC22;
    exports.AWSECSLAUNCHTYPEVALUES_FARGATE = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE2;
    exports.AwsEcsLaunchtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_AWSECSLAUNCHTYPEVALUES_EC22,
      TMP_AWSECSLAUNCHTYPEVALUES_FARGATE2
    ]);
    var TMP_HOSTARCHVALUES_AMD642 = "amd64";
    var TMP_HOSTARCHVALUES_ARM322 = "arm32";
    var TMP_HOSTARCHVALUES_ARM642 = "arm64";
    var TMP_HOSTARCHVALUES_IA642 = "ia64";
    var TMP_HOSTARCHVALUES_PPC322 = "ppc32";
    var TMP_HOSTARCHVALUES_PPC642 = "ppc64";
    var TMP_HOSTARCHVALUES_X862 = "x86";
    exports.HOSTARCHVALUES_AMD64 = TMP_HOSTARCHVALUES_AMD642;
    exports.HOSTARCHVALUES_ARM32 = TMP_HOSTARCHVALUES_ARM322;
    exports.HOSTARCHVALUES_ARM64 = TMP_HOSTARCHVALUES_ARM642;
    exports.HOSTARCHVALUES_IA64 = TMP_HOSTARCHVALUES_IA642;
    exports.HOSTARCHVALUES_PPC32 = TMP_HOSTARCHVALUES_PPC322;
    exports.HOSTARCHVALUES_PPC64 = TMP_HOSTARCHVALUES_PPC642;
    exports.HOSTARCHVALUES_X86 = TMP_HOSTARCHVALUES_X862;
    exports.HostArchValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_HOSTARCHVALUES_AMD642,
      TMP_HOSTARCHVALUES_ARM322,
      TMP_HOSTARCHVALUES_ARM642,
      TMP_HOSTARCHVALUES_IA642,
      TMP_HOSTARCHVALUES_PPC322,
      TMP_HOSTARCHVALUES_PPC642,
      TMP_HOSTARCHVALUES_X862
    ]);
    var TMP_OSTYPEVALUES_WINDOWS2 = "windows";
    var TMP_OSTYPEVALUES_LINUX2 = "linux";
    var TMP_OSTYPEVALUES_DARWIN2 = "darwin";
    var TMP_OSTYPEVALUES_FREEBSD2 = "freebsd";
    var TMP_OSTYPEVALUES_NETBSD2 = "netbsd";
    var TMP_OSTYPEVALUES_OPENBSD2 = "openbsd";
    var TMP_OSTYPEVALUES_DRAGONFLYBSD2 = "dragonflybsd";
    var TMP_OSTYPEVALUES_HPUX2 = "hpux";
    var TMP_OSTYPEVALUES_AIX2 = "aix";
    var TMP_OSTYPEVALUES_SOLARIS2 = "solaris";
    var TMP_OSTYPEVALUES_Z_OS2 = "z_os";
    exports.OSTYPEVALUES_WINDOWS = TMP_OSTYPEVALUES_WINDOWS2;
    exports.OSTYPEVALUES_LINUX = TMP_OSTYPEVALUES_LINUX2;
    exports.OSTYPEVALUES_DARWIN = TMP_OSTYPEVALUES_DARWIN2;
    exports.OSTYPEVALUES_FREEBSD = TMP_OSTYPEVALUES_FREEBSD2;
    exports.OSTYPEVALUES_NETBSD = TMP_OSTYPEVALUES_NETBSD2;
    exports.OSTYPEVALUES_OPENBSD = TMP_OSTYPEVALUES_OPENBSD2;
    exports.OSTYPEVALUES_DRAGONFLYBSD = TMP_OSTYPEVALUES_DRAGONFLYBSD2;
    exports.OSTYPEVALUES_HPUX = TMP_OSTYPEVALUES_HPUX2;
    exports.OSTYPEVALUES_AIX = TMP_OSTYPEVALUES_AIX2;
    exports.OSTYPEVALUES_SOLARIS = TMP_OSTYPEVALUES_SOLARIS2;
    exports.OSTYPEVALUES_Z_OS = TMP_OSTYPEVALUES_Z_OS2;
    exports.OsTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_OSTYPEVALUES_WINDOWS2,
      TMP_OSTYPEVALUES_LINUX2,
      TMP_OSTYPEVALUES_DARWIN2,
      TMP_OSTYPEVALUES_FREEBSD2,
      TMP_OSTYPEVALUES_NETBSD2,
      TMP_OSTYPEVALUES_OPENBSD2,
      TMP_OSTYPEVALUES_DRAGONFLYBSD2,
      TMP_OSTYPEVALUES_HPUX2,
      TMP_OSTYPEVALUES_AIX2,
      TMP_OSTYPEVALUES_SOLARIS2,
      TMP_OSTYPEVALUES_Z_OS2
    ]);
    var TMP_TELEMETRYSDKLANGUAGEVALUES_CPP2 = "cpp";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET2 = "dotnet";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG2 = "erlang";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_GO2 = "go";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA2 = "java";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS2 = "nodejs";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_PHP2 = "php";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON2 = "python";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY2 = "ruby";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS2 = "webjs";
    exports.TELEMETRYSDKLANGUAGEVALUES_CPP = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP2;
    exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET2;
    exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG2;
    exports.TELEMETRYSDKLANGUAGEVALUES_GO = TMP_TELEMETRYSDKLANGUAGEVALUES_GO2;
    exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA2;
    exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS2;
    exports.TELEMETRYSDKLANGUAGEVALUES_PHP = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP2;
    exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON2;
    exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY2;
    exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS2;
    exports.TelemetrySdkLanguageValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_TELEMETRYSDKLANGUAGEVALUES_CPP2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_GO2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PHP2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS2
    ]);
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js
var require_resource3 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_SemanticResourceAttributes3(), exports);
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/src/index.js
var require_src8 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/semantic-conventions/build/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_trace3(), exports);
    __exportStar(require_resource3(), exports);
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js
var require_sdk_info4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDK_INFO = void 0;
    var version_1 = require_version4();
    var semantic_conventions_1 = require_src8();
    exports.SDK_INFO = {
      [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_NAME]: "opentelemetry",
      [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_NAME]: "node",
      [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE]: semantic_conventions_1.TelemetrySdkLanguageValues.NODEJS,
      [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_VERSION]: version_1.VERSION
    };
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js
var require_timer_util4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unrefTimer = void 0;
    function unrefTimer(timer) {
      timer.unref();
    }
    exports.unrefTimer = unrefTimer;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/index.js
var require_node7 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/platform/node/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnv = exports.getEnvWithoutDefaults = void 0;
    var environment_1 = require_environment8();
    Object.defineProperty(exports, "getEnvWithoutDefaults", { enumerable: true, get: function() {
      return environment_1.getEnvWithoutDefaults;
    } });
    Object.defineProperty(exports, "getEnv", { enumerable: true, get: function() {
      return environment_1.getEnv;
    } });
    __exportStar(require_globalThis4(), exports);
    __exportStar(require_hex_to_base644(), exports);
    __exportStar(require_RandomIdGenerator5(), exports);
    __exportStar(require_performance4(), exports);
    __exportStar(require_sdk_info4(), exports);
    __exportStar(require_timer_util4(), exports);
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/platform/index.js
var require_platform7 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/platform/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_node7(), exports);
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/common/time.js
var require_time4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/common/time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addHrTimes = exports.isTimeInput = exports.isTimeInputHrTime = exports.hrTimeToMicroseconds = exports.hrTimeToMilliseconds = exports.hrTimeToNanoseconds = exports.hrTimeToTimeStamp = exports.hrTimeDuration = exports.timeInputToHrTime = exports.hrTime = exports.getTimeOrigin = exports.millisToHrTime = void 0;
    var platform_1 = require_platform7();
    var NANOSECOND_DIGITS = 9;
    var NANOSECOND_DIGITS_IN_MILLIS = 6;
    var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
    var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
    function millisToHrTime(epochMillis) {
      const epochSeconds = epochMillis / 1e3;
      const seconds = Math.trunc(epochSeconds);
      const nanos = Math.round(epochMillis % 1e3 * MILLISECONDS_TO_NANOSECONDS);
      return [seconds, nanos];
    }
    exports.millisToHrTime = millisToHrTime;
    function getTimeOrigin() {
      let timeOrigin = platform_1.otperformance.timeOrigin;
      if (typeof timeOrigin !== "number") {
        const perf = platform_1.otperformance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
      }
      return timeOrigin;
    }
    exports.getTimeOrigin = getTimeOrigin;
    function hrTime(performanceNow) {
      const timeOrigin = millisToHrTime(getTimeOrigin());
      const now = millisToHrTime(typeof performanceNow === "number" ? performanceNow : platform_1.otperformance.now());
      return addHrTimes(timeOrigin, now);
    }
    exports.hrTime = hrTime;
    function timeInputToHrTime(time) {
      if (isTimeInputHrTime(time)) {
        return time;
      } else if (typeof time === "number") {
        if (time < getTimeOrigin()) {
          return hrTime(time);
        } else {
          return millisToHrTime(time);
        }
      } else if (time instanceof Date) {
        return millisToHrTime(time.getTime());
      } else {
        throw TypeError("Invalid input type");
      }
    }
    exports.timeInputToHrTime = timeInputToHrTime;
    function hrTimeDuration(startTime, endTime) {
      let seconds = endTime[0] - startTime[0];
      let nanos = endTime[1] - startTime[1];
      if (nanos < 0) {
        seconds -= 1;
        nanos += SECOND_TO_NANOSECONDS;
      }
      return [seconds, nanos];
    }
    exports.hrTimeDuration = hrTimeDuration;
    function hrTimeToTimeStamp(time) {
      const precision = NANOSECOND_DIGITS;
      const tmp = `${"0".repeat(precision)}${time[1]}Z`;
      const nanoString = tmp.substr(tmp.length - precision - 1);
      const date = new Date(time[0] * 1e3).toISOString();
      return date.replace("000Z", nanoString);
    }
    exports.hrTimeToTimeStamp = hrTimeToTimeStamp;
    function hrTimeToNanoseconds(time) {
      return time[0] * SECOND_TO_NANOSECONDS + time[1];
    }
    exports.hrTimeToNanoseconds = hrTimeToNanoseconds;
    function hrTimeToMilliseconds(time) {
      return time[0] * 1e3 + time[1] / 1e6;
    }
    exports.hrTimeToMilliseconds = hrTimeToMilliseconds;
    function hrTimeToMicroseconds(time) {
      return time[0] * 1e6 + time[1] / 1e3;
    }
    exports.hrTimeToMicroseconds = hrTimeToMicroseconds;
    function isTimeInputHrTime(value) {
      return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
    }
    exports.isTimeInputHrTime = isTimeInputHrTime;
    function isTimeInput(value) {
      return isTimeInputHrTime(value) || typeof value === "number" || value instanceof Date;
    }
    exports.isTimeInput = isTimeInput;
    function addHrTimes(time1, time2) {
      const out = [time1[0] + time2[0], time1[1] + time2[1]];
      if (out[1] >= SECOND_TO_NANOSECONDS) {
        out[1] -= SECOND_TO_NANOSECONDS;
        out[0] += 1;
      }
      return out;
    }
    exports.addHrTimes = addHrTimes;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/common/types.js
var require_types3 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/common/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/ExportResult.js
var require_ExportResult4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/ExportResult.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExportResultCode = void 0;
    var ExportResultCode;
    (function(ExportResultCode2) {
      ExportResultCode2[ExportResultCode2["SUCCESS"] = 0] = "SUCCESS";
      ExportResultCode2[ExportResultCode2["FAILED"] = 1] = "FAILED";
    })(ExportResultCode = exports.ExportResultCode || (exports.ExportResultCode = {}));
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/propagation/composite.js
var require_composite4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/propagation/composite.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompositePropagator = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var CompositePropagator = class {
      /**
       * Construct a composite propagator from a list of propagators.
       *
       * @param [config] Configuration object for composite propagator
       */
      constructor(config = {}) {
        var _a12;
        this._propagators = (_a12 = config.propagators) !== null && _a12 !== void 0 ? _a12 : [];
        this._fields = Array.from(new Set(this._propagators.map((p2) => typeof p2.fields === "function" ? p2.fields() : []).reduce((x2, y2) => x2.concat(y2), [])));
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same carrier key, the propagator later in the list
       * will "win".
       *
       * @param context Context to inject
       * @param carrier Carrier into which context will be injected
       */
      inject(context3, carrier, setter) {
        for (const propagator of this._propagators) {
          try {
            propagator.inject(context3, carrier, setter);
          } catch (err) {
            api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
          }
        }
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same context key, the propagator later in the list
       * will "win".
       *
       * @param context Context to add values to
       * @param carrier Carrier from which to extract context
       */
      extract(context3, carrier, getter) {
        return this._propagators.reduce((ctx, propagator) => {
          try {
            return propagator.extract(ctx, carrier, getter);
          } catch (err) {
            api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
          }
          return ctx;
        }, context3);
      }
      fields() {
        return this._fields.slice();
      }
    };
    exports.CompositePropagator = CompositePropagator;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/internal/validators.js
var require_validators4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/internal/validators.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateValue = exports.validateKey = void 0;
    var VALID_KEY_CHAR_RANGE2 = "[_0-9a-z-*/]";
    var VALID_KEY2 = `[a-z]${VALID_KEY_CHAR_RANGE2}{0,255}`;
    var VALID_VENDOR_KEY2 = `[a-z0-9]${VALID_KEY_CHAR_RANGE2}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE2}{0,13}`;
    var VALID_KEY_REGEX2 = new RegExp(`^(?:${VALID_KEY2}|${VALID_VENDOR_KEY2})$`);
    var VALID_VALUE_BASE_REGEX2 = /^[ -~]{0,255}[!-~]$/;
    var INVALID_VALUE_COMMA_EQUAL_REGEX2 = /,|=/;
    function validateKey2(key) {
      return VALID_KEY_REGEX2.test(key);
    }
    exports.validateKey = validateKey2;
    function validateValue2(value) {
      return VALID_VALUE_BASE_REGEX2.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX2.test(value);
    }
    exports.validateValue = validateValue2;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/trace/TraceState.js
var require_TraceState4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/trace/TraceState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TraceState = void 0;
    var validators_1 = require_validators4();
    var MAX_TRACE_STATE_ITEMS2 = 32;
    var MAX_TRACE_STATE_LEN2 = 512;
    var LIST_MEMBERS_SEPARATOR2 = ",";
    var LIST_MEMBER_KEY_VALUE_SPLITTER2 = "=";
    var TraceState = class _TraceState {
      constructor(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      set(key, value) {
        const traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      }
      unset(key) {
        const traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      }
      get(key) {
        return this._internalState.get(key);
      }
      serialize() {
        return this._keys().reduce((agg, key) => {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER2 + this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR2);
      }
      _parse(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN2)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR2).reverse().reduce((agg, part) => {
          const listMember = part.trim();
          const i2 = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER2);
          if (i2 !== -1) {
            const key = listMember.slice(0, i2);
            const value = listMember.slice(i2 + 1, part.length);
            if ((0, validators_1.validateKey)(key) && (0, validators_1.validateValue)(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS2) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS2));
        }
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        const traceState = new _TraceState();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      }
    };
    exports.TraceState = TraceState;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js
var require_W3CTraceContextPropagator4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.W3CTraceContextPropagator = exports.parseTraceParent = exports.TRACE_STATE_HEADER = exports.TRACE_PARENT_HEADER = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing4();
    var TraceState_1 = require_TraceState4();
    exports.TRACE_PARENT_HEADER = "traceparent";
    exports.TRACE_STATE_HEADER = "tracestate";
    var VERSION2 = "00";
    var VERSION_PART = "(?!ff)[\\da-f]{2}";
    var TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}";
    var PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}";
    var FLAGS_PART = "[\\da-f]{2}";
    var TRACE_PARENT_REGEX = new RegExp(`^\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\s?$`);
    function parseTraceParent(traceParent) {
      const match4 = TRACE_PARENT_REGEX.exec(traceParent);
      if (!match4)
        return null;
      if (match4[1] === "00" && match4[5])
        return null;
      return {
        traceId: match4[2],
        spanId: match4[3],
        traceFlags: parseInt(match4[4], 16)
      };
    }
    exports.parseTraceParent = parseTraceParent;
    var W3CTraceContextPropagator = class {
      inject(context3, carrier, setter) {
        const spanContext = api_1.trace.getSpanContext(context3);
        if (!spanContext || (0, suppress_tracing_1.isTracingSuppressed)(context3) || !(0, api_1.isSpanContextValid)(spanContext))
          return;
        const traceParent = `${VERSION2}-${spanContext.traceId}-${spanContext.spanId}-0${Number(spanContext.traceFlags || api_1.TraceFlags.NONE).toString(16)}`;
        setter.set(carrier, exports.TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) {
          setter.set(carrier, exports.TRACE_STATE_HEADER, spanContext.traceState.serialize());
        }
      }
      extract(context3, carrier, getter) {
        const traceParentHeader = getter.get(carrier, exports.TRACE_PARENT_HEADER);
        if (!traceParentHeader)
          return context3;
        const traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
        if (typeof traceParent !== "string")
          return context3;
        const spanContext = parseTraceParent(traceParent);
        if (!spanContext)
          return context3;
        spanContext.isRemote = true;
        const traceStateHeader = getter.get(carrier, exports.TRACE_STATE_HEADER);
        if (traceStateHeader) {
          const state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
          spanContext.traceState = new TraceState_1.TraceState(typeof state === "string" ? state : void 0);
        }
        return api_1.trace.setSpanContext(context3, spanContext);
      }
      fields() {
        return [exports.TRACE_PARENT_HEADER, exports.TRACE_STATE_HEADER];
      }
    };
    exports.W3CTraceContextPropagator = W3CTraceContextPropagator;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/trace/IdGenerator.js
var require_IdGenerator3 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/trace/IdGenerator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js
var require_rpc_metadata4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRPCMetadata = exports.deleteRPCMetadata = exports.setRPCMetadata = exports.RPCType = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var RPC_METADATA_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key RPC_METADATA");
    var RPCType;
    (function(RPCType2) {
      RPCType2["HTTP"] = "http";
    })(RPCType = exports.RPCType || (exports.RPCType = {}));
    function setRPCMetadata(context3, meta) {
      return context3.setValue(RPC_METADATA_KEY, meta);
    }
    exports.setRPCMetadata = setRPCMetadata;
    function deleteRPCMetadata(context3) {
      return context3.deleteValue(RPC_METADATA_KEY);
    }
    exports.deleteRPCMetadata = deleteRPCMetadata;
    function getRPCMetadata(context3) {
      return context3.getValue(RPC_METADATA_KEY);
    }
    exports.getRPCMetadata = getRPCMetadata;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js
var require_AlwaysOffSampler5 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AlwaysOffSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var AlwaysOffSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return "AlwaysOffSampler";
      }
    };
    exports.AlwaysOffSampler = AlwaysOffSampler;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js
var require_AlwaysOnSampler5 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AlwaysOnSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var AlwaysOnSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.RECORD_AND_SAMPLED
        };
      }
      toString() {
        return "AlwaysOnSampler";
      }
    };
    exports.AlwaysOnSampler = AlwaysOnSampler;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js
var require_ParentBasedSampler5 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParentBasedSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var global_error_handler_1 = require_global_error_handler4();
    var AlwaysOffSampler_1 = require_AlwaysOffSampler5();
    var AlwaysOnSampler_1 = require_AlwaysOnSampler5();
    var ParentBasedSampler = class {
      constructor(config) {
        var _a12, _b5, _c4, _d4;
        this._root = config.root;
        if (!this._root) {
          (0, global_error_handler_1.globalErrorHandler)(new Error("ParentBasedSampler must have a root sampler configured"));
          this._root = new AlwaysOnSampler_1.AlwaysOnSampler();
        }
        this._remoteParentSampled = (_a12 = config.remoteParentSampled) !== null && _a12 !== void 0 ? _a12 : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._remoteParentNotSampled = (_b5 = config.remoteParentNotSampled) !== null && _b5 !== void 0 ? _b5 : new AlwaysOffSampler_1.AlwaysOffSampler();
        this._localParentSampled = (_c4 = config.localParentSampled) !== null && _c4 !== void 0 ? _c4 : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._localParentNotSampled = (_d4 = config.localParentNotSampled) !== null && _d4 !== void 0 ? _d4 : new AlwaysOffSampler_1.AlwaysOffSampler();
      }
      shouldSample(context3, traceId, spanName, spanKind, attributes, links) {
        const parentContext = api_1.trace.getSpanContext(context3);
        if (!parentContext || !(0, api_1.isSpanContextValid)(parentContext)) {
          return this._root.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
          if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
            return this._remoteParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
          }
          return this._remoteParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
          return this._localParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
      }
      toString() {
        return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
      }
    };
    exports.ParentBasedSampler = ParentBasedSampler;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js
var require_TraceIdRatioBasedSampler5 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TraceIdRatioBasedSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var TraceIdRatioBasedSampler = class {
      constructor(_ratio = 0) {
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 4294967295);
      }
      shouldSample(context3, traceId) {
        return {
          decision: (0, api_1.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? api_1.SamplingDecision.RECORD_AND_SAMPLED : api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return `TraceIdRatioBased{${this._ratio}}`;
      }
      _normalize(ratio) {
        if (typeof ratio !== "number" || isNaN(ratio))
          return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
      }
      _accumulate(traceId) {
        let accumulation = 0;
        for (let i2 = 0; i2 < traceId.length / 8; i2++) {
          const pos = i2 * 8;
          const part = parseInt(traceId.slice(pos, pos + 8), 16);
          accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
      }
    };
    exports.TraceIdRatioBasedSampler = TraceIdRatioBasedSampler;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js
var require_lodash_merge4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isPlainObject = void 0;
    var objectTag = "[object Object]";
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    var objectCtorString = funcToString.call(Object);
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    var nativeObjectToString = objectProto.toString;
    function overArg(func2, transform) {
      return function(arg) {
        return func2(transform(arg));
      };
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
        return false;
      }
      const proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      const Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
    }
    exports.isPlainObject = isPlainObject;
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function getRawTag(value) {
      const isOwn = hasOwnProperty2.call(value, symToStringTag), tag2 = value[symToStringTag];
      let unmasked = false;
      try {
        value[symToStringTag] = void 0;
        unmasked = true;
      } catch (e2) {
      }
      const result4 = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag2;
        } else {
          delete value[symToStringTag];
        }
      }
      return result4;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/utils/merge.js
var require_merge4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/utils/merge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = void 0;
    var lodash_merge_1 = require_lodash_merge4();
    var MAX_LEVEL = 20;
    function merge5(...args) {
      let result4 = args.shift();
      const objects = /* @__PURE__ */ new WeakMap();
      while (args.length > 0) {
        result4 = mergeTwoObjects(result4, args.shift(), 0, objects);
      }
      return result4;
    }
    exports.merge = merge5;
    function takeValue(value) {
      if (isArray(value)) {
        return value.slice();
      }
      return value;
    }
    function mergeTwoObjects(one, two, level = 0, objects) {
      let result4;
      if (level > MAX_LEVEL) {
        return void 0;
      }
      level++;
      if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {
        result4 = takeValue(two);
      } else if (isArray(one)) {
        result4 = one.slice();
        if (isArray(two)) {
          for (let i2 = 0, j2 = two.length; i2 < j2; i2++) {
            result4.push(takeValue(two[i2]));
          }
        } else if (isObject(two)) {
          const keys4 = Object.keys(two);
          for (let i2 = 0, j2 = keys4.length; i2 < j2; i2++) {
            const key = keys4[i2];
            result4[key] = takeValue(two[key]);
          }
        }
      } else if (isObject(one)) {
        if (isObject(two)) {
          if (!shouldMerge(one, two)) {
            return two;
          }
          result4 = Object.assign({}, one);
          const keys4 = Object.keys(two);
          for (let i2 = 0, j2 = keys4.length; i2 < j2; i2++) {
            const key = keys4[i2];
            const twoValue = two[key];
            if (isPrimitive(twoValue)) {
              if (typeof twoValue === "undefined") {
                delete result4[key];
              } else {
                result4[key] = twoValue;
              }
            } else {
              const obj1 = result4[key];
              const obj2 = twoValue;
              if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {
                delete result4[key];
              } else {
                if (isObject(obj1) && isObject(obj2)) {
                  const arr1 = objects.get(obj1) || [];
                  const arr2 = objects.get(obj2) || [];
                  arr1.push({ obj: one, key });
                  arr2.push({ obj: two, key });
                  objects.set(obj1, arr1);
                  objects.set(obj2, arr2);
                }
                result4[key] = mergeTwoObjects(result4[key], twoValue, level, objects);
              }
            }
          }
        } else {
          result4 = two;
        }
      }
      return result4;
    }
    function wasObjectReferenced(obj, key, objects) {
      const arr = objects.get(obj[key]) || [];
      for (let i2 = 0, j2 = arr.length; i2 < j2; i2++) {
        const info = arr[i2];
        if (info.key === key && info.obj === obj) {
          return true;
        }
      }
      return false;
    }
    function isArray(value) {
      return Array.isArray(value);
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isObject(value) {
      return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === "object";
    }
    function isPrimitive(value) {
      return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "undefined" || value instanceof Date || value instanceof RegExp || value === null;
    }
    function shouldMerge(one, two) {
      if (!(0, lodash_merge_1.isPlainObject)(one) || !(0, lodash_merge_1.isPlainObject)(two)) {
        return false;
      }
      return true;
    }
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/utils/timeout.js
var require_timeout4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/utils/timeout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callWithTimeout = exports.TimeoutError = void 0;
    var TimeoutError = class _TimeoutError extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, _TimeoutError.prototype);
      }
    };
    exports.TimeoutError = TimeoutError;
    function callWithTimeout(promise2, timeout4) {
      let timeoutHandle;
      const timeoutPromise = new Promise(function timeoutFunction(_resolve, reject3) {
        timeoutHandle = setTimeout(function timeoutHandler() {
          reject3(new TimeoutError("Operation timed out."));
        }, timeout4);
      });
      return Promise.race([promise2, timeoutPromise]).then((result4) => {
        clearTimeout(timeoutHandle);
        return result4;
      }, (reason) => {
        clearTimeout(timeoutHandle);
        throw reason;
      });
    }
    exports.callWithTimeout = callWithTimeout;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/utils/url.js
var require_url4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/utils/url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isUrlIgnored = exports.urlMatches = void 0;
    function urlMatches(url, urlToMatch) {
      if (typeof urlToMatch === "string") {
        return url === urlToMatch;
      } else {
        return !!url.match(urlToMatch);
      }
    }
    exports.urlMatches = urlMatches;
    function isUrlIgnored(url, ignoredUrls) {
      if (!ignoredUrls) {
        return false;
      }
      for (const ignoreUrl of ignoredUrls) {
        if (urlMatches(url, ignoreUrl)) {
          return true;
        }
      }
      return false;
    }
    exports.isUrlIgnored = isUrlIgnored;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/utils/wrap.js
var require_wrap4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/utils/wrap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isWrapped = void 0;
    function isWrapped(func2) {
      return typeof func2 === "function" && typeof func2.__original === "function" && typeof func2.__unwrap === "function" && func2.__wrapped === true;
    }
    exports.isWrapped = isWrapped;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/utils/promise.js
var require_promise4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/utils/promise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Deferred = void 0;
    var Deferred = class {
      constructor() {
        this._promise = new Promise((resolve, reject3) => {
          this._resolve = resolve;
          this._reject = reject3;
        });
      }
      get promise() {
        return this._promise;
      }
      resolve(val) {
        this._resolve(val);
      }
      reject(err) {
        this._reject(err);
      }
    };
    exports.Deferred = Deferred;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/utils/callback.js
var require_callback4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/utils/callback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BindOnceFuture = void 0;
    var promise_1 = require_promise4();
    var BindOnceFuture = class {
      constructor(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new promise_1.Deferred();
      }
      get isCalled() {
        return this._isCalled;
      }
      get promise() {
        return this._deferred.promise;
      }
      call(...args) {
        if (!this._isCalled) {
          this._isCalled = true;
          try {
            Promise.resolve(this._callback.call(this._that, ...args)).then((val) => this._deferred.resolve(val), (err) => this._deferred.reject(err));
          } catch (err) {
            this._deferred.reject(err);
          }
        }
        return this._deferred.promise;
      }
    };
    exports.BindOnceFuture = BindOnceFuture;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/internal/exporter.js
var require_exporter4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/internal/exporter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._export = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing4();
    function _export(exporter, arg) {
      return new Promise((resolve) => {
        api_1.context.with((0, suppress_tracing_1.suppressTracing)(api_1.context.active()), () => {
          exporter.export(arg, (result4) => {
            resolve(result4);
          });
        });
      });
    }
    exports._export = _export;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/index.js
var require_src9 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/node_modules/@opentelemetry/core/build/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.internal = exports.baggageUtils = void 0;
    __exportStar(require_W3CBaggagePropagator4(), exports);
    __exportStar(require_anchored_clock4(), exports);
    __exportStar(require_attributes4(), exports);
    __exportStar(require_global_error_handler4(), exports);
    __exportStar(require_logging_error_handler4(), exports);
    __exportStar(require_time4(), exports);
    __exportStar(require_types3(), exports);
    __exportStar(require_hex_to_binary4(), exports);
    __exportStar(require_ExportResult4(), exports);
    exports.baggageUtils = require_utils8();
    __exportStar(require_platform7(), exports);
    __exportStar(require_composite4(), exports);
    __exportStar(require_W3CTraceContextPropagator4(), exports);
    __exportStar(require_IdGenerator3(), exports);
    __exportStar(require_rpc_metadata4(), exports);
    __exportStar(require_AlwaysOffSampler5(), exports);
    __exportStar(require_AlwaysOnSampler5(), exports);
    __exportStar(require_ParentBasedSampler5(), exports);
    __exportStar(require_TraceIdRatioBasedSampler5(), exports);
    __exportStar(require_suppress_tracing4(), exports);
    __exportStar(require_TraceState4(), exports);
    __exportStar(require_environment7(), exports);
    __exportStar(require_merge4(), exports);
    __exportStar(require_sampling4(), exports);
    __exportStar(require_timeout4(), exports);
    __exportStar(require_url4(), exports);
    __exportStar(require_wrap4(), exports);
    __exportStar(require_callback4(), exports);
    __exportStar(require_version4(), exports);
    var exporter_1 = require_exporter4();
    exports.internal = {
      _export: exporter_1._export
    };
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/util.js
var require_util = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/build/src/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseRetryAfterToMills = exports.isExportRetryable = exports.invalidTimeout = exports.configureExporterTimeout = exports.appendRootPathToUrlIfNeeded = exports.appendResourcePathToUrl = exports.parseHeaders = exports.DEFAULT_EXPORT_BACKOFF_MULTIPLIER = exports.DEFAULT_EXPORT_MAX_BACKOFF = exports.DEFAULT_EXPORT_INITIAL_BACKOFF = exports.DEFAULT_EXPORT_MAX_ATTEMPTS = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src9();
    var DEFAULT_TRACE_TIMEOUT = 1e4;
    exports.DEFAULT_EXPORT_MAX_ATTEMPTS = 5;
    exports.DEFAULT_EXPORT_INITIAL_BACKOFF = 1e3;
    exports.DEFAULT_EXPORT_MAX_BACKOFF = 5e3;
    exports.DEFAULT_EXPORT_BACKOFF_MULTIPLIER = 1.5;
    function parseHeaders(partialHeaders = {}) {
      const headers = {};
      Object.entries(partialHeaders).forEach(([key, value]) => {
        if (typeof value !== "undefined") {
          headers[key] = String(value);
        } else {
          api_1.diag.warn(`Header "${key}" has invalid value (${value}) and will be ignored`);
        }
      });
      return headers;
    }
    exports.parseHeaders = parseHeaders;
    function appendResourcePathToUrl(url, path9) {
      if (!url.endsWith("/")) {
        url = url + "/";
      }
      return url + path9;
    }
    exports.appendResourcePathToUrl = appendResourcePathToUrl;
    function appendRootPathToUrlIfNeeded(url) {
      try {
        const parsedUrl = new URL(url);
        if (parsedUrl.pathname === "") {
          parsedUrl.pathname = parsedUrl.pathname + "/";
        }
        return parsedUrl.toString();
      } catch (_a12) {
        api_1.diag.warn(`Could not parse export URL: '${url}'`);
        return url;
      }
    }
    exports.appendRootPathToUrlIfNeeded = appendRootPathToUrlIfNeeded;
    function configureExporterTimeout(timeoutMillis) {
      if (typeof timeoutMillis === "number") {
        if (timeoutMillis <= 0) {
          return invalidTimeout(timeoutMillis, DEFAULT_TRACE_TIMEOUT);
        }
        return timeoutMillis;
      } else {
        return getExporterTimeoutFromEnv();
      }
    }
    exports.configureExporterTimeout = configureExporterTimeout;
    function getExporterTimeoutFromEnv() {
      var _a12;
      const definedTimeout = Number((_a12 = (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_TRACES_TIMEOUT) !== null && _a12 !== void 0 ? _a12 : (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_TIMEOUT);
      if (definedTimeout <= 0) {
        return invalidTimeout(definedTimeout, DEFAULT_TRACE_TIMEOUT);
      } else {
        return definedTimeout;
      }
    }
    function invalidTimeout(timeout4, defaultTimeout) {
      api_1.diag.warn("Timeout must be greater than 0", timeout4);
      return defaultTimeout;
    }
    exports.invalidTimeout = invalidTimeout;
    function isExportRetryable(statusCode) {
      const retryCodes = [429, 502, 503, 504];
      return retryCodes.includes(statusCode);
    }
    exports.isExportRetryable = isExportRetryable;
    function parseRetryAfterToMills(retryAfter) {
      if (retryAfter == null) {
        return -1;
      }
      const seconds = Number.parseInt(retryAfter, 10);
      if (Number.isInteger(seconds)) {
        return seconds > 0 ? seconds * 1e3 : -1;
      }
      const delay2 = new Date(retryAfter).getTime() - Date.now();
      if (delay2 >= 0) {
        return delay2;
      }
      return 0;
    }
    exports.parseRetryAfterToMills = parseRetryAfterToMills;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/OTLPExporterBase.js
var require_OTLPExporterBase = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/build/src/OTLPExporterBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OTLPExporterBase = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src9();
    var util_1 = require_util();
    var OTLPExporterBase = class {
      /**
       * @param config
       */
      constructor(config = {}) {
        this._sendingPromises = [];
        this.url = this.getDefaultUrl(config);
        if (typeof config.hostname === "string") {
          this.hostname = config.hostname;
        }
        this.shutdown = this.shutdown.bind(this);
        this._shutdownOnce = new core_1.BindOnceFuture(this._shutdown, this);
        this._concurrencyLimit = typeof config.concurrencyLimit === "number" ? config.concurrencyLimit : 30;
        this.timeoutMillis = (0, util_1.configureExporterTimeout)(config.timeoutMillis);
        this.onInit(config);
      }
      /**
       * Export items.
       * @param items
       * @param resultCallback
       */
      export(items, resultCallback) {
        if (this._shutdownOnce.isCalled) {
          resultCallback({
            code: core_1.ExportResultCode.FAILED,
            error: new Error("Exporter has been shutdown")
          });
          return;
        }
        if (this._sendingPromises.length >= this._concurrencyLimit) {
          resultCallback({
            code: core_1.ExportResultCode.FAILED,
            error: new Error("Concurrent export limit reached")
          });
          return;
        }
        this._export(items).then(() => {
          resultCallback({ code: core_1.ExportResultCode.SUCCESS });
        }).catch((error) => {
          resultCallback({ code: core_1.ExportResultCode.FAILED, error });
        });
      }
      _export(items) {
        return new Promise((resolve, reject3) => {
          try {
            api_1.diag.debug("items to be sent", items);
            this.send(items, resolve, reject3);
          } catch (e2) {
            reject3(e2);
          }
        });
      }
      /**
       * Shutdown the exporter.
       */
      shutdown() {
        return this._shutdownOnce.call();
      }
      /**
       * Exports any pending spans in the exporter
       */
      forceFlush() {
        return Promise.all(this._sendingPromises).then(() => {
        });
      }
      /**
       * Called by _shutdownOnce with BindOnceFuture
       */
      _shutdown() {
        api_1.diag.debug("shutdown started");
        this.onShutdown();
        return this.forceFlush();
      }
    };
    exports.OTLPExporterBase = OTLPExporterBase;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/node/types.js
var require_types4 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/node/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompressionAlgorithm = void 0;
    var CompressionAlgorithm;
    (function(CompressionAlgorithm2) {
      CompressionAlgorithm2["NONE"] = "none";
      CompressionAlgorithm2["GZIP"] = "gzip";
    })(CompressionAlgorithm = exports.CompressionAlgorithm || (exports.CompressionAlgorithm = {}));
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/types.js
var require_types5 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/build/src/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OTLPExporterError = void 0;
    var OTLPExporterError = class extends Error {
      constructor(message, code, data) {
        super(message);
        this.name = "OTLPExporterError";
        this.data = data;
        this.code = code;
      }
    };
    exports.OTLPExporterError = OTLPExporterError;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/node/util.js
var require_util2 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/node/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.configureCompression = exports.createHttpAgent = exports.sendWithHttp = void 0;
    var url = __require("url");
    var http = __require("http");
    var https = __require("https");
    var zlib = __require("zlib");
    var stream_1 = __require("stream");
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var types_1 = require_types4();
    var core_1 = require_src9();
    var types_2 = require_types5();
    var util_1 = require_util();
    function sendWithHttp(collector, data, contentType, onSuccess, onError3) {
      const exporterTimeout = collector.timeoutMillis;
      const parsedUrl = new url.URL(collector.url);
      const nodeVersion = Number(process.versions.node.split(".")[0]);
      let retryTimer;
      let req;
      let reqIsDestroyed = false;
      const exporterTimer = setTimeout(() => {
        clearTimeout(retryTimer);
        reqIsDestroyed = true;
        if (req.destroyed) {
          const err = new types_2.OTLPExporterError("Request Timeout");
          onError3(err);
        } else {
          nodeVersion >= 14 ? req.destroy() : req.abort();
        }
      }, exporterTimeout);
      const options = {
        hostname: parsedUrl.hostname,
        port: parsedUrl.port,
        path: parsedUrl.pathname,
        method: "POST",
        headers: Object.assign({ "Content-Type": contentType }, collector.headers),
        agent: collector.agent
      };
      const request = parsedUrl.protocol === "http:" ? http.request : https.request;
      const sendWithRetry = (retries = util_1.DEFAULT_EXPORT_MAX_ATTEMPTS, minDelay = util_1.DEFAULT_EXPORT_INITIAL_BACKOFF) => {
        req = request(options, (res) => {
          let responseData = "";
          res.on("data", (chunk2) => responseData += chunk2);
          res.on("aborted", () => {
            if (reqIsDestroyed) {
              const err = new types_2.OTLPExporterError("Request Timeout");
              onError3(err);
            }
          });
          res.on("end", () => {
            if (reqIsDestroyed === false) {
              if (res.statusCode && res.statusCode < 299) {
                api_1.diag.debug(`statusCode: ${res.statusCode}`, responseData);
                onSuccess();
                clearTimeout(exporterTimer);
                clearTimeout(retryTimer);
              } else if (res.statusCode && (0, util_1.isExportRetryable)(res.statusCode) && retries > 0) {
                let retryTime;
                minDelay = util_1.DEFAULT_EXPORT_BACKOFF_MULTIPLIER * minDelay;
                if (res.headers["retry-after"]) {
                  retryTime = (0, util_1.parseRetryAfterToMills)(res.headers["retry-after"]);
                } else {
                  retryTime = Math.round(Math.random() * (util_1.DEFAULT_EXPORT_MAX_BACKOFF - minDelay) + minDelay);
                }
                retryTimer = setTimeout(() => {
                  sendWithRetry(retries - 1, minDelay);
                }, retryTime);
              } else {
                const error = new types_2.OTLPExporterError(res.statusMessage, res.statusCode, responseData);
                onError3(error);
                clearTimeout(exporterTimer);
                clearTimeout(retryTimer);
              }
            }
          });
        });
        req.on("error", (error) => {
          if (reqIsDestroyed) {
            const err = new types_2.OTLPExporterError("Request Timeout", error.code);
            onError3(err);
          } else {
            onError3(error);
          }
          clearTimeout(exporterTimer);
          clearTimeout(retryTimer);
        });
        req.on("abort", () => {
          if (reqIsDestroyed) {
            const err = new types_2.OTLPExporterError("Request Timeout");
            onError3(err);
          }
          clearTimeout(exporterTimer);
          clearTimeout(retryTimer);
        });
        switch (collector.compression) {
          case types_1.CompressionAlgorithm.GZIP: {
            req.setHeader("Content-Encoding", "gzip");
            const dataStream = readableFromBuffer(data);
            dataStream.on("error", onError3).pipe(zlib.createGzip()).on("error", onError3).pipe(req);
            break;
          }
          default:
            req.end(data);
            break;
        }
      };
      sendWithRetry();
    }
    exports.sendWithHttp = sendWithHttp;
    function readableFromBuffer(buff) {
      const readable = new stream_1.Readable();
      readable.push(buff);
      readable.push(null);
      return readable;
    }
    function createHttpAgent(config) {
      if (config.httpAgentOptions && config.keepAlive === false) {
        api_1.diag.warn("httpAgentOptions is used only when keepAlive is true");
        return void 0;
      }
      if (config.keepAlive === false || !config.url)
        return void 0;
      try {
        const parsedUrl = new url.URL(config.url);
        const Agent = parsedUrl.protocol === "http:" ? http.Agent : https.Agent;
        return new Agent(Object.assign({ keepAlive: true }, config.httpAgentOptions));
      } catch (err) {
        api_1.diag.error(`collector exporter failed to create http agent. err: ${err.message}`);
        return void 0;
      }
    }
    exports.createHttpAgent = createHttpAgent;
    function configureCompression(compression) {
      if (compression) {
        return compression;
      } else {
        const definedCompression = (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_TRACES_COMPRESSION || (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_COMPRESSION;
        return definedCompression === types_1.CompressionAlgorithm.GZIP ? types_1.CompressionAlgorithm.GZIP : types_1.CompressionAlgorithm.NONE;
      }
    }
    exports.configureCompression = configureCompression;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/node/OTLPExporterNodeBase.js
var require_OTLPExporterNodeBase = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/node/OTLPExporterNodeBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OTLPExporterNodeBase = void 0;
    var OTLPExporterBase_1 = require_OTLPExporterBase();
    var util_1 = require_util();
    var util_2 = require_util2();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src9();
    var OTLPExporterNodeBase = class extends OTLPExporterBase_1.OTLPExporterBase {
      constructor(config = {}) {
        super(config);
        this.DEFAULT_HEADERS = {};
        if (config.metadata) {
          api_1.diag.warn("Metadata cannot be set when using http");
        }
        this.headers = Object.assign(this.DEFAULT_HEADERS, (0, util_1.parseHeaders)(config.headers), core_1.baggageUtils.parseKeyPairsIntoRecord((0, core_1.getEnv)().OTEL_EXPORTER_OTLP_HEADERS));
        this.agent = (0, util_2.createHttpAgent)(config);
        this.compression = (0, util_2.configureCompression)(config.compression);
      }
      onInit(_config) {
      }
      send(objects, onSuccess, onError3) {
        if (this._shutdownOnce.isCalled) {
          api_1.diag.debug("Shutdown already started. Cannot send objects");
          return;
        }
        const serviceRequest = this.convert(objects);
        const promise2 = new Promise((resolve, reject3) => {
          (0, util_2.sendWithHttp)(this, JSON.stringify(serviceRequest), "application/json", resolve, reject3);
        }).then(onSuccess, onError3);
        this._sendingPromises.push(promise2);
        const popPromise = () => {
          const index = this._sendingPromises.indexOf(promise2);
          this._sendingPromises.splice(index, 1);
        };
        promise2.then(popPromise, popPromise);
      }
      onShutdown() {
      }
    };
    exports.OTLPExporterNodeBase = OTLPExporterNodeBase;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/node/index.js
var require_node8 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompressionAlgorithm = exports.configureCompression = exports.createHttpAgent = exports.sendWithHttp = exports.OTLPExporterNodeBase = void 0;
    var OTLPExporterNodeBase_1 = require_OTLPExporterNodeBase();
    Object.defineProperty(exports, "OTLPExporterNodeBase", { enumerable: true, get: function() {
      return OTLPExporterNodeBase_1.OTLPExporterNodeBase;
    } });
    var util_1 = require_util2();
    Object.defineProperty(exports, "sendWithHttp", { enumerable: true, get: function() {
      return util_1.sendWithHttp;
    } });
    Object.defineProperty(exports, "createHttpAgent", { enumerable: true, get: function() {
      return util_1.createHttpAgent;
    } });
    Object.defineProperty(exports, "configureCompression", { enumerable: true, get: function() {
      return util_1.configureCompression;
    } });
    var types_1 = require_types4();
    Object.defineProperty(exports, "CompressionAlgorithm", { enumerable: true, get: function() {
      return types_1.CompressionAlgorithm;
    } });
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/browser/util.js
var require_util3 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/browser/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sendWithXhr = exports.sendWithBeacon = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var types_1 = require_types5();
    var util_1 = require_util();
    function sendWithBeacon(body, url, blobPropertyBag, onSuccess, onError3) {
      if (navigator.sendBeacon(url, new Blob([body], blobPropertyBag))) {
        api_1.diag.debug("sendBeacon - can send", body);
        onSuccess();
      } else {
        const error = new types_1.OTLPExporterError(`sendBeacon - cannot send ${body}`);
        onError3(error);
      }
    }
    exports.sendWithBeacon = sendWithBeacon;
    function sendWithXhr(body, url, headers, exporterTimeout, onSuccess, onError3) {
      let retryTimer;
      let xhr;
      let reqIsDestroyed = false;
      const exporterTimer = setTimeout(() => {
        clearTimeout(retryTimer);
        reqIsDestroyed = true;
        if (xhr.readyState === XMLHttpRequest.DONE) {
          const err = new types_1.OTLPExporterError("Request Timeout");
          onError3(err);
        } else {
          xhr.abort();
        }
      }, exporterTimeout);
      const sendWithRetry = (retries = util_1.DEFAULT_EXPORT_MAX_ATTEMPTS, minDelay = util_1.DEFAULT_EXPORT_INITIAL_BACKOFF) => {
        xhr = new XMLHttpRequest();
        xhr.open("POST", url);
        const defaultHeaders = {
          Accept: "application/json",
          "Content-Type": "application/json"
        };
        Object.entries(Object.assign(Object.assign({}, defaultHeaders), headers)).forEach(([k2, v2]) => {
          xhr.setRequestHeader(k2, v2);
        });
        xhr.send(body);
        xhr.onreadystatechange = () => {
          if (xhr.readyState === XMLHttpRequest.DONE && reqIsDestroyed === false) {
            if (xhr.status >= 200 && xhr.status <= 299) {
              api_1.diag.debug("xhr success", body);
              onSuccess();
              clearTimeout(exporterTimer);
              clearTimeout(retryTimer);
            } else if (xhr.status && (0, util_1.isExportRetryable)(xhr.status) && retries > 0) {
              let retryTime;
              minDelay = util_1.DEFAULT_EXPORT_BACKOFF_MULTIPLIER * minDelay;
              if (xhr.getResponseHeader("Retry-After")) {
                retryTime = (0, util_1.parseRetryAfterToMills)(xhr.getResponseHeader("Retry-After"));
              } else {
                retryTime = Math.round(Math.random() * (util_1.DEFAULT_EXPORT_MAX_BACKOFF - minDelay) + minDelay);
              }
              retryTimer = setTimeout(() => {
                sendWithRetry(retries - 1, minDelay);
              }, retryTime);
            } else {
              const error = new types_1.OTLPExporterError(`Failed to export with XHR (status: ${xhr.status})`, xhr.status);
              onError3(error);
              clearTimeout(exporterTimer);
              clearTimeout(retryTimer);
            }
          }
        };
        xhr.onabort = () => {
          if (reqIsDestroyed) {
            const err = new types_1.OTLPExporterError("Request Timeout");
            onError3(err);
          }
          clearTimeout(exporterTimer);
          clearTimeout(retryTimer);
        };
        xhr.onerror = () => {
          if (reqIsDestroyed) {
            const err = new types_1.OTLPExporterError("Request Timeout");
            onError3(err);
          }
          clearTimeout(exporterTimer);
          clearTimeout(retryTimer);
        };
      };
      sendWithRetry();
    }
    exports.sendWithXhr = sendWithXhr;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/browser/OTLPExporterBrowserBase.js
var require_OTLPExporterBrowserBase = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/browser/OTLPExporterBrowserBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OTLPExporterBrowserBase = void 0;
    var OTLPExporterBase_1 = require_OTLPExporterBase();
    var util_1 = require_util();
    var util_2 = require_util3();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src9();
    var OTLPExporterBrowserBase = class extends OTLPExporterBase_1.OTLPExporterBase {
      /**
       * @param config
       */
      constructor(config = {}) {
        super(config);
        this._useXHR = false;
        this._useXHR = !!config.headers || typeof navigator.sendBeacon !== "function";
        if (this._useXHR) {
          this._headers = Object.assign({}, (0, util_1.parseHeaders)(config.headers), core_1.baggageUtils.parseKeyPairsIntoRecord((0, core_1.getEnv)().OTEL_EXPORTER_OTLP_HEADERS));
        } else {
          this._headers = {};
        }
      }
      onInit() {
      }
      onShutdown() {
      }
      send(items, onSuccess, onError3) {
        if (this._shutdownOnce.isCalled) {
          api_1.diag.debug("Shutdown already started. Cannot send objects");
          return;
        }
        const serviceRequest = this.convert(items);
        const body = JSON.stringify(serviceRequest);
        const promise2 = new Promise((resolve, reject3) => {
          if (this._useXHR) {
            (0, util_2.sendWithXhr)(body, this.url, this._headers, this.timeoutMillis, resolve, reject3);
          } else {
            (0, util_2.sendWithBeacon)(body, this.url, { type: "application/json" }, resolve, reject3);
          }
        }).then(onSuccess, onError3);
        this._sendingPromises.push(promise2);
        const popPromise = () => {
          const index = this._sendingPromises.indexOf(promise2);
          this._sendingPromises.splice(index, 1);
        };
        promise2.then(popPromise, popPromise);
      }
    };
    exports.OTLPExporterBrowserBase = OTLPExporterBrowserBase;
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/browser/index.js
var require_browser = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/browser/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sendWithXhr = exports.OTLPExporterBrowserBase = void 0;
    var OTLPExporterBrowserBase_1 = require_OTLPExporterBrowserBase();
    Object.defineProperty(exports, "OTLPExporterBrowserBase", { enumerable: true, get: function() {
      return OTLPExporterBrowserBase_1.OTLPExporterBrowserBase;
    } });
    var util_1 = require_util3();
    Object.defineProperty(exports, "sendWithXhr", { enumerable: true, get: function() {
      return util_1.sendWithXhr;
    } });
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/index.js
var require_platform8 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/build/src/platform/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sendWithXhr = exports.OTLPExporterBrowserBase = exports.CompressionAlgorithm = exports.configureCompression = exports.createHttpAgent = exports.sendWithHttp = exports.OTLPExporterNodeBase = void 0;
    var node_1 = require_node8();
    Object.defineProperty(exports, "OTLPExporterNodeBase", { enumerable: true, get: function() {
      return node_1.OTLPExporterNodeBase;
    } });
    Object.defineProperty(exports, "sendWithHttp", { enumerable: true, get: function() {
      return node_1.sendWithHttp;
    } });
    Object.defineProperty(exports, "createHttpAgent", { enumerable: true, get: function() {
      return node_1.createHttpAgent;
    } });
    Object.defineProperty(exports, "configureCompression", { enumerable: true, get: function() {
      return node_1.configureCompression;
    } });
    Object.defineProperty(exports, "CompressionAlgorithm", { enumerable: true, get: function() {
      return node_1.CompressionAlgorithm;
    } });
    var browser_1 = require_browser();
    Object.defineProperty(exports, "OTLPExporterBrowserBase", { enumerable: true, get: function() {
      return browser_1.OTLPExporterBrowserBase;
    } });
    Object.defineProperty(exports, "sendWithXhr", { enumerable: true, get: function() {
      return browser_1.sendWithXhr;
    } });
  }
});

// node_modules/@opentelemetry/otlp-exporter-base/build/src/index.js
var require_src10 = __commonJS({
  "node_modules/@opentelemetry/otlp-exporter-base/build/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.invalidTimeout = exports.configureExporterTimeout = exports.appendRootPathToUrlIfNeeded = exports.appendResourcePathToUrl = exports.parseHeaders = exports.OTLPExporterError = exports.OTLPExporterBase = void 0;
    __exportStar(require_platform8(), exports);
    var OTLPExporterBase_1 = require_OTLPExporterBase();
    Object.defineProperty(exports, "OTLPExporterBase", { enumerable: true, get: function() {
      return OTLPExporterBase_1.OTLPExporterBase;
    } });
    var types_1 = require_types5();
    Object.defineProperty(exports, "OTLPExporterError", { enumerable: true, get: function() {
      return types_1.OTLPExporterError;
    } });
    var util_1 = require_util();
    Object.defineProperty(exports, "parseHeaders", { enumerable: true, get: function() {
      return util_1.parseHeaders;
    } });
    Object.defineProperty(exports, "appendResourcePathToUrl", { enumerable: true, get: function() {
      return util_1.appendResourcePathToUrl;
    } });
    Object.defineProperty(exports, "appendRootPathToUrlIfNeeded", { enumerable: true, get: function() {
      return util_1.appendRootPathToUrlIfNeeded;
    } });
    Object.defineProperty(exports, "configureExporterTimeout", { enumerable: true, get: function() {
      return util_1.configureExporterTimeout;
    } });
    Object.defineProperty(exports, "invalidTimeout", { enumerable: true, get: function() {
      return util_1.invalidTimeout;
    } });
  }
});

// node_modules/@grpc/grpc-js/build/src/constants.js
var require_constants5 = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = exports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = exports.Propagate = exports.LogVerbosity = exports.Status = void 0;
    var Status;
    (function(Status2) {
      Status2[Status2["OK"] = 0] = "OK";
      Status2[Status2["CANCELLED"] = 1] = "CANCELLED";
      Status2[Status2["UNKNOWN"] = 2] = "UNKNOWN";
      Status2[Status2["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
      Status2[Status2["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
      Status2[Status2["NOT_FOUND"] = 5] = "NOT_FOUND";
      Status2[Status2["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
      Status2[Status2["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
      Status2[Status2["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
      Status2[Status2["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
      Status2[Status2["ABORTED"] = 10] = "ABORTED";
      Status2[Status2["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
      Status2[Status2["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
      Status2[Status2["INTERNAL"] = 13] = "INTERNAL";
      Status2[Status2["UNAVAILABLE"] = 14] = "UNAVAILABLE";
      Status2[Status2["DATA_LOSS"] = 15] = "DATA_LOSS";
      Status2[Status2["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
    })(Status || (exports.Status = Status = {}));
    var LogVerbosity;
    (function(LogVerbosity2) {
      LogVerbosity2[LogVerbosity2["DEBUG"] = 0] = "DEBUG";
      LogVerbosity2[LogVerbosity2["INFO"] = 1] = "INFO";
      LogVerbosity2[LogVerbosity2["ERROR"] = 2] = "ERROR";
      LogVerbosity2[LogVerbosity2["NONE"] = 3] = "NONE";
    })(LogVerbosity || (exports.LogVerbosity = LogVerbosity = {}));
    var Propagate;
    (function(Propagate2) {
      Propagate2[Propagate2["DEADLINE"] = 1] = "DEADLINE";
      Propagate2[Propagate2["CENSUS_STATS_CONTEXT"] = 2] = "CENSUS_STATS_CONTEXT";
      Propagate2[Propagate2["CENSUS_TRACING_CONTEXT"] = 4] = "CENSUS_TRACING_CONTEXT";
      Propagate2[Propagate2["CANCELLATION"] = 8] = "CANCELLATION";
      Propagate2[Propagate2["DEFAULTS"] = 65535] = "DEFAULTS";
    })(Propagate || (exports.Propagate = Propagate = {}));
    exports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;
    exports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024;
  }
});

// node_modules/@grpc/grpc-js/package.json
var require_package = __commonJS({
  "node_modules/@grpc/grpc-js/package.json"(exports, module) {
    module.exports = {
      name: "@grpc/grpc-js",
      version: "1.12.5",
      description: "gRPC Library for Node - pure JS implementation",
      homepage: "https://grpc.io/",
      repository: "https://github.com/grpc/grpc-node/tree/master/packages/grpc-js",
      main: "build/src/index.js",
      engines: {
        node: ">=12.10.0"
      },
      keywords: [],
      author: {
        name: "Google Inc."
      },
      types: "build/src/index.d.ts",
      license: "Apache-2.0",
      devDependencies: {
        "@grpc/proto-loader": "file:../proto-loader",
        "@types/gulp": "^4.0.17",
        "@types/gulp-mocha": "0.0.37",
        "@types/lodash": "^4.14.202",
        "@types/mocha": "^10.0.6",
        "@types/ncp": "^2.0.8",
        "@types/node": ">=20.11.20",
        "@types/pify": "^5.0.4",
        "@types/semver": "^7.5.8",
        "@typescript-eslint/eslint-plugin": "^7.1.0",
        "@typescript-eslint/parser": "^7.1.0",
        "@typescript-eslint/typescript-estree": "^7.1.0",
        "clang-format": "^1.8.0",
        eslint: "^8.42.0",
        "eslint-config-prettier": "^8.8.0",
        "eslint-plugin-node": "^11.1.0",
        "eslint-plugin-prettier": "^4.2.1",
        execa: "^2.0.3",
        gulp: "^4.0.2",
        "gulp-mocha": "^6.0.0",
        lodash: "^4.17.21",
        madge: "^5.0.1",
        "mocha-jenkins-reporter": "^0.4.1",
        ncp: "^2.0.0",
        pify: "^4.0.1",
        prettier: "^2.8.8",
        rimraf: "^3.0.2",
        semver: "^7.6.0",
        "ts-node": "^10.9.2",
        typescript: "^5.3.3"
      },
      contributors: [
        {
          name: "Google Inc."
        }
      ],
      scripts: {
        build: "npm run compile",
        clean: "rimraf ./build",
        compile: "tsc -p .",
        format: 'clang-format -i -style="{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}" src/*.ts test/*.ts',
        lint: "eslint src/*.ts test/*.ts",
        prepare: "npm run generate-types && npm run compile",
        test: "gulp test",
        check: "npm run lint",
        fix: "eslint --fix src/*.ts test/*.ts",
        pretest: "npm run generate-types && npm run generate-test-types && npm run compile",
        posttest: "npm run check && madge -c ./build/src",
        "generate-types": "proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --includeDirs proto/ --include-dirs test/fixtures/ -O src/generated/ --grpcLib ../index channelz.proto",
        "generate-test-types": "proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --include-dirs test/fixtures/ -O test/generated/ --grpcLib ../../src/index test_service.proto"
      },
      dependencies: {
        "@grpc/proto-loader": "^0.7.13",
        "@js-sdsl/ordered-map": "^4.4.2"
      },
      files: [
        "src/**/*.ts",
        "build/src/**/*.{js,d.ts,js.map}",
        "proto/*.proto",
        "LICENSE",
        "deps/envoy-api/envoy/api/v2/**/*.proto",
        "deps/envoy-api/envoy/config/**/*.proto",
        "deps/envoy-api/envoy/service/**/*.proto",
        "deps/envoy-api/envoy/type/**/*.proto",
        "deps/udpa/udpa/**/*.proto",
        "deps/googleapis/google/api/*.proto",
        "deps/googleapis/google/rpc/*.proto",
        "deps/protoc-gen-validate/validate/**/*.proto"
      ]
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/logging.js
var require_logging = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/logging.js"(exports) {
    "use strict";
    var _a12;
    var _b5;
    var _c4;
    var _d4;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTracerEnabled = exports.trace = exports.log = exports.setLoggerVerbosity = exports.setLogger = exports.getLogger = void 0;
    var constants_1 = require_constants5();
    var process_1 = __require("process");
    var clientVersion = require_package().version;
    var DEFAULT_LOGGER = {
      error: (message, ...optionalParams) => {
        console.error("E " + message, ...optionalParams);
      },
      info: (message, ...optionalParams) => {
        console.error("I " + message, ...optionalParams);
      },
      debug: (message, ...optionalParams) => {
        console.error("D " + message, ...optionalParams);
      }
    };
    var _logger = DEFAULT_LOGGER;
    var _logVerbosity = constants_1.LogVerbosity.ERROR;
    var verbosityString = (_b5 = (_a12 = process.env.GRPC_NODE_VERBOSITY) !== null && _a12 !== void 0 ? _a12 : process.env.GRPC_VERBOSITY) !== null && _b5 !== void 0 ? _b5 : "";
    switch (verbosityString.toUpperCase()) {
      case "DEBUG":
        _logVerbosity = constants_1.LogVerbosity.DEBUG;
        break;
      case "INFO":
        _logVerbosity = constants_1.LogVerbosity.INFO;
        break;
      case "ERROR":
        _logVerbosity = constants_1.LogVerbosity.ERROR;
        break;
      case "NONE":
        _logVerbosity = constants_1.LogVerbosity.NONE;
        break;
      default:
    }
    var getLogger = () => {
      return _logger;
    };
    exports.getLogger = getLogger;
    var setLogger = (logger) => {
      _logger = logger;
    };
    exports.setLogger = setLogger;
    var setLoggerVerbosity = (verbosity) => {
      _logVerbosity = verbosity;
    };
    exports.setLoggerVerbosity = setLoggerVerbosity;
    var log3 = (severity, ...args) => {
      let logFunction;
      if (severity >= _logVerbosity) {
        switch (severity) {
          case constants_1.LogVerbosity.DEBUG:
            logFunction = _logger.debug;
            break;
          case constants_1.LogVerbosity.INFO:
            logFunction = _logger.info;
            break;
          case constants_1.LogVerbosity.ERROR:
            logFunction = _logger.error;
            break;
        }
        if (!logFunction) {
          logFunction = _logger.error;
        }
        if (logFunction) {
          logFunction.bind(_logger)(...args);
        }
      }
    };
    exports.log = log3;
    var tracersString = (_d4 = (_c4 = process.env.GRPC_NODE_TRACE) !== null && _c4 !== void 0 ? _c4 : process.env.GRPC_TRACE) !== null && _d4 !== void 0 ? _d4 : "";
    var enabledTracers = /* @__PURE__ */ new Set();
    var disabledTracers = /* @__PURE__ */ new Set();
    for (const tracerName of tracersString.split(",")) {
      if (tracerName.startsWith("-")) {
        disabledTracers.add(tracerName.substring(1));
      } else {
        enabledTracers.add(tracerName);
      }
    }
    var allEnabled = enabledTracers.has("all");
    function trace3(severity, tracer2, text) {
      if (isTracerEnabled(tracer2)) {
        (0, exports.log)(severity, (/* @__PURE__ */ new Date()).toISOString() + " | v" + clientVersion + " " + process_1.pid + " | " + tracer2 + " | " + text);
      }
    }
    exports.trace = trace3;
    function isTracerEnabled(tracer2) {
      return !disabledTracers.has(tracer2) && (allEnabled || enabledTracers.has(tracer2));
    }
    exports.isTracerEnabled = isTracerEnabled;
  }
});

// node_modules/@grpc/grpc-js/build/src/error.js
var require_error = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getErrorCode = exports.getErrorMessage = void 0;
    function getErrorMessage(error) {
      if (error instanceof Error) {
        return error.message;
      } else {
        return String(error);
      }
    }
    exports.getErrorMessage = getErrorMessage;
    function getErrorCode(error) {
      if (typeof error === "object" && error !== null && "code" in error && typeof error.code === "number") {
        return error.code;
      } else {
        return null;
      }
    }
    exports.getErrorCode = getErrorCode;
  }
});

// node_modules/@grpc/grpc-js/build/src/metadata.js
var require_metadata = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Metadata = void 0;
    var logging_1 = require_logging();
    var constants_1 = require_constants5();
    var error_1 = require_error();
    var LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;
    var LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;
    function isLegalKey(key) {
      return LEGAL_KEY_REGEX.test(key);
    }
    function isLegalNonBinaryValue(value) {
      return LEGAL_NON_BINARY_VALUE_REGEX.test(value);
    }
    function isBinaryKey(key) {
      return key.endsWith("-bin");
    }
    function isCustomMetadata(key) {
      return !key.startsWith("grpc-");
    }
    function normalizeKey(key) {
      return key.toLowerCase();
    }
    function validate2(key, value) {
      if (!isLegalKey(key)) {
        throw new Error('Metadata key "' + key + '" contains illegal characters');
      }
      if (value !== null && value !== void 0) {
        if (isBinaryKey(key)) {
          if (!Buffer.isBuffer(value)) {
            throw new Error("keys that end with '-bin' must have Buffer values");
          }
        } else {
          if (Buffer.isBuffer(value)) {
            throw new Error("keys that don't end with '-bin' must have String values");
          }
          if (!isLegalNonBinaryValue(value)) {
            throw new Error('Metadata string value "' + value + '" contains illegal characters');
          }
        }
      }
    }
    var Metadata = class _Metadata {
      constructor(options = {}) {
        this.internalRepr = /* @__PURE__ */ new Map();
        this.options = options;
      }
      /**
       * Sets the given value for the given key by replacing any other values
       * associated with that key. Normalizes the key.
       * @param key The key to whose value should be set.
       * @param value The value to set. Must be a buffer if and only
       *   if the normalized key ends with '-bin'.
       */
      set(key, value) {
        key = normalizeKey(key);
        validate2(key, value);
        this.internalRepr.set(key, [value]);
      }
      /**
       * Adds the given value for the given key by appending to a list of previous
       * values associated with that key. Normalizes the key.
       * @param key The key for which a new value should be appended.
       * @param value The value to add. Must be a buffer if and only
       *   if the normalized key ends with '-bin'.
       */
      add(key, value) {
        key = normalizeKey(key);
        validate2(key, value);
        const existingValue = this.internalRepr.get(key);
        if (existingValue === void 0) {
          this.internalRepr.set(key, [value]);
        } else {
          existingValue.push(value);
        }
      }
      /**
       * Removes the given key and any associated values. Normalizes the key.
       * @param key The key whose values should be removed.
       */
      remove(key) {
        key = normalizeKey(key);
        this.internalRepr.delete(key);
      }
      /**
       * Gets a list of all values associated with the key. Normalizes the key.
       * @param key The key whose value should be retrieved.
       * @return A list of values associated with the given key.
       */
      get(key) {
        key = normalizeKey(key);
        return this.internalRepr.get(key) || [];
      }
      /**
       * Gets a plain object mapping each key to the first value associated with it.
       * This reflects the most common way that people will want to see metadata.
       * @return A key/value mapping of the metadata.
       */
      getMap() {
        const result4 = {};
        for (const [key, values3] of this.internalRepr) {
          if (values3.length > 0) {
            const v2 = values3[0];
            result4[key] = Buffer.isBuffer(v2) ? Buffer.from(v2) : v2;
          }
        }
        return result4;
      }
      /**
       * Clones the metadata object.
       * @return The newly cloned object.
       */
      clone() {
        const newMetadata = new _Metadata(this.options);
        const newInternalRepr = newMetadata.internalRepr;
        for (const [key, value] of this.internalRepr) {
          const clonedValue = value.map((v2) => {
            if (Buffer.isBuffer(v2)) {
              return Buffer.from(v2);
            } else {
              return v2;
            }
          });
          newInternalRepr.set(key, clonedValue);
        }
        return newMetadata;
      }
      /**
       * Merges all key-value pairs from a given Metadata object into this one.
       * If both this object and the given object have values in the same key,
       * values from the other Metadata object will be appended to this object's
       * values.
       * @param other A Metadata object.
       */
      merge(other) {
        for (const [key, values3] of other.internalRepr) {
          const mergedValue = (this.internalRepr.get(key) || []).concat(values3);
          this.internalRepr.set(key, mergedValue);
        }
      }
      setOptions(options) {
        this.options = options;
      }
      getOptions() {
        return this.options;
      }
      /**
       * Creates an OutgoingHttpHeaders object that can be used with the http2 API.
       */
      toHttp2Headers() {
        const result4 = {};
        for (const [key, values3] of this.internalRepr) {
          result4[key] = values3.map(bufToString);
        }
        return result4;
      }
      /**
       * This modifies the behavior of JSON.stringify to show an object
       * representation of the metadata map.
       */
      toJSON() {
        const result4 = {};
        for (const [key, values3] of this.internalRepr) {
          result4[key] = values3;
        }
        return result4;
      }
      /**
       * Returns a new Metadata object based fields in a given IncomingHttpHeaders
       * object.
       * @param headers An IncomingHttpHeaders object.
       */
      static fromHttp2Headers(headers) {
        const result4 = new _Metadata();
        for (const key of Object.keys(headers)) {
          if (key.charAt(0) === ":") {
            continue;
          }
          const values3 = headers[key];
          try {
            if (isBinaryKey(key)) {
              if (Array.isArray(values3)) {
                values3.forEach((value) => {
                  result4.add(key, Buffer.from(value, "base64"));
                });
              } else if (values3 !== void 0) {
                if (isCustomMetadata(key)) {
                  values3.split(",").forEach((v2) => {
                    result4.add(key, Buffer.from(v2.trim(), "base64"));
                  });
                } else {
                  result4.add(key, Buffer.from(values3, "base64"));
                }
              }
            } else {
              if (Array.isArray(values3)) {
                values3.forEach((value) => {
                  result4.add(key, value);
                });
              } else if (values3 !== void 0) {
                result4.add(key, values3);
              }
            }
          } catch (error) {
            const message = `Failed to add metadata entry ${key}: ${values3}. ${(0, error_1.getErrorMessage)(error)}. For more information see https://github.com/grpc/grpc-node/issues/1173`;
            (0, logging_1.log)(constants_1.LogVerbosity.ERROR, message);
          }
        }
        return result4;
      }
    };
    exports.Metadata = Metadata;
    var bufToString = (val) => {
      return Buffer.isBuffer(val) ? val.toString("base64") : val;
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/call-credentials.js
var require_call_credentials = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/call-credentials.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CallCredentials = void 0;
    var metadata_1 = require_metadata();
    function isCurrentOauth2Client(client) {
      return "getRequestHeaders" in client && typeof client.getRequestHeaders === "function";
    }
    var CallCredentials = class _CallCredentials {
      /**
       * Creates a new CallCredentials object from a given function that generates
       * Metadata objects.
       * @param metadataGenerator A function that accepts a set of options, and
       * generates a Metadata object based on these options, which is passed back
       * to the caller via a supplied (err, metadata) callback.
       */
      static createFromMetadataGenerator(metadataGenerator) {
        return new SingleCallCredentials(metadataGenerator);
      }
      /**
       * Create a gRPC credential from a Google credential object.
       * @param googleCredentials The authentication client to use.
       * @return The resulting CallCredentials object.
       */
      static createFromGoogleCredential(googleCredentials) {
        return _CallCredentials.createFromMetadataGenerator((options, callback) => {
          let getHeaders;
          if (isCurrentOauth2Client(googleCredentials)) {
            getHeaders = googleCredentials.getRequestHeaders(options.service_url);
          } else {
            getHeaders = new Promise((resolve, reject3) => {
              googleCredentials.getRequestMetadata(options.service_url, (err, headers) => {
                if (err) {
                  reject3(err);
                  return;
                }
                if (!headers) {
                  reject3(new Error("Headers not set by metadata plugin"));
                  return;
                }
                resolve(headers);
              });
            });
          }
          getHeaders.then((headers) => {
            const metadata = new metadata_1.Metadata();
            for (const key of Object.keys(headers)) {
              metadata.add(key, headers[key]);
            }
            callback(null, metadata);
          }, (err) => {
            callback(err);
          });
        });
      }
      static createEmpty() {
        return new EmptyCallCredentials();
      }
    };
    exports.CallCredentials = CallCredentials;
    var ComposedCallCredentials = class _ComposedCallCredentials extends CallCredentials {
      constructor(creds) {
        super();
        this.creds = creds;
      }
      async generateMetadata(options) {
        const base = new metadata_1.Metadata();
        const generated = await Promise.all(this.creds.map((cred) => cred.generateMetadata(options)));
        for (const gen7 of generated) {
          base.merge(gen7);
        }
        return base;
      }
      compose(other) {
        return new _ComposedCallCredentials(this.creds.concat([other]));
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof _ComposedCallCredentials) {
          return this.creds.every((value, index) => value._equals(other.creds[index]));
        } else {
          return false;
        }
      }
    };
    var SingleCallCredentials = class _SingleCallCredentials extends CallCredentials {
      constructor(metadataGenerator) {
        super();
        this.metadataGenerator = metadataGenerator;
      }
      generateMetadata(options) {
        return new Promise((resolve, reject3) => {
          this.metadataGenerator(options, (err, metadata) => {
            if (metadata !== void 0) {
              resolve(metadata);
            } else {
              reject3(err);
            }
          });
        });
      }
      compose(other) {
        return new ComposedCallCredentials([this, other]);
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof _SingleCallCredentials) {
          return this.metadataGenerator === other.metadataGenerator;
        } else {
          return false;
        }
      }
    };
    var EmptyCallCredentials = class _EmptyCallCredentials extends CallCredentials {
      generateMetadata(options) {
        return Promise.resolve(new metadata_1.Metadata());
      }
      compose(other) {
        return other;
      }
      _equals(other) {
        return other instanceof _EmptyCallCredentials;
      }
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/tls-helpers.js
var require_tls_helpers = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/tls-helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDefaultRootsData = exports.CIPHER_SUITES = void 0;
    var fs3 = __require("fs");
    exports.CIPHER_SUITES = process.env.GRPC_SSL_CIPHER_SUITES;
    var DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;
    var defaultRootsData = null;
    function getDefaultRootsData() {
      if (DEFAULT_ROOTS_FILE_PATH) {
        if (defaultRootsData === null) {
          defaultRootsData = fs3.readFileSync(DEFAULT_ROOTS_FILE_PATH);
        }
        return defaultRootsData;
      }
      return null;
    }
    exports.getDefaultRootsData = getDefaultRootsData;
  }
});

// node_modules/@grpc/grpc-js/build/src/channel-credentials.js
var require_channel_credentials = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/channel-credentials.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCertificateProviderChannelCredentials = exports.ChannelCredentials = void 0;
    var tls_1 = __require("tls");
    var call_credentials_1 = require_call_credentials();
    var tls_helpers_1 = require_tls_helpers();
    function verifyIsBufferOrNull(obj, friendlyName) {
      if (obj && !(obj instanceof Buffer)) {
        throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);
      }
    }
    var ChannelCredentials = class {
      constructor(callCredentials) {
        this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();
      }
      /**
       * Gets the set of per-call credentials associated with this instance.
       */
      _getCallCredentials() {
        return this.callCredentials;
      }
      _ref() {
      }
      _unref() {
      }
      /**
       * Return a new ChannelCredentials instance with a given set of credentials.
       * The resulting instance can be used to construct a Channel that communicates
       * over TLS.
       * @param rootCerts The root certificate data.
       * @param privateKey The client certificate private key, if available.
       * @param certChain The client certificate key chain, if available.
       * @param verifyOptions Additional options to modify certificate verification
       */
      static createSsl(rootCerts, privateKey, certChain, verifyOptions) {
        var _a12;
        verifyIsBufferOrNull(rootCerts, "Root certificate");
        verifyIsBufferOrNull(privateKey, "Private key");
        verifyIsBufferOrNull(certChain, "Certificate chain");
        if (privateKey && !certChain) {
          throw new Error("Private key must be given with accompanying certificate chain");
        }
        if (!privateKey && certChain) {
          throw new Error("Certificate chain must be given with accompanying private key");
        }
        const secureContext = (0, tls_1.createSecureContext)({
          ca: (_a12 = rootCerts !== null && rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a12 !== void 0 ? _a12 : void 0,
          key: privateKey !== null && privateKey !== void 0 ? privateKey : void 0,
          cert: certChain !== null && certChain !== void 0 ? certChain : void 0,
          ciphers: tls_helpers_1.CIPHER_SUITES
        });
        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});
      }
      /**
       * Return a new ChannelCredentials instance with credentials created using
       * the provided secureContext. The resulting instances can be used to
       * construct a Channel that communicates over TLS. gRPC will not override
       * anything in the provided secureContext, so the environment variables
       * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will
       * not be applied.
       * @param secureContext The return value of tls.createSecureContext()
       * @param verifyOptions Additional options to modify certificate verification
       */
      static createFromSecureContext(secureContext, verifyOptions) {
        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});
      }
      /**
       * Return a new ChannelCredentials instance with no credentials.
       */
      static createInsecure() {
        return new InsecureChannelCredentialsImpl();
      }
    };
    exports.ChannelCredentials = ChannelCredentials;
    var InsecureChannelCredentialsImpl = class _InsecureChannelCredentialsImpl extends ChannelCredentials {
      constructor() {
        super();
      }
      compose(callCredentials) {
        throw new Error("Cannot compose insecure credentials");
      }
      _getConnectionOptions() {
        return {};
      }
      _isSecure() {
        return false;
      }
      _equals(other) {
        return other instanceof _InsecureChannelCredentialsImpl;
      }
    };
    var SecureChannelCredentialsImpl = class _SecureChannelCredentialsImpl extends ChannelCredentials {
      constructor(secureContext, verifyOptions) {
        super();
        this.secureContext = secureContext;
        this.verifyOptions = verifyOptions;
        this.connectionOptions = {
          secureContext
        };
        if (verifyOptions === null || verifyOptions === void 0 ? void 0 : verifyOptions.checkServerIdentity) {
          this.connectionOptions.checkServerIdentity = verifyOptions.checkServerIdentity;
        }
        if ((verifyOptions === null || verifyOptions === void 0 ? void 0 : verifyOptions.rejectUnauthorized) !== void 0) {
          this.connectionOptions.rejectUnauthorized = verifyOptions.rejectUnauthorized;
        }
      }
      compose(callCredentials) {
        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
        return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);
      }
      _getConnectionOptions() {
        return Object.assign({}, this.connectionOptions);
      }
      _isSecure() {
        return true;
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof _SecureChannelCredentialsImpl) {
          return this.secureContext === other.secureContext && this.verifyOptions.checkServerIdentity === other.verifyOptions.checkServerIdentity;
        } else {
          return false;
        }
      }
    };
    var CertificateProviderChannelCredentialsImpl = class _CertificateProviderChannelCredentialsImpl extends ChannelCredentials {
      constructor(caCertificateProvider, identityCertificateProvider, verifyOptions) {
        super();
        this.caCertificateProvider = caCertificateProvider;
        this.identityCertificateProvider = identityCertificateProvider;
        this.verifyOptions = verifyOptions;
        this.refcount = 0;
        this.latestCaUpdate = null;
        this.latestIdentityUpdate = null;
        this.caCertificateUpdateListener = this.handleCaCertificateUpdate.bind(this);
        this.identityCertificateUpdateListener = this.handleIdentityCertitificateUpdate.bind(this);
      }
      compose(callCredentials) {
        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
        return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);
      }
      _getConnectionOptions() {
        var _a12, _b5, _c4;
        if (this.latestCaUpdate === null) {
          return null;
        }
        if (this.identityCertificateProvider !== null && this.latestIdentityUpdate === null) {
          return null;
        }
        const secureContext = (0, tls_1.createSecureContext)({
          ca: this.latestCaUpdate.caCertificate,
          key: (_a12 = this.latestIdentityUpdate) === null || _a12 === void 0 ? void 0 : _a12.privateKey,
          cert: (_b5 = this.latestIdentityUpdate) === null || _b5 === void 0 ? void 0 : _b5.certificate,
          ciphers: tls_helpers_1.CIPHER_SUITES
        });
        const options = {
          secureContext
        };
        if ((_c4 = this.verifyOptions) === null || _c4 === void 0 ? void 0 : _c4.checkServerIdentity) {
          options.checkServerIdentity = this.verifyOptions.checkServerIdentity;
        }
        return options;
      }
      _isSecure() {
        return true;
      }
      _equals(other) {
        var _a12, _b5;
        if (this === other) {
          return true;
        }
        if (other instanceof _CertificateProviderChannelCredentialsImpl) {
          return this.caCertificateProvider === other.caCertificateProvider && this.identityCertificateProvider === other.identityCertificateProvider && ((_a12 = this.verifyOptions) === null || _a12 === void 0 ? void 0 : _a12.checkServerIdentity) === ((_b5 = other.verifyOptions) === null || _b5 === void 0 ? void 0 : _b5.checkServerIdentity);
        } else {
          return false;
        }
      }
      _ref() {
        var _a12;
        if (this.refcount === 0) {
          this.caCertificateProvider.addCaCertificateListener(this.caCertificateUpdateListener);
          (_a12 = this.identityCertificateProvider) === null || _a12 === void 0 ? void 0 : _a12.addIdentityCertificateListener(this.identityCertificateUpdateListener);
        }
        this.refcount += 1;
      }
      _unref() {
        var _a12;
        this.refcount -= 1;
        if (this.refcount === 0) {
          this.caCertificateProvider.removeCaCertificateListener(this.caCertificateUpdateListener);
          (_a12 = this.identityCertificateProvider) === null || _a12 === void 0 ? void 0 : _a12.removeIdentityCertificateListener(this.identityCertificateUpdateListener);
        }
      }
      handleCaCertificateUpdate(update4) {
        this.latestCaUpdate = update4;
      }
      handleIdentityCertitificateUpdate(update4) {
        this.latestIdentityUpdate = update4;
      }
    };
    function createCertificateProviderChannelCredentials(caCertificateProvider, identityCertificateProvider, verifyOptions) {
      return new CertificateProviderChannelCredentialsImpl(caCertificateProvider, identityCertificateProvider, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : null);
    }
    exports.createCertificateProviderChannelCredentials = createCertificateProviderChannelCredentials;
    var ComposedChannelCredentialsImpl = class _ComposedChannelCredentialsImpl extends ChannelCredentials {
      constructor(channelCredentials, callCreds) {
        super(callCreds);
        this.channelCredentials = channelCredentials;
        if (!channelCredentials._isSecure()) {
          throw new Error("Cannot compose insecure credentials");
        }
      }
      compose(callCredentials) {
        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
        return new _ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);
      }
      _getConnectionOptions() {
        return this.channelCredentials._getConnectionOptions();
      }
      _isSecure() {
        return true;
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof _ComposedChannelCredentialsImpl) {
          return this.channelCredentials._equals(other.channelCredentials) && this.callCredentials._equals(other.callCredentials);
        } else {
          return false;
        }
      }
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer.js
var require_load_balancer = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.selectLbConfigFromList = exports.getDefaultConfig = exports.parseLoadBalancingConfig = exports.isLoadBalancerNameRegistered = exports.createLoadBalancer = exports.registerDefaultLoadBalancerType = exports.registerLoadBalancerType = exports.createChildChannelControlHelper = void 0;
    var logging_1 = require_logging();
    var constants_1 = require_constants5();
    function createChildChannelControlHelper(parent, overrides) {
      var _a12, _b5, _c4, _d4, _e4, _f3, _g2, _h, _j, _k;
      return {
        createSubchannel: (_b5 = (_a12 = overrides.createSubchannel) === null || _a12 === void 0 ? void 0 : _a12.bind(overrides)) !== null && _b5 !== void 0 ? _b5 : parent.createSubchannel.bind(parent),
        updateState: (_d4 = (_c4 = overrides.updateState) === null || _c4 === void 0 ? void 0 : _c4.bind(overrides)) !== null && _d4 !== void 0 ? _d4 : parent.updateState.bind(parent),
        requestReresolution: (_f3 = (_e4 = overrides.requestReresolution) === null || _e4 === void 0 ? void 0 : _e4.bind(overrides)) !== null && _f3 !== void 0 ? _f3 : parent.requestReresolution.bind(parent),
        addChannelzChild: (_h = (_g2 = overrides.addChannelzChild) === null || _g2 === void 0 ? void 0 : _g2.bind(overrides)) !== null && _h !== void 0 ? _h : parent.addChannelzChild.bind(parent),
        removeChannelzChild: (_k = (_j = overrides.removeChannelzChild) === null || _j === void 0 ? void 0 : _j.bind(overrides)) !== null && _k !== void 0 ? _k : parent.removeChannelzChild.bind(parent)
      };
    }
    exports.createChildChannelControlHelper = createChildChannelControlHelper;
    var registeredLoadBalancerTypes = {};
    var defaultLoadBalancerType = null;
    function registerLoadBalancerType(typeName, loadBalancerType, loadBalancingConfigType) {
      registeredLoadBalancerTypes[typeName] = {
        LoadBalancer: loadBalancerType,
        LoadBalancingConfig: loadBalancingConfigType
      };
    }
    exports.registerLoadBalancerType = registerLoadBalancerType;
    function registerDefaultLoadBalancerType(typeName) {
      defaultLoadBalancerType = typeName;
    }
    exports.registerDefaultLoadBalancerType = registerDefaultLoadBalancerType;
    function createLoadBalancer(config, channelControlHelper, credentials, options) {
      const typeName = config.getLoadBalancerName();
      if (typeName in registeredLoadBalancerTypes) {
        return new registeredLoadBalancerTypes[typeName].LoadBalancer(channelControlHelper, credentials, options);
      } else {
        return null;
      }
    }
    exports.createLoadBalancer = createLoadBalancer;
    function isLoadBalancerNameRegistered(typeName) {
      return typeName in registeredLoadBalancerTypes;
    }
    exports.isLoadBalancerNameRegistered = isLoadBalancerNameRegistered;
    function parseLoadBalancingConfig(rawConfig) {
      const keys4 = Object.keys(rawConfig);
      if (keys4.length !== 1) {
        throw new Error("Provided load balancing config has multiple conflicting entries");
      }
      const typeName = keys4[0];
      if (typeName in registeredLoadBalancerTypes) {
        try {
          return registeredLoadBalancerTypes[typeName].LoadBalancingConfig.createFromJson(rawConfig[typeName]);
        } catch (e2) {
          throw new Error(`${typeName}: ${e2.message}`);
        }
      } else {
        throw new Error(`Unrecognized load balancing config name ${typeName}`);
      }
    }
    exports.parseLoadBalancingConfig = parseLoadBalancingConfig;
    function getDefaultConfig() {
      if (!defaultLoadBalancerType) {
        throw new Error("No default load balancer type registered");
      }
      return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();
    }
    exports.getDefaultConfig = getDefaultConfig;
    function selectLbConfigFromList(configs, fallbackTodefault = false) {
      for (const config of configs) {
        try {
          return parseLoadBalancingConfig(config);
        } catch (e2) {
          (0, logging_1.log)(constants_1.LogVerbosity.DEBUG, "Config parsing failed with error", e2.message);
          continue;
        }
      }
      if (fallbackTodefault) {
        if (defaultLoadBalancerType) {
          return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();
        } else {
          return null;
        }
      } else {
        return null;
      }
    }
    exports.selectLbConfigFromList = selectLbConfigFromList;
  }
});

// node_modules/@grpc/grpc-js/build/src/service-config.js
var require_service_config = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/service-config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractAndSelectServiceConfig = exports.validateServiceConfig = exports.validateRetryThrottling = void 0;
    var os3 = __require("os");
    var constants_1 = require_constants5();
    var DURATION_REGEX = /^\d+(\.\d{1,9})?s$/;
    var CLIENT_LANGUAGE_STRING = "node";
    function validateName(obj) {
      if ("service" in obj && obj.service !== "") {
        if (typeof obj.service !== "string") {
          throw new Error(`Invalid method config name: invalid service: expected type string, got ${typeof obj.service}`);
        }
        if ("method" in obj && obj.method !== "") {
          if (typeof obj.method !== "string") {
            throw new Error(`Invalid method config name: invalid method: expected type string, got ${typeof obj.service}`);
          }
          return {
            service: obj.service,
            method: obj.method
          };
        } else {
          return {
            service: obj.service
          };
        }
      } else {
        if ("method" in obj && obj.method !== void 0) {
          throw new Error(`Invalid method config name: method set with empty or unset service`);
        }
        return {};
      }
    }
    function validateRetryPolicy(obj) {
      if (!("maxAttempts" in obj) || !Number.isInteger(obj.maxAttempts) || obj.maxAttempts < 2) {
        throw new Error("Invalid method config retry policy: maxAttempts must be an integer at least 2");
      }
      if (!("initialBackoff" in obj) || typeof obj.initialBackoff !== "string" || !DURATION_REGEX.test(obj.initialBackoff)) {
        throw new Error("Invalid method config retry policy: initialBackoff must be a string consisting of a positive integer or decimal followed by s");
      }
      if (!("maxBackoff" in obj) || typeof obj.maxBackoff !== "string" || !DURATION_REGEX.test(obj.maxBackoff)) {
        throw new Error("Invalid method config retry policy: maxBackoff must be a string consisting of a positive integer or decimal followed by s");
      }
      if (!("backoffMultiplier" in obj) || typeof obj.backoffMultiplier !== "number" || obj.backoffMultiplier <= 0) {
        throw new Error("Invalid method config retry policy: backoffMultiplier must be a number greater than 0");
      }
      if (!("retryableStatusCodes" in obj && Array.isArray(obj.retryableStatusCodes))) {
        throw new Error("Invalid method config retry policy: retryableStatusCodes is required");
      }
      if (obj.retryableStatusCodes.length === 0) {
        throw new Error("Invalid method config retry policy: retryableStatusCodes must be non-empty");
      }
      for (const value of obj.retryableStatusCodes) {
        if (typeof value === "number") {
          if (!Object.values(constants_1.Status).includes(value)) {
            throw new Error("Invalid method config retry policy: retryableStatusCodes value not in status code range");
          }
        } else if (typeof value === "string") {
          if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {
            throw new Error("Invalid method config retry policy: retryableStatusCodes value not a status code name");
          }
        } else {
          throw new Error("Invalid method config retry policy: retryableStatusCodes value must be a string or number");
        }
      }
      return {
        maxAttempts: obj.maxAttempts,
        initialBackoff: obj.initialBackoff,
        maxBackoff: obj.maxBackoff,
        backoffMultiplier: obj.backoffMultiplier,
        retryableStatusCodes: obj.retryableStatusCodes
      };
    }
    function validateHedgingPolicy(obj) {
      if (!("maxAttempts" in obj) || !Number.isInteger(obj.maxAttempts) || obj.maxAttempts < 2) {
        throw new Error("Invalid method config hedging policy: maxAttempts must be an integer at least 2");
      }
      if ("hedgingDelay" in obj && (typeof obj.hedgingDelay !== "string" || !DURATION_REGEX.test(obj.hedgingDelay))) {
        throw new Error("Invalid method config hedging policy: hedgingDelay must be a string consisting of a positive integer followed by s");
      }
      if ("nonFatalStatusCodes" in obj && Array.isArray(obj.nonFatalStatusCodes)) {
        for (const value of obj.nonFatalStatusCodes) {
          if (typeof value === "number") {
            if (!Object.values(constants_1.Status).includes(value)) {
              throw new Error("Invalid method config hedging policy: nonFatalStatusCodes value not in status code range");
            }
          } else if (typeof value === "string") {
            if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {
              throw new Error("Invalid method config hedging policy: nonFatalStatusCodes value not a status code name");
            }
          } else {
            throw new Error("Invalid method config hedging policy: nonFatalStatusCodes value must be a string or number");
          }
        }
      }
      const result4 = {
        maxAttempts: obj.maxAttempts
      };
      if (obj.hedgingDelay) {
        result4.hedgingDelay = obj.hedgingDelay;
      }
      if (obj.nonFatalStatusCodes) {
        result4.nonFatalStatusCodes = obj.nonFatalStatusCodes;
      }
      return result4;
    }
    function validateMethodConfig(obj) {
      var _a12;
      const result4 = {
        name: []
      };
      if (!("name" in obj) || !Array.isArray(obj.name)) {
        throw new Error("Invalid method config: invalid name array");
      }
      for (const name of obj.name) {
        result4.name.push(validateName(name));
      }
      if ("waitForReady" in obj) {
        if (typeof obj.waitForReady !== "boolean") {
          throw new Error("Invalid method config: invalid waitForReady");
        }
        result4.waitForReady = obj.waitForReady;
      }
      if ("timeout" in obj) {
        if (typeof obj.timeout === "object") {
          if (!("seconds" in obj.timeout) || !(typeof obj.timeout.seconds === "number")) {
            throw new Error("Invalid method config: invalid timeout.seconds");
          }
          if (!("nanos" in obj.timeout) || !(typeof obj.timeout.nanos === "number")) {
            throw new Error("Invalid method config: invalid timeout.nanos");
          }
          result4.timeout = obj.timeout;
        } else if (typeof obj.timeout === "string" && DURATION_REGEX.test(obj.timeout)) {
          const timeoutParts = obj.timeout.substring(0, obj.timeout.length - 1).split(".");
          result4.timeout = {
            seconds: timeoutParts[0] | 0,
            nanos: ((_a12 = timeoutParts[1]) !== null && _a12 !== void 0 ? _a12 : 0) | 0
          };
        } else {
          throw new Error("Invalid method config: invalid timeout");
        }
      }
      if ("maxRequestBytes" in obj) {
        if (typeof obj.maxRequestBytes !== "number") {
          throw new Error("Invalid method config: invalid maxRequestBytes");
        }
        result4.maxRequestBytes = obj.maxRequestBytes;
      }
      if ("maxResponseBytes" in obj) {
        if (typeof obj.maxResponseBytes !== "number") {
          throw new Error("Invalid method config: invalid maxRequestBytes");
        }
        result4.maxResponseBytes = obj.maxResponseBytes;
      }
      if ("retryPolicy" in obj) {
        if ("hedgingPolicy" in obj) {
          throw new Error("Invalid method config: retryPolicy and hedgingPolicy cannot both be specified");
        } else {
          result4.retryPolicy = validateRetryPolicy(obj.retryPolicy);
        }
      } else if ("hedgingPolicy" in obj) {
        result4.hedgingPolicy = validateHedgingPolicy(obj.hedgingPolicy);
      }
      return result4;
    }
    function validateRetryThrottling(obj) {
      if (!("maxTokens" in obj) || typeof obj.maxTokens !== "number" || obj.maxTokens <= 0 || obj.maxTokens > 1e3) {
        throw new Error("Invalid retryThrottling: maxTokens must be a number in (0, 1000]");
      }
      if (!("tokenRatio" in obj) || typeof obj.tokenRatio !== "number" || obj.tokenRatio <= 0) {
        throw new Error("Invalid retryThrottling: tokenRatio must be a number greater than 0");
      }
      return {
        maxTokens: +obj.maxTokens.toFixed(3),
        tokenRatio: +obj.tokenRatio.toFixed(3)
      };
    }
    exports.validateRetryThrottling = validateRetryThrottling;
    function validateLoadBalancingConfig(obj) {
      if (!(typeof obj === "object" && obj !== null)) {
        throw new Error(`Invalid loadBalancingConfig: unexpected type ${typeof obj}`);
      }
      const keys4 = Object.keys(obj);
      if (keys4.length > 1) {
        throw new Error(`Invalid loadBalancingConfig: unexpected multiple keys ${keys4}`);
      }
      if (keys4.length === 0) {
        throw new Error("Invalid loadBalancingConfig: load balancing policy name required");
      }
      return {
        [keys4[0]]: obj[keys4[0]]
      };
    }
    function validateServiceConfig(obj) {
      const result4 = {
        loadBalancingConfig: [],
        methodConfig: []
      };
      if ("loadBalancingPolicy" in obj) {
        if (typeof obj.loadBalancingPolicy === "string") {
          result4.loadBalancingPolicy = obj.loadBalancingPolicy;
        } else {
          throw new Error("Invalid service config: invalid loadBalancingPolicy");
        }
      }
      if ("loadBalancingConfig" in obj) {
        if (Array.isArray(obj.loadBalancingConfig)) {
          for (const config of obj.loadBalancingConfig) {
            result4.loadBalancingConfig.push(validateLoadBalancingConfig(config));
          }
        } else {
          throw new Error("Invalid service config: invalid loadBalancingConfig");
        }
      }
      if ("methodConfig" in obj) {
        if (Array.isArray(obj.methodConfig)) {
          for (const methodConfig of obj.methodConfig) {
            result4.methodConfig.push(validateMethodConfig(methodConfig));
          }
        }
      }
      if ("retryThrottling" in obj) {
        result4.retryThrottling = validateRetryThrottling(obj.retryThrottling);
      }
      const seenMethodNames = [];
      for (const methodConfig of result4.methodConfig) {
        for (const name of methodConfig.name) {
          for (const seenName of seenMethodNames) {
            if (name.service === seenName.service && name.method === seenName.method) {
              throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);
            }
          }
          seenMethodNames.push(name);
        }
      }
      return result4;
    }
    exports.validateServiceConfig = validateServiceConfig;
    function validateCanaryConfig(obj) {
      if (!("serviceConfig" in obj)) {
        throw new Error("Invalid service config choice: missing service config");
      }
      const result4 = {
        serviceConfig: validateServiceConfig(obj.serviceConfig)
      };
      if ("clientLanguage" in obj) {
        if (Array.isArray(obj.clientLanguage)) {
          result4.clientLanguage = [];
          for (const lang of obj.clientLanguage) {
            if (typeof lang === "string") {
              result4.clientLanguage.push(lang);
            } else {
              throw new Error("Invalid service config choice: invalid clientLanguage");
            }
          }
        } else {
          throw new Error("Invalid service config choice: invalid clientLanguage");
        }
      }
      if ("clientHostname" in obj) {
        if (Array.isArray(obj.clientHostname)) {
          result4.clientHostname = [];
          for (const lang of obj.clientHostname) {
            if (typeof lang === "string") {
              result4.clientHostname.push(lang);
            } else {
              throw new Error("Invalid service config choice: invalid clientHostname");
            }
          }
        } else {
          throw new Error("Invalid service config choice: invalid clientHostname");
        }
      }
      if ("percentage" in obj) {
        if (typeof obj.percentage === "number" && 0 <= obj.percentage && obj.percentage <= 100) {
          result4.percentage = obj.percentage;
        } else {
          throw new Error("Invalid service config choice: invalid percentage");
        }
      }
      const allowedFields = [
        "clientLanguage",
        "percentage",
        "clientHostname",
        "serviceConfig"
      ];
      for (const field in obj) {
        if (!allowedFields.includes(field)) {
          throw new Error(`Invalid service config choice: unexpected field ${field}`);
        }
      }
      return result4;
    }
    function validateAndSelectCanaryConfig(obj, percentage) {
      if (!Array.isArray(obj)) {
        throw new Error("Invalid service config list");
      }
      for (const config of obj) {
        const validatedConfig = validateCanaryConfig(config);
        if (typeof validatedConfig.percentage === "number" && percentage > validatedConfig.percentage) {
          continue;
        }
        if (Array.isArray(validatedConfig.clientHostname)) {
          let hostnameMatched = false;
          for (const hostname of validatedConfig.clientHostname) {
            if (hostname === os3.hostname()) {
              hostnameMatched = true;
            }
          }
          if (!hostnameMatched) {
            continue;
          }
        }
        if (Array.isArray(validatedConfig.clientLanguage)) {
          let languageMatched = false;
          for (const language of validatedConfig.clientLanguage) {
            if (language === CLIENT_LANGUAGE_STRING) {
              languageMatched = true;
            }
          }
          if (!languageMatched) {
            continue;
          }
        }
        return validatedConfig.serviceConfig;
      }
      throw new Error("No matching service config found");
    }
    function extractAndSelectServiceConfig(txtRecord, percentage) {
      for (const record2 of txtRecord) {
        if (record2.length > 0 && record2[0].startsWith("grpc_config=")) {
          const recordString = record2.join("").substring("grpc_config=".length);
          const recordJson = JSON.parse(recordString);
          return validateAndSelectCanaryConfig(recordJson, percentage);
        }
      }
      return null;
    }
    exports.extractAndSelectServiceConfig = extractAndSelectServiceConfig;
  }
});

// node_modules/@grpc/grpc-js/build/src/connectivity-state.js
var require_connectivity_state = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/connectivity-state.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectivityState = void 0;
    var ConnectivityState;
    (function(ConnectivityState2) {
      ConnectivityState2[ConnectivityState2["IDLE"] = 0] = "IDLE";
      ConnectivityState2[ConnectivityState2["CONNECTING"] = 1] = "CONNECTING";
      ConnectivityState2[ConnectivityState2["READY"] = 2] = "READY";
      ConnectivityState2[ConnectivityState2["TRANSIENT_FAILURE"] = 3] = "TRANSIENT_FAILURE";
      ConnectivityState2[ConnectivityState2["SHUTDOWN"] = 4] = "SHUTDOWN";
    })(ConnectivityState || (exports.ConnectivityState = ConnectivityState = {}));
  }
});

// node_modules/@grpc/grpc-js/build/src/uri-parser.js
var require_uri_parser = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/uri-parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uriToString = exports.combineHostPort = exports.splitHostPort = exports.parseUri = void 0;
    var URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\/\/([^/]*)\/)?(.+)$/;
    function parseUri(uriString) {
      const parsedUri = URI_REGEX.exec(uriString);
      if (parsedUri === null) {
        return null;
      }
      return {
        scheme: parsedUri[1],
        authority: parsedUri[2],
        path: parsedUri[3]
      };
    }
    exports.parseUri = parseUri;
    var NUMBER_REGEX = /^\d+$/;
    function splitHostPort(path9) {
      if (path9.startsWith("[")) {
        const hostEnd = path9.indexOf("]");
        if (hostEnd === -1) {
          return null;
        }
        const host = path9.substring(1, hostEnd);
        if (host.indexOf(":") === -1) {
          return null;
        }
        if (path9.length > hostEnd + 1) {
          if (path9[hostEnd + 1] === ":") {
            const portString = path9.substring(hostEnd + 2);
            if (NUMBER_REGEX.test(portString)) {
              return {
                host,
                port: +portString
              };
            } else {
              return null;
            }
          } else {
            return null;
          }
        } else {
          return {
            host
          };
        }
      } else {
        const splitPath = path9.split(":");
        if (splitPath.length === 2) {
          if (NUMBER_REGEX.test(splitPath[1])) {
            return {
              host: splitPath[0],
              port: +splitPath[1]
            };
          } else {
            return null;
          }
        } else {
          return {
            host: path9
          };
        }
      }
    }
    exports.splitHostPort = splitHostPort;
    function combineHostPort(hostPort) {
      if (hostPort.port === void 0) {
        return hostPort.host;
      } else {
        if (hostPort.host.includes(":")) {
          return `[${hostPort.host}]:${hostPort.port}`;
        } else {
          return `${hostPort.host}:${hostPort.port}`;
        }
      }
    }
    exports.combineHostPort = combineHostPort;
    function uriToString(uri) {
      let result4 = "";
      if (uri.scheme !== void 0) {
        result4 += uri.scheme + ":";
      }
      if (uri.authority !== void 0) {
        result4 += "//" + uri.authority + "/";
      }
      result4 += uri.path;
      return result4;
    }
    exports.uriToString = uriToString;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver.js
var require_resolver = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapUriDefaultScheme = exports.getDefaultAuthority = exports.createResolver = exports.registerDefaultScheme = exports.registerResolver = void 0;
    var uri_parser_1 = require_uri_parser();
    var registeredResolvers = {};
    var defaultScheme = null;
    function registerResolver(scheme, resolverClass) {
      registeredResolvers[scheme] = resolverClass;
    }
    exports.registerResolver = registerResolver;
    function registerDefaultScheme(scheme) {
      defaultScheme = scheme;
    }
    exports.registerDefaultScheme = registerDefaultScheme;
    function createResolver(target, listener, options) {
      if (target.scheme !== void 0 && target.scheme in registeredResolvers) {
        return new registeredResolvers[target.scheme](target, listener, options);
      } else {
        throw new Error(`No resolver could be created for target ${(0, uri_parser_1.uriToString)(target)}`);
      }
    }
    exports.createResolver = createResolver;
    function getDefaultAuthority(target) {
      if (target.scheme !== void 0 && target.scheme in registeredResolvers) {
        return registeredResolvers[target.scheme].getDefaultAuthority(target);
      } else {
        throw new Error(`Invalid target ${(0, uri_parser_1.uriToString)(target)}`);
      }
    }
    exports.getDefaultAuthority = getDefaultAuthority;
    function mapUriDefaultScheme(target) {
      if (target.scheme === void 0 || !(target.scheme in registeredResolvers)) {
        if (defaultScheme !== null) {
          return {
            scheme: defaultScheme,
            authority: void 0,
            path: (0, uri_parser_1.uriToString)(target)
          };
        } else {
          return null;
        }
      }
      return target;
    }
    exports.mapUriDefaultScheme = mapUriDefaultScheme;
  }
});

// node_modules/@grpc/grpc-js/build/src/picker.js
var require_picker = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/picker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueuePicker = exports.UnavailablePicker = exports.PickResultType = void 0;
    var metadata_1 = require_metadata();
    var constants_1 = require_constants5();
    var PickResultType;
    (function(PickResultType2) {
      PickResultType2[PickResultType2["COMPLETE"] = 0] = "COMPLETE";
      PickResultType2[PickResultType2["QUEUE"] = 1] = "QUEUE";
      PickResultType2[PickResultType2["TRANSIENT_FAILURE"] = 2] = "TRANSIENT_FAILURE";
      PickResultType2[PickResultType2["DROP"] = 3] = "DROP";
    })(PickResultType || (exports.PickResultType = PickResultType = {}));
    var UnavailablePicker = class {
      constructor(status) {
        this.status = Object.assign({ code: constants_1.Status.UNAVAILABLE, details: "No connection established", metadata: new metadata_1.Metadata() }, status);
      }
      pick(pickArgs) {
        return {
          pickResultType: PickResultType.TRANSIENT_FAILURE,
          subchannel: null,
          status: this.status,
          onCallStarted: null,
          onCallEnded: null
        };
      }
    };
    exports.UnavailablePicker = UnavailablePicker;
    var QueuePicker = class {
      // Constructed with a load balancer. Calls exitIdle on it the first time pick is called
      constructor(loadBalancer, childPicker) {
        this.loadBalancer = loadBalancer;
        this.childPicker = childPicker;
        this.calledExitIdle = false;
      }
      pick(pickArgs) {
        if (!this.calledExitIdle) {
          process.nextTick(() => {
            this.loadBalancer.exitIdle();
          });
          this.calledExitIdle = true;
        }
        if (this.childPicker) {
          return this.childPicker.pick(pickArgs);
        } else {
          return {
            pickResultType: PickResultType.QUEUE,
            subchannel: null,
            status: null,
            onCallStarted: null,
            onCallEnded: null
          };
        }
      }
    };
    exports.QueuePicker = QueuePicker;
  }
});

// node_modules/@grpc/grpc-js/build/src/backoff-timeout.js
var require_backoff_timeout = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/backoff-timeout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BackoffTimeout = void 0;
    var INITIAL_BACKOFF_MS = 1e3;
    var BACKOFF_MULTIPLIER = 1.6;
    var MAX_BACKOFF_MS = 12e4;
    var BACKOFF_JITTER = 0.2;
    function uniformRandom(min2, max2) {
      return Math.random() * (max2 - min2) + min2;
    }
    var BackoffTimeout = class {
      constructor(callback, options) {
        this.callback = callback;
        this.initialDelay = INITIAL_BACKOFF_MS;
        this.multiplier = BACKOFF_MULTIPLIER;
        this.maxDelay = MAX_BACKOFF_MS;
        this.jitter = BACKOFF_JITTER;
        this.running = false;
        this.hasRef = true;
        this.startTime = /* @__PURE__ */ new Date();
        this.endTime = /* @__PURE__ */ new Date();
        if (options) {
          if (options.initialDelay) {
            this.initialDelay = options.initialDelay;
          }
          if (options.multiplier) {
            this.multiplier = options.multiplier;
          }
          if (options.jitter) {
            this.jitter = options.jitter;
          }
          if (options.maxDelay) {
            this.maxDelay = options.maxDelay;
          }
        }
        this.nextDelay = this.initialDelay;
        this.timerId = setTimeout(() => {
        }, 0);
        clearTimeout(this.timerId);
      }
      runTimer(delay2) {
        var _a12, _b5;
        this.endTime = this.startTime;
        this.endTime.setMilliseconds(this.endTime.getMilliseconds() + this.nextDelay);
        clearTimeout(this.timerId);
        this.timerId = setTimeout(() => {
          this.callback();
          this.running = false;
        }, delay2);
        if (!this.hasRef) {
          (_b5 = (_a12 = this.timerId).unref) === null || _b5 === void 0 ? void 0 : _b5.call(_a12);
        }
      }
      /**
       * Call the callback after the current amount of delay time
       */
      runOnce() {
        this.running = true;
        this.startTime = /* @__PURE__ */ new Date();
        this.runTimer(this.nextDelay);
        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);
        const jitterMagnitude = nextBackoff * this.jitter;
        this.nextDelay = nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);
      }
      /**
       * Stop the timer. The callback will not be called until `runOnce` is called
       * again.
       */
      stop() {
        clearTimeout(this.timerId);
        this.running = false;
      }
      /**
       * Reset the delay time to its initial value. If the timer is still running,
       * retroactively apply that reset to the current timer.
       */
      reset() {
        this.nextDelay = this.initialDelay;
        if (this.running) {
          const now = /* @__PURE__ */ new Date();
          const newEndTime = this.startTime;
          newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);
          clearTimeout(this.timerId);
          if (now < newEndTime) {
            this.runTimer(newEndTime.getTime() - now.getTime());
          } else {
            this.running = false;
          }
        }
      }
      /**
       * Check whether the timer is currently running.
       */
      isRunning() {
        return this.running;
      }
      /**
       * Set that while the timer is running, it should keep the Node process
       * running.
       */
      ref() {
        var _a12, _b5;
        this.hasRef = true;
        (_b5 = (_a12 = this.timerId).ref) === null || _b5 === void 0 ? void 0 : _b5.call(_a12);
      }
      /**
       * Set that while the timer is running, it should not keep the Node process
       * running.
       */
      unref() {
        var _a12, _b5;
        this.hasRef = false;
        (_b5 = (_a12 = this.timerId).unref) === null || _b5 === void 0 ? void 0 : _b5.call(_a12);
      }
      /**
       * Get the approximate timestamp of when the timer will fire. Only valid if
       * this.isRunning() is true.
       */
      getEndTime() {
        return this.endTime;
      }
    };
    exports.BackoffTimeout = BackoffTimeout;
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js
var require_load_balancer_child_handler = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChildLoadBalancerHandler = void 0;
    var load_balancer_1 = require_load_balancer();
    var connectivity_state_1 = require_connectivity_state();
    var TYPE_NAME = "child_load_balancer_helper";
    var ChildLoadBalancerHandler = class {
      constructor(channelControlHelper, credentials, options) {
        this.channelControlHelper = channelControlHelper;
        this.credentials = credentials;
        this.options = options;
        this.currentChild = null;
        this.pendingChild = null;
        this.latestConfig = null;
        this.ChildPolicyHelper = class {
          constructor(parent) {
            this.parent = parent;
            this.child = null;
          }
          createSubchannel(subchannelAddress, subchannelArgs, credentialsOverride) {
            return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs, credentialsOverride);
          }
          updateState(connectivityState, picker) {
            var _a12;
            if (this.calledByPendingChild()) {
              if (connectivityState === connectivity_state_1.ConnectivityState.CONNECTING) {
                return;
              }
              (_a12 = this.parent.currentChild) === null || _a12 === void 0 ? void 0 : _a12.destroy();
              this.parent.currentChild = this.parent.pendingChild;
              this.parent.pendingChild = null;
            } else if (!this.calledByCurrentChild()) {
              return;
            }
            this.parent.channelControlHelper.updateState(connectivityState, picker);
          }
          requestReresolution() {
            var _a12;
            const latestChild = (_a12 = this.parent.pendingChild) !== null && _a12 !== void 0 ? _a12 : this.parent.currentChild;
            if (this.child === latestChild) {
              this.parent.channelControlHelper.requestReresolution();
            }
          }
          setChild(newChild) {
            this.child = newChild;
          }
          addChannelzChild(child) {
            this.parent.channelControlHelper.addChannelzChild(child);
          }
          removeChannelzChild(child) {
            this.parent.channelControlHelper.removeChannelzChild(child);
          }
          calledByPendingChild() {
            return this.child === this.parent.pendingChild;
          }
          calledByCurrentChild() {
            return this.child === this.parent.currentChild;
          }
        };
      }
      configUpdateRequiresNewPolicyInstance(oldConfig, newConfig) {
        return oldConfig.getLoadBalancerName() !== newConfig.getLoadBalancerName();
      }
      /**
       * Prerequisites: lbConfig !== null and lbConfig.name is registered
       * @param endpointList
       * @param lbConfig
       * @param attributes
       */
      updateAddressList(endpointList, lbConfig, attributes) {
        let childToUpdate;
        if (this.currentChild === null || this.latestConfig === null || this.configUpdateRequiresNewPolicyInstance(this.latestConfig, lbConfig)) {
          const newHelper = new this.ChildPolicyHelper(this);
          const newChild = (0, load_balancer_1.createLoadBalancer)(lbConfig, newHelper, this.credentials, this.options);
          newHelper.setChild(newChild);
          if (this.currentChild === null) {
            this.currentChild = newChild;
            childToUpdate = this.currentChild;
          } else {
            if (this.pendingChild) {
              this.pendingChild.destroy();
            }
            this.pendingChild = newChild;
            childToUpdate = this.pendingChild;
          }
        } else {
          if (this.pendingChild === null) {
            childToUpdate = this.currentChild;
          } else {
            childToUpdate = this.pendingChild;
          }
        }
        this.latestConfig = lbConfig;
        childToUpdate.updateAddressList(endpointList, lbConfig, attributes);
      }
      exitIdle() {
        if (this.currentChild) {
          this.currentChild.exitIdle();
          if (this.pendingChild) {
            this.pendingChild.exitIdle();
          }
        }
      }
      resetBackoff() {
        if (this.currentChild) {
          this.currentChild.resetBackoff();
          if (this.pendingChild) {
            this.pendingChild.resetBackoff();
          }
        }
      }
      destroy() {
        if (this.currentChild) {
          this.currentChild.destroy();
          this.currentChild = null;
        }
        if (this.pendingChild) {
          this.pendingChild.destroy();
          this.pendingChild = null;
        }
      }
      getTypeName() {
        return TYPE_NAME;
      }
    };
    exports.ChildLoadBalancerHandler = ChildLoadBalancerHandler;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js
var require_resolving_load_balancer = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ResolvingLoadBalancer = void 0;
    var load_balancer_1 = require_load_balancer();
    var service_config_1 = require_service_config();
    var connectivity_state_1 = require_connectivity_state();
    var resolver_1 = require_resolver();
    var picker_1 = require_picker();
    var backoff_timeout_1 = require_backoff_timeout();
    var constants_1 = require_constants5();
    var metadata_1 = require_metadata();
    var logging = require_logging();
    var constants_2 = require_constants5();
    var uri_parser_1 = require_uri_parser();
    var load_balancer_child_handler_1 = require_load_balancer_child_handler();
    var TRACER_NAME = "resolving_load_balancer";
    function trace3(text) {
      logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var NAME_MATCH_LEVEL_ORDER = [
      "SERVICE_AND_METHOD",
      "SERVICE",
      "EMPTY"
    ];
    function hasMatchingName(service4, method, methodConfig, matchLevel) {
      for (const name of methodConfig.name) {
        switch (matchLevel) {
          case "EMPTY":
            if (!name.service && !name.method) {
              return true;
            }
            break;
          case "SERVICE":
            if (name.service === service4 && !name.method) {
              return true;
            }
            break;
          case "SERVICE_AND_METHOD":
            if (name.service === service4 && name.method === method) {
              return true;
            }
        }
      }
      return false;
    }
    function findMatchingConfig(service4, method, methodConfigs, matchLevel) {
      for (const config of methodConfigs) {
        if (hasMatchingName(service4, method, config, matchLevel)) {
          return config;
        }
      }
      return null;
    }
    function getDefaultConfigSelector(serviceConfig) {
      return function defaultConfigSelector(methodName, metadata) {
        var _a12, _b5;
        const splitName = methodName.split("/").filter((x2) => x2.length > 0);
        const service4 = (_a12 = splitName[0]) !== null && _a12 !== void 0 ? _a12 : "";
        const method = (_b5 = splitName[1]) !== null && _b5 !== void 0 ? _b5 : "";
        if (serviceConfig && serviceConfig.methodConfig) {
          for (const matchLevel of NAME_MATCH_LEVEL_ORDER) {
            const matchingConfig = findMatchingConfig(service4, method, serviceConfig.methodConfig, matchLevel);
            if (matchingConfig) {
              return {
                methodConfig: matchingConfig,
                pickInformation: {},
                status: constants_1.Status.OK,
                dynamicFilterFactories: []
              };
            }
          }
        }
        return {
          methodConfig: { name: [] },
          pickInformation: {},
          status: constants_1.Status.OK,
          dynamicFilterFactories: []
        };
      };
    }
    var ResolvingLoadBalancer = class {
      /**
       * Wrapper class that behaves like a `LoadBalancer` and also handles name
       * resolution internally.
       * @param target The address of the backend to connect to.
       * @param channelControlHelper `ChannelControlHelper` instance provided by
       *     this load balancer's owner.
       * @param defaultServiceConfig The default service configuration to be used
       *     if none is provided by the name resolver. A `null` value indicates
       *     that the default behavior should be the default unconfigured behavior.
       *     In practice, that means using the "pick first" load balancer
       *     implmentation
       */
      constructor(target, channelControlHelper, credentials, channelOptions, onSuccessfulResolution, onFailedResolution) {
        this.target = target;
        this.channelControlHelper = channelControlHelper;
        this.onSuccessfulResolution = onSuccessfulResolution;
        this.onFailedResolution = onFailedResolution;
        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;
        this.latestChildPicker = new picker_1.QueuePicker(this);
        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
        this.previousServiceConfig = null;
        this.continueResolving = false;
        if (channelOptions["grpc.service_config"]) {
          this.defaultServiceConfig = (0, service_config_1.validateServiceConfig)(JSON.parse(channelOptions["grpc.service_config"]));
        } else {
          this.defaultServiceConfig = {
            loadBalancingConfig: [],
            methodConfig: []
          };
        }
        this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
        this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({
          createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),
          requestReresolution: () => {
            if (this.backoffTimeout.isRunning()) {
              trace3("requestReresolution delayed by backoff timer until " + this.backoffTimeout.getEndTime().toISOString());
              this.continueResolving = true;
            } else {
              this.updateResolution();
            }
          },
          updateState: (newState, picker) => {
            this.latestChildState = newState;
            this.latestChildPicker = picker;
            this.updateState(newState, picker);
          },
          addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),
          removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper)
        }, credentials, channelOptions);
        this.innerResolver = (0, resolver_1.createResolver)(target, {
          onSuccessfulResolution: (endpointList, serviceConfig, serviceConfigError, configSelector, attributes) => {
            var _a12;
            this.backoffTimeout.stop();
            this.backoffTimeout.reset();
            let workingServiceConfig = null;
            if (serviceConfig === null) {
              if (serviceConfigError === null) {
                this.previousServiceConfig = null;
                workingServiceConfig = this.defaultServiceConfig;
              } else {
                if (this.previousServiceConfig === null) {
                  this.handleResolutionFailure(serviceConfigError);
                } else {
                  workingServiceConfig = this.previousServiceConfig;
                }
              }
            } else {
              workingServiceConfig = serviceConfig;
              this.previousServiceConfig = serviceConfig;
            }
            const workingConfigList = (_a12 = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a12 !== void 0 ? _a12 : [];
            const loadBalancingConfig = (0, load_balancer_1.selectLbConfigFromList)(workingConfigList, true);
            if (loadBalancingConfig === null) {
              this.handleResolutionFailure({
                code: constants_1.Status.UNAVAILABLE,
                details: "All load balancer options in service config are not compatible",
                metadata: new metadata_1.Metadata()
              });
              return;
            }
            this.childLoadBalancer.updateAddressList(endpointList, loadBalancingConfig, attributes);
            const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;
            this.onSuccessfulResolution(finalServiceConfig, configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));
          },
          onError: (error) => {
            this.handleResolutionFailure(error);
          }
        }, channelOptions);
        const backoffOptions = {
          initialDelay: channelOptions["grpc.initial_reconnect_backoff_ms"],
          maxDelay: channelOptions["grpc.max_reconnect_backoff_ms"]
        };
        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
          if (this.continueResolving) {
            this.updateResolution();
            this.continueResolving = false;
          } else {
            this.updateState(this.latestChildState, this.latestChildPicker);
          }
        }, backoffOptions);
        this.backoffTimeout.unref();
      }
      updateResolution() {
        this.innerResolver.updateResolution();
        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {
          this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, this.latestChildPicker);
        }
        this.backoffTimeout.runOnce();
      }
      updateState(connectivityState, picker) {
        trace3((0, uri_parser_1.uriToString)(this.target) + " " + connectivity_state_1.ConnectivityState[this.currentState] + " -> " + connectivity_state_1.ConnectivityState[connectivityState]);
        if (connectivityState === connectivity_state_1.ConnectivityState.IDLE) {
          picker = new picker_1.QueuePicker(this, picker);
        }
        this.currentState = connectivityState;
        this.channelControlHelper.updateState(connectivityState, picker);
      }
      handleResolutionFailure(error) {
        if (this.latestChildState === connectivity_state_1.ConnectivityState.IDLE) {
          this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));
          this.onFailedResolution(error);
        }
      }
      exitIdle() {
        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE || this.currentState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
          if (this.backoffTimeout.isRunning()) {
            this.continueResolving = true;
          } else {
            this.updateResolution();
          }
        }
        this.childLoadBalancer.exitIdle();
      }
      updateAddressList(endpointList, lbConfig) {
        throw new Error("updateAddressList not supported on ResolvingLoadBalancer");
      }
      resetBackoff() {
        this.backoffTimeout.reset();
        this.childLoadBalancer.resetBackoff();
      }
      destroy() {
        this.childLoadBalancer.destroy();
        this.innerResolver.destroy();
        this.backoffTimeout.reset();
        this.backoffTimeout.stop();
        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;
        this.latestChildPicker = new picker_1.QueuePicker(this);
        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
        this.previousServiceConfig = null;
        this.continueResolving = false;
      }
      getTypeName() {
        return "resolving_load_balancer";
      }
    };
    exports.ResolvingLoadBalancer = ResolvingLoadBalancer;
  }
});

// node_modules/@grpc/grpc-js/build/src/channel-options.js
var require_channel_options = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/channel-options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.channelOptionsEqual = exports.recognizedOptions = void 0;
    exports.recognizedOptions = {
      "grpc.ssl_target_name_override": true,
      "grpc.primary_user_agent": true,
      "grpc.secondary_user_agent": true,
      "grpc.default_authority": true,
      "grpc.keepalive_time_ms": true,
      "grpc.keepalive_timeout_ms": true,
      "grpc.keepalive_permit_without_calls": true,
      "grpc.service_config": true,
      "grpc.max_concurrent_streams": true,
      "grpc.initial_reconnect_backoff_ms": true,
      "grpc.max_reconnect_backoff_ms": true,
      "grpc.use_local_subchannel_pool": true,
      "grpc.max_send_message_length": true,
      "grpc.max_receive_message_length": true,
      "grpc.enable_http_proxy": true,
      "grpc.enable_channelz": true,
      "grpc.dns_min_time_between_resolutions_ms": true,
      "grpc.enable_retries": true,
      "grpc.per_rpc_retry_buffer_size": true,
      "grpc.retry_buffer_size": true,
      "grpc.max_connection_age_ms": true,
      "grpc.max_connection_age_grace_ms": true,
      "grpc-node.max_session_memory": true,
      "grpc.service_config_disable_resolution": true,
      "grpc.client_idle_timeout_ms": true,
      "grpc-node.tls_enable_trace": true,
      "grpc.lb.ring_hash.ring_size_cap": true,
      "grpc-node.retry_max_attempts_limit": true
    };
    function channelOptionsEqual(options1, options2) {
      const keys1 = Object.keys(options1).sort();
      const keys22 = Object.keys(options2).sort();
      if (keys1.length !== keys22.length) {
        return false;
      }
      for (let i2 = 0; i2 < keys1.length; i2 += 1) {
        if (keys1[i2] !== keys22[i2]) {
          return false;
        }
        if (options1[keys1[i2]] !== options2[keys22[i2]]) {
          return false;
        }
      }
      return true;
    }
    exports.channelOptionsEqual = channelOptionsEqual;
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel-address.js
var require_subchannel_address = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/subchannel-address.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EndpointMap = exports.endpointHasAddress = exports.endpointToString = exports.endpointEqual = exports.stringToSubchannelAddress = exports.subchannelAddressToString = exports.subchannelAddressEqual = exports.isTcpSubchannelAddress = void 0;
    var net_1 = __require("net");
    function isTcpSubchannelAddress(address) {
      return "port" in address;
    }
    exports.isTcpSubchannelAddress = isTcpSubchannelAddress;
    function subchannelAddressEqual(address1, address2) {
      if (!address1 && !address2) {
        return true;
      }
      if (!address1 || !address2) {
        return false;
      }
      if (isTcpSubchannelAddress(address1)) {
        return isTcpSubchannelAddress(address2) && address1.host === address2.host && address1.port === address2.port;
      } else {
        return !isTcpSubchannelAddress(address2) && address1.path === address2.path;
      }
    }
    exports.subchannelAddressEqual = subchannelAddressEqual;
    function subchannelAddressToString(address) {
      if (isTcpSubchannelAddress(address)) {
        if ((0, net_1.isIPv6)(address.host)) {
          return "[" + address.host + "]:" + address.port;
        } else {
          return address.host + ":" + address.port;
        }
      } else {
        return address.path;
      }
    }
    exports.subchannelAddressToString = subchannelAddressToString;
    var DEFAULT_PORT = 443;
    function stringToSubchannelAddress(addressString, port) {
      if ((0, net_1.isIP)(addressString)) {
        return {
          host: addressString,
          port: port !== null && port !== void 0 ? port : DEFAULT_PORT
        };
      } else {
        return {
          path: addressString
        };
      }
    }
    exports.stringToSubchannelAddress = stringToSubchannelAddress;
    function endpointEqual(endpoint1, endpoint2) {
      if (endpoint1.addresses.length !== endpoint2.addresses.length) {
        return false;
      }
      for (let i2 = 0; i2 < endpoint1.addresses.length; i2++) {
        if (!subchannelAddressEqual(endpoint1.addresses[i2], endpoint2.addresses[i2])) {
          return false;
        }
      }
      return true;
    }
    exports.endpointEqual = endpointEqual;
    function endpointToString(endpoint) {
      return "[" + endpoint.addresses.map(subchannelAddressToString).join(", ") + "]";
    }
    exports.endpointToString = endpointToString;
    function endpointHasAddress(endpoint, expectedAddress) {
      for (const address of endpoint.addresses) {
        if (subchannelAddressEqual(address, expectedAddress)) {
          return true;
        }
      }
      return false;
    }
    exports.endpointHasAddress = endpointHasAddress;
    function endpointEqualUnordered(endpoint1, endpoint2) {
      if (endpoint1.addresses.length !== endpoint2.addresses.length) {
        return false;
      }
      for (const address1 of endpoint1.addresses) {
        let matchFound = false;
        for (const address2 of endpoint2.addresses) {
          if (subchannelAddressEqual(address1, address2)) {
            matchFound = true;
            break;
          }
        }
        if (!matchFound) {
          return false;
        }
      }
      return true;
    }
    var EndpointMap = class {
      constructor() {
        this.map = /* @__PURE__ */ new Set();
      }
      get size() {
        return this.map.size;
      }
      getForSubchannelAddress(address) {
        for (const entry of this.map) {
          if (endpointHasAddress(entry.key, address)) {
            return entry.value;
          }
        }
        return void 0;
      }
      /**
       * Delete any entries in this map with keys that are not in endpoints
       * @param endpoints
       */
      deleteMissing(endpoints) {
        const removedValues = [];
        for (const entry of this.map) {
          let foundEntry = false;
          for (const endpoint of endpoints) {
            if (endpointEqualUnordered(endpoint, entry.key)) {
              foundEntry = true;
            }
          }
          if (!foundEntry) {
            removedValues.push(entry.value);
            this.map.delete(entry);
          }
        }
        return removedValues;
      }
      get(endpoint) {
        for (const entry of this.map) {
          if (endpointEqualUnordered(endpoint, entry.key)) {
            return entry.value;
          }
        }
        return void 0;
      }
      set(endpoint, mapEntry) {
        for (const entry of this.map) {
          if (endpointEqualUnordered(endpoint, entry.key)) {
            entry.value = mapEntry;
            return;
          }
        }
        this.map.add({ key: endpoint, value: mapEntry });
      }
      delete(endpoint) {
        for (const entry of this.map) {
          if (endpointEqualUnordered(endpoint, entry.key)) {
            this.map.delete(entry);
            return;
          }
        }
      }
      has(endpoint) {
        for (const entry of this.map) {
          if (endpointEqualUnordered(endpoint, entry.key)) {
            return true;
          }
        }
        return false;
      }
      clear() {
        this.map.clear();
      }
      *keys() {
        for (const entry of this.map) {
          yield entry.key;
        }
      }
      *values() {
        for (const entry of this.map) {
          yield entry.value;
        }
      }
      *entries() {
        for (const entry of this.map) {
          yield [entry.key, entry.value];
        }
      }
    };
    exports.EndpointMap = EndpointMap;
  }
});

// node_modules/@js-sdsl/ordered-map/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@js-sdsl/ordered-map/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "t", {
      value: true
    });
    var TreeNode = class {
      constructor(t2, e2, s2 = 1) {
        this.i = void 0;
        this.h = void 0;
        this.o = void 0;
        this.u = t2;
        this.l = e2;
        this.p = s2;
      }
      I() {
        let t2 = this;
        const e2 = t2.o.o === t2;
        if (e2 && t2.p === 1) {
          t2 = t2.h;
        } else if (t2.i) {
          t2 = t2.i;
          while (t2.h) {
            t2 = t2.h;
          }
        } else {
          if (e2) {
            return t2.o;
          }
          let s2 = t2.o;
          while (s2.i === t2) {
            t2 = s2;
            s2 = t2.o;
          }
          t2 = s2;
        }
        return t2;
      }
      B() {
        let t2 = this;
        if (t2.h) {
          t2 = t2.h;
          while (t2.i) {
            t2 = t2.i;
          }
          return t2;
        } else {
          let e2 = t2.o;
          while (e2.h === t2) {
            t2 = e2;
            e2 = t2.o;
          }
          if (t2.h !== e2) {
            return e2;
          } else
            return t2;
        }
      }
      _() {
        const t2 = this.o;
        const e2 = this.h;
        const s2 = e2.i;
        if (t2.o === this)
          t2.o = e2;
        else if (t2.i === this)
          t2.i = e2;
        else
          t2.h = e2;
        e2.o = t2;
        e2.i = this;
        this.o = e2;
        this.h = s2;
        if (s2)
          s2.o = this;
        return e2;
      }
      g() {
        const t2 = this.o;
        const e2 = this.i;
        const s2 = e2.h;
        if (t2.o === this)
          t2.o = e2;
        else if (t2.i === this)
          t2.i = e2;
        else
          t2.h = e2;
        e2.o = t2;
        e2.h = this;
        this.o = e2;
        this.i = s2;
        if (s2)
          s2.o = this;
        return e2;
      }
    };
    var TreeNodeEnableIndex = class extends TreeNode {
      constructor() {
        super(...arguments);
        this.M = 1;
      }
      _() {
        const t2 = super._();
        this.O();
        t2.O();
        return t2;
      }
      g() {
        const t2 = super.g();
        this.O();
        t2.O();
        return t2;
      }
      O() {
        this.M = 1;
        if (this.i) {
          this.M += this.i.M;
        }
        if (this.h) {
          this.M += this.h.M;
        }
      }
    };
    var ContainerIterator = class {
      constructor(t2 = 0) {
        this.iteratorType = t2;
      }
      equals(t2) {
        return this.T === t2.T;
      }
    };
    var Base3 = class {
      constructor() {
        this.m = 0;
      }
      get length() {
        return this.m;
      }
      size() {
        return this.m;
      }
      empty() {
        return this.m === 0;
      }
    };
    var Container = class extends Base3 {
    };
    function throwIteratorAccessError() {
      throw new RangeError("Iterator access denied!");
    }
    var TreeContainer = class extends Container {
      constructor(t2 = function(t3, e3) {
        if (t3 < e3)
          return -1;
        if (t3 > e3)
          return 1;
        return 0;
      }, e2 = false) {
        super();
        this.v = void 0;
        this.A = t2;
        this.enableIndex = e2;
        this.N = e2 ? TreeNodeEnableIndex : TreeNode;
        this.C = new this.N();
      }
      R(t2, e2) {
        let s2 = this.C;
        while (t2) {
          const i2 = this.A(t2.u, e2);
          if (i2 < 0) {
            t2 = t2.h;
          } else if (i2 > 0) {
            s2 = t2;
            t2 = t2.i;
          } else
            return t2;
        }
        return s2;
      }
      K(t2, e2) {
        let s2 = this.C;
        while (t2) {
          const i2 = this.A(t2.u, e2);
          if (i2 <= 0) {
            t2 = t2.h;
          } else {
            s2 = t2;
            t2 = t2.i;
          }
        }
        return s2;
      }
      L(t2, e2) {
        let s2 = this.C;
        while (t2) {
          const i2 = this.A(t2.u, e2);
          if (i2 < 0) {
            s2 = t2;
            t2 = t2.h;
          } else if (i2 > 0) {
            t2 = t2.i;
          } else
            return t2;
        }
        return s2;
      }
      k(t2, e2) {
        let s2 = this.C;
        while (t2) {
          const i2 = this.A(t2.u, e2);
          if (i2 < 0) {
            s2 = t2;
            t2 = t2.h;
          } else {
            t2 = t2.i;
          }
        }
        return s2;
      }
      P(t2) {
        while (true) {
          const e2 = t2.o;
          if (e2 === this.C)
            return;
          if (t2.p === 1) {
            t2.p = 0;
            return;
          }
          if (t2 === e2.i) {
            const s2 = e2.h;
            if (s2.p === 1) {
              s2.p = 0;
              e2.p = 1;
              if (e2 === this.v) {
                this.v = e2._();
              } else
                e2._();
            } else {
              if (s2.h && s2.h.p === 1) {
                s2.p = e2.p;
                e2.p = 0;
                s2.h.p = 0;
                if (e2 === this.v) {
                  this.v = e2._();
                } else
                  e2._();
                return;
              } else if (s2.i && s2.i.p === 1) {
                s2.p = 1;
                s2.i.p = 0;
                s2.g();
              } else {
                s2.p = 1;
                t2 = e2;
              }
            }
          } else {
            const s2 = e2.i;
            if (s2.p === 1) {
              s2.p = 0;
              e2.p = 1;
              if (e2 === this.v) {
                this.v = e2.g();
              } else
                e2.g();
            } else {
              if (s2.i && s2.i.p === 1) {
                s2.p = e2.p;
                e2.p = 0;
                s2.i.p = 0;
                if (e2 === this.v) {
                  this.v = e2.g();
                } else
                  e2.g();
                return;
              } else if (s2.h && s2.h.p === 1) {
                s2.p = 1;
                s2.h.p = 0;
                s2._();
              } else {
                s2.p = 1;
                t2 = e2;
              }
            }
          }
        }
      }
      S(t2) {
        if (this.m === 1) {
          this.clear();
          return;
        }
        let e2 = t2;
        while (e2.i || e2.h) {
          if (e2.h) {
            e2 = e2.h;
            while (e2.i)
              e2 = e2.i;
          } else {
            e2 = e2.i;
          }
          const s3 = t2.u;
          t2.u = e2.u;
          e2.u = s3;
          const i2 = t2.l;
          t2.l = e2.l;
          e2.l = i2;
          t2 = e2;
        }
        if (this.C.i === e2) {
          this.C.i = e2.o;
        } else if (this.C.h === e2) {
          this.C.h = e2.o;
        }
        this.P(e2);
        let s2 = e2.o;
        if (e2 === s2.i) {
          s2.i = void 0;
        } else
          s2.h = void 0;
        this.m -= 1;
        this.v.p = 0;
        if (this.enableIndex) {
          while (s2 !== this.C) {
            s2.M -= 1;
            s2 = s2.o;
          }
        }
      }
      U(t2) {
        const e2 = typeof t2 === "number" ? t2 : void 0;
        const s2 = typeof t2 === "function" ? t2 : void 0;
        const i2 = typeof t2 === "undefined" ? [] : void 0;
        let r2 = 0;
        let n2 = this.v;
        const h2 = [];
        while (h2.length || n2) {
          if (n2) {
            h2.push(n2);
            n2 = n2.i;
          } else {
            n2 = h2.pop();
            if (r2 === e2)
              return n2;
            i2 && i2.push(n2);
            s2 && s2(n2, r2, this);
            r2 += 1;
            n2 = n2.h;
          }
        }
        return i2;
      }
      j(t2) {
        while (true) {
          const e2 = t2.o;
          if (e2.p === 0)
            return;
          const s2 = e2.o;
          if (e2 === s2.i) {
            const i2 = s2.h;
            if (i2 && i2.p === 1) {
              i2.p = e2.p = 0;
              if (s2 === this.v)
                return;
              s2.p = 1;
              t2 = s2;
              continue;
            } else if (t2 === e2.h) {
              t2.p = 0;
              if (t2.i) {
                t2.i.o = e2;
              }
              if (t2.h) {
                t2.h.o = s2;
              }
              e2.h = t2.i;
              s2.i = t2.h;
              t2.i = e2;
              t2.h = s2;
              if (s2 === this.v) {
                this.v = t2;
                this.C.o = t2;
              } else {
                const e3 = s2.o;
                if (e3.i === s2) {
                  e3.i = t2;
                } else
                  e3.h = t2;
              }
              t2.o = s2.o;
              e2.o = t2;
              s2.o = t2;
              s2.p = 1;
            } else {
              e2.p = 0;
              if (s2 === this.v) {
                this.v = s2.g();
              } else
                s2.g();
              s2.p = 1;
              return;
            }
          } else {
            const i2 = s2.i;
            if (i2 && i2.p === 1) {
              i2.p = e2.p = 0;
              if (s2 === this.v)
                return;
              s2.p = 1;
              t2 = s2;
              continue;
            } else if (t2 === e2.i) {
              t2.p = 0;
              if (t2.i) {
                t2.i.o = s2;
              }
              if (t2.h) {
                t2.h.o = e2;
              }
              s2.h = t2.i;
              e2.i = t2.h;
              t2.i = s2;
              t2.h = e2;
              if (s2 === this.v) {
                this.v = t2;
                this.C.o = t2;
              } else {
                const e3 = s2.o;
                if (e3.i === s2) {
                  e3.i = t2;
                } else
                  e3.h = t2;
              }
              t2.o = s2.o;
              e2.o = t2;
              s2.o = t2;
              s2.p = 1;
            } else {
              e2.p = 0;
              if (s2 === this.v) {
                this.v = s2._();
              } else
                s2._();
              s2.p = 1;
              return;
            }
          }
          if (this.enableIndex) {
            e2.O();
            s2.O();
            t2.O();
          }
          return;
        }
      }
      q(t2, e2, s2) {
        if (this.v === void 0) {
          this.m += 1;
          this.v = new this.N(t2, e2, 0);
          this.v.o = this.C;
          this.C.o = this.C.i = this.C.h = this.v;
          return this.m;
        }
        let i2;
        const r2 = this.C.i;
        const n2 = this.A(r2.u, t2);
        if (n2 === 0) {
          r2.l = e2;
          return this.m;
        } else if (n2 > 0) {
          r2.i = new this.N(t2, e2);
          r2.i.o = r2;
          i2 = r2.i;
          this.C.i = i2;
        } else {
          const r3 = this.C.h;
          const n3 = this.A(r3.u, t2);
          if (n3 === 0) {
            r3.l = e2;
            return this.m;
          } else if (n3 < 0) {
            r3.h = new this.N(t2, e2);
            r3.h.o = r3;
            i2 = r3.h;
            this.C.h = i2;
          } else {
            if (s2 !== void 0) {
              const r4 = s2.T;
              if (r4 !== this.C) {
                const s3 = this.A(r4.u, t2);
                if (s3 === 0) {
                  r4.l = e2;
                  return this.m;
                } else if (s3 > 0) {
                  const s4 = r4.I();
                  const n4 = this.A(s4.u, t2);
                  if (n4 === 0) {
                    s4.l = e2;
                    return this.m;
                  } else if (n4 < 0) {
                    i2 = new this.N(t2, e2);
                    if (s4.h === void 0) {
                      s4.h = i2;
                      i2.o = s4;
                    } else {
                      r4.i = i2;
                      i2.o = r4;
                    }
                  }
                }
              }
            }
            if (i2 === void 0) {
              i2 = this.v;
              while (true) {
                const s3 = this.A(i2.u, t2);
                if (s3 > 0) {
                  if (i2.i === void 0) {
                    i2.i = new this.N(t2, e2);
                    i2.i.o = i2;
                    i2 = i2.i;
                    break;
                  }
                  i2 = i2.i;
                } else if (s3 < 0) {
                  if (i2.h === void 0) {
                    i2.h = new this.N(t2, e2);
                    i2.h.o = i2;
                    i2 = i2.h;
                    break;
                  }
                  i2 = i2.h;
                } else {
                  i2.l = e2;
                  return this.m;
                }
              }
            }
          }
        }
        if (this.enableIndex) {
          let t3 = i2.o;
          while (t3 !== this.C) {
            t3.M += 1;
            t3 = t3.o;
          }
        }
        this.j(i2);
        this.m += 1;
        return this.m;
      }
      H(t2, e2) {
        while (t2) {
          const s2 = this.A(t2.u, e2);
          if (s2 < 0) {
            t2 = t2.h;
          } else if (s2 > 0) {
            t2 = t2.i;
          } else
            return t2;
        }
        return t2 || this.C;
      }
      clear() {
        this.m = 0;
        this.v = void 0;
        this.C.o = void 0;
        this.C.i = this.C.h = void 0;
      }
      updateKeyByIterator(t2, e2) {
        const s2 = t2.T;
        if (s2 === this.C) {
          throwIteratorAccessError();
        }
        if (this.m === 1) {
          s2.u = e2;
          return true;
        }
        const i2 = s2.B().u;
        if (s2 === this.C.i) {
          if (this.A(i2, e2) > 0) {
            s2.u = e2;
            return true;
          }
          return false;
        }
        const r2 = s2.I().u;
        if (s2 === this.C.h) {
          if (this.A(r2, e2) < 0) {
            s2.u = e2;
            return true;
          }
          return false;
        }
        if (this.A(r2, e2) >= 0 || this.A(i2, e2) <= 0)
          return false;
        s2.u = e2;
        return true;
      }
      eraseElementByPos(t2) {
        if (t2 < 0 || t2 > this.m - 1) {
          throw new RangeError();
        }
        const e2 = this.U(t2);
        this.S(e2);
        return this.m;
      }
      eraseElementByKey(t2) {
        if (this.m === 0)
          return false;
        const e2 = this.H(this.v, t2);
        if (e2 === this.C)
          return false;
        this.S(e2);
        return true;
      }
      eraseElementByIterator(t2) {
        const e2 = t2.T;
        if (e2 === this.C) {
          throwIteratorAccessError();
        }
        const s2 = e2.h === void 0;
        const i2 = t2.iteratorType === 0;
        if (i2) {
          if (s2)
            t2.next();
        } else {
          if (!s2 || e2.i === void 0)
            t2.next();
        }
        this.S(e2);
        return t2;
      }
      getHeight() {
        if (this.m === 0)
          return 0;
        function traversal(t2) {
          if (!t2)
            return 0;
          return Math.max(traversal(t2.i), traversal(t2.h)) + 1;
        }
        return traversal(this.v);
      }
    };
    var TreeIterator = class extends ContainerIterator {
      constructor(t2, e2, s2) {
        super(s2);
        this.T = t2;
        this.C = e2;
        if (this.iteratorType === 0) {
          this.pre = function() {
            if (this.T === this.C.i) {
              throwIteratorAccessError();
            }
            this.T = this.T.I();
            return this;
          };
          this.next = function() {
            if (this.T === this.C) {
              throwIteratorAccessError();
            }
            this.T = this.T.B();
            return this;
          };
        } else {
          this.pre = function() {
            if (this.T === this.C.h) {
              throwIteratorAccessError();
            }
            this.T = this.T.B();
            return this;
          };
          this.next = function() {
            if (this.T === this.C) {
              throwIteratorAccessError();
            }
            this.T = this.T.I();
            return this;
          };
        }
      }
      get index() {
        let t2 = this.T;
        const e2 = this.C.o;
        if (t2 === this.C) {
          if (e2) {
            return e2.M - 1;
          }
          return 0;
        }
        let s2 = 0;
        if (t2.i) {
          s2 += t2.i.M;
        }
        while (t2 !== e2) {
          const e3 = t2.o;
          if (t2 === e3.h) {
            s2 += 1;
            if (e3.i) {
              s2 += e3.i.M;
            }
          }
          t2 = e3;
        }
        return s2;
      }
      isAccessible() {
        return this.T !== this.C;
      }
    };
    var OrderedMapIterator = class _OrderedMapIterator extends TreeIterator {
      constructor(t2, e2, s2, i2) {
        super(t2, e2, i2);
        this.container = s2;
      }
      get pointer() {
        if (this.T === this.C) {
          throwIteratorAccessError();
        }
        const t2 = this;
        return new Proxy([], {
          get(e2, s2) {
            if (s2 === "0")
              return t2.T.u;
            else if (s2 === "1")
              return t2.T.l;
            e2[0] = t2.T.u;
            e2[1] = t2.T.l;
            return e2[s2];
          },
          set(e2, s2, i2) {
            if (s2 !== "1") {
              throw new TypeError("prop must be 1");
            }
            t2.T.l = i2;
            return true;
          }
        });
      }
      copy() {
        return new _OrderedMapIterator(this.T, this.C, this.container, this.iteratorType);
      }
    };
    var OrderedMap = class extends TreeContainer {
      constructor(t2 = [], e2, s2) {
        super(e2, s2);
        const i2 = this;
        t2.forEach(function(t3) {
          i2.setElement(t3[0], t3[1]);
        });
      }
      begin() {
        return new OrderedMapIterator(this.C.i || this.C, this.C, this);
      }
      end() {
        return new OrderedMapIterator(this.C, this.C, this);
      }
      rBegin() {
        return new OrderedMapIterator(this.C.h || this.C, this.C, this, 1);
      }
      rEnd() {
        return new OrderedMapIterator(this.C, this.C, this, 1);
      }
      front() {
        if (this.m === 0)
          return;
        const t2 = this.C.i;
        return [t2.u, t2.l];
      }
      back() {
        if (this.m === 0)
          return;
        const t2 = this.C.h;
        return [t2.u, t2.l];
      }
      lowerBound(t2) {
        const e2 = this.R(this.v, t2);
        return new OrderedMapIterator(e2, this.C, this);
      }
      upperBound(t2) {
        const e2 = this.K(this.v, t2);
        return new OrderedMapIterator(e2, this.C, this);
      }
      reverseLowerBound(t2) {
        const e2 = this.L(this.v, t2);
        return new OrderedMapIterator(e2, this.C, this);
      }
      reverseUpperBound(t2) {
        const e2 = this.k(this.v, t2);
        return new OrderedMapIterator(e2, this.C, this);
      }
      forEach(t2) {
        this.U(function(e2, s2, i2) {
          t2([e2.u, e2.l], s2, i2);
        });
      }
      setElement(t2, e2, s2) {
        return this.q(t2, e2, s2);
      }
      getElementByPos(t2) {
        if (t2 < 0 || t2 > this.m - 1) {
          throw new RangeError();
        }
        const e2 = this.U(t2);
        return [e2.u, e2.l];
      }
      find(t2) {
        const e2 = this.H(this.v, t2);
        return new OrderedMapIterator(e2, this.C, this);
      }
      getElementByKey(t2) {
        const e2 = this.H(this.v, t2);
        return e2.l;
      }
      union(t2) {
        const e2 = this;
        t2.forEach(function(t3) {
          e2.setElement(t3[0], t3[1]);
        });
        return this.m;
      }
      *[Symbol.iterator]() {
        const t2 = this.m;
        const e2 = this.U();
        for (let s2 = 0; s2 < t2; ++s2) {
          const t3 = e2[s2];
          yield [t3.u, t3.l];
        }
      }
    };
    exports.OrderedMap = OrderedMap;
  }
});

// node_modules/@grpc/grpc-js/build/src/admin.js
var require_admin = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/admin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addAdminServicesToServer = exports.registerAdminService = void 0;
    var registeredAdminServices = [];
    function registerAdminService(getServiceDefinition, getHandlers) {
      registeredAdminServices.push({ getServiceDefinition, getHandlers });
    }
    exports.registerAdminService = registerAdminService;
    function addAdminServicesToServer(server) {
      for (const { getServiceDefinition, getHandlers } of registeredAdminServices) {
        server.addService(getServiceDefinition(), getHandlers());
      }
    }
    exports.addAdminServicesToServer = addAdminServicesToServer;
  }
});

// node_modules/@grpc/grpc-js/build/src/call.js
var require_call = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/call.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClientDuplexStreamImpl = exports.ClientWritableStreamImpl = exports.ClientReadableStreamImpl = exports.ClientUnaryCallImpl = exports.callErrorFromStatus = void 0;
    var events_1 = __require("events");
    var stream_1 = __require("stream");
    var constants_1 = require_constants5();
    function callErrorFromStatus(status, callerStack) {
      const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;
      const error = new Error(message);
      const stack = `${error.stack}
for call at
${callerStack}`;
      return Object.assign(new Error(message), status, { stack });
    }
    exports.callErrorFromStatus = callErrorFromStatus;
    var ClientUnaryCallImpl = class extends events_1.EventEmitter {
      constructor() {
        super();
      }
      cancel() {
        var _a12;
        (_a12 = this.call) === null || _a12 === void 0 ? void 0 : _a12.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
      }
      getPeer() {
        var _a12, _b5;
        return (_b5 = (_a12 = this.call) === null || _a12 === void 0 ? void 0 : _a12.getPeer()) !== null && _b5 !== void 0 ? _b5 : "unknown";
      }
    };
    exports.ClientUnaryCallImpl = ClientUnaryCallImpl;
    var ClientReadableStreamImpl = class extends stream_1.Readable {
      constructor(deserialize) {
        super({ objectMode: true });
        this.deserialize = deserialize;
      }
      cancel() {
        var _a12;
        (_a12 = this.call) === null || _a12 === void 0 ? void 0 : _a12.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
      }
      getPeer() {
        var _a12, _b5;
        return (_b5 = (_a12 = this.call) === null || _a12 === void 0 ? void 0 : _a12.getPeer()) !== null && _b5 !== void 0 ? _b5 : "unknown";
      }
      _read(_size) {
        var _a12;
        (_a12 = this.call) === null || _a12 === void 0 ? void 0 : _a12.startRead();
      }
    };
    exports.ClientReadableStreamImpl = ClientReadableStreamImpl;
    var ClientWritableStreamImpl = class extends stream_1.Writable {
      constructor(serialize) {
        super({ objectMode: true });
        this.serialize = serialize;
      }
      cancel() {
        var _a12;
        (_a12 = this.call) === null || _a12 === void 0 ? void 0 : _a12.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
      }
      getPeer() {
        var _a12, _b5;
        return (_b5 = (_a12 = this.call) === null || _a12 === void 0 ? void 0 : _a12.getPeer()) !== null && _b5 !== void 0 ? _b5 : "unknown";
      }
      _write(chunk2, encoding, cb) {
        var _a12;
        const context3 = {
          callback: cb
        };
        const flags = Number(encoding);
        if (!Number.isNaN(flags)) {
          context3.flags = flags;
        }
        (_a12 = this.call) === null || _a12 === void 0 ? void 0 : _a12.sendMessageWithContext(context3, chunk2);
      }
      _final(cb) {
        var _a12;
        (_a12 = this.call) === null || _a12 === void 0 ? void 0 : _a12.halfClose();
        cb();
      }
    };
    exports.ClientWritableStreamImpl = ClientWritableStreamImpl;
    var ClientDuplexStreamImpl = class extends stream_1.Duplex {
      constructor(serialize, deserialize) {
        super({ objectMode: true });
        this.serialize = serialize;
        this.deserialize = deserialize;
      }
      cancel() {
        var _a12;
        (_a12 = this.call) === null || _a12 === void 0 ? void 0 : _a12.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
      }
      getPeer() {
        var _a12, _b5;
        return (_b5 = (_a12 = this.call) === null || _a12 === void 0 ? void 0 : _a12.getPeer()) !== null && _b5 !== void 0 ? _b5 : "unknown";
      }
      _read(_size) {
        var _a12;
        (_a12 = this.call) === null || _a12 === void 0 ? void 0 : _a12.startRead();
      }
      _write(chunk2, encoding, cb) {
        var _a12;
        const context3 = {
          callback: cb
        };
        const flags = Number(encoding);
        if (!Number.isNaN(flags)) {
          context3.flags = flags;
        }
        (_a12 = this.call) === null || _a12 === void 0 ? void 0 : _a12.sendMessageWithContext(context3, chunk2);
      }
      _final(cb) {
        var _a12;
        (_a12 = this.call) === null || _a12 === void 0 ? void 0 : _a12.halfClose();
        cb();
      }
    };
    exports.ClientDuplexStreamImpl = ClientDuplexStreamImpl;
  }
});

// node_modules/@grpc/grpc-js/build/src/call-interface.js
var require_call_interface = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/call-interface.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InterceptingListenerImpl = exports.isInterceptingListener = void 0;
    function isInterceptingListener(listener) {
      return listener.onReceiveMetadata !== void 0 && listener.onReceiveMetadata.length === 1;
    }
    exports.isInterceptingListener = isInterceptingListener;
    var InterceptingListenerImpl = class {
      constructor(listener, nextListener) {
        this.listener = listener;
        this.nextListener = nextListener;
        this.processingMetadata = false;
        this.hasPendingMessage = false;
        this.processingMessage = false;
        this.pendingStatus = null;
      }
      processPendingMessage() {
        if (this.hasPendingMessage) {
          this.nextListener.onReceiveMessage(this.pendingMessage);
          this.pendingMessage = null;
          this.hasPendingMessage = false;
        }
      }
      processPendingStatus() {
        if (this.pendingStatus) {
          this.nextListener.onReceiveStatus(this.pendingStatus);
        }
      }
      onReceiveMetadata(metadata) {
        this.processingMetadata = true;
        this.listener.onReceiveMetadata(metadata, (metadata2) => {
          this.processingMetadata = false;
          this.nextListener.onReceiveMetadata(metadata2);
          this.processPendingMessage();
          this.processPendingStatus();
        });
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      onReceiveMessage(message) {
        this.processingMessage = true;
        this.listener.onReceiveMessage(message, (msg) => {
          this.processingMessage = false;
          if (this.processingMetadata) {
            this.pendingMessage = msg;
            this.hasPendingMessage = true;
          } else {
            this.nextListener.onReceiveMessage(msg);
            this.processPendingStatus();
          }
        });
      }
      onReceiveStatus(status) {
        this.listener.onReceiveStatus(status, (processedStatus) => {
          if (this.processingMetadata || this.processingMessage) {
            this.pendingStatus = processedStatus;
          } else {
            this.nextListener.onReceiveStatus(processedStatus);
          }
        });
      }
    };
    exports.InterceptingListenerImpl = InterceptingListenerImpl;
  }
});

// node_modules/@grpc/grpc-js/build/src/client-interceptors.js
var require_client_interceptors = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/client-interceptors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getInterceptingCall = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.InterceptorConfigurationError = void 0;
    var metadata_1 = require_metadata();
    var call_interface_1 = require_call_interface();
    var constants_1 = require_constants5();
    var error_1 = require_error();
    var InterceptorConfigurationError = class _InterceptorConfigurationError extends Error {
      constructor(message) {
        super(message);
        this.name = "InterceptorConfigurationError";
        Error.captureStackTrace(this, _InterceptorConfigurationError);
      }
    };
    exports.InterceptorConfigurationError = InterceptorConfigurationError;
    var ListenerBuilder = class {
      constructor() {
        this.metadata = void 0;
        this.message = void 0;
        this.status = void 0;
      }
      withOnReceiveMetadata(onReceiveMetadata) {
        this.metadata = onReceiveMetadata;
        return this;
      }
      withOnReceiveMessage(onReceiveMessage) {
        this.message = onReceiveMessage;
        return this;
      }
      withOnReceiveStatus(onReceiveStatus) {
        this.status = onReceiveStatus;
        return this;
      }
      build() {
        return {
          onReceiveMetadata: this.metadata,
          onReceiveMessage: this.message,
          onReceiveStatus: this.status
        };
      }
    };
    exports.ListenerBuilder = ListenerBuilder;
    var RequesterBuilder = class {
      constructor() {
        this.start = void 0;
        this.message = void 0;
        this.halfClose = void 0;
        this.cancel = void 0;
      }
      withStart(start) {
        this.start = start;
        return this;
      }
      withSendMessage(sendMessage) {
        this.message = sendMessage;
        return this;
      }
      withHalfClose(halfClose) {
        this.halfClose = halfClose;
        return this;
      }
      withCancel(cancel) {
        this.cancel = cancel;
        return this;
      }
      build() {
        return {
          start: this.start,
          sendMessage: this.message,
          halfClose: this.halfClose,
          cancel: this.cancel
        };
      }
    };
    exports.RequesterBuilder = RequesterBuilder;
    var defaultListener = {
      onReceiveMetadata: (metadata, next2) => {
        next2(metadata);
      },
      onReceiveMessage: (message, next2) => {
        next2(message);
      },
      onReceiveStatus: (status, next2) => {
        next2(status);
      }
    };
    var defaultRequester = {
      start: (metadata, listener, next2) => {
        next2(metadata, listener);
      },
      sendMessage: (message, next2) => {
        next2(message);
      },
      halfClose: (next2) => {
        next2();
      },
      cancel: (next2) => {
        next2();
      }
    };
    var InterceptingCall = class {
      constructor(nextCall, requester) {
        var _a12, _b5, _c4, _d4;
        this.nextCall = nextCall;
        this.processingMetadata = false;
        this.pendingMessageContext = null;
        this.processingMessage = false;
        this.pendingHalfClose = false;
        if (requester) {
          this.requester = {
            start: (_a12 = requester.start) !== null && _a12 !== void 0 ? _a12 : defaultRequester.start,
            sendMessage: (_b5 = requester.sendMessage) !== null && _b5 !== void 0 ? _b5 : defaultRequester.sendMessage,
            halfClose: (_c4 = requester.halfClose) !== null && _c4 !== void 0 ? _c4 : defaultRequester.halfClose,
            cancel: (_d4 = requester.cancel) !== null && _d4 !== void 0 ? _d4 : defaultRequester.cancel
          };
        } else {
          this.requester = defaultRequester;
        }
      }
      cancelWithStatus(status, details) {
        this.requester.cancel(() => {
          this.nextCall.cancelWithStatus(status, details);
        });
      }
      getPeer() {
        return this.nextCall.getPeer();
      }
      processPendingMessage() {
        if (this.pendingMessageContext) {
          this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);
          this.pendingMessageContext = null;
          this.pendingMessage = null;
        }
      }
      processPendingHalfClose() {
        if (this.pendingHalfClose) {
          this.nextCall.halfClose();
        }
      }
      start(metadata, interceptingListener) {
        var _a12, _b5, _c4, _d4, _e4, _f3;
        const fullInterceptingListener = {
          onReceiveMetadata: (_b5 = (_a12 = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a12 === void 0 ? void 0 : _a12.bind(interceptingListener)) !== null && _b5 !== void 0 ? _b5 : (metadata2) => {
          },
          onReceiveMessage: (_d4 = (_c4 = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c4 === void 0 ? void 0 : _c4.bind(interceptingListener)) !== null && _d4 !== void 0 ? _d4 : (message) => {
          },
          onReceiveStatus: (_f3 = (_e4 = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e4 === void 0 ? void 0 : _e4.bind(interceptingListener)) !== null && _f3 !== void 0 ? _f3 : (status) => {
          }
        };
        this.processingMetadata = true;
        this.requester.start(metadata, fullInterceptingListener, (md, listener) => {
          var _a13, _b6, _c5;
          this.processingMetadata = false;
          let finalInterceptingListener;
          if ((0, call_interface_1.isInterceptingListener)(listener)) {
            finalInterceptingListener = listener;
          } else {
            const fullListener = {
              onReceiveMetadata: (_a13 = listener.onReceiveMetadata) !== null && _a13 !== void 0 ? _a13 : defaultListener.onReceiveMetadata,
              onReceiveMessage: (_b6 = listener.onReceiveMessage) !== null && _b6 !== void 0 ? _b6 : defaultListener.onReceiveMessage,
              onReceiveStatus: (_c5 = listener.onReceiveStatus) !== null && _c5 !== void 0 ? _c5 : defaultListener.onReceiveStatus
            };
            finalInterceptingListener = new call_interface_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);
          }
          this.nextCall.start(md, finalInterceptingListener);
          this.processPendingMessage();
          this.processPendingHalfClose();
        });
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      sendMessageWithContext(context3, message) {
        this.processingMessage = true;
        this.requester.sendMessage(message, (finalMessage) => {
          this.processingMessage = false;
          if (this.processingMetadata) {
            this.pendingMessageContext = context3;
            this.pendingMessage = message;
          } else {
            this.nextCall.sendMessageWithContext(context3, finalMessage);
            this.processPendingHalfClose();
          }
        });
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      sendMessage(message) {
        this.sendMessageWithContext({}, message);
      }
      startRead() {
        this.nextCall.startRead();
      }
      halfClose() {
        this.requester.halfClose(() => {
          if (this.processingMetadata || this.processingMessage) {
            this.pendingHalfClose = true;
          } else {
            this.nextCall.halfClose();
          }
        });
      }
    };
    exports.InterceptingCall = InterceptingCall;
    function getCall(channel, path9, options) {
      var _a12, _b5;
      const deadline = (_a12 = options.deadline) !== null && _a12 !== void 0 ? _a12 : Infinity;
      const host = options.host;
      const parent = (_b5 = options.parent) !== null && _b5 !== void 0 ? _b5 : null;
      const propagateFlags = options.propagate_flags;
      const credentials = options.credentials;
      const call = channel.createCall(path9, deadline, host, parent, propagateFlags);
      if (credentials) {
        call.setCredentials(credentials);
      }
      return call;
    }
    var BaseInterceptingCall = class {
      constructor(call, methodDefinition) {
        this.call = call;
        this.methodDefinition = methodDefinition;
      }
      cancelWithStatus(status, details) {
        this.call.cancelWithStatus(status, details);
      }
      getPeer() {
        return this.call.getPeer();
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      sendMessageWithContext(context3, message) {
        let serialized;
        try {
          serialized = this.methodDefinition.requestSerialize(message);
        } catch (e2) {
          this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${(0, error_1.getErrorMessage)(e2)}`);
          return;
        }
        this.call.sendMessageWithContext(context3, serialized);
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      sendMessage(message) {
        this.sendMessageWithContext({}, message);
      }
      start(metadata, interceptingListener) {
        let readError = null;
        this.call.start(metadata, {
          onReceiveMetadata: (metadata2) => {
            var _a12;
            (_a12 = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a12 === void 0 ? void 0 : _a12.call(interceptingListener, metadata2);
          },
          onReceiveMessage: (message) => {
            var _a12;
            let deserialized;
            try {
              deserialized = this.methodDefinition.responseDeserialize(message);
            } catch (e2) {
              readError = {
                code: constants_1.Status.INTERNAL,
                details: `Response message parsing error: ${(0, error_1.getErrorMessage)(e2)}`,
                metadata: new metadata_1.Metadata()
              };
              this.call.cancelWithStatus(readError.code, readError.details);
              return;
            }
            (_a12 = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a12 === void 0 ? void 0 : _a12.call(interceptingListener, deserialized);
          },
          onReceiveStatus: (status) => {
            var _a12, _b5;
            if (readError) {
              (_a12 = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a12 === void 0 ? void 0 : _a12.call(interceptingListener, readError);
            } else {
              (_b5 = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b5 === void 0 ? void 0 : _b5.call(interceptingListener, status);
            }
          }
        });
      }
      startRead() {
        this.call.startRead();
      }
      halfClose() {
        this.call.halfClose();
      }
    };
    var BaseUnaryInterceptingCall = class extends BaseInterceptingCall {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      constructor(call, methodDefinition) {
        super(call, methodDefinition);
      }
      start(metadata, listener) {
        var _a12, _b5;
        let receivedMessage = false;
        const wrapperListener = {
          onReceiveMetadata: (_b5 = (_a12 = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a12 === void 0 ? void 0 : _a12.bind(listener)) !== null && _b5 !== void 0 ? _b5 : (metadata2) => {
          },
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          onReceiveMessage: (message) => {
            var _a13;
            receivedMessage = true;
            (_a13 = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a13 === void 0 ? void 0 : _a13.call(listener, message);
          },
          onReceiveStatus: (status) => {
            var _a13, _b6;
            if (!receivedMessage) {
              (_a13 = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a13 === void 0 ? void 0 : _a13.call(listener, null);
            }
            (_b6 = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b6 === void 0 ? void 0 : _b6.call(listener, status);
          }
        };
        super.start(metadata, wrapperListener);
        this.call.startRead();
      }
    };
    var BaseStreamingInterceptingCall = class extends BaseInterceptingCall {
    };
    function getBottomInterceptingCall(channel, options, methodDefinition) {
      const call = getCall(channel, methodDefinition.path, options);
      if (methodDefinition.responseStream) {
        return new BaseStreamingInterceptingCall(call, methodDefinition);
      } else {
        return new BaseUnaryInterceptingCall(call, methodDefinition);
      }
    }
    function getInterceptingCall(interceptorArgs, methodDefinition, options, channel) {
      if (interceptorArgs.clientInterceptors.length > 0 && interceptorArgs.clientInterceptorProviders.length > 0) {
        throw new InterceptorConfigurationError("Both interceptors and interceptor_providers were passed as options to the client constructor. Only one of these is allowed.");
      }
      if (interceptorArgs.callInterceptors.length > 0 && interceptorArgs.callInterceptorProviders.length > 0) {
        throw new InterceptorConfigurationError("Both interceptors and interceptor_providers were passed as call options. Only one of these is allowed.");
      }
      let interceptors = [];
      if (interceptorArgs.callInterceptors.length > 0 || interceptorArgs.callInterceptorProviders.length > 0) {
        interceptors = [].concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map((provider) => provider(methodDefinition))).filter((interceptor) => interceptor);
      } else {
        interceptors = [].concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map((provider) => provider(methodDefinition))).filter((interceptor) => interceptor);
      }
      const interceptorOptions = Object.assign({}, options, {
        method_definition: methodDefinition
      });
      const getCall2 = interceptors.reduceRight((nextCall, nextInterceptor) => {
        return (currentOptions) => nextInterceptor(currentOptions, nextCall);
      }, (finalOptions) => getBottomInterceptingCall(channel, finalOptions, methodDefinition));
      return getCall2(interceptorOptions);
    }
    exports.getInterceptingCall = getInterceptingCall;
  }
});

// node_modules/@grpc/grpc-js/build/src/client.js
var require_client = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Client = void 0;
    var call_1 = require_call();
    var channel_1 = require_channel();
    var connectivity_state_1 = require_connectivity_state();
    var constants_1 = require_constants5();
    var metadata_1 = require_metadata();
    var client_interceptors_1 = require_client_interceptors();
    var CHANNEL_SYMBOL = Symbol();
    var INTERCEPTOR_SYMBOL = Symbol();
    var INTERCEPTOR_PROVIDER_SYMBOL = Symbol();
    var CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();
    function isFunction(arg) {
      return typeof arg === "function";
    }
    function getErrorStackString(error) {
      var _a12;
      return ((_a12 = error.stack) === null || _a12 === void 0 ? void 0 : _a12.split("\n").slice(1).join("\n")) || "no stack trace available";
    }
    var Client = class {
      constructor(address, credentials, options = {}) {
        var _a12, _b5;
        options = Object.assign({}, options);
        this[INTERCEPTOR_SYMBOL] = (_a12 = options.interceptors) !== null && _a12 !== void 0 ? _a12 : [];
        delete options.interceptors;
        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b5 = options.interceptor_providers) !== null && _b5 !== void 0 ? _b5 : [];
        delete options.interceptor_providers;
        if (this[INTERCEPTOR_SYMBOL].length > 0 && this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {
          throw new Error("Both interceptors and interceptor_providers were passed as options to the client constructor. Only one of these is allowed.");
        }
        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] = options.callInvocationTransformer;
        delete options.callInvocationTransformer;
        if (options.channelOverride) {
          this[CHANNEL_SYMBOL] = options.channelOverride;
        } else if (options.channelFactoryOverride) {
          const channelFactoryOverride = options.channelFactoryOverride;
          delete options.channelFactoryOverride;
          this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);
        } else {
          this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);
        }
      }
      close() {
        this[CHANNEL_SYMBOL].close();
      }
      getChannel() {
        return this[CHANNEL_SYMBOL];
      }
      waitForReady(deadline, callback) {
        const checkState = (err) => {
          if (err) {
            callback(new Error("Failed to connect before the deadline"));
            return;
          }
          let newState;
          try {
            newState = this[CHANNEL_SYMBOL].getConnectivityState(true);
          } catch (e2) {
            callback(new Error("The channel has been closed"));
            return;
          }
          if (newState === connectivity_state_1.ConnectivityState.READY) {
            callback();
          } else {
            try {
              this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);
            } catch (e2) {
              callback(new Error("The channel has been closed"));
            }
          }
        };
        setImmediate(checkState);
      }
      checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {
        if (isFunction(arg1)) {
          return { metadata: new metadata_1.Metadata(), options: {}, callback: arg1 };
        } else if (isFunction(arg2)) {
          if (arg1 instanceof metadata_1.Metadata) {
            return { metadata: arg1, options: {}, callback: arg2 };
          } else {
            return { metadata: new metadata_1.Metadata(), options: arg1, callback: arg2 };
          }
        } else {
          if (!(arg1 instanceof metadata_1.Metadata && arg2 instanceof Object && isFunction(arg3))) {
            throw new Error("Incorrect arguments passed");
          }
          return { metadata: arg1, options: arg2, callback: arg3 };
        }
      }
      makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {
        var _a12, _b5;
        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);
        const methodDefinition = {
          path: method,
          requestStream: false,
          responseStream: false,
          requestSerialize: serialize,
          responseDeserialize: deserialize
        };
        let callProperties = {
          argument,
          metadata: checkedArguments.metadata,
          call: new call_1.ClientUnaryCallImpl(),
          channel: this[CHANNEL_SYMBOL],
          methodDefinition,
          callOptions: checkedArguments.options,
          callback: checkedArguments.callback
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
          callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const emitter = callProperties.call;
        const interceptorArgs = {
          clientInterceptors: this[INTERCEPTOR_SYMBOL],
          clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
          callInterceptors: (_a12 = callProperties.callOptions.interceptors) !== null && _a12 !== void 0 ? _a12 : [],
          callInterceptorProviders: (_b5 = callProperties.callOptions.interceptor_providers) !== null && _b5 !== void 0 ? _b5 : []
        };
        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        emitter.call = call;
        let responseMessage = null;
        let receivedStatus = false;
        let callerStackError = new Error();
        call.start(callProperties.metadata, {
          onReceiveMetadata: (metadata2) => {
            emitter.emit("metadata", metadata2);
          },
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          onReceiveMessage(message) {
            if (responseMessage !== null) {
              call.cancelWithStatus(constants_1.Status.UNIMPLEMENTED, "Too many responses received");
            }
            responseMessage = message;
          },
          onReceiveStatus(status) {
            if (receivedStatus) {
              return;
            }
            receivedStatus = true;
            if (status.code === constants_1.Status.OK) {
              if (responseMessage === null) {
                const callerStack = getErrorStackString(callerStackError);
                callProperties.callback((0, call_1.callErrorFromStatus)({
                  code: constants_1.Status.UNIMPLEMENTED,
                  details: "No message received",
                  metadata: status.metadata
                }, callerStack));
              } else {
                callProperties.callback(null, responseMessage);
              }
            } else {
              const callerStack = getErrorStackString(callerStackError);
              callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));
            }
            callerStackError = null;
            emitter.emit("status", status);
          }
        });
        call.sendMessage(argument);
        call.halfClose();
        return emitter;
      }
      makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {
        var _a12, _b5;
        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);
        const methodDefinition = {
          path: method,
          requestStream: true,
          responseStream: false,
          requestSerialize: serialize,
          responseDeserialize: deserialize
        };
        let callProperties = {
          metadata: checkedArguments.metadata,
          call: new call_1.ClientWritableStreamImpl(serialize),
          channel: this[CHANNEL_SYMBOL],
          methodDefinition,
          callOptions: checkedArguments.options,
          callback: checkedArguments.callback
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
          callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const emitter = callProperties.call;
        const interceptorArgs = {
          clientInterceptors: this[INTERCEPTOR_SYMBOL],
          clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
          callInterceptors: (_a12 = callProperties.callOptions.interceptors) !== null && _a12 !== void 0 ? _a12 : [],
          callInterceptorProviders: (_b5 = callProperties.callOptions.interceptor_providers) !== null && _b5 !== void 0 ? _b5 : []
        };
        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        emitter.call = call;
        let responseMessage = null;
        let receivedStatus = false;
        let callerStackError = new Error();
        call.start(callProperties.metadata, {
          onReceiveMetadata: (metadata2) => {
            emitter.emit("metadata", metadata2);
          },
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          onReceiveMessage(message) {
            if (responseMessage !== null) {
              call.cancelWithStatus(constants_1.Status.UNIMPLEMENTED, "Too many responses received");
            }
            responseMessage = message;
            call.startRead();
          },
          onReceiveStatus(status) {
            if (receivedStatus) {
              return;
            }
            receivedStatus = true;
            if (status.code === constants_1.Status.OK) {
              if (responseMessage === null) {
                const callerStack = getErrorStackString(callerStackError);
                callProperties.callback((0, call_1.callErrorFromStatus)({
                  code: constants_1.Status.UNIMPLEMENTED,
                  details: "No message received",
                  metadata: status.metadata
                }, callerStack));
              } else {
                callProperties.callback(null, responseMessage);
              }
            } else {
              const callerStack = getErrorStackString(callerStackError);
              callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));
            }
            callerStackError = null;
            emitter.emit("status", status);
          }
        });
        return emitter;
      }
      checkMetadataAndOptions(arg1, arg2) {
        let metadata;
        let options;
        if (arg1 instanceof metadata_1.Metadata) {
          metadata = arg1;
          if (arg2) {
            options = arg2;
          } else {
            options = {};
          }
        } else {
          if (arg1) {
            options = arg1;
          } else {
            options = {};
          }
          metadata = new metadata_1.Metadata();
        }
        return { metadata, options };
      }
      makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {
        var _a12, _b5;
        const checkedArguments = this.checkMetadataAndOptions(metadata, options);
        const methodDefinition = {
          path: method,
          requestStream: false,
          responseStream: true,
          requestSerialize: serialize,
          responseDeserialize: deserialize
        };
        let callProperties = {
          argument,
          metadata: checkedArguments.metadata,
          call: new call_1.ClientReadableStreamImpl(deserialize),
          channel: this[CHANNEL_SYMBOL],
          methodDefinition,
          callOptions: checkedArguments.options
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
          callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const stream = callProperties.call;
        const interceptorArgs = {
          clientInterceptors: this[INTERCEPTOR_SYMBOL],
          clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
          callInterceptors: (_a12 = callProperties.callOptions.interceptors) !== null && _a12 !== void 0 ? _a12 : [],
          callInterceptorProviders: (_b5 = callProperties.callOptions.interceptor_providers) !== null && _b5 !== void 0 ? _b5 : []
        };
        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        stream.call = call;
        let receivedStatus = false;
        let callerStackError = new Error();
        call.start(callProperties.metadata, {
          onReceiveMetadata(metadata2) {
            stream.emit("metadata", metadata2);
          },
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          onReceiveMessage(message) {
            stream.push(message);
          },
          onReceiveStatus(status) {
            if (receivedStatus) {
              return;
            }
            receivedStatus = true;
            stream.push(null);
            if (status.code !== constants_1.Status.OK) {
              const callerStack = getErrorStackString(callerStackError);
              stream.emit("error", (0, call_1.callErrorFromStatus)(status, callerStack));
            }
            callerStackError = null;
            stream.emit("status", status);
          }
        });
        call.sendMessage(argument);
        call.halfClose();
        return stream;
      }
      makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {
        var _a12, _b5;
        const checkedArguments = this.checkMetadataAndOptions(metadata, options);
        const methodDefinition = {
          path: method,
          requestStream: true,
          responseStream: true,
          requestSerialize: serialize,
          responseDeserialize: deserialize
        };
        let callProperties = {
          metadata: checkedArguments.metadata,
          call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),
          channel: this[CHANNEL_SYMBOL],
          methodDefinition,
          callOptions: checkedArguments.options
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
          callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const stream = callProperties.call;
        const interceptorArgs = {
          clientInterceptors: this[INTERCEPTOR_SYMBOL],
          clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
          callInterceptors: (_a12 = callProperties.callOptions.interceptors) !== null && _a12 !== void 0 ? _a12 : [],
          callInterceptorProviders: (_b5 = callProperties.callOptions.interceptor_providers) !== null && _b5 !== void 0 ? _b5 : []
        };
        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        stream.call = call;
        let receivedStatus = false;
        let callerStackError = new Error();
        call.start(callProperties.metadata, {
          onReceiveMetadata(metadata2) {
            stream.emit("metadata", metadata2);
          },
          onReceiveMessage(message) {
            stream.push(message);
          },
          onReceiveStatus(status) {
            if (receivedStatus) {
              return;
            }
            receivedStatus = true;
            stream.push(null);
            if (status.code !== constants_1.Status.OK) {
              const callerStack = getErrorStackString(callerStackError);
              stream.emit("error", (0, call_1.callErrorFromStatus)(status, callerStack));
            }
            callerStackError = null;
            stream.emit("status", status);
          }
        });
        return stream;
      }
    };
    exports.Client = Client;
  }
});

// node_modules/@grpc/grpc-js/build/src/make-client.js
var require_make_client = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/make-client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadPackageDefinition = exports.makeClientConstructor = void 0;
    var client_1 = require_client();
    var requesterFuncs = {
      unary: client_1.Client.prototype.makeUnaryRequest,
      server_stream: client_1.Client.prototype.makeServerStreamRequest,
      client_stream: client_1.Client.prototype.makeClientStreamRequest,
      bidi: client_1.Client.prototype.makeBidiStreamRequest
    };
    function isPrototypePolluted(key) {
      return ["__proto__", "prototype", "constructor"].includes(key);
    }
    function makeClientConstructor(methods, serviceName, classOptions) {
      if (!classOptions) {
        classOptions = {};
      }
      class ServiceClientImpl extends client_1.Client {
      }
      Object.keys(methods).forEach((name) => {
        if (isPrototypePolluted(name)) {
          return;
        }
        const attrs = methods[name];
        let methodType;
        if (typeof name === "string" && name.charAt(0) === "$") {
          throw new Error("Method names cannot start with $");
        }
        if (attrs.requestStream) {
          if (attrs.responseStream) {
            methodType = "bidi";
          } else {
            methodType = "client_stream";
          }
        } else {
          if (attrs.responseStream) {
            methodType = "server_stream";
          } else {
            methodType = "unary";
          }
        }
        const serialize = attrs.requestSerialize;
        const deserialize = attrs.responseDeserialize;
        const methodFunc = partial2(requesterFuncs[methodType], attrs.path, serialize, deserialize);
        ServiceClientImpl.prototype[name] = methodFunc;
        Object.assign(ServiceClientImpl.prototype[name], attrs);
        if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {
          ServiceClientImpl.prototype[attrs.originalName] = ServiceClientImpl.prototype[name];
        }
      });
      ServiceClientImpl.service = methods;
      ServiceClientImpl.serviceName = serviceName;
      return ServiceClientImpl;
    }
    exports.makeClientConstructor = makeClientConstructor;
    function partial2(fn, path9, serialize, deserialize) {
      return function(...args) {
        return fn.call(this, path9, serialize, deserialize, ...args);
      };
    }
    function isProtobufTypeDefinition(obj) {
      return "format" in obj;
    }
    function loadPackageDefinition(packageDef) {
      const result4 = {};
      for (const serviceFqn in packageDef) {
        if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {
          const service4 = packageDef[serviceFqn];
          const nameComponents = serviceFqn.split(".");
          if (nameComponents.some((comp) => isPrototypePolluted(comp))) {
            continue;
          }
          const serviceName = nameComponents[nameComponents.length - 1];
          let current = result4;
          for (const packageName of nameComponents.slice(0, -1)) {
            if (!current[packageName]) {
              current[packageName] = {};
            }
            current = current[packageName];
          }
          if (isProtobufTypeDefinition(service4)) {
            current[serviceName] = service4;
          } else {
            current[serviceName] = makeClientConstructor(service4, serviceName, {});
          }
        }
      }
      return result4;
    }
    exports.loadPackageDefinition = loadPackageDefinition;
  }
});

// node_modules/@grpc/proto-loader/build/src/util.js
var require_util4 = __commonJS({
  "node_modules/@grpc/proto-loader/build/src/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addCommonProtos = exports.loadProtosWithOptionsSync = exports.loadProtosWithOptions = void 0;
    var fs3 = __require("fs");
    var path9 = __require("path");
    var Protobuf = __require("protobufjs");
    function addIncludePathResolver(root, includePaths) {
      const originalResolvePath = root.resolvePath;
      root.resolvePath = (origin, target) => {
        if (path9.isAbsolute(target)) {
          return target;
        }
        for (const directory of includePaths) {
          const fullPath = path9.join(directory, target);
          try {
            fs3.accessSync(fullPath, fs3.constants.R_OK);
            return fullPath;
          } catch (err) {
            continue;
          }
        }
        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);
        return originalResolvePath(origin, target);
      };
    }
    async function loadProtosWithOptions(filename, options) {
      const root = new Protobuf.Root();
      options = options || {};
      if (!!options.includeDirs) {
        if (!Array.isArray(options.includeDirs)) {
          return Promise.reject(new Error("The includeDirs option must be an array"));
        }
        addIncludePathResolver(root, options.includeDirs);
      }
      const loadedRoot = await root.load(filename, options);
      loadedRoot.resolveAll();
      return loadedRoot;
    }
    exports.loadProtosWithOptions = loadProtosWithOptions;
    function loadProtosWithOptionsSync(filename, options) {
      const root = new Protobuf.Root();
      options = options || {};
      if (!!options.includeDirs) {
        if (!Array.isArray(options.includeDirs)) {
          throw new Error("The includeDirs option must be an array");
        }
        addIncludePathResolver(root, options.includeDirs);
      }
      const loadedRoot = root.loadSync(filename, options);
      loadedRoot.resolveAll();
      return loadedRoot;
    }
    exports.loadProtosWithOptionsSync = loadProtosWithOptionsSync;
    function addCommonProtos() {
      const apiDescriptor = __require("protobufjs/google/protobuf/api.json");
      const descriptorDescriptor = __require("protobufjs/google/protobuf/descriptor.json");
      const sourceContextDescriptor = __require("protobufjs/google/protobuf/source_context.json");
      const typeDescriptor = __require("protobufjs/google/protobuf/type.json");
      Protobuf.common("api", apiDescriptor.nested.google.nested.protobuf.nested);
      Protobuf.common("descriptor", descriptorDescriptor.nested.google.nested.protobuf.nested);
      Protobuf.common("source_context", sourceContextDescriptor.nested.google.nested.protobuf.nested);
      Protobuf.common("type", typeDescriptor.nested.google.nested.protobuf.nested);
    }
    exports.addCommonProtos = addCommonProtos;
  }
});

// node_modules/@grpc/proto-loader/build/src/index.js
var require_src11 = __commonJS({
  "node_modules/@grpc/proto-loader/build/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadFileDescriptorSetFromObject = exports.loadFileDescriptorSetFromBuffer = exports.fromJSON = exports.loadSync = exports.load = exports.IdempotencyLevel = exports.isAnyExtension = exports.Long = void 0;
    var camelCase2 = __require("lodash.camelcase");
    var Protobuf = __require("protobufjs");
    var descriptor3 = __require("protobufjs/ext/descriptor");
    var util_1 = require_util4();
    var Long = __require("long");
    exports.Long = Long;
    function isAnyExtension(obj) {
      return "@type" in obj && typeof obj["@type"] === "string";
    }
    exports.isAnyExtension = isAnyExtension;
    var IdempotencyLevel;
    (function(IdempotencyLevel2) {
      IdempotencyLevel2["IDEMPOTENCY_UNKNOWN"] = "IDEMPOTENCY_UNKNOWN";
      IdempotencyLevel2["NO_SIDE_EFFECTS"] = "NO_SIDE_EFFECTS";
      IdempotencyLevel2["IDEMPOTENT"] = "IDEMPOTENT";
    })(IdempotencyLevel = exports.IdempotencyLevel || (exports.IdempotencyLevel = {}));
    var descriptorOptions = {
      longs: String,
      enums: String,
      bytes: String,
      defaults: true,
      oneofs: true,
      json: true
    };
    function joinName(baseName, name) {
      if (baseName === "") {
        return name;
      } else {
        return baseName + "." + name;
      }
    }
    function isHandledReflectionObject(obj) {
      return obj instanceof Protobuf.Service || obj instanceof Protobuf.Type || obj instanceof Protobuf.Enum;
    }
    function isNamespaceBase(obj) {
      return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;
    }
    function getAllHandledReflectionObjects(obj, parentName) {
      const objName = joinName(parentName, obj.name);
      if (isHandledReflectionObject(obj)) {
        return [[objName, obj]];
      } else {
        if (isNamespaceBase(obj) && typeof obj.nested !== "undefined") {
          return Object.keys(obj.nested).map((name) => {
            return getAllHandledReflectionObjects(obj.nested[name], objName);
          }).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);
        }
      }
      return [];
    }
    function createDeserializer(cls, options) {
      return function deserialize(argBuf) {
        return cls.toObject(cls.decode(argBuf), options);
      };
    }
    function createSerializer(cls) {
      return function serialize(arg) {
        if (Array.isArray(arg)) {
          throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);
        }
        const message = cls.fromObject(arg);
        return cls.encode(message).finish();
      };
    }
    function mapMethodOptions(options) {
      return (options || []).reduce((obj, item) => {
        for (const [key, value] of Object.entries(item)) {
          switch (key) {
            case "uninterpreted_option":
              obj.uninterpreted_option.push(item.uninterpreted_option);
              break;
            default:
              obj[key] = value;
          }
        }
        return obj;
      }, {
        deprecated: false,
        idempotency_level: IdempotencyLevel.IDEMPOTENCY_UNKNOWN,
        uninterpreted_option: []
      });
    }
    function createMethodDefinition(method, serviceName, options, fileDescriptors) {
      const requestType = method.resolvedRequestType;
      const responseType = method.resolvedResponseType;
      return {
        path: "/" + serviceName + "/" + method.name,
        requestStream: !!method.requestStream,
        responseStream: !!method.responseStream,
        requestSerialize: createSerializer(requestType),
        requestDeserialize: createDeserializer(requestType, options),
        responseSerialize: createSerializer(responseType),
        responseDeserialize: createDeserializer(responseType, options),
        // TODO(murgatroid99): Find a better way to handle this
        originalName: camelCase2(method.name),
        requestType: createMessageDefinition(requestType, fileDescriptors),
        responseType: createMessageDefinition(responseType, fileDescriptors),
        options: mapMethodOptions(method.parsedOptions)
      };
    }
    function createServiceDefinition(service4, name, options, fileDescriptors) {
      const def = {};
      for (const method of service4.methodsArray) {
        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);
      }
      return def;
    }
    function createMessageDefinition(message, fileDescriptors) {
      const messageDescriptor = message.toDescriptor("proto3");
      return {
        format: "Protocol Buffer 3 DescriptorProto",
        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),
        fileDescriptorProtos: fileDescriptors
      };
    }
    function createEnumDefinition(enumType, fileDescriptors) {
      const enumDescriptor = enumType.toDescriptor("proto3");
      return {
        format: "Protocol Buffer 3 EnumDescriptorProto",
        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),
        fileDescriptorProtos: fileDescriptors
      };
    }
    function createDefinition(obj, name, options, fileDescriptors) {
      if (obj instanceof Protobuf.Service) {
        return createServiceDefinition(obj, name, options, fileDescriptors);
      } else if (obj instanceof Protobuf.Type) {
        return createMessageDefinition(obj, fileDescriptors);
      } else if (obj instanceof Protobuf.Enum) {
        return createEnumDefinition(obj, fileDescriptors);
      } else {
        throw new Error("Type mismatch in reflection object handling");
      }
    }
    function createPackageDefinition(root, options) {
      const def = {};
      root.resolveAll();
      const descriptorList = root.toDescriptor("proto3").file;
      const bufferList = descriptorList.map((value) => Buffer.from(descriptor3.FileDescriptorProto.encode(value).finish()));
      for (const [name, obj] of getAllHandledReflectionObjects(root, "")) {
        def[name] = createDefinition(obj, name, options, bufferList);
      }
      return def;
    }
    function createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {
      options = options || {};
      const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);
      root.resolveAll();
      return createPackageDefinition(root, options);
    }
    function load(filename, options) {
      return (0, util_1.loadProtosWithOptions)(filename, options).then((loadedRoot) => {
        return createPackageDefinition(loadedRoot, options);
      });
    }
    exports.load = load;
    function loadSync(filename, options) {
      const loadedRoot = (0, util_1.loadProtosWithOptionsSync)(filename, options);
      return createPackageDefinition(loadedRoot, options);
    }
    exports.loadSync = loadSync;
    function fromJSON(json, options) {
      options = options || {};
      const loadedRoot = Protobuf.Root.fromJSON(json);
      loadedRoot.resolveAll();
      return createPackageDefinition(loadedRoot, options);
    }
    exports.fromJSON = fromJSON;
    function loadFileDescriptorSetFromBuffer(descriptorSet, options) {
      const decodedDescriptorSet = descriptor3.FileDescriptorSet.decode(descriptorSet);
      return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);
    }
    exports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;
    function loadFileDescriptorSetFromObject(descriptorSet, options) {
      const decodedDescriptorSet = descriptor3.FileDescriptorSet.fromObject(descriptorSet);
      return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);
    }
    exports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;
    (0, util_1.addCommonProtos)();
  }
});

// node_modules/@grpc/grpc-js/build/src/channelz.js
var require_channelz = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/channelz.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setup = exports.getChannelzServiceDefinition = exports.getChannelzHandlers = exports.unregisterChannelzRef = exports.registerChannelzSocket = exports.registerChannelzServer = exports.registerChannelzSubchannel = exports.registerChannelzChannel = exports.ChannelzCallTrackerStub = exports.ChannelzCallTracker = exports.ChannelzChildrenTrackerStub = exports.ChannelzChildrenTracker = exports.ChannelzTrace = exports.ChannelzTraceStub = void 0;
    var net_1 = __require("net");
    var ordered_map_1 = require_cjs();
    var connectivity_state_1 = require_connectivity_state();
    var constants_1 = require_constants5();
    var subchannel_address_1 = require_subchannel_address();
    var admin_1 = require_admin();
    var make_client_1 = require_make_client();
    function channelRefToMessage(ref) {
      return {
        channel_id: ref.id,
        name: ref.name
      };
    }
    function subchannelRefToMessage(ref) {
      return {
        subchannel_id: ref.id,
        name: ref.name
      };
    }
    function serverRefToMessage(ref) {
      return {
        server_id: ref.id
      };
    }
    function socketRefToMessage(ref) {
      return {
        socket_id: ref.id,
        name: ref.name
      };
    }
    var TARGET_RETAINED_TRACES = 32;
    var DEFAULT_MAX_RESULTS = 100;
    var ChannelzTraceStub = class {
      constructor() {
        this.events = [];
        this.creationTimestamp = /* @__PURE__ */ new Date();
        this.eventsLogged = 0;
      }
      addTrace() {
      }
      getTraceMessage() {
        return {
          creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),
          num_events_logged: this.eventsLogged,
          events: []
        };
      }
    };
    exports.ChannelzTraceStub = ChannelzTraceStub;
    var ChannelzTrace = class {
      constructor() {
        this.events = [];
        this.eventsLogged = 0;
        this.creationTimestamp = /* @__PURE__ */ new Date();
      }
      addTrace(severity, description, child) {
        const timestamp = /* @__PURE__ */ new Date();
        this.events.push({
          description,
          severity,
          timestamp,
          childChannel: (child === null || child === void 0 ? void 0 : child.kind) === "channel" ? child : void 0,
          childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === "subchannel" ? child : void 0
        });
        if (this.events.length >= TARGET_RETAINED_TRACES * 2) {
          this.events = this.events.slice(TARGET_RETAINED_TRACES);
        }
        this.eventsLogged += 1;
      }
      getTraceMessage() {
        return {
          creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),
          num_events_logged: this.eventsLogged,
          events: this.events.map((event) => {
            return {
              description: event.description,
              severity: event.severity,
              timestamp: dateToProtoTimestamp(event.timestamp),
              channel_ref: event.childChannel ? channelRefToMessage(event.childChannel) : null,
              subchannel_ref: event.childSubchannel ? subchannelRefToMessage(event.childSubchannel) : null
            };
          })
        };
      }
    };
    exports.ChannelzTrace = ChannelzTrace;
    var ChannelzChildrenTracker = class {
      constructor() {
        this.channelChildren = new ordered_map_1.OrderedMap();
        this.subchannelChildren = new ordered_map_1.OrderedMap();
        this.socketChildren = new ordered_map_1.OrderedMap();
        this.trackerMap = {
          [
            "channel"
            /* EntityTypes.channel */
          ]: this.channelChildren,
          [
            "subchannel"
            /* EntityTypes.subchannel */
          ]: this.subchannelChildren,
          [
            "socket"
            /* EntityTypes.socket */
          ]: this.socketChildren
        };
      }
      refChild(child) {
        const tracker = this.trackerMap[child.kind];
        const trackedChild = tracker.find(child.id);
        if (trackedChild.equals(tracker.end())) {
          tracker.setElement(child.id, {
            ref: child,
            count: 1
          }, trackedChild);
        } else {
          trackedChild.pointer[1].count += 1;
        }
      }
      unrefChild(child) {
        const tracker = this.trackerMap[child.kind];
        const trackedChild = tracker.getElementByKey(child.id);
        if (trackedChild !== void 0) {
          trackedChild.count -= 1;
          if (trackedChild.count === 0) {
            tracker.eraseElementByKey(child.id);
          }
        }
      }
      getChildLists() {
        return {
          channels: this.channelChildren,
          subchannels: this.subchannelChildren,
          sockets: this.socketChildren
        };
      }
    };
    exports.ChannelzChildrenTracker = ChannelzChildrenTracker;
    var ChannelzChildrenTrackerStub = class extends ChannelzChildrenTracker {
      refChild() {
      }
      unrefChild() {
      }
    };
    exports.ChannelzChildrenTrackerStub = ChannelzChildrenTrackerStub;
    var ChannelzCallTracker = class {
      constructor() {
        this.callsStarted = 0;
        this.callsSucceeded = 0;
        this.callsFailed = 0;
        this.lastCallStartedTimestamp = null;
      }
      addCallStarted() {
        this.callsStarted += 1;
        this.lastCallStartedTimestamp = /* @__PURE__ */ new Date();
      }
      addCallSucceeded() {
        this.callsSucceeded += 1;
      }
      addCallFailed() {
        this.callsFailed += 1;
      }
    };
    exports.ChannelzCallTracker = ChannelzCallTracker;
    var ChannelzCallTrackerStub = class extends ChannelzCallTracker {
      addCallStarted() {
      }
      addCallSucceeded() {
      }
      addCallFailed() {
      }
    };
    exports.ChannelzCallTrackerStub = ChannelzCallTrackerStub;
    var entityMaps = {
      [
        "channel"
        /* EntityTypes.channel */
      ]: new ordered_map_1.OrderedMap(),
      [
        "subchannel"
        /* EntityTypes.subchannel */
      ]: new ordered_map_1.OrderedMap(),
      [
        "server"
        /* EntityTypes.server */
      ]: new ordered_map_1.OrderedMap(),
      [
        "socket"
        /* EntityTypes.socket */
      ]: new ordered_map_1.OrderedMap()
    };
    var generateRegisterFn = (kind) => {
      let nextId = 1;
      function getNextId() {
        return nextId++;
      }
      const entityMap = entityMaps[kind];
      return (name, getInfo, channelzEnabled) => {
        const id = getNextId();
        const ref = { id, name, kind };
        if (channelzEnabled) {
          entityMap.setElement(id, { ref, getInfo });
        }
        return ref;
      };
    };
    exports.registerChannelzChannel = generateRegisterFn(
      "channel"
      /* EntityTypes.channel */
    );
    exports.registerChannelzSubchannel = generateRegisterFn(
      "subchannel"
      /* EntityTypes.subchannel */
    );
    exports.registerChannelzServer = generateRegisterFn(
      "server"
      /* EntityTypes.server */
    );
    exports.registerChannelzSocket = generateRegisterFn(
      "socket"
      /* EntityTypes.socket */
    );
    function unregisterChannelzRef(ref) {
      entityMaps[ref.kind].eraseElementByKey(ref.id);
    }
    exports.unregisterChannelzRef = unregisterChannelzRef;
    function parseIPv6Section(addressSection) {
      const numberValue = Number.parseInt(addressSection, 16);
      return [numberValue / 256 | 0, numberValue % 256];
    }
    function parseIPv6Chunk(addressChunk) {
      if (addressChunk === "") {
        return [];
      }
      const bytePairs = addressChunk.split(":").map((section) => parseIPv6Section(section));
      const result4 = [];
      return result4.concat(...bytePairs);
    }
    function ipAddressStringToBuffer(ipAddress) {
      if ((0, net_1.isIPv4)(ipAddress)) {
        return Buffer.from(Uint8Array.from(ipAddress.split(".").map((segment) => Number.parseInt(segment))));
      } else if ((0, net_1.isIPv6)(ipAddress)) {
        let leftSection;
        let rightSection;
        const doubleColonIndex = ipAddress.indexOf("::");
        if (doubleColonIndex === -1) {
          leftSection = ipAddress;
          rightSection = "";
        } else {
          leftSection = ipAddress.substring(0, doubleColonIndex);
          rightSection = ipAddress.substring(doubleColonIndex + 2);
        }
        const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));
        const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));
        const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);
        return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);
      } else {
        return null;
      }
    }
    function connectivityStateToMessage(state) {
      switch (state) {
        case connectivity_state_1.ConnectivityState.CONNECTING:
          return {
            state: "CONNECTING"
          };
        case connectivity_state_1.ConnectivityState.IDLE:
          return {
            state: "IDLE"
          };
        case connectivity_state_1.ConnectivityState.READY:
          return {
            state: "READY"
          };
        case connectivity_state_1.ConnectivityState.SHUTDOWN:
          return {
            state: "SHUTDOWN"
          };
        case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:
          return {
            state: "TRANSIENT_FAILURE"
          };
        default:
          return {
            state: "UNKNOWN"
          };
      }
    }
    function dateToProtoTimestamp(date) {
      if (!date) {
        return null;
      }
      const millisSinceEpoch = date.getTime();
      return {
        seconds: millisSinceEpoch / 1e3 | 0,
        nanos: millisSinceEpoch % 1e3 * 1e6
      };
    }
    function getChannelMessage(channelEntry) {
      const resolvedInfo = channelEntry.getInfo();
      const channelRef = [];
      const subchannelRef = [];
      resolvedInfo.children.channels.forEach((el) => {
        channelRef.push(channelRefToMessage(el[1].ref));
      });
      resolvedInfo.children.subchannels.forEach((el) => {
        subchannelRef.push(subchannelRefToMessage(el[1].ref));
      });
      return {
        ref: channelRefToMessage(channelEntry.ref),
        data: {
          target: resolvedInfo.target,
          state: connectivityStateToMessage(resolvedInfo.state),
          calls_started: resolvedInfo.callTracker.callsStarted,
          calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
          calls_failed: resolvedInfo.callTracker.callsFailed,
          last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
          trace: resolvedInfo.trace.getTraceMessage()
        },
        channel_ref: channelRef,
        subchannel_ref: subchannelRef
      };
    }
    function GetChannel(call, callback) {
      const channelId = parseInt(call.request.channel_id, 10);
      const channelEntry = entityMaps[
        "channel"
        /* EntityTypes.channel */
      ].getElementByKey(channelId);
      if (channelEntry === void 0) {
        callback({
          code: constants_1.Status.NOT_FOUND,
          details: "No channel data found for id " + channelId
        });
        return;
      }
      callback(null, { channel: getChannelMessage(channelEntry) });
    }
    function GetTopChannels(call, callback) {
      const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;
      const resultList = [];
      const startId = parseInt(call.request.start_channel_id, 10);
      const channelEntries = entityMaps[
        "channel"
        /* EntityTypes.channel */
      ];
      let i2;
      for (i2 = channelEntries.lowerBound(startId); !i2.equals(channelEntries.end()) && resultList.length < maxResults; i2 = i2.next()) {
        resultList.push(getChannelMessage(i2.pointer[1]));
      }
      callback(null, {
        channel: resultList,
        end: i2.equals(channelEntries.end())
      });
    }
    function getServerMessage(serverEntry) {
      const resolvedInfo = serverEntry.getInfo();
      const listenSocket = [];
      resolvedInfo.listenerChildren.sockets.forEach((el) => {
        listenSocket.push(socketRefToMessage(el[1].ref));
      });
      return {
        ref: serverRefToMessage(serverEntry.ref),
        data: {
          calls_started: resolvedInfo.callTracker.callsStarted,
          calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
          calls_failed: resolvedInfo.callTracker.callsFailed,
          last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
          trace: resolvedInfo.trace.getTraceMessage()
        },
        listen_socket: listenSocket
      };
    }
    function GetServer(call, callback) {
      const serverId = parseInt(call.request.server_id, 10);
      const serverEntries = entityMaps[
        "server"
        /* EntityTypes.server */
      ];
      const serverEntry = serverEntries.getElementByKey(serverId);
      if (serverEntry === void 0) {
        callback({
          code: constants_1.Status.NOT_FOUND,
          details: "No server data found for id " + serverId
        });
        return;
      }
      callback(null, { server: getServerMessage(serverEntry) });
    }
    function GetServers(call, callback) {
      const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;
      const startId = parseInt(call.request.start_server_id, 10);
      const serverEntries = entityMaps[
        "server"
        /* EntityTypes.server */
      ];
      const resultList = [];
      let i2;
      for (i2 = serverEntries.lowerBound(startId); !i2.equals(serverEntries.end()) && resultList.length < maxResults; i2 = i2.next()) {
        resultList.push(getServerMessage(i2.pointer[1]));
      }
      callback(null, {
        server: resultList,
        end: i2.equals(serverEntries.end())
      });
    }
    function GetSubchannel(call, callback) {
      const subchannelId = parseInt(call.request.subchannel_id, 10);
      const subchannelEntry = entityMaps[
        "subchannel"
        /* EntityTypes.subchannel */
      ].getElementByKey(subchannelId);
      if (subchannelEntry === void 0) {
        callback({
          code: constants_1.Status.NOT_FOUND,
          details: "No subchannel data found for id " + subchannelId
        });
        return;
      }
      const resolvedInfo = subchannelEntry.getInfo();
      const listenSocket = [];
      resolvedInfo.children.sockets.forEach((el) => {
        listenSocket.push(socketRefToMessage(el[1].ref));
      });
      const subchannelMessage = {
        ref: subchannelRefToMessage(subchannelEntry.ref),
        data: {
          target: resolvedInfo.target,
          state: connectivityStateToMessage(resolvedInfo.state),
          calls_started: resolvedInfo.callTracker.callsStarted,
          calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
          calls_failed: resolvedInfo.callTracker.callsFailed,
          last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
          trace: resolvedInfo.trace.getTraceMessage()
        },
        socket_ref: listenSocket
      };
      callback(null, { subchannel: subchannelMessage });
    }
    function subchannelAddressToAddressMessage(subchannelAddress) {
      var _a12;
      if ((0, subchannel_address_1.isTcpSubchannelAddress)(subchannelAddress)) {
        return {
          address: "tcpip_address",
          tcpip_address: {
            ip_address: (_a12 = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a12 !== void 0 ? _a12 : void 0,
            port: subchannelAddress.port
          }
        };
      } else {
        return {
          address: "uds_address",
          uds_address: {
            filename: subchannelAddress.path
          }
        };
      }
    }
    function GetSocket(call, callback) {
      var _a12, _b5, _c4, _d4, _e4;
      const socketId = parseInt(call.request.socket_id, 10);
      const socketEntry = entityMaps[
        "socket"
        /* EntityTypes.socket */
      ].getElementByKey(socketId);
      if (socketEntry === void 0) {
        callback({
          code: constants_1.Status.NOT_FOUND,
          details: "No socket data found for id " + socketId
        });
        return;
      }
      const resolvedInfo = socketEntry.getInfo();
      const securityMessage = resolvedInfo.security ? {
        model: "tls",
        tls: {
          cipher_suite: resolvedInfo.security.cipherSuiteStandardName ? "standard_name" : "other_name",
          standard_name: (_a12 = resolvedInfo.security.cipherSuiteStandardName) !== null && _a12 !== void 0 ? _a12 : void 0,
          other_name: (_b5 = resolvedInfo.security.cipherSuiteOtherName) !== null && _b5 !== void 0 ? _b5 : void 0,
          local_certificate: (_c4 = resolvedInfo.security.localCertificate) !== null && _c4 !== void 0 ? _c4 : void 0,
          remote_certificate: (_d4 = resolvedInfo.security.remoteCertificate) !== null && _d4 !== void 0 ? _d4 : void 0
        }
      } : null;
      const socketMessage = {
        ref: socketRefToMessage(socketEntry.ref),
        local: resolvedInfo.localAddress ? subchannelAddressToAddressMessage(resolvedInfo.localAddress) : null,
        remote: resolvedInfo.remoteAddress ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress) : null,
        remote_name: (_e4 = resolvedInfo.remoteName) !== null && _e4 !== void 0 ? _e4 : void 0,
        security: securityMessage,
        data: {
          keep_alives_sent: resolvedInfo.keepAlivesSent,
          streams_started: resolvedInfo.streamsStarted,
          streams_succeeded: resolvedInfo.streamsSucceeded,
          streams_failed: resolvedInfo.streamsFailed,
          last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),
          last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),
          messages_received: resolvedInfo.messagesReceived,
          messages_sent: resolvedInfo.messagesSent,
          last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),
          last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),
          local_flow_control_window: resolvedInfo.localFlowControlWindow ? { value: resolvedInfo.localFlowControlWindow } : null,
          remote_flow_control_window: resolvedInfo.remoteFlowControlWindow ? { value: resolvedInfo.remoteFlowControlWindow } : null
        }
      };
      callback(null, { socket: socketMessage });
    }
    function GetServerSockets(call, callback) {
      const serverId = parseInt(call.request.server_id, 10);
      const serverEntry = entityMaps[
        "server"
        /* EntityTypes.server */
      ].getElementByKey(serverId);
      if (serverEntry === void 0) {
        callback({
          code: constants_1.Status.NOT_FOUND,
          details: "No server data found for id " + serverId
        });
        return;
      }
      const startId = parseInt(call.request.start_socket_id, 10);
      const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;
      const resolvedInfo = serverEntry.getInfo();
      const allSockets = resolvedInfo.sessionChildren.sockets;
      const resultList = [];
      let i2;
      for (i2 = allSockets.lowerBound(startId); !i2.equals(allSockets.end()) && resultList.length < maxResults; i2 = i2.next()) {
        resultList.push(socketRefToMessage(i2.pointer[1].ref));
      }
      callback(null, {
        socket_ref: resultList,
        end: i2.equals(allSockets.end())
      });
    }
    function getChannelzHandlers() {
      return {
        GetChannel,
        GetTopChannels,
        GetServer,
        GetServers,
        GetSubchannel,
        GetSocket,
        GetServerSockets
      };
    }
    exports.getChannelzHandlers = getChannelzHandlers;
    var loadedChannelzDefinition = null;
    function getChannelzServiceDefinition() {
      if (loadedChannelzDefinition) {
        return loadedChannelzDefinition;
      }
      const loaderLoadSync = require_src11().loadSync;
      const loadedProto = loaderLoadSync("channelz.proto", {
        keepCase: true,
        longs: String,
        enums: String,
        defaults: true,
        oneofs: true,
        includeDirs: [`${__dirname}/../../proto`]
      });
      const channelzGrpcObject = (0, make_client_1.loadPackageDefinition)(loadedProto);
      loadedChannelzDefinition = channelzGrpcObject.grpc.channelz.v1.Channelz.service;
      return loadedChannelzDefinition;
    }
    exports.getChannelzServiceDefinition = getChannelzServiceDefinition;
    function setup() {
      (0, admin_1.registerAdminService)(getChannelzServiceDefinition, getChannelzHandlers);
    }
    exports.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel.js
var require_subchannel = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/subchannel.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Subchannel = void 0;
    var connectivity_state_1 = require_connectivity_state();
    var backoff_timeout_1 = require_backoff_timeout();
    var logging = require_logging();
    var constants_1 = require_constants5();
    var uri_parser_1 = require_uri_parser();
    var subchannel_address_1 = require_subchannel_address();
    var channelz_1 = require_channelz();
    var TRACER_NAME = "subchannel";
    var KEEPALIVE_MAX_TIME_MS = ~(1 << 31);
    var Subchannel = class {
      /**
       * A class representing a connection to a single backend.
       * @param channelTarget The target string for the channel as a whole
       * @param subchannelAddress The address for the backend that this subchannel
       *     will connect to
       * @param options The channel options, plus any specific subchannel options
       *     for this subchannel
       * @param credentials The channel credentials used to establish this
       *     connection
       */
      constructor(channelTarget, subchannelAddress, options, credentials, connector) {
        var _a12;
        this.channelTarget = channelTarget;
        this.subchannelAddress = subchannelAddress;
        this.options = options;
        this.credentials = credentials;
        this.connector = connector;
        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;
        this.transport = null;
        this.continueConnecting = false;
        this.stateListeners = /* @__PURE__ */ new Set();
        this.refcount = 0;
        this.channelzEnabled = true;
        const backoffOptions = {
          initialDelay: options["grpc.initial_reconnect_backoff_ms"],
          maxDelay: options["grpc.max_reconnect_backoff_ms"]
        };
        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
          this.handleBackoffTimer();
        }, backoffOptions);
        this.backoffTimeout.unref();
        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);
        this.keepaliveTime = (_a12 = options["grpc.keepalive_time_ms"]) !== null && _a12 !== void 0 ? _a12 : -1;
        if (options["grpc.enable_channelz"] === 0) {
          this.channelzEnabled = false;
          this.channelzTrace = new channelz_1.ChannelzTraceStub();
          this.callTracker = new channelz_1.ChannelzCallTrackerStub();
          this.childrenTracker = new channelz_1.ChannelzChildrenTrackerStub();
          this.streamTracker = new channelz_1.ChannelzCallTrackerStub();
        } else {
          this.channelzTrace = new channelz_1.ChannelzTrace();
          this.callTracker = new channelz_1.ChannelzCallTracker();
          this.childrenTracker = new channelz_1.ChannelzChildrenTracker();
          this.streamTracker = new channelz_1.ChannelzCallTracker();
        }
        this.channelzRef = (0, channelz_1.registerChannelzSubchannel)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);
        this.channelzTrace.addTrace("CT_INFO", "Subchannel created");
        this.trace("Subchannel constructed with options " + JSON.stringify(options, void 0, 2));
        credentials._ref();
      }
      getChannelzInfo() {
        return {
          state: this.connectivityState,
          trace: this.channelzTrace,
          callTracker: this.callTracker,
          children: this.childrenTracker.getChildLists(),
          target: this.subchannelAddressString
        };
      }
      trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
      }
      refTrace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, "subchannel_refcount", "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
      }
      handleBackoffTimer() {
        if (this.continueConnecting) {
          this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);
        } else {
          this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);
        }
      }
      /**
       * Start a backoff timer with the current nextBackoff timeout
       */
      startBackoff() {
        this.backoffTimeout.runOnce();
      }
      stopBackoff() {
        this.backoffTimeout.stop();
        this.backoffTimeout.reset();
      }
      startConnectingInternal() {
        let options = this.options;
        if (options["grpc.keepalive_time_ms"]) {
          const adjustedKeepaliveTime = Math.min(this.keepaliveTime, KEEPALIVE_MAX_TIME_MS);
          options = Object.assign(Object.assign({}, options), { "grpc.keepalive_time_ms": adjustedKeepaliveTime });
        }
        this.connector.connect(this.subchannelAddress, this.credentials, options).then((transport) => {
          if (this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY)) {
            this.transport = transport;
            if (this.channelzEnabled) {
              this.childrenTracker.refChild(transport.getChannelzRef());
            }
            transport.addDisconnectListener((tooManyPings) => {
              this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);
              if (tooManyPings && this.keepaliveTime > 0) {
                this.keepaliveTime *= 2;
                logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${(0, uri_parser_1.uriToString)(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTime} ms`);
              }
            });
          } else {
            transport.shutdown();
          }
        }, (error) => {
          this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, `${error}`);
        });
      }
      /**
       * Initiate a state transition from any element of oldStates to the new
       * state. If the current connectivityState is not in oldStates, do nothing.
       * @param oldStates The set of states to transition from
       * @param newState The state to transition to
       * @returns True if the state changed, false otherwise
       */
      transitionToState(oldStates, newState, errorMessage) {
        var _a12, _b5;
        if (oldStates.indexOf(this.connectivityState) === -1) {
          return false;
        }
        if (errorMessage) {
          this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + " -> " + connectivity_state_1.ConnectivityState[newState] + ' with error "' + errorMessage + '"');
        } else {
          this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + " -> " + connectivity_state_1.ConnectivityState[newState]);
        }
        if (this.channelzEnabled) {
          this.channelzTrace.addTrace("CT_INFO", "Connectivity state change to " + connectivity_state_1.ConnectivityState[newState]);
        }
        const previousState = this.connectivityState;
        this.connectivityState = newState;
        switch (newState) {
          case connectivity_state_1.ConnectivityState.READY:
            this.stopBackoff();
            break;
          case connectivity_state_1.ConnectivityState.CONNECTING:
            this.startBackoff();
            this.startConnectingInternal();
            this.continueConnecting = false;
            break;
          case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:
            if (this.channelzEnabled && this.transport) {
              this.childrenTracker.unrefChild(this.transport.getChannelzRef());
            }
            (_a12 = this.transport) === null || _a12 === void 0 ? void 0 : _a12.shutdown();
            this.transport = null;
            if (!this.backoffTimeout.isRunning()) {
              process.nextTick(() => {
                this.handleBackoffTimer();
              });
            }
            break;
          case connectivity_state_1.ConnectivityState.IDLE:
            if (this.channelzEnabled && this.transport) {
              this.childrenTracker.unrefChild(this.transport.getChannelzRef());
            }
            (_b5 = this.transport) === null || _b5 === void 0 ? void 0 : _b5.shutdown();
            this.transport = null;
            break;
          default:
            throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);
        }
        for (const listener of this.stateListeners) {
          listener(this, previousState, newState, this.keepaliveTime, errorMessage);
        }
        return true;
      }
      ref() {
        this.refTrace("refcount " + this.refcount + " -> " + (this.refcount + 1));
        this.refcount += 1;
      }
      unref() {
        this.refTrace("refcount " + this.refcount + " -> " + (this.refcount - 1));
        this.refcount -= 1;
        if (this.refcount === 0) {
          this.channelzTrace.addTrace("CT_INFO", "Shutting down");
          (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
          this.credentials._unref();
          process.nextTick(() => {
            this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);
          });
        }
      }
      unrefIfOneRef() {
        if (this.refcount === 1) {
          this.unref();
          return true;
        }
        return false;
      }
      createCall(metadata, host, method, listener) {
        if (!this.transport) {
          throw new Error("Cannot create call, subchannel not READY");
        }
        let statsTracker;
        if (this.channelzEnabled) {
          this.callTracker.addCallStarted();
          this.streamTracker.addCallStarted();
          statsTracker = {
            onCallEnd: (status) => {
              if (status.code === constants_1.Status.OK) {
                this.callTracker.addCallSucceeded();
              } else {
                this.callTracker.addCallFailed();
              }
            }
          };
        } else {
          statsTracker = {};
        }
        return this.transport.createCall(metadata, host, method, listener, statsTracker);
      }
      /**
       * If the subchannel is currently IDLE, start connecting and switch to the
       * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,
       * the next time it would transition to IDLE, start connecting again instead.
       * Otherwise, do nothing.
       */
      startConnecting() {
        process.nextTick(() => {
          if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {
            if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
              this.continueConnecting = true;
            }
          }
        });
      }
      /**
       * Get the subchannel's current connectivity state.
       */
      getConnectivityState() {
        return this.connectivityState;
      }
      /**
       * Add a listener function to be called whenever the subchannel's
       * connectivity state changes.
       * @param listener
       */
      addConnectivityStateListener(listener) {
        this.stateListeners.add(listener);
      }
      /**
       * Remove a listener previously added with `addConnectivityStateListener`
       * @param listener A reference to a function previously passed to
       *     `addConnectivityStateListener`
       */
      removeConnectivityStateListener(listener) {
        this.stateListeners.delete(listener);
      }
      /**
       * Reset the backoff timeout, and immediately start connecting if in backoff.
       */
      resetBackoff() {
        process.nextTick(() => {
          this.backoffTimeout.reset();
          this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);
        });
      }
      getAddress() {
        return this.subchannelAddressString;
      }
      getChannelzRef() {
        return this.channelzRef;
      }
      isHealthy() {
        return true;
      }
      addHealthStateWatcher(listener) {
      }
      removeHealthStateWatcher(listener) {
      }
      getRealSubchannel() {
        return this;
      }
      realSubchannelEquals(other) {
        return other.getRealSubchannel() === this;
      }
      throttleKeepalive(newKeepaliveTime) {
        if (newKeepaliveTime > this.keepaliveTime) {
          this.keepaliveTime = newKeepaliveTime;
        }
      }
    };
    exports.Subchannel = Subchannel;
  }
});

// node_modules/@grpc/grpc-js/build/src/environment.js
var require_environment9 = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/environment.js"(exports) {
    "use strict";
    var _a12;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GRPC_NODE_USE_ALTERNATIVE_RESOLVER = void 0;
    exports.GRPC_NODE_USE_ALTERNATIVE_RESOLVER = ((_a12 = process.env.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) !== null && _a12 !== void 0 ? _a12 : "false") === "true";
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver-dns.js
var require_resolver_dns = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolver-dns.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setup = exports.DEFAULT_PORT = void 0;
    var resolver_1 = require_resolver();
    var dns_1 = __require("dns");
    var service_config_1 = require_service_config();
    var constants_1 = require_constants5();
    var metadata_1 = require_metadata();
    var logging = require_logging();
    var constants_2 = require_constants5();
    var uri_parser_1 = require_uri_parser();
    var net_1 = __require("net");
    var backoff_timeout_1 = require_backoff_timeout();
    var environment_1 = require_environment9();
    var TRACER_NAME = "dns_resolver";
    function trace3(text) {
      logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    exports.DEFAULT_PORT = 443;
    var DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 3e4;
    var DnsResolver = class {
      constructor(target, listener, channelOptions) {
        var _a12, _b5, _c4;
        this.target = target;
        this.listener = listener;
        this.pendingLookupPromise = null;
        this.pendingTxtPromise = null;
        this.latestLookupResult = null;
        this.latestServiceConfig = null;
        this.latestServiceConfigError = null;
        this.continueResolving = false;
        this.isNextResolutionTimerRunning = false;
        this.isServiceConfigEnabled = true;
        this.returnedIpResult = false;
        this.alternativeResolver = new dns_1.promises.Resolver();
        trace3("Resolver constructed for target " + (0, uri_parser_1.uriToString)(target));
        if (target.authority) {
          this.alternativeResolver.setServers([target.authority]);
        }
        const hostPort = (0, uri_parser_1.splitHostPort)(target.path);
        if (hostPort === null) {
          this.ipResult = null;
          this.dnsHostname = null;
          this.port = null;
        } else {
          if ((0, net_1.isIPv4)(hostPort.host) || (0, net_1.isIPv6)(hostPort.host)) {
            this.ipResult = [
              {
                addresses: [
                  {
                    host: hostPort.host,
                    port: (_a12 = hostPort.port) !== null && _a12 !== void 0 ? _a12 : exports.DEFAULT_PORT
                  }
                ]
              }
            ];
            this.dnsHostname = null;
            this.port = null;
          } else {
            this.ipResult = null;
            this.dnsHostname = hostPort.host;
            this.port = (_b5 = hostPort.port) !== null && _b5 !== void 0 ? _b5 : exports.DEFAULT_PORT;
          }
        }
        this.percentage = Math.random() * 100;
        if (channelOptions["grpc.service_config_disable_resolution"] === 1) {
          this.isServiceConfigEnabled = false;
        }
        this.defaultResolutionError = {
          code: constants_1.Status.UNAVAILABLE,
          details: `Name resolution failed for target ${(0, uri_parser_1.uriToString)(this.target)}`,
          metadata: new metadata_1.Metadata()
        };
        const backoffOptions = {
          initialDelay: channelOptions["grpc.initial_reconnect_backoff_ms"],
          maxDelay: channelOptions["grpc.max_reconnect_backoff_ms"]
        };
        this.backoff = new backoff_timeout_1.BackoffTimeout(() => {
          if (this.continueResolving) {
            this.startResolutionWithBackoff();
          }
        }, backoffOptions);
        this.backoff.unref();
        this.minTimeBetweenResolutionsMs = (_c4 = channelOptions["grpc.dns_min_time_between_resolutions_ms"]) !== null && _c4 !== void 0 ? _c4 : DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;
        this.nextResolutionTimer = setTimeout(() => {
        }, 0);
        clearTimeout(this.nextResolutionTimer);
      }
      /**
       * If the target is an IP address, just provide that address as a result.
       * Otherwise, initiate A, AAAA, and TXT lookups
       */
      startResolution() {
        if (this.ipResult !== null) {
          if (!this.returnedIpResult) {
            trace3("Returning IP address for target " + (0, uri_parser_1.uriToString)(this.target));
            setImmediate(() => {
              this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});
            });
            this.returnedIpResult = true;
          }
          this.backoff.stop();
          this.backoff.reset();
          this.stopNextResolutionTimer();
          return;
        }
        if (this.dnsHostname === null) {
          trace3("Failed to parse DNS address " + (0, uri_parser_1.uriToString)(this.target));
          setImmediate(() => {
            this.listener.onError({
              code: constants_1.Status.UNAVAILABLE,
              details: `Failed to parse DNS address ${(0, uri_parser_1.uriToString)(this.target)}`,
              metadata: new metadata_1.Metadata()
            });
          });
          this.stopNextResolutionTimer();
        } else {
          if (this.pendingLookupPromise !== null) {
            return;
          }
          trace3("Looking up DNS hostname " + this.dnsHostname);
          this.latestLookupResult = null;
          const hostname = this.dnsHostname;
          this.pendingLookupPromise = this.lookup(hostname);
          this.pendingLookupPromise.then((addressList) => {
            if (this.pendingLookupPromise === null) {
              return;
            }
            this.pendingLookupPromise = null;
            this.backoff.reset();
            this.backoff.stop();
            this.latestLookupResult = addressList.map((address) => ({
              addresses: [address]
            }));
            const allAddressesString = "[" + addressList.map((addr) => addr.host + ":" + addr.port).join(",") + "]";
            trace3("Resolved addresses for target " + (0, uri_parser_1.uriToString)(this.target) + ": " + allAddressesString);
            if (this.latestLookupResult.length === 0) {
              this.listener.onError(this.defaultResolutionError);
              return;
            }
            this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});
          }, (err) => {
            if (this.pendingLookupPromise === null) {
              return;
            }
            trace3("Resolution error for target " + (0, uri_parser_1.uriToString)(this.target) + ": " + err.message);
            this.pendingLookupPromise = null;
            this.stopNextResolutionTimer();
            this.listener.onError(this.defaultResolutionError);
          });
          if (this.isServiceConfigEnabled && this.pendingTxtPromise === null) {
            this.pendingTxtPromise = this.resolveTxt(hostname);
            this.pendingTxtPromise.then((txtRecord) => {
              if (this.pendingTxtPromise === null) {
                return;
              }
              this.pendingTxtPromise = null;
              try {
                this.latestServiceConfig = (0, service_config_1.extractAndSelectServiceConfig)(txtRecord, this.percentage);
              } catch (err) {
                this.latestServiceConfigError = {
                  code: constants_1.Status.UNAVAILABLE,
                  details: `Parsing service config failed with error ${err.message}`,
                  metadata: new metadata_1.Metadata()
                };
              }
              if (this.latestLookupResult !== null) {
                this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});
              }
            }, (err) => {
            });
          }
        }
      }
      async lookup(hostname) {
        if (environment_1.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) {
          trace3("Using alternative DNS resolver.");
          const records = await Promise.allSettled([
            this.alternativeResolver.resolve4(hostname),
            this.alternativeResolver.resolve6(hostname)
          ]);
          if (records.every((result4) => result4.status === "rejected")) {
            throw new Error(records[0].reason);
          }
          return records.reduce((acc, result4) => {
            return result4.status === "fulfilled" ? [...acc, ...result4.value] : acc;
          }, []).map((addr) => ({
            host: addr,
            port: +this.port
          }));
        }
        const addressList = await dns_1.promises.lookup(hostname, { all: true });
        return addressList.map((addr) => ({ host: addr.address, port: +this.port }));
      }
      async resolveTxt(hostname) {
        if (environment_1.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) {
          trace3("Using alternative DNS resolver.");
          return this.alternativeResolver.resolveTxt(hostname);
        }
        return dns_1.promises.resolveTxt(hostname);
      }
      startNextResolutionTimer() {
        var _a12, _b5;
        clearTimeout(this.nextResolutionTimer);
        this.nextResolutionTimer = setTimeout(() => {
          this.stopNextResolutionTimer();
          if (this.continueResolving) {
            this.startResolutionWithBackoff();
          }
        }, this.minTimeBetweenResolutionsMs);
        (_b5 = (_a12 = this.nextResolutionTimer).unref) === null || _b5 === void 0 ? void 0 : _b5.call(_a12);
        this.isNextResolutionTimerRunning = true;
      }
      stopNextResolutionTimer() {
        clearTimeout(this.nextResolutionTimer);
        this.isNextResolutionTimerRunning = false;
      }
      startResolutionWithBackoff() {
        if (this.pendingLookupPromise === null) {
          this.continueResolving = false;
          this.backoff.runOnce();
          this.startNextResolutionTimer();
          this.startResolution();
        }
      }
      updateResolution() {
        if (this.pendingLookupPromise === null) {
          if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {
            if (this.isNextResolutionTimerRunning) {
              trace3('resolution update delayed by "min time between resolutions" rate limit');
            } else {
              trace3("resolution update delayed by backoff timer until " + this.backoff.getEndTime().toISOString());
            }
            this.continueResolving = true;
          } else {
            this.startResolutionWithBackoff();
          }
        }
      }
      /**
       * Reset the resolver to the same state it had when it was created. In-flight
       * DNS requests cannot be cancelled, but they are discarded and their results
       * will be ignored.
       */
      destroy() {
        this.continueResolving = false;
        this.backoff.reset();
        this.backoff.stop();
        this.stopNextResolutionTimer();
        this.pendingLookupPromise = null;
        this.pendingTxtPromise = null;
        this.latestLookupResult = null;
        this.latestServiceConfig = null;
        this.latestServiceConfigError = null;
        this.returnedIpResult = false;
      }
      /**
       * Get the default authority for the given target. For IP targets, that is
       * the IP address. For DNS targets, it is the hostname.
       * @param target
       */
      static getDefaultAuthority(target) {
        return target.path;
      }
    };
    function setup() {
      (0, resolver_1.registerResolver)("dns", DnsResolver);
      (0, resolver_1.registerDefaultScheme)("dns");
    }
    exports.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/http_proxy.js
var require_http_proxy = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/http_proxy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getProxiedConnection = exports.mapProxyName = void 0;
    var logging_1 = require_logging();
    var constants_1 = require_constants5();
    var resolver_1 = require_resolver();
    var http = __require("http");
    var tls = __require("tls");
    var logging = require_logging();
    var subchannel_address_1 = require_subchannel_address();
    var uri_parser_1 = require_uri_parser();
    var url_1 = __require("url");
    var resolver_dns_1 = require_resolver_dns();
    var TRACER_NAME = "proxy";
    function trace3(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    function getProxyInfo() {
      let proxyEnv = "";
      let envVar = "";
      if (process.env.grpc_proxy) {
        envVar = "grpc_proxy";
        proxyEnv = process.env.grpc_proxy;
      } else if (process.env.https_proxy) {
        envVar = "https_proxy";
        proxyEnv = process.env.https_proxy;
      } else if (process.env.http_proxy) {
        envVar = "http_proxy";
        proxyEnv = process.env.http_proxy;
      } else {
        return {};
      }
      let proxyUrl;
      try {
        proxyUrl = new url_1.URL(proxyEnv);
      } catch (e2) {
        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `cannot parse value of "${envVar}" env var`);
        return {};
      }
      if (proxyUrl.protocol !== "http:") {
        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `"${proxyUrl.protocol}" scheme not supported in proxy URI`);
        return {};
      }
      let userCred = null;
      if (proxyUrl.username) {
        if (proxyUrl.password) {
          (0, logging_1.log)(constants_1.LogVerbosity.INFO, "userinfo found in proxy URI");
          userCred = decodeURIComponent(`${proxyUrl.username}:${proxyUrl.password}`);
        } else {
          userCred = proxyUrl.username;
        }
      }
      const hostname = proxyUrl.hostname;
      let port = proxyUrl.port;
      if (port === "") {
        port = "80";
      }
      const result4 = {
        address: `${hostname}:${port}`
      };
      if (userCred) {
        result4.creds = userCred;
      }
      trace3("Proxy server " + result4.address + " set by environment variable " + envVar);
      return result4;
    }
    function getNoProxyHostList() {
      let noProxyStr = process.env.no_grpc_proxy;
      let envVar = "no_grpc_proxy";
      if (!noProxyStr) {
        noProxyStr = process.env.no_proxy;
        envVar = "no_proxy";
      }
      if (noProxyStr) {
        trace3("No proxy server list set by environment variable " + envVar);
        return noProxyStr.split(",");
      } else {
        return [];
      }
    }
    function mapProxyName(target, options) {
      var _a12;
      const noProxyResult = {
        target,
        extraOptions: {}
      };
      if (((_a12 = options["grpc.enable_http_proxy"]) !== null && _a12 !== void 0 ? _a12 : 1) === 0) {
        return noProxyResult;
      }
      if (target.scheme === "unix") {
        return noProxyResult;
      }
      const proxyInfo = getProxyInfo();
      if (!proxyInfo.address) {
        return noProxyResult;
      }
      const hostPort = (0, uri_parser_1.splitHostPort)(target.path);
      if (!hostPort) {
        return noProxyResult;
      }
      const serverHost = hostPort.host;
      for (const host of getNoProxyHostList()) {
        if (host === serverHost) {
          trace3("Not using proxy for target in no_proxy list: " + (0, uri_parser_1.uriToString)(target));
          return noProxyResult;
        }
      }
      const extraOptions = {
        "grpc.http_connect_target": (0, uri_parser_1.uriToString)(target)
      };
      if (proxyInfo.creds) {
        extraOptions["grpc.http_connect_creds"] = proxyInfo.creds;
      }
      return {
        target: {
          scheme: "dns",
          path: proxyInfo.address
        },
        extraOptions
      };
    }
    exports.mapProxyName = mapProxyName;
    function getProxiedConnection(address, channelOptions, connectionOptions) {
      var _a12;
      if (!("grpc.http_connect_target" in channelOptions)) {
        return Promise.resolve({});
      }
      const realTarget = channelOptions["grpc.http_connect_target"];
      const parsedTarget = (0, uri_parser_1.parseUri)(realTarget);
      if (parsedTarget === null) {
        return Promise.resolve({});
      }
      const splitHostPost = (0, uri_parser_1.splitHostPort)(parsedTarget.path);
      if (splitHostPost === null) {
        return Promise.resolve({});
      }
      const hostPort = `${splitHostPost.host}:${(_a12 = splitHostPost.port) !== null && _a12 !== void 0 ? _a12 : resolver_dns_1.DEFAULT_PORT}`;
      const options = {
        method: "CONNECT",
        path: hostPort
      };
      const headers = {
        Host: hostPort
      };
      if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {
        options.host = address.host;
        options.port = address.port;
      } else {
        options.socketPath = address.path;
      }
      if ("grpc.http_connect_creds" in channelOptions) {
        headers["Proxy-Authorization"] = "Basic " + Buffer.from(channelOptions["grpc.http_connect_creds"]).toString("base64");
      }
      options.headers = headers;
      const proxyAddressString = (0, subchannel_address_1.subchannelAddressToString)(address);
      trace3("Using proxy " + proxyAddressString + " to connect to " + options.path);
      return new Promise((resolve, reject3) => {
        const request = http.request(options);
        request.once("connect", (res, socket, head6) => {
          var _a13;
          request.removeAllListeners();
          socket.removeAllListeners();
          if (res.statusCode === 200) {
            trace3("Successfully connected to " + options.path + " through proxy " + proxyAddressString);
            if (head6.length > 0) {
              socket.unshift(head6);
            }
            if ("secureContext" in connectionOptions) {
              const targetPath = (0, resolver_1.getDefaultAuthority)(parsedTarget);
              const hostPort2 = (0, uri_parser_1.splitHostPort)(targetPath);
              const remoteHost = (_a13 = hostPort2 === null || hostPort2 === void 0 ? void 0 : hostPort2.host) !== null && _a13 !== void 0 ? _a13 : targetPath;
              const cts = tls.connect(Object.assign({ host: remoteHost, servername: remoteHost, socket }, connectionOptions), () => {
                trace3("Successfully established a TLS connection to " + options.path + " through proxy " + proxyAddressString);
                resolve({ socket: cts, realTarget: parsedTarget });
              });
              cts.on("error", (error) => {
                trace3("Failed to establish a TLS connection to " + options.path + " through proxy " + proxyAddressString + " with error " + error.message);
                reject3();
              });
            } else {
              trace3("Successfully established a plaintext connection to " + options.path + " through proxy " + proxyAddressString);
              resolve({
                socket,
                realTarget: parsedTarget
              });
            }
          } else {
            (0, logging_1.log)(constants_1.LogVerbosity.ERROR, "Failed to connect to " + options.path + " through proxy " + proxyAddressString + " with status " + res.statusCode);
            reject3();
          }
        });
        request.once("error", (err) => {
          request.removeAllListeners();
          (0, logging_1.log)(constants_1.LogVerbosity.ERROR, "Failed to connect to proxy " + proxyAddressString + " with error " + err.message);
          reject3();
        });
        request.end();
      });
    }
    exports.getProxiedConnection = getProxiedConnection;
  }
});

// node_modules/@grpc/grpc-js/build/src/stream-decoder.js
var require_stream_decoder = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/stream-decoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StreamDecoder = void 0;
    var ReadState;
    (function(ReadState2) {
      ReadState2[ReadState2["NO_DATA"] = 0] = "NO_DATA";
      ReadState2[ReadState2["READING_SIZE"] = 1] = "READING_SIZE";
      ReadState2[ReadState2["READING_MESSAGE"] = 2] = "READING_MESSAGE";
    })(ReadState || (ReadState = {}));
    var StreamDecoder = class {
      constructor(maxReadMessageLength) {
        this.maxReadMessageLength = maxReadMessageLength;
        this.readState = ReadState.NO_DATA;
        this.readCompressFlag = Buffer.alloc(1);
        this.readPartialSize = Buffer.alloc(4);
        this.readSizeRemaining = 4;
        this.readMessageSize = 0;
        this.readPartialMessage = [];
        this.readMessageRemaining = 0;
      }
      write(data) {
        let readHead = 0;
        let toRead;
        const result4 = [];
        while (readHead < data.length) {
          switch (this.readState) {
            case ReadState.NO_DATA:
              this.readCompressFlag = data.slice(readHead, readHead + 1);
              readHead += 1;
              this.readState = ReadState.READING_SIZE;
              this.readPartialSize.fill(0);
              this.readSizeRemaining = 4;
              this.readMessageSize = 0;
              this.readMessageRemaining = 0;
              this.readPartialMessage = [];
              break;
            case ReadState.READING_SIZE:
              toRead = Math.min(data.length - readHead, this.readSizeRemaining);
              data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);
              this.readSizeRemaining -= toRead;
              readHead += toRead;
              if (this.readSizeRemaining === 0) {
                this.readMessageSize = this.readPartialSize.readUInt32BE(0);
                if (this.maxReadMessageLength !== -1 && this.readMessageSize > this.maxReadMessageLength) {
                  throw new Error(`Received message larger than max (${this.readMessageSize} vs ${this.maxReadMessageLength})`);
                }
                this.readMessageRemaining = this.readMessageSize;
                if (this.readMessageRemaining > 0) {
                  this.readState = ReadState.READING_MESSAGE;
                } else {
                  const message = Buffer.concat([this.readCompressFlag, this.readPartialSize], 5);
                  this.readState = ReadState.NO_DATA;
                  result4.push(message);
                }
              }
              break;
            case ReadState.READING_MESSAGE:
              toRead = Math.min(data.length - readHead, this.readMessageRemaining);
              this.readPartialMessage.push(data.slice(readHead, readHead + toRead));
              this.readMessageRemaining -= toRead;
              readHead += toRead;
              if (this.readMessageRemaining === 0) {
                const framedMessageBuffers = [
                  this.readCompressFlag,
                  this.readPartialSize
                ].concat(this.readPartialMessage);
                const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);
                this.readState = ReadState.NO_DATA;
                result4.push(framedMessage);
              }
              break;
            default:
              throw new Error("Unexpected read state");
          }
        }
        return result4;
      }
    };
    exports.StreamDecoder = StreamDecoder;
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel-call.js
var require_subchannel_call = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/subchannel-call.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Http2SubchannelCall = void 0;
    var http2 = __require("http2");
    var os3 = __require("os");
    var constants_1 = require_constants5();
    var metadata_1 = require_metadata();
    var stream_decoder_1 = require_stream_decoder();
    var logging = require_logging();
    var constants_2 = require_constants5();
    var TRACER_NAME = "subchannel_call";
    function getSystemErrorName(errno) {
      for (const [name, num] of Object.entries(os3.constants.errno)) {
        if (num === errno) {
          return name;
        }
      }
      return "Unknown system error " + errno;
    }
    function mapHttpStatusCode(code) {
      const details = `Received HTTP status code ${code}`;
      let mappedStatusCode;
      switch (code) {
        case 400:
          mappedStatusCode = constants_1.Status.INTERNAL;
          break;
        case 401:
          mappedStatusCode = constants_1.Status.UNAUTHENTICATED;
          break;
        case 403:
          mappedStatusCode = constants_1.Status.PERMISSION_DENIED;
          break;
        case 404:
          mappedStatusCode = constants_1.Status.UNIMPLEMENTED;
          break;
        case 429:
        case 502:
        case 503:
        case 504:
          mappedStatusCode = constants_1.Status.UNAVAILABLE;
          break;
        default:
          mappedStatusCode = constants_1.Status.UNKNOWN;
      }
      return {
        code: mappedStatusCode,
        details,
        metadata: new metadata_1.Metadata()
      };
    }
    var Http2SubchannelCall = class {
      constructor(http2Stream, callEventTracker, listener, transport, callId) {
        var _a12;
        this.http2Stream = http2Stream;
        this.callEventTracker = callEventTracker;
        this.listener = listener;
        this.transport = transport;
        this.callId = callId;
        this.isReadFilterPending = false;
        this.isPushPending = false;
        this.canPush = false;
        this.readsClosed = false;
        this.statusOutput = false;
        this.unpushedReadMessages = [];
        this.finalStatus = null;
        this.internalError = null;
        this.serverEndedCall = false;
        this.connectionDropped = false;
        const maxReceiveMessageLength = (_a12 = transport.getOptions()["grpc.max_receive_message_length"]) !== null && _a12 !== void 0 ? _a12 : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
        this.decoder = new stream_decoder_1.StreamDecoder(maxReceiveMessageLength);
        http2Stream.on("response", (headers, flags) => {
          let headersString = "";
          for (const header of Object.keys(headers)) {
            headersString += "		" + header + ": " + headers[header] + "\n";
          }
          this.trace("Received server headers:\n" + headersString);
          this.httpStatusCode = headers[":status"];
          if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {
            this.handleTrailers(headers);
          } else {
            let metadata;
            try {
              metadata = metadata_1.Metadata.fromHttp2Headers(headers);
            } catch (error) {
              this.endCall({
                code: constants_1.Status.UNKNOWN,
                details: error.message,
                metadata: new metadata_1.Metadata()
              });
              return;
            }
            this.listener.onReceiveMetadata(metadata);
          }
        });
        http2Stream.on("trailers", (headers) => {
          this.handleTrailers(headers);
        });
        http2Stream.on("data", (data) => {
          if (this.statusOutput) {
            return;
          }
          this.trace("receive HTTP/2 data frame of length " + data.length);
          let messages;
          try {
            messages = this.decoder.write(data);
          } catch (e2) {
            if (this.httpStatusCode !== void 0 && this.httpStatusCode !== 200) {
              const mappedStatus = mapHttpStatusCode(this.httpStatusCode);
              this.cancelWithStatus(mappedStatus.code, mappedStatus.details);
            } else {
              this.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, e2.message);
            }
            return;
          }
          for (const message of messages) {
            this.trace("parsed message of length " + message.length);
            this.callEventTracker.addMessageReceived();
            this.tryPush(message);
          }
        });
        http2Stream.on("end", () => {
          this.readsClosed = true;
          this.maybeOutputStatus();
        });
        http2Stream.on("close", () => {
          this.serverEndedCall = true;
          process.nextTick(() => {
            var _a13;
            this.trace("HTTP/2 stream closed with code " + http2Stream.rstCode);
            if (((_a13 = this.finalStatus) === null || _a13 === void 0 ? void 0 : _a13.code) === constants_1.Status.OK) {
              return;
            }
            let code;
            let details = "";
            switch (http2Stream.rstCode) {
              case http2.constants.NGHTTP2_NO_ERROR:
                if (this.finalStatus !== null) {
                  return;
                }
                if (this.httpStatusCode && this.httpStatusCode !== 200) {
                  const mappedStatus = mapHttpStatusCode(this.httpStatusCode);
                  code = mappedStatus.code;
                  details = mappedStatus.details;
                } else {
                  code = constants_1.Status.INTERNAL;
                  details = `Received RST_STREAM with code ${http2Stream.rstCode} (Call ended without gRPC status)`;
                }
                break;
              case http2.constants.NGHTTP2_REFUSED_STREAM:
                code = constants_1.Status.UNAVAILABLE;
                details = "Stream refused by server";
                break;
              case http2.constants.NGHTTP2_CANCEL:
                if (this.connectionDropped) {
                  code = constants_1.Status.UNAVAILABLE;
                  details = "Connection dropped";
                } else {
                  code = constants_1.Status.CANCELLED;
                  details = "Call cancelled";
                }
                break;
              case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:
                code = constants_1.Status.RESOURCE_EXHAUSTED;
                details = "Bandwidth exhausted or memory limit exceeded";
                break;
              case http2.constants.NGHTTP2_INADEQUATE_SECURITY:
                code = constants_1.Status.PERMISSION_DENIED;
                details = "Protocol not secure enough";
                break;
              case http2.constants.NGHTTP2_INTERNAL_ERROR:
                code = constants_1.Status.INTERNAL;
                if (this.internalError === null) {
                  details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;
                } else {
                  if (this.internalError.code === "ECONNRESET" || this.internalError.code === "ETIMEDOUT") {
                    code = constants_1.Status.UNAVAILABLE;
                    details = this.internalError.message;
                  } else {
                    details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;
                  }
                }
                break;
              default:
                code = constants_1.Status.INTERNAL;
                details = `Received RST_STREAM with code ${http2Stream.rstCode}`;
            }
            this.endCall({
              code,
              details,
              metadata: new metadata_1.Metadata(),
              rstCode: http2Stream.rstCode
            });
          });
        });
        http2Stream.on("error", (err) => {
          if (err.code !== "ERR_HTTP2_STREAM_ERROR") {
            this.trace("Node error event: message=" + err.message + " code=" + err.code + " errno=" + getSystemErrorName(err.errno) + " syscall=" + err.syscall);
            this.internalError = err;
          }
          this.callEventTracker.onStreamEnd(false);
        });
      }
      getDeadlineInfo() {
        return [`remote_addr=${this.getPeer()}`];
      }
      onDisconnect() {
        this.connectionDropped = true;
        setImmediate(() => {
          this.endCall({
            code: constants_1.Status.UNAVAILABLE,
            details: "Connection dropped",
            metadata: new metadata_1.Metadata()
          });
        });
      }
      outputStatus() {
        if (!this.statusOutput) {
          this.statusOutput = true;
          this.trace("ended with status: code=" + this.finalStatus.code + ' details="' + this.finalStatus.details + '"');
          this.callEventTracker.onCallEnd(this.finalStatus);
          process.nextTick(() => {
            this.listener.onReceiveStatus(this.finalStatus);
          });
          this.http2Stream.resume();
        }
      }
      trace(text) {
        logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, "[" + this.callId + "] " + text);
      }
      /**
       * On first call, emits a 'status' event with the given StatusObject.
       * Subsequent calls are no-ops.
       * @param status The status of the call.
       */
      endCall(status) {
        if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {
          this.finalStatus = status;
          this.maybeOutputStatus();
        }
        this.destroyHttp2Stream();
      }
      maybeOutputStatus() {
        if (this.finalStatus !== null) {
          if (this.finalStatus.code !== constants_1.Status.OK || this.readsClosed && this.unpushedReadMessages.length === 0 && !this.isReadFilterPending && !this.isPushPending) {
            this.outputStatus();
          }
        }
      }
      push(message) {
        this.trace("pushing to reader message of length " + (message instanceof Buffer ? message.length : null));
        this.canPush = false;
        this.isPushPending = true;
        process.nextTick(() => {
          this.isPushPending = false;
          if (this.statusOutput) {
            return;
          }
          this.listener.onReceiveMessage(message);
          this.maybeOutputStatus();
        });
      }
      tryPush(messageBytes) {
        if (this.canPush) {
          this.http2Stream.pause();
          this.push(messageBytes);
        } else {
          this.trace("unpushedReadMessages.push message of length " + messageBytes.length);
          this.unpushedReadMessages.push(messageBytes);
        }
      }
      handleTrailers(headers) {
        this.serverEndedCall = true;
        this.callEventTracker.onStreamEnd(true);
        let headersString = "";
        for (const header of Object.keys(headers)) {
          headersString += "		" + header + ": " + headers[header] + "\n";
        }
        this.trace("Received server trailers:\n" + headersString);
        let metadata;
        try {
          metadata = metadata_1.Metadata.fromHttp2Headers(headers);
        } catch (e2) {
          metadata = new metadata_1.Metadata();
        }
        const metadataMap = metadata.getMap();
        let status;
        if (typeof metadataMap["grpc-status"] === "string") {
          const receivedStatus = Number(metadataMap["grpc-status"]);
          this.trace("received status code " + receivedStatus + " from server");
          metadata.remove("grpc-status");
          let details = "";
          if (typeof metadataMap["grpc-message"] === "string") {
            try {
              details = decodeURI(metadataMap["grpc-message"]);
            } catch (e2) {
              details = metadataMap["grpc-message"];
            }
            metadata.remove("grpc-message");
            this.trace('received status details string "' + details + '" from server');
          }
          status = {
            code: receivedStatus,
            details,
            metadata
          };
        } else if (this.httpStatusCode) {
          status = mapHttpStatusCode(this.httpStatusCode);
          status.metadata = metadata;
        } else {
          status = {
            code: constants_1.Status.UNKNOWN,
            details: "No status information received",
            metadata
          };
        }
        this.endCall(status);
      }
      destroyHttp2Stream() {
        var _a12;
        if (this.http2Stream.destroyed) {
          return;
        }
        if (this.serverEndedCall) {
          this.http2Stream.end();
        } else {
          let code;
          if (((_a12 = this.finalStatus) === null || _a12 === void 0 ? void 0 : _a12.code) === constants_1.Status.OK) {
            code = http2.constants.NGHTTP2_NO_ERROR;
          } else {
            code = http2.constants.NGHTTP2_CANCEL;
          }
          this.trace("close http2 stream with code " + code);
          this.http2Stream.close(code);
        }
      }
      cancelWithStatus(status, details) {
        this.trace("cancelWithStatus code: " + status + ' details: "' + details + '"');
        this.endCall({ code: status, details, metadata: new metadata_1.Metadata() });
      }
      getStatus() {
        return this.finalStatus;
      }
      getPeer() {
        return this.transport.getPeerName();
      }
      getCallNumber() {
        return this.callId;
      }
      startRead() {
        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {
          this.readsClosed = true;
          this.maybeOutputStatus();
          return;
        }
        this.canPush = true;
        if (this.unpushedReadMessages.length > 0) {
          const nextMessage = this.unpushedReadMessages.shift();
          this.push(nextMessage);
          return;
        }
        this.http2Stream.resume();
      }
      sendMessageWithContext(context3, message) {
        this.trace("write() called with message of length " + message.length);
        const cb = (error) => {
          process.nextTick(() => {
            var _a12;
            let code = constants_1.Status.UNAVAILABLE;
            if ((error === null || error === void 0 ? void 0 : error.code) === "ERR_STREAM_WRITE_AFTER_END") {
              code = constants_1.Status.INTERNAL;
            }
            if (error) {
              this.cancelWithStatus(code, `Write error: ${error.message}`);
            }
            (_a12 = context3.callback) === null || _a12 === void 0 ? void 0 : _a12.call(context3);
          });
        };
        this.trace("sending data chunk of length " + message.length);
        this.callEventTracker.addMessageSent();
        try {
          this.http2Stream.write(message, cb);
        } catch (error) {
          this.endCall({
            code: constants_1.Status.UNAVAILABLE,
            details: `Write failed with error ${error.message}`,
            metadata: new metadata_1.Metadata()
          });
        }
      }
      halfClose() {
        this.trace("end() called");
        this.trace("calling end() on HTTP/2 stream");
        this.http2Stream.end();
      }
    };
    exports.Http2SubchannelCall = Http2SubchannelCall;
  }
});

// node_modules/@grpc/grpc-js/build/src/call-number.js
var require_call_number = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/call-number.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNextCallNumber = void 0;
    var nextCallNumber = 0;
    function getNextCallNumber() {
      return nextCallNumber++;
    }
    exports.getNextCallNumber = getNextCallNumber;
  }
});

// node_modules/@grpc/grpc-js/build/src/transport.js
var require_transport = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/transport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Http2SubchannelConnector = void 0;
    var http2 = __require("http2");
    var tls_1 = __require("tls");
    var channelz_1 = require_channelz();
    var constants_1 = require_constants5();
    var http_proxy_1 = require_http_proxy();
    var logging = require_logging();
    var resolver_1 = require_resolver();
    var subchannel_address_1 = require_subchannel_address();
    var uri_parser_1 = require_uri_parser();
    var net = __require("net");
    var subchannel_call_1 = require_subchannel_call();
    var call_number_1 = require_call_number();
    var TRACER_NAME = "transport";
    var FLOW_CONTROL_TRACER_NAME = "transport_flowctrl";
    var clientVersion = require_package().version;
    var { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT } = http2.constants;
    var KEEPALIVE_TIMEOUT_MS = 2e4;
    var tooManyPingsData = Buffer.from("too_many_pings", "ascii");
    var Http2Transport = class {
      constructor(session, subchannelAddress, options, remoteName) {
        this.session = session;
        this.options = options;
        this.remoteName = remoteName;
        this.keepaliveTimer = null;
        this.pendingSendKeepalivePing = false;
        this.activeCalls = /* @__PURE__ */ new Set();
        this.disconnectListeners = [];
        this.disconnectHandled = false;
        this.channelzEnabled = true;
        this.keepalivesSent = 0;
        this.messagesSent = 0;
        this.messagesReceived = 0;
        this.lastMessageSentTimestamp = null;
        this.lastMessageReceivedTimestamp = null;
        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);
        if (options["grpc.enable_channelz"] === 0) {
          this.channelzEnabled = false;
          this.streamTracker = new channelz_1.ChannelzCallTrackerStub();
        } else {
          this.streamTracker = new channelz_1.ChannelzCallTracker();
        }
        this.channelzRef = (0, channelz_1.registerChannelzSocket)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);
        this.userAgent = [
          options["grpc.primary_user_agent"],
          `grpc-node-js/${clientVersion}`,
          options["grpc.secondary_user_agent"]
        ].filter((e2) => e2).join(" ");
        if ("grpc.keepalive_time_ms" in options) {
          this.keepaliveTimeMs = options["grpc.keepalive_time_ms"];
        } else {
          this.keepaliveTimeMs = -1;
        }
        if ("grpc.keepalive_timeout_ms" in options) {
          this.keepaliveTimeoutMs = options["grpc.keepalive_timeout_ms"];
        } else {
          this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;
        }
        if ("grpc.keepalive_permit_without_calls" in options) {
          this.keepaliveWithoutCalls = options["grpc.keepalive_permit_without_calls"] === 1;
        } else {
          this.keepaliveWithoutCalls = false;
        }
        session.once("close", () => {
          this.trace("session closed");
          this.handleDisconnect();
        });
        session.once("goaway", (errorCode, lastStreamID, opaqueData) => {
          let tooManyPings = false;
          if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData && opaqueData.equals(tooManyPingsData)) {
            tooManyPings = true;
          }
          this.trace("connection closed by GOAWAY with code " + errorCode + " and data " + (opaqueData === null || opaqueData === void 0 ? void 0 : opaqueData.toString()));
          this.reportDisconnectToOwner(tooManyPings);
        });
        session.once("error", (error) => {
          this.trace("connection closed with error " + error.message);
          this.handleDisconnect();
        });
        session.socket.once("close", () => {
          this.trace("connection closed");
          this.handleDisconnect();
        });
        if (logging.isTracerEnabled(TRACER_NAME)) {
          session.on("remoteSettings", (settings) => {
            this.trace("new settings received" + (this.session !== session ? " on the old connection" : "") + ": " + JSON.stringify(settings));
          });
          session.on("localSettings", (settings) => {
            this.trace("local settings acknowledged by remote" + (this.session !== session ? " on the old connection" : "") + ": " + JSON.stringify(settings));
          });
        }
        if (this.keepaliveWithoutCalls) {
          this.maybeStartKeepalivePingTimer();
        }
      }
      getChannelzInfo() {
        var _a12, _b5, _c4;
        const sessionSocket = this.session.socket;
        const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;
        const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;
        let tlsInfo;
        if (this.session.encrypted) {
          const tlsSocket = sessionSocket;
          const cipherInfo = tlsSocket.getCipher();
          const certificate = tlsSocket.getCertificate();
          const peerCertificate = tlsSocket.getPeerCertificate();
          tlsInfo = {
            cipherSuiteStandardName: (_a12 = cipherInfo.standardName) !== null && _a12 !== void 0 ? _a12 : null,
            cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,
            localCertificate: certificate && "raw" in certificate ? certificate.raw : null,
            remoteCertificate: peerCertificate && "raw" in peerCertificate ? peerCertificate.raw : null
          };
        } else {
          tlsInfo = null;
        }
        const socketInfo = {
          remoteAddress,
          localAddress,
          security: tlsInfo,
          remoteName: this.remoteName,
          streamsStarted: this.streamTracker.callsStarted,
          streamsSucceeded: this.streamTracker.callsSucceeded,
          streamsFailed: this.streamTracker.callsFailed,
          messagesSent: this.messagesSent,
          messagesReceived: this.messagesReceived,
          keepAlivesSent: this.keepalivesSent,
          lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,
          lastRemoteStreamCreatedTimestamp: null,
          lastMessageSentTimestamp: this.lastMessageSentTimestamp,
          lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,
          localFlowControlWindow: (_b5 = this.session.state.localWindowSize) !== null && _b5 !== void 0 ? _b5 : null,
          remoteFlowControlWindow: (_c4 = this.session.state.remoteWindowSize) !== null && _c4 !== void 0 ? _c4 : null
        };
        return socketInfo;
      }
      trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
      }
      keepaliveTrace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, "keepalive", "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
      }
      flowControlTrace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
      }
      internalsTrace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, "transport_internals", "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
      }
      /**
       * Indicate to the owner of this object that this transport should no longer
       * be used. That happens if the connection drops, or if the server sends a
       * GOAWAY.
       * @param tooManyPings If true, this was triggered by a GOAWAY with data
       * indicating that the session was closed becaues the client sent too many
       * pings.
       * @returns
       */
      reportDisconnectToOwner(tooManyPings) {
        if (this.disconnectHandled) {
          return;
        }
        this.disconnectHandled = true;
        this.disconnectListeners.forEach((listener) => listener(tooManyPings));
      }
      /**
       * Handle connection drops, but not GOAWAYs.
       */
      handleDisconnect() {
        this.clearKeepaliveTimeout();
        this.reportDisconnectToOwner(false);
        for (const call of this.activeCalls) {
          call.onDisconnect();
        }
        setImmediate(() => {
          this.session.destroy();
        });
      }
      addDisconnectListener(listener) {
        this.disconnectListeners.push(listener);
      }
      canSendPing() {
        return !this.session.destroyed && this.keepaliveTimeMs > 0 && (this.keepaliveWithoutCalls || this.activeCalls.size > 0);
      }
      maybeSendPing() {
        var _a12, _b5;
        if (!this.canSendPing()) {
          this.pendingSendKeepalivePing = true;
          return;
        }
        if (this.keepaliveTimer) {
          console.error("keepaliveTimeout is not null");
          return;
        }
        if (this.channelzEnabled) {
          this.keepalivesSent += 1;
        }
        this.keepaliveTrace("Sending ping with timeout " + this.keepaliveTimeoutMs + "ms");
        this.keepaliveTimer = setTimeout(() => {
          this.keepaliveTimer = null;
          this.keepaliveTrace("Ping timeout passed without response");
          this.handleDisconnect();
        }, this.keepaliveTimeoutMs);
        (_b5 = (_a12 = this.keepaliveTimer).unref) === null || _b5 === void 0 ? void 0 : _b5.call(_a12);
        let pingSendError = "";
        try {
          const pingSentSuccessfully = this.session.ping((err, duration, payload) => {
            this.clearKeepaliveTimeout();
            if (err) {
              this.keepaliveTrace("Ping failed with error " + err.message);
              this.handleDisconnect();
            } else {
              this.keepaliveTrace("Received ping response");
              this.maybeStartKeepalivePingTimer();
            }
          });
          if (!pingSentSuccessfully) {
            pingSendError = "Ping returned false";
          }
        } catch (e2) {
          pingSendError = (e2 instanceof Error ? e2.message : "") || "Unknown error";
        }
        if (pingSendError) {
          this.keepaliveTrace("Ping send failed: " + pingSendError);
          this.handleDisconnect();
        }
      }
      /**
       * Starts the keepalive ping timer if appropriate. If the timer already ran
       * out while there were no active requests, instead send a ping immediately.
       * If the ping timer is already running or a ping is currently in flight,
       * instead do nothing and wait for them to resolve.
       */
      maybeStartKeepalivePingTimer() {
        var _a12, _b5;
        if (!this.canSendPing()) {
          return;
        }
        if (this.pendingSendKeepalivePing) {
          this.pendingSendKeepalivePing = false;
          this.maybeSendPing();
        } else if (!this.keepaliveTimer) {
          this.keepaliveTrace("Starting keepalive timer for " + this.keepaliveTimeMs + "ms");
          this.keepaliveTimer = setTimeout(() => {
            this.keepaliveTimer = null;
            this.maybeSendPing();
          }, this.keepaliveTimeMs);
          (_b5 = (_a12 = this.keepaliveTimer).unref) === null || _b5 === void 0 ? void 0 : _b5.call(_a12);
        }
      }
      /**
       * Clears whichever keepalive timeout is currently active, if any.
       */
      clearKeepaliveTimeout() {
        if (this.keepaliveTimer) {
          clearTimeout(this.keepaliveTimer);
          this.keepaliveTimer = null;
        }
      }
      removeActiveCall(call) {
        this.activeCalls.delete(call);
        if (this.activeCalls.size === 0) {
          this.session.unref();
        }
      }
      addActiveCall(call) {
        this.activeCalls.add(call);
        if (this.activeCalls.size === 1) {
          this.session.ref();
          if (!this.keepaliveWithoutCalls) {
            this.maybeStartKeepalivePingTimer();
          }
        }
      }
      createCall(metadata, host, method, listener, subchannelCallStatsTracker) {
        const headers = metadata.toHttp2Headers();
        headers[HTTP2_HEADER_AUTHORITY] = host;
        headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;
        headers[HTTP2_HEADER_CONTENT_TYPE] = "application/grpc";
        headers[HTTP2_HEADER_METHOD] = "POST";
        headers[HTTP2_HEADER_PATH] = method;
        headers[HTTP2_HEADER_TE] = "trailers";
        let http2Stream;
        try {
          http2Stream = this.session.request(headers);
        } catch (e2) {
          this.handleDisconnect();
          throw e2;
        }
        this.flowControlTrace("local window size: " + this.session.state.localWindowSize + " remote window size: " + this.session.state.remoteWindowSize);
        this.internalsTrace("session.closed=" + this.session.closed + " session.destroyed=" + this.session.destroyed + " session.socket.destroyed=" + this.session.socket.destroyed);
        let eventTracker;
        let call;
        if (this.channelzEnabled) {
          this.streamTracker.addCallStarted();
          eventTracker = {
            addMessageSent: () => {
              var _a12;
              this.messagesSent += 1;
              this.lastMessageSentTimestamp = /* @__PURE__ */ new Date();
              (_a12 = subchannelCallStatsTracker.addMessageSent) === null || _a12 === void 0 ? void 0 : _a12.call(subchannelCallStatsTracker);
            },
            addMessageReceived: () => {
              var _a12;
              this.messagesReceived += 1;
              this.lastMessageReceivedTimestamp = /* @__PURE__ */ new Date();
              (_a12 = subchannelCallStatsTracker.addMessageReceived) === null || _a12 === void 0 ? void 0 : _a12.call(subchannelCallStatsTracker);
            },
            onCallEnd: (status) => {
              var _a12;
              (_a12 = subchannelCallStatsTracker.onCallEnd) === null || _a12 === void 0 ? void 0 : _a12.call(subchannelCallStatsTracker, status);
              this.removeActiveCall(call);
            },
            onStreamEnd: (success) => {
              var _a12;
              if (success) {
                this.streamTracker.addCallSucceeded();
              } else {
                this.streamTracker.addCallFailed();
              }
              (_a12 = subchannelCallStatsTracker.onStreamEnd) === null || _a12 === void 0 ? void 0 : _a12.call(subchannelCallStatsTracker, success);
            }
          };
        } else {
          eventTracker = {
            addMessageSent: () => {
              var _a12;
              (_a12 = subchannelCallStatsTracker.addMessageSent) === null || _a12 === void 0 ? void 0 : _a12.call(subchannelCallStatsTracker);
            },
            addMessageReceived: () => {
              var _a12;
              (_a12 = subchannelCallStatsTracker.addMessageReceived) === null || _a12 === void 0 ? void 0 : _a12.call(subchannelCallStatsTracker);
            },
            onCallEnd: (status) => {
              var _a12;
              (_a12 = subchannelCallStatsTracker.onCallEnd) === null || _a12 === void 0 ? void 0 : _a12.call(subchannelCallStatsTracker, status);
              this.removeActiveCall(call);
            },
            onStreamEnd: (success) => {
              var _a12;
              (_a12 = subchannelCallStatsTracker.onStreamEnd) === null || _a12 === void 0 ? void 0 : _a12.call(subchannelCallStatsTracker, success);
            }
          };
        }
        call = new subchannel_call_1.Http2SubchannelCall(http2Stream, eventTracker, listener, this, (0, call_number_1.getNextCallNumber)());
        this.addActiveCall(call);
        return call;
      }
      getChannelzRef() {
        return this.channelzRef;
      }
      getPeerName() {
        return this.subchannelAddressString;
      }
      getOptions() {
        return this.options;
      }
      shutdown() {
        this.session.close();
        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
      }
    };
    var Http2SubchannelConnector = class {
      constructor(channelTarget) {
        this.channelTarget = channelTarget;
        this.session = null;
        this.isShutdown = false;
      }
      trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, (0, uri_parser_1.uriToString)(this.channelTarget) + " " + text);
      }
      createSession(address, credentials, options, proxyConnectionResult) {
        if (this.isShutdown) {
          return Promise.reject();
        }
        return new Promise((resolve, reject3) => {
          var _a12, _b5, _c4, _d4;
          let remoteName;
          if (proxyConnectionResult.realTarget) {
            remoteName = (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget);
            this.trace("creating HTTP/2 session through proxy to " + (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget));
          } else {
            remoteName = null;
            this.trace("creating HTTP/2 session to " + (0, subchannel_address_1.subchannelAddressToString)(address));
          }
          const targetAuthority = (0, resolver_1.getDefaultAuthority)((_a12 = proxyConnectionResult.realTarget) !== null && _a12 !== void 0 ? _a12 : this.channelTarget);
          let connectionOptions = credentials._getConnectionOptions();
          if (!connectionOptions) {
            reject3("Credentials not loaded");
            return;
          }
          connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;
          if ("grpc-node.max_session_memory" in options) {
            connectionOptions.maxSessionMemory = options["grpc-node.max_session_memory"];
          } else {
            connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;
          }
          let addressScheme = "http://";
          if ("secureContext" in connectionOptions) {
            addressScheme = "https://";
            if (options["grpc.ssl_target_name_override"]) {
              const sslTargetNameOverride = options["grpc.ssl_target_name_override"];
              const originalCheckServerIdentity = (_b5 = connectionOptions.checkServerIdentity) !== null && _b5 !== void 0 ? _b5 : tls_1.checkServerIdentity;
              connectionOptions.checkServerIdentity = (host, cert) => {
                return originalCheckServerIdentity(sslTargetNameOverride, cert);
              };
              connectionOptions.servername = sslTargetNameOverride;
            } else {
              const authorityHostname = (_d4 = (_c4 = (0, uri_parser_1.splitHostPort)(targetAuthority)) === null || _c4 === void 0 ? void 0 : _c4.host) !== null && _d4 !== void 0 ? _d4 : "localhost";
              connectionOptions.servername = authorityHostname;
            }
            if (proxyConnectionResult.socket) {
              connectionOptions.createConnection = (authority, option3) => {
                return proxyConnectionResult.socket;
              };
            }
          } else {
            connectionOptions.createConnection = (authority, option3) => {
              if (proxyConnectionResult.socket) {
                return proxyConnectionResult.socket;
              } else {
                return net.connect(address);
              }
            };
          }
          connectionOptions = Object.assign(Object.assign(Object.assign({}, connectionOptions), address), { enableTrace: options["grpc-node.tls_enable_trace"] === 1 });
          const session = http2.connect(addressScheme + targetAuthority, connectionOptions);
          this.session = session;
          let errorMessage = "Failed to connect";
          let reportedError = false;
          session.unref();
          session.once("connect", () => {
            session.removeAllListeners();
            resolve(new Http2Transport(session, address, options, remoteName));
            this.session = null;
          });
          session.once("close", () => {
            this.session = null;
            setImmediate(() => {
              if (!reportedError) {
                reportedError = true;
                reject3(`${errorMessage} (${(/* @__PURE__ */ new Date()).toISOString()})`);
              }
            });
          });
          session.once("error", (error) => {
            errorMessage = error.message;
            this.trace("connection failed with error " + errorMessage);
            if (!reportedError) {
              reportedError = true;
              reject3(`${errorMessage} (${(/* @__PURE__ */ new Date()).toISOString()})`);
            }
          });
        });
      }
      connect(address, credentials, options) {
        var _a12, _b5, _c4;
        if (this.isShutdown) {
          return Promise.reject();
        }
        const connectionOptions = credentials._getConnectionOptions();
        if (!connectionOptions) {
          return Promise.reject("Credentials not loaded");
        }
        if ("secureContext" in connectionOptions) {
          connectionOptions.ALPNProtocols = ["h2"];
          if (options["grpc.ssl_target_name_override"]) {
            const sslTargetNameOverride = options["grpc.ssl_target_name_override"];
            const originalCheckServerIdentity = (_a12 = connectionOptions.checkServerIdentity) !== null && _a12 !== void 0 ? _a12 : tls_1.checkServerIdentity;
            connectionOptions.checkServerIdentity = (host, cert) => {
              return originalCheckServerIdentity(sslTargetNameOverride, cert);
            };
            connectionOptions.servername = sslTargetNameOverride;
          } else {
            if ("grpc.http_connect_target" in options) {
              const targetPath = (0, resolver_1.getDefaultAuthority)((_b5 = (0, uri_parser_1.parseUri)(options["grpc.http_connect_target"])) !== null && _b5 !== void 0 ? _b5 : {
                path: "localhost"
              });
              const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);
              connectionOptions.servername = (_c4 = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _c4 !== void 0 ? _c4 : targetPath;
            }
          }
          if (options["grpc-node.tls_enable_trace"]) {
            connectionOptions.enableTrace = true;
          }
        }
        return (0, http_proxy_1.getProxiedConnection)(address, options, connectionOptions).then((result4) => this.createSession(address, credentials, options, result4));
      }
      shutdown() {
        var _a12;
        this.isShutdown = true;
        (_a12 = this.session) === null || _a12 === void 0 ? void 0 : _a12.close();
        this.session = null;
      }
    };
    exports.Http2SubchannelConnector = Http2SubchannelConnector;
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel-pool.js
var require_subchannel_pool = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/subchannel-pool.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSubchannelPool = exports.SubchannelPool = void 0;
    var channel_options_1 = require_channel_options();
    var subchannel_1 = require_subchannel();
    var subchannel_address_1 = require_subchannel_address();
    var uri_parser_1 = require_uri_parser();
    var transport_1 = require_transport();
    var REF_CHECK_INTERVAL = 1e4;
    var SubchannelPool = class {
      /**
       * A pool of subchannels use for making connections. Subchannels with the
       * exact same parameters will be reused.
       */
      constructor() {
        this.pool = /* @__PURE__ */ Object.create(null);
        this.cleanupTimer = null;
      }
      /**
       * Unrefs all unused subchannels and cancels the cleanup task if all
       * subchannels have been unrefed.
       */
      unrefUnusedSubchannels() {
        let allSubchannelsUnrefed = true;
        for (const channelTarget in this.pool) {
          const subchannelObjArray = this.pool[channelTarget];
          const refedSubchannels = subchannelObjArray.filter((value) => !value.subchannel.unrefIfOneRef());
          if (refedSubchannels.length > 0) {
            allSubchannelsUnrefed = false;
          }
          this.pool[channelTarget] = refedSubchannels;
        }
        if (allSubchannelsUnrefed && this.cleanupTimer !== null) {
          clearInterval(this.cleanupTimer);
          this.cleanupTimer = null;
        }
      }
      /**
       * Ensures that the cleanup task is spawned.
       */
      ensureCleanupTask() {
        var _a12, _b5;
        if (this.cleanupTimer === null) {
          this.cleanupTimer = setInterval(() => {
            this.unrefUnusedSubchannels();
          }, REF_CHECK_INTERVAL);
          (_b5 = (_a12 = this.cleanupTimer).unref) === null || _b5 === void 0 ? void 0 : _b5.call(_a12);
        }
      }
      /**
       * Get a subchannel if one already exists with exactly matching parameters.
       * Otherwise, create and save a subchannel with those parameters.
       * @param channelTarget
       * @param subchannelTarget
       * @param channelArguments
       * @param channelCredentials
       */
      getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {
        this.ensureCleanupTask();
        const channelTarget = (0, uri_parser_1.uriToString)(channelTargetUri);
        if (channelTarget in this.pool) {
          const subchannelObjArray = this.pool[channelTarget];
          for (const subchannelObj of subchannelObjArray) {
            if ((0, subchannel_address_1.subchannelAddressEqual)(subchannelTarget, subchannelObj.subchannelAddress) && (0, channel_options_1.channelOptionsEqual)(channelArguments, subchannelObj.channelArguments) && channelCredentials._equals(subchannelObj.channelCredentials)) {
              return subchannelObj.subchannel;
            }
          }
        }
        const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials, new transport_1.Http2SubchannelConnector(channelTargetUri));
        if (!(channelTarget in this.pool)) {
          this.pool[channelTarget] = [];
        }
        this.pool[channelTarget].push({
          subchannelAddress: subchannelTarget,
          channelArguments,
          channelCredentials,
          subchannel
        });
        subchannel.ref();
        return subchannel;
      }
    };
    exports.SubchannelPool = SubchannelPool;
    var globalSubchannelPool = new SubchannelPool();
    function getSubchannelPool(global2) {
      if (global2) {
        return globalSubchannelPool;
      } else {
        return new SubchannelPool();
      }
    }
    exports.getSubchannelPool = getSubchannelPool;
  }
});

// node_modules/@grpc/grpc-js/build/src/filter-stack.js
var require_filter_stack = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/filter-stack.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FilterStackFactory = exports.FilterStack = void 0;
    var FilterStack = class {
      constructor(filters) {
        this.filters = filters;
      }
      sendMetadata(metadata) {
        let result4 = metadata;
        for (let i2 = 0; i2 < this.filters.length; i2++) {
          result4 = this.filters[i2].sendMetadata(result4);
        }
        return result4;
      }
      receiveMetadata(metadata) {
        let result4 = metadata;
        for (let i2 = this.filters.length - 1; i2 >= 0; i2--) {
          result4 = this.filters[i2].receiveMetadata(result4);
        }
        return result4;
      }
      sendMessage(message) {
        let result4 = message;
        for (let i2 = 0; i2 < this.filters.length; i2++) {
          result4 = this.filters[i2].sendMessage(result4);
        }
        return result4;
      }
      receiveMessage(message) {
        let result4 = message;
        for (let i2 = this.filters.length - 1; i2 >= 0; i2--) {
          result4 = this.filters[i2].receiveMessage(result4);
        }
        return result4;
      }
      receiveTrailers(status) {
        let result4 = status;
        for (let i2 = this.filters.length - 1; i2 >= 0; i2--) {
          result4 = this.filters[i2].receiveTrailers(result4);
        }
        return result4;
      }
      push(filters) {
        this.filters.unshift(...filters);
      }
      getFilters() {
        return this.filters;
      }
    };
    exports.FilterStack = FilterStack;
    var FilterStackFactory = class _FilterStackFactory {
      constructor(factories) {
        this.factories = factories;
      }
      push(filterFactories) {
        this.factories.unshift(...filterFactories);
      }
      clone() {
        return new _FilterStackFactory([...this.factories]);
      }
      createFilter() {
        return new FilterStack(this.factories.map((factory) => factory.createFilter()));
      }
    };
    exports.FilterStackFactory = FilterStackFactory;
  }
});

// node_modules/@grpc/grpc-js/build/src/compression-algorithms.js
var require_compression_algorithms = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/compression-algorithms.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompressionAlgorithms = void 0;
    var CompressionAlgorithms;
    (function(CompressionAlgorithms2) {
      CompressionAlgorithms2[CompressionAlgorithms2["identity"] = 0] = "identity";
      CompressionAlgorithms2[CompressionAlgorithms2["deflate"] = 1] = "deflate";
      CompressionAlgorithms2[CompressionAlgorithms2["gzip"] = 2] = "gzip";
    })(CompressionAlgorithms || (exports.CompressionAlgorithms = CompressionAlgorithms = {}));
  }
});

// node_modules/@grpc/grpc-js/build/src/filter.js
var require_filter = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/filter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseFilter = void 0;
    var BaseFilter = class {
      async sendMetadata(metadata) {
        return metadata;
      }
      receiveMetadata(metadata) {
        return metadata;
      }
      async sendMessage(message) {
        return message;
      }
      async receiveMessage(message) {
        return message;
      }
      receiveTrailers(status) {
        return status;
      }
    };
    exports.BaseFilter = BaseFilter;
  }
});

// node_modules/@grpc/grpc-js/build/src/compression-filter.js
var require_compression_filter = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/compression-filter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompressionFilterFactory = exports.CompressionFilter = void 0;
    var zlib = __require("zlib");
    var compression_algorithms_1 = require_compression_algorithms();
    var constants_1 = require_constants5();
    var filter_1 = require_filter();
    var logging = require_logging();
    var isCompressionAlgorithmKey = (key) => {
      return typeof key === "number" && typeof compression_algorithms_1.CompressionAlgorithms[key] === "string";
    };
    var CompressionHandler = class {
      /**
       * @param message Raw uncompressed message bytes
       * @param compress Indicates whether the message should be compressed
       * @return Framed message, compressed if applicable
       */
      async writeMessage(message, compress) {
        let messageBuffer = message;
        if (compress) {
          messageBuffer = await this.compressMessage(messageBuffer);
        }
        const output = Buffer.allocUnsafe(messageBuffer.length + 5);
        output.writeUInt8(compress ? 1 : 0, 0);
        output.writeUInt32BE(messageBuffer.length, 1);
        messageBuffer.copy(output, 5);
        return output;
      }
      /**
       * @param data Framed message, possibly compressed
       * @return Uncompressed message
       */
      async readMessage(data) {
        const compressed = data.readUInt8(0) === 1;
        let messageBuffer = data.slice(5);
        if (compressed) {
          messageBuffer = await this.decompressMessage(messageBuffer);
        }
        return messageBuffer;
      }
    };
    var IdentityHandler = class extends CompressionHandler {
      async compressMessage(message) {
        return message;
      }
      async writeMessage(message, compress) {
        const output = Buffer.allocUnsafe(message.length + 5);
        output.writeUInt8(0, 0);
        output.writeUInt32BE(message.length, 1);
        message.copy(output, 5);
        return output;
      }
      decompressMessage(message) {
        return Promise.reject(new Error('Received compressed message but "grpc-encoding" header was identity'));
      }
    };
    var DeflateHandler = class extends CompressionHandler {
      constructor(maxRecvMessageLength) {
        super();
        this.maxRecvMessageLength = maxRecvMessageLength;
      }
      compressMessage(message) {
        return new Promise((resolve, reject3) => {
          zlib.deflate(message, (err, output) => {
            if (err) {
              reject3(err);
            } else {
              resolve(output);
            }
          });
        });
      }
      decompressMessage(message) {
        return new Promise((resolve, reject3) => {
          let totalLength = 0;
          const messageParts = [];
          const decompresser = zlib.createInflate();
          decompresser.on("data", (chunk2) => {
            messageParts.push(chunk2);
            totalLength += chunk2.byteLength;
            if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {
              decompresser.destroy();
              reject3({
                code: constants_1.Status.RESOURCE_EXHAUSTED,
                details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`
              });
            }
          });
          decompresser.on("end", () => {
            resolve(Buffer.concat(messageParts));
          });
          decompresser.write(message);
          decompresser.end();
        });
      }
    };
    var GzipHandler = class extends CompressionHandler {
      constructor(maxRecvMessageLength) {
        super();
        this.maxRecvMessageLength = maxRecvMessageLength;
      }
      compressMessage(message) {
        return new Promise((resolve, reject3) => {
          zlib.gzip(message, (err, output) => {
            if (err) {
              reject3(err);
            } else {
              resolve(output);
            }
          });
        });
      }
      decompressMessage(message) {
        return new Promise((resolve, reject3) => {
          let totalLength = 0;
          const messageParts = [];
          const decompresser = zlib.createGunzip();
          decompresser.on("data", (chunk2) => {
            messageParts.push(chunk2);
            totalLength += chunk2.byteLength;
            if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {
              decompresser.destroy();
              reject3({
                code: constants_1.Status.RESOURCE_EXHAUSTED,
                details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`
              });
            }
          });
          decompresser.on("end", () => {
            resolve(Buffer.concat(messageParts));
          });
          decompresser.write(message);
          decompresser.end();
        });
      }
    };
    var UnknownHandler = class extends CompressionHandler {
      constructor(compressionName) {
        super();
        this.compressionName = compressionName;
      }
      compressMessage(message) {
        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));
      }
      decompressMessage(message) {
        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));
      }
    };
    function getCompressionHandler(compressionName, maxReceiveMessageSize) {
      switch (compressionName) {
        case "identity":
          return new IdentityHandler();
        case "deflate":
          return new DeflateHandler(maxReceiveMessageSize);
        case "gzip":
          return new GzipHandler(maxReceiveMessageSize);
        default:
          return new UnknownHandler(compressionName);
      }
    }
    var CompressionFilter = class extends filter_1.BaseFilter {
      constructor(channelOptions, sharedFilterConfig) {
        var _a12, _b5, _c4;
        super();
        this.sharedFilterConfig = sharedFilterConfig;
        this.sendCompression = new IdentityHandler();
        this.receiveCompression = new IdentityHandler();
        this.currentCompressionAlgorithm = "identity";
        const compressionAlgorithmKey = channelOptions["grpc.default_compression_algorithm"];
        this.maxReceiveMessageLength = (_a12 = channelOptions["grpc.max_receive_message_length"]) !== null && _a12 !== void 0 ? _a12 : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
        this.maxSendMessageLength = (_b5 = channelOptions["grpc.max_send_message_length"]) !== null && _b5 !== void 0 ? _b5 : constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
        if (compressionAlgorithmKey !== void 0) {
          if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {
            const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];
            const serverSupportedEncodings = (_c4 = sharedFilterConfig.serverSupportedEncodingHeader) === null || _c4 === void 0 ? void 0 : _c4.split(",");
            if (!serverSupportedEncodings || serverSupportedEncodings.includes(clientSelectedEncoding)) {
              this.currentCompressionAlgorithm = clientSelectedEncoding;
              this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm, -1);
            }
          } else {
            logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);
          }
        }
      }
      async sendMetadata(metadata) {
        const headers = await metadata;
        headers.set("grpc-accept-encoding", "identity,deflate,gzip");
        headers.set("accept-encoding", "identity");
        if (this.currentCompressionAlgorithm === "identity") {
          headers.remove("grpc-encoding");
        } else {
          headers.set("grpc-encoding", this.currentCompressionAlgorithm);
        }
        return headers;
      }
      receiveMetadata(metadata) {
        const receiveEncoding = metadata.get("grpc-encoding");
        if (receiveEncoding.length > 0) {
          const encoding = receiveEncoding[0];
          if (typeof encoding === "string") {
            this.receiveCompression = getCompressionHandler(encoding, this.maxReceiveMessageLength);
          }
        }
        metadata.remove("grpc-encoding");
        const serverSupportedEncodingsHeader = metadata.get("grpc-accept-encoding")[0];
        if (serverSupportedEncodingsHeader) {
          this.sharedFilterConfig.serverSupportedEncodingHeader = serverSupportedEncodingsHeader;
          const serverSupportedEncodings = serverSupportedEncodingsHeader.split(",");
          if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {
            this.sendCompression = new IdentityHandler();
            this.currentCompressionAlgorithm = "identity";
          }
        }
        metadata.remove("grpc-accept-encoding");
        return metadata;
      }
      async sendMessage(message) {
        var _a12;
        const resolvedMessage = await message;
        if (this.maxSendMessageLength !== -1 && resolvedMessage.message.length > this.maxSendMessageLength) {
          throw {
            code: constants_1.Status.RESOURCE_EXHAUSTED,
            details: `Attempted to send message with a size larger than ${this.maxSendMessageLength}`
          };
        }
        let compress;
        if (this.sendCompression instanceof IdentityHandler) {
          compress = false;
        } else {
          compress = (((_a12 = resolvedMessage.flags) !== null && _a12 !== void 0 ? _a12 : 0) & 2) === 0;
        }
        return {
          message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),
          flags: resolvedMessage.flags
        };
      }
      async receiveMessage(message) {
        return this.receiveCompression.readMessage(await message);
      }
    };
    exports.CompressionFilter = CompressionFilter;
    var CompressionFilterFactory = class {
      constructor(channel, options) {
        this.options = options;
        this.sharedFilterConfig = {};
      }
      createFilter() {
        return new CompressionFilter(this.options, this.sharedFilterConfig);
      }
    };
    exports.CompressionFilterFactory = CompressionFilterFactory;
  }
});

// node_modules/@grpc/grpc-js/build/src/deadline.js
var require_deadline = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/deadline.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatDateDifference = exports.deadlineToString = exports.getRelativeTimeout = exports.getDeadlineTimeoutString = exports.minDeadline = void 0;
    function minDeadline(...deadlineList) {
      let minValue = Infinity;
      for (const deadline of deadlineList) {
        const deadlineMsecs = deadline instanceof Date ? deadline.getTime() : deadline;
        if (deadlineMsecs < minValue) {
          minValue = deadlineMsecs;
        }
      }
      return minValue;
    }
    exports.minDeadline = minDeadline;
    var units = [
      ["m", 1],
      ["S", 1e3],
      ["M", 60 * 1e3],
      ["H", 60 * 60 * 1e3]
    ];
    function getDeadlineTimeoutString(deadline) {
      const now = (/* @__PURE__ */ new Date()).getTime();
      if (deadline instanceof Date) {
        deadline = deadline.getTime();
      }
      const timeoutMs = Math.max(deadline - now, 0);
      for (const [unit7, factor] of units) {
        const amount = timeoutMs / factor;
        if (amount < 1e8) {
          return String(Math.ceil(amount)) + unit7;
        }
      }
      throw new Error("Deadline is too far in the future");
    }
    exports.getDeadlineTimeoutString = getDeadlineTimeoutString;
    var MAX_TIMEOUT_TIME = 2147483647;
    function getRelativeTimeout(deadline) {
      const deadlineMs = deadline instanceof Date ? deadline.getTime() : deadline;
      const now = (/* @__PURE__ */ new Date()).getTime();
      const timeout4 = deadlineMs - now;
      if (timeout4 < 0) {
        return 0;
      } else if (timeout4 > MAX_TIMEOUT_TIME) {
        return Infinity;
      } else {
        return timeout4;
      }
    }
    exports.getRelativeTimeout = getRelativeTimeout;
    function deadlineToString(deadline) {
      if (deadline instanceof Date) {
        return deadline.toISOString();
      } else {
        const dateDeadline = new Date(deadline);
        if (Number.isNaN(dateDeadline.getTime())) {
          return "" + deadline;
        } else {
          return dateDeadline.toISOString();
        }
      }
    }
    exports.deadlineToString = deadlineToString;
    function formatDateDifference(startDate, endDate) {
      return ((endDate.getTime() - startDate.getTime()) / 1e3).toFixed(3) + "s";
    }
    exports.formatDateDifference = formatDateDifference;
  }
});

// node_modules/@grpc/grpc-js/build/src/control-plane-status.js
var require_control_plane_status = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/control-plane-status.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.restrictControlPlaneStatusCode = void 0;
    var constants_1 = require_constants5();
    var INAPPROPRIATE_CONTROL_PLANE_CODES = [
      constants_1.Status.OK,
      constants_1.Status.INVALID_ARGUMENT,
      constants_1.Status.NOT_FOUND,
      constants_1.Status.ALREADY_EXISTS,
      constants_1.Status.FAILED_PRECONDITION,
      constants_1.Status.ABORTED,
      constants_1.Status.OUT_OF_RANGE,
      constants_1.Status.DATA_LOSS
    ];
    function restrictControlPlaneStatusCode(code, details) {
      if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {
        return {
          code: constants_1.Status.INTERNAL,
          details: `Invalid status from control plane: ${code} ${constants_1.Status[code]} ${details}`
        };
      } else {
        return { code, details };
      }
    }
    exports.restrictControlPlaneStatusCode = restrictControlPlaneStatusCode;
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancing-call.js
var require_load_balancing_call = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancing-call.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LoadBalancingCall = void 0;
    var connectivity_state_1 = require_connectivity_state();
    var constants_1 = require_constants5();
    var deadline_1 = require_deadline();
    var metadata_1 = require_metadata();
    var picker_1 = require_picker();
    var uri_parser_1 = require_uri_parser();
    var logging = require_logging();
    var control_plane_status_1 = require_control_plane_status();
    var http2 = __require("http2");
    var TRACER_NAME = "load_balancing_call";
    var LoadBalancingCall = class {
      constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber) {
        var _a12, _b5;
        this.channel = channel;
        this.callConfig = callConfig;
        this.methodName = methodName;
        this.host = host;
        this.credentials = credentials;
        this.deadline = deadline;
        this.callNumber = callNumber;
        this.child = null;
        this.readPending = false;
        this.pendingMessage = null;
        this.pendingHalfClose = false;
        this.ended = false;
        this.metadata = null;
        this.listener = null;
        this.onCallEnded = null;
        this.childStartTime = null;
        const splitPath = this.methodName.split("/");
        let serviceName = "";
        if (splitPath.length >= 2) {
          serviceName = splitPath[1];
        }
        const hostname = (_b5 = (_a12 = (0, uri_parser_1.splitHostPort)(this.host)) === null || _a12 === void 0 ? void 0 : _a12.host) !== null && _b5 !== void 0 ? _b5 : "localhost";
        this.serviceUrl = `https://${hostname}/${serviceName}`;
        this.startTime = /* @__PURE__ */ new Date();
      }
      getDeadlineInfo() {
        var _a12, _b5;
        const deadlineInfo = [];
        if (this.childStartTime) {
          if (this.childStartTime > this.startTime) {
            if ((_a12 = this.metadata) === null || _a12 === void 0 ? void 0 : _a12.getOptions().waitForReady) {
              deadlineInfo.push("wait_for_ready");
            }
            deadlineInfo.push(`LB pick: ${(0, deadline_1.formatDateDifference)(this.startTime, this.childStartTime)}`);
          }
          deadlineInfo.push(...this.child.getDeadlineInfo());
          return deadlineInfo;
        } else {
          if ((_b5 = this.metadata) === null || _b5 === void 0 ? void 0 : _b5.getOptions().waitForReady) {
            deadlineInfo.push("wait_for_ready");
          }
          deadlineInfo.push("Waiting for LB pick");
        }
        return deadlineInfo;
      }
      trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "[" + this.callNumber + "] " + text);
      }
      outputStatus(status, progress) {
        var _a12, _b5;
        if (!this.ended) {
          this.ended = true;
          this.trace("ended with status: code=" + status.code + ' details="' + status.details + '" start time=' + this.startTime.toISOString());
          const finalStatus = Object.assign(Object.assign({}, status), { progress });
          (_a12 = this.listener) === null || _a12 === void 0 ? void 0 : _a12.onReceiveStatus(finalStatus);
          (_b5 = this.onCallEnded) === null || _b5 === void 0 ? void 0 : _b5.call(this, finalStatus.code);
        }
      }
      doPick() {
        var _a12, _b5;
        if (this.ended) {
          return;
        }
        if (!this.metadata) {
          throw new Error("doPick called before start");
        }
        this.trace("Pick called");
        const finalMetadata = this.metadata.clone();
        const pickResult = this.channel.doPick(finalMetadata, this.callConfig.pickInformation);
        const subchannelString = pickResult.subchannel ? "(" + pickResult.subchannel.getChannelzRef().id + ") " + pickResult.subchannel.getAddress() : "" + pickResult.subchannel;
        this.trace("Pick result: " + picker_1.PickResultType[pickResult.pickResultType] + " subchannel: " + subchannelString + " status: " + ((_a12 = pickResult.status) === null || _a12 === void 0 ? void 0 : _a12.code) + " " + ((_b5 = pickResult.status) === null || _b5 === void 0 ? void 0 : _b5.details));
        switch (pickResult.pickResultType) {
          case picker_1.PickResultType.COMPLETE:
            this.credentials.generateMetadata({ method_name: this.methodName, service_url: this.serviceUrl }).then((credsMetadata) => {
              var _a13, _b6, _c4;
              if (this.ended) {
                this.trace("Credentials metadata generation finished after call ended");
                return;
              }
              finalMetadata.merge(credsMetadata);
              if (finalMetadata.get("authorization").length > 1) {
                this.outputStatus({
                  code: constants_1.Status.INTERNAL,
                  details: '"authorization" metadata cannot have multiple values',
                  metadata: new metadata_1.Metadata()
                }, "PROCESSED");
              }
              if (pickResult.subchannel.getConnectivityState() !== connectivity_state_1.ConnectivityState.READY) {
                this.trace("Picked subchannel " + subchannelString + " has state " + connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()] + " after getting credentials metadata. Retrying pick");
                this.doPick();
                return;
              }
              if (this.deadline !== Infinity) {
                finalMetadata.set("grpc-timeout", (0, deadline_1.getDeadlineTimeoutString)(this.deadline));
              }
              try {
                this.child = pickResult.subchannel.getRealSubchannel().createCall(finalMetadata, this.host, this.methodName, {
                  onReceiveMetadata: (metadata) => {
                    this.trace("Received metadata");
                    this.listener.onReceiveMetadata(metadata);
                  },
                  onReceiveMessage: (message) => {
                    this.trace("Received message");
                    this.listener.onReceiveMessage(message);
                  },
                  onReceiveStatus: (status) => {
                    this.trace("Received status");
                    if (status.rstCode === http2.constants.NGHTTP2_REFUSED_STREAM) {
                      this.outputStatus(status, "REFUSED");
                    } else {
                      this.outputStatus(status, "PROCESSED");
                    }
                  }
                });
                this.childStartTime = /* @__PURE__ */ new Date();
              } catch (error) {
                this.trace("Failed to start call on picked subchannel " + subchannelString + " with error " + error.message);
                this.outputStatus({
                  code: constants_1.Status.INTERNAL,
                  details: "Failed to start HTTP/2 stream with error " + error.message,
                  metadata: new metadata_1.Metadata()
                }, "NOT_STARTED");
                return;
              }
              (_b6 = (_a13 = this.callConfig).onCommitted) === null || _b6 === void 0 ? void 0 : _b6.call(_a13);
              (_c4 = pickResult.onCallStarted) === null || _c4 === void 0 ? void 0 : _c4.call(pickResult);
              this.onCallEnded = pickResult.onCallEnded;
              this.trace("Created child call [" + this.child.getCallNumber() + "]");
              if (this.readPending) {
                this.child.startRead();
              }
              if (this.pendingMessage) {
                this.child.sendMessageWithContext(this.pendingMessage.context, this.pendingMessage.message);
              }
              if (this.pendingHalfClose) {
                this.child.halfClose();
              }
            }, (error) => {
              const { code: code2, details: details2 } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(typeof error.code === "number" ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);
              this.outputStatus({
                code: code2,
                details: details2,
                metadata: new metadata_1.Metadata()
              }, "PROCESSED");
            });
            break;
          case picker_1.PickResultType.DROP:
            const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);
            setImmediate(() => {
              this.outputStatus({ code, details, metadata: pickResult.status.metadata }, "DROP");
            });
            break;
          case picker_1.PickResultType.TRANSIENT_FAILURE:
            if (this.metadata.getOptions().waitForReady) {
              this.channel.queueCallForPick(this);
            } else {
              const { code: code2, details: details2 } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);
              setImmediate(() => {
                this.outputStatus({ code: code2, details: details2, metadata: pickResult.status.metadata }, "PROCESSED");
              });
            }
            break;
          case picker_1.PickResultType.QUEUE:
            this.channel.queueCallForPick(this);
        }
      }
      cancelWithStatus(status, details) {
        var _a12;
        this.trace("cancelWithStatus code: " + status + ' details: "' + details + '"');
        (_a12 = this.child) === null || _a12 === void 0 ? void 0 : _a12.cancelWithStatus(status, details);
        this.outputStatus({ code: status, details, metadata: new metadata_1.Metadata() }, "PROCESSED");
      }
      getPeer() {
        var _a12, _b5;
        return (_b5 = (_a12 = this.child) === null || _a12 === void 0 ? void 0 : _a12.getPeer()) !== null && _b5 !== void 0 ? _b5 : this.channel.getTarget();
      }
      start(metadata, listener) {
        this.trace("start called");
        this.listener = listener;
        this.metadata = metadata;
        this.doPick();
      }
      sendMessageWithContext(context3, message) {
        this.trace("write() called with message of length " + message.length);
        if (this.child) {
          this.child.sendMessageWithContext(context3, message);
        } else {
          this.pendingMessage = { context: context3, message };
        }
      }
      startRead() {
        this.trace("startRead called");
        if (this.child) {
          this.child.startRead();
        } else {
          this.readPending = true;
        }
      }
      halfClose() {
        this.trace("halfClose called");
        if (this.child) {
          this.child.halfClose();
        } else {
          this.pendingHalfClose = true;
        }
      }
      setCredentials(credentials) {
        throw new Error("Method not implemented.");
      }
      getCallNumber() {
        return this.callNumber;
      }
    };
    exports.LoadBalancingCall = LoadBalancingCall;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolving-call.js
var require_resolving_call = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolving-call.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ResolvingCall = void 0;
    var constants_1 = require_constants5();
    var deadline_1 = require_deadline();
    var metadata_1 = require_metadata();
    var logging = require_logging();
    var control_plane_status_1 = require_control_plane_status();
    var TRACER_NAME = "resolving_call";
    var ResolvingCall = class {
      constructor(channel, method, options, filterStackFactory, credentials, callNumber) {
        this.channel = channel;
        this.method = method;
        this.filterStackFactory = filterStackFactory;
        this.credentials = credentials;
        this.callNumber = callNumber;
        this.child = null;
        this.readPending = false;
        this.pendingMessage = null;
        this.pendingHalfClose = false;
        this.ended = false;
        this.readFilterPending = false;
        this.writeFilterPending = false;
        this.pendingChildStatus = null;
        this.metadata = null;
        this.listener = null;
        this.statusWatchers = [];
        this.deadlineTimer = setTimeout(() => {
        }, 0);
        this.filterStack = null;
        this.deadlineStartTime = null;
        this.configReceivedTime = null;
        this.childStartTime = null;
        this.deadline = options.deadline;
        this.host = options.host;
        if (options.parentCall) {
          if (options.flags & constants_1.Propagate.CANCELLATION) {
            options.parentCall.on("cancelled", () => {
              this.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled by parent call");
            });
          }
          if (options.flags & constants_1.Propagate.DEADLINE) {
            this.trace("Propagating deadline from parent: " + options.parentCall.getDeadline());
            this.deadline = (0, deadline_1.minDeadline)(this.deadline, options.parentCall.getDeadline());
          }
        }
        this.trace("Created");
        this.runDeadlineTimer();
      }
      trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "[" + this.callNumber + "] " + text);
      }
      runDeadlineTimer() {
        clearTimeout(this.deadlineTimer);
        this.deadlineStartTime = /* @__PURE__ */ new Date();
        this.trace("Deadline: " + (0, deadline_1.deadlineToString)(this.deadline));
        const timeout4 = (0, deadline_1.getRelativeTimeout)(this.deadline);
        if (timeout4 !== Infinity) {
          this.trace("Deadline will be reached in " + timeout4 + "ms");
          const handleDeadline = () => {
            if (!this.deadlineStartTime) {
              this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, "Deadline exceeded");
              return;
            }
            const deadlineInfo = [];
            const deadlineEndTime = /* @__PURE__ */ new Date();
            deadlineInfo.push(`Deadline exceeded after ${(0, deadline_1.formatDateDifference)(this.deadlineStartTime, deadlineEndTime)}`);
            if (this.configReceivedTime) {
              if (this.configReceivedTime > this.deadlineStartTime) {
                deadlineInfo.push(`name resolution: ${(0, deadline_1.formatDateDifference)(this.deadlineStartTime, this.configReceivedTime)}`);
              }
              if (this.childStartTime) {
                if (this.childStartTime > this.configReceivedTime) {
                  deadlineInfo.push(`metadata filters: ${(0, deadline_1.formatDateDifference)(this.configReceivedTime, this.childStartTime)}`);
                }
              } else {
                deadlineInfo.push("waiting for metadata filters");
              }
            } else {
              deadlineInfo.push("waiting for name resolution");
            }
            if (this.child) {
              deadlineInfo.push(...this.child.getDeadlineInfo());
            }
            this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, deadlineInfo.join(","));
          };
          if (timeout4 <= 0) {
            process.nextTick(handleDeadline);
          } else {
            this.deadlineTimer = setTimeout(handleDeadline, timeout4);
          }
        }
      }
      outputStatus(status) {
        if (!this.ended) {
          this.ended = true;
          if (!this.filterStack) {
            this.filterStack = this.filterStackFactory.createFilter();
          }
          clearTimeout(this.deadlineTimer);
          const filteredStatus = this.filterStack.receiveTrailers(status);
          this.trace("ended with status: code=" + filteredStatus.code + ' details="' + filteredStatus.details + '"');
          this.statusWatchers.forEach((watcher) => watcher(filteredStatus));
          process.nextTick(() => {
            var _a12;
            (_a12 = this.listener) === null || _a12 === void 0 ? void 0 : _a12.onReceiveStatus(filteredStatus);
          });
        }
      }
      sendMessageOnChild(context3, message) {
        if (!this.child) {
          throw new Error("sendMessageonChild called with child not populated");
        }
        const child = this.child;
        this.writeFilterPending = true;
        this.filterStack.sendMessage(Promise.resolve({ message, flags: context3.flags })).then((filteredMessage) => {
          this.writeFilterPending = false;
          child.sendMessageWithContext(context3, filteredMessage.message);
          if (this.pendingHalfClose) {
            child.halfClose();
          }
        }, (status) => {
          this.cancelWithStatus(status.code, status.details);
        });
      }
      getConfig() {
        if (this.ended) {
          return;
        }
        if (!this.metadata || !this.listener) {
          throw new Error("getConfig called before start");
        }
        const configResult = this.channel.getConfig(this.method, this.metadata);
        if (configResult.type === "NONE") {
          this.channel.queueCallForConfig(this);
          return;
        } else if (configResult.type === "ERROR") {
          if (this.metadata.getOptions().waitForReady) {
            this.channel.queueCallForConfig(this);
          } else {
            this.outputStatus(configResult.error);
          }
          return;
        }
        this.configReceivedTime = /* @__PURE__ */ new Date();
        const config = configResult.config;
        if (config.status !== constants_1.Status.OK) {
          const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(config.status, "Failed to route call to method " + this.method);
          this.outputStatus({
            code,
            details,
            metadata: new metadata_1.Metadata()
          });
          return;
        }
        if (config.methodConfig.timeout) {
          const configDeadline = /* @__PURE__ */ new Date();
          configDeadline.setSeconds(configDeadline.getSeconds() + config.methodConfig.timeout.seconds);
          configDeadline.setMilliseconds(configDeadline.getMilliseconds() + config.methodConfig.timeout.nanos / 1e6);
          this.deadline = (0, deadline_1.minDeadline)(this.deadline, configDeadline);
          this.runDeadlineTimer();
        }
        this.filterStackFactory.push(config.dynamicFilterFactories);
        this.filterStack = this.filterStackFactory.createFilter();
        this.filterStack.sendMetadata(Promise.resolve(this.metadata)).then((filteredMetadata) => {
          this.child = this.channel.createInnerCall(config, this.method, this.host, this.credentials, this.deadline);
          this.trace("Created child [" + this.child.getCallNumber() + "]");
          this.childStartTime = /* @__PURE__ */ new Date();
          this.child.start(filteredMetadata, {
            onReceiveMetadata: (metadata) => {
              this.trace("Received metadata");
              this.listener.onReceiveMetadata(this.filterStack.receiveMetadata(metadata));
            },
            onReceiveMessage: (message) => {
              this.trace("Received message");
              this.readFilterPending = true;
              this.filterStack.receiveMessage(message).then((filteredMesssage) => {
                this.trace("Finished filtering received message");
                this.readFilterPending = false;
                this.listener.onReceiveMessage(filteredMesssage);
                if (this.pendingChildStatus) {
                  this.outputStatus(this.pendingChildStatus);
                }
              }, (status) => {
                this.cancelWithStatus(status.code, status.details);
              });
            },
            onReceiveStatus: (status) => {
              this.trace("Received status");
              if (this.readFilterPending) {
                this.pendingChildStatus = status;
              } else {
                this.outputStatus(status);
              }
            }
          });
          if (this.readPending) {
            this.child.startRead();
          }
          if (this.pendingMessage) {
            this.sendMessageOnChild(this.pendingMessage.context, this.pendingMessage.message);
          } else if (this.pendingHalfClose) {
            this.child.halfClose();
          }
        }, (status) => {
          this.outputStatus(status);
        });
      }
      reportResolverError(status) {
        var _a12;
        if ((_a12 = this.metadata) === null || _a12 === void 0 ? void 0 : _a12.getOptions().waitForReady) {
          this.channel.queueCallForConfig(this);
        } else {
          this.outputStatus(status);
        }
      }
      cancelWithStatus(status, details) {
        var _a12;
        this.trace("cancelWithStatus code: " + status + ' details: "' + details + '"');
        (_a12 = this.child) === null || _a12 === void 0 ? void 0 : _a12.cancelWithStatus(status, details);
        this.outputStatus({
          code: status,
          details,
          metadata: new metadata_1.Metadata()
        });
      }
      getPeer() {
        var _a12, _b5;
        return (_b5 = (_a12 = this.child) === null || _a12 === void 0 ? void 0 : _a12.getPeer()) !== null && _b5 !== void 0 ? _b5 : this.channel.getTarget();
      }
      start(metadata, listener) {
        this.trace("start called");
        this.metadata = metadata.clone();
        this.listener = listener;
        this.getConfig();
      }
      sendMessageWithContext(context3, message) {
        this.trace("write() called with message of length " + message.length);
        if (this.child) {
          this.sendMessageOnChild(context3, message);
        } else {
          this.pendingMessage = { context: context3, message };
        }
      }
      startRead() {
        this.trace("startRead called");
        if (this.child) {
          this.child.startRead();
        } else {
          this.readPending = true;
        }
      }
      halfClose() {
        this.trace("halfClose called");
        if (this.child && !this.writeFilterPending) {
          this.child.halfClose();
        } else {
          this.pendingHalfClose = true;
        }
      }
      setCredentials(credentials) {
        this.credentials = this.credentials.compose(credentials);
      }
      addStatusWatcher(watcher) {
        this.statusWatchers.push(watcher);
      }
      getCallNumber() {
        return this.callNumber;
      }
    };
    exports.ResolvingCall = ResolvingCall;
  }
});

// node_modules/@grpc/grpc-js/build/src/retrying-call.js
var require_retrying_call = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/retrying-call.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RetryingCall = exports.MessageBufferTracker = exports.RetryThrottler = void 0;
    var constants_1 = require_constants5();
    var deadline_1 = require_deadline();
    var metadata_1 = require_metadata();
    var logging = require_logging();
    var TRACER_NAME = "retrying_call";
    var RetryThrottler = class {
      constructor(maxTokens, tokenRatio, previousRetryThrottler) {
        this.maxTokens = maxTokens;
        this.tokenRatio = tokenRatio;
        if (previousRetryThrottler) {
          this.tokens = previousRetryThrottler.tokens * (maxTokens / previousRetryThrottler.maxTokens);
        } else {
          this.tokens = maxTokens;
        }
      }
      addCallSucceeded() {
        this.tokens = Math.max(this.tokens + this.tokenRatio, this.maxTokens);
      }
      addCallFailed() {
        this.tokens = Math.min(this.tokens - 1, 0);
      }
      canRetryCall() {
        return this.tokens > this.maxTokens / 2;
      }
    };
    exports.RetryThrottler = RetryThrottler;
    var MessageBufferTracker = class {
      constructor(totalLimit, limitPerCall) {
        this.totalLimit = totalLimit;
        this.limitPerCall = limitPerCall;
        this.totalAllocated = 0;
        this.allocatedPerCall = /* @__PURE__ */ new Map();
      }
      allocate(size7, callId) {
        var _a12;
        const currentPerCall = (_a12 = this.allocatedPerCall.get(callId)) !== null && _a12 !== void 0 ? _a12 : 0;
        if (this.limitPerCall - currentPerCall < size7 || this.totalLimit - this.totalAllocated < size7) {
          return false;
        }
        this.allocatedPerCall.set(callId, currentPerCall + size7);
        this.totalAllocated += size7;
        return true;
      }
      free(size7, callId) {
        var _a12;
        if (this.totalAllocated < size7) {
          throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size7} > total allocated ${this.totalAllocated}`);
        }
        this.totalAllocated -= size7;
        const currentPerCall = (_a12 = this.allocatedPerCall.get(callId)) !== null && _a12 !== void 0 ? _a12 : 0;
        if (currentPerCall < size7) {
          throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size7} > allocated for call ${currentPerCall}`);
        }
        this.allocatedPerCall.set(callId, currentPerCall - size7);
      }
      freeAll(callId) {
        var _a12;
        const currentPerCall = (_a12 = this.allocatedPerCall.get(callId)) !== null && _a12 !== void 0 ? _a12 : 0;
        if (this.totalAllocated < currentPerCall) {
          throw new Error(`Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`);
        }
        this.totalAllocated -= currentPerCall;
        this.allocatedPerCall.delete(callId);
      }
    };
    exports.MessageBufferTracker = MessageBufferTracker;
    var PREVIONS_RPC_ATTEMPTS_METADATA_KEY = "grpc-previous-rpc-attempts";
    var DEFAULT_MAX_ATTEMPTS_LIMIT = 5;
    var RetryingCall = class {
      constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber, bufferTracker, retryThrottler) {
        var _a12;
        this.channel = channel;
        this.callConfig = callConfig;
        this.methodName = methodName;
        this.host = host;
        this.credentials = credentials;
        this.deadline = deadline;
        this.callNumber = callNumber;
        this.bufferTracker = bufferTracker;
        this.retryThrottler = retryThrottler;
        this.listener = null;
        this.initialMetadata = null;
        this.underlyingCalls = [];
        this.writeBuffer = [];
        this.writeBufferOffset = 0;
        this.readStarted = false;
        this.transparentRetryUsed = false;
        this.attempts = 0;
        this.hedgingTimer = null;
        this.committedCallIndex = null;
        this.initialRetryBackoffSec = 0;
        this.nextRetryBackoffSec = 0;
        const maxAttemptsLimit = (_a12 = channel.getOptions()["grpc-node.retry_max_attempts_limit"]) !== null && _a12 !== void 0 ? _a12 : DEFAULT_MAX_ATTEMPTS_LIMIT;
        if (callConfig.methodConfig.retryPolicy) {
          this.state = "RETRY";
          const retryPolicy = callConfig.methodConfig.retryPolicy;
          this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(retryPolicy.initialBackoff.substring(0, retryPolicy.initialBackoff.length - 1));
          this.maxAttempts = Math.min(retryPolicy.maxAttempts, maxAttemptsLimit);
        } else if (callConfig.methodConfig.hedgingPolicy) {
          this.state = "HEDGING";
          this.maxAttempts = Math.min(callConfig.methodConfig.hedgingPolicy.maxAttempts, maxAttemptsLimit);
        } else {
          this.state = "TRANSPARENT_ONLY";
          this.maxAttempts = 1;
        }
        this.startTime = /* @__PURE__ */ new Date();
      }
      getDeadlineInfo() {
        if (this.underlyingCalls.length === 0) {
          return [];
        }
        const deadlineInfo = [];
        const latestCall = this.underlyingCalls[this.underlyingCalls.length - 1];
        if (this.underlyingCalls.length > 1) {
          deadlineInfo.push(`previous attempts: ${this.underlyingCalls.length - 1}`);
        }
        if (latestCall.startTime > this.startTime) {
          deadlineInfo.push(`time to current attempt start: ${(0, deadline_1.formatDateDifference)(this.startTime, latestCall.startTime)}`);
        }
        deadlineInfo.push(...latestCall.call.getDeadlineInfo());
        return deadlineInfo;
      }
      getCallNumber() {
        return this.callNumber;
      }
      trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "[" + this.callNumber + "] " + text);
      }
      reportStatus(statusObject) {
        this.trace("ended with status: code=" + statusObject.code + ' details="' + statusObject.details + '" start time=' + this.startTime.toISOString());
        this.bufferTracker.freeAll(this.callNumber);
        this.writeBufferOffset = this.writeBufferOffset + this.writeBuffer.length;
        this.writeBuffer = [];
        process.nextTick(() => {
          var _a12;
          (_a12 = this.listener) === null || _a12 === void 0 ? void 0 : _a12.onReceiveStatus({
            code: statusObject.code,
            details: statusObject.details,
            metadata: statusObject.metadata
          });
        });
      }
      cancelWithStatus(status, details) {
        this.trace("cancelWithStatus code: " + status + ' details: "' + details + '"');
        this.reportStatus({ code: status, details, metadata: new metadata_1.Metadata() });
        for (const { call } of this.underlyingCalls) {
          call.cancelWithStatus(status, details);
        }
      }
      getPeer() {
        if (this.committedCallIndex !== null) {
          return this.underlyingCalls[this.committedCallIndex].call.getPeer();
        } else {
          return "unknown";
        }
      }
      getBufferEntry(messageIndex) {
        var _a12;
        return (_a12 = this.writeBuffer[messageIndex - this.writeBufferOffset]) !== null && _a12 !== void 0 ? _a12 : {
          entryType: "FREED",
          allocated: false
        };
      }
      getNextBufferIndex() {
        return this.writeBufferOffset + this.writeBuffer.length;
      }
      clearSentMessages() {
        if (this.state !== "COMMITTED") {
          return;
        }
        const earliestNeededMessageIndex = this.underlyingCalls[this.committedCallIndex].nextMessageToSend;
        for (let messageIndex = this.writeBufferOffset; messageIndex < earliestNeededMessageIndex; messageIndex++) {
          const bufferEntry = this.getBufferEntry(messageIndex);
          if (bufferEntry.allocated) {
            this.bufferTracker.free(bufferEntry.message.message.length, this.callNumber);
          }
        }
        this.writeBuffer = this.writeBuffer.slice(earliestNeededMessageIndex - this.writeBufferOffset);
        this.writeBufferOffset = earliestNeededMessageIndex;
      }
      commitCall(index) {
        if (this.state === "COMMITTED") {
          return;
        }
        if (this.underlyingCalls[index].state === "COMPLETED") {
          return;
        }
        this.trace("Committing call [" + this.underlyingCalls[index].call.getCallNumber() + "] at index " + index);
        this.state = "COMMITTED";
        this.committedCallIndex = index;
        for (let i2 = 0; i2 < this.underlyingCalls.length; i2++) {
          if (i2 === index) {
            continue;
          }
          if (this.underlyingCalls[i2].state === "COMPLETED") {
            continue;
          }
          this.underlyingCalls[i2].state = "COMPLETED";
          this.underlyingCalls[i2].call.cancelWithStatus(constants_1.Status.CANCELLED, "Discarded in favor of other hedged attempt");
        }
        this.clearSentMessages();
      }
      commitCallWithMostMessages() {
        if (this.state === "COMMITTED") {
          return;
        }
        let mostMessages = -1;
        let callWithMostMessages = -1;
        for (const [index, childCall] of this.underlyingCalls.entries()) {
          if (childCall.state === "ACTIVE" && childCall.nextMessageToSend > mostMessages) {
            mostMessages = childCall.nextMessageToSend;
            callWithMostMessages = index;
          }
        }
        if (callWithMostMessages === -1) {
          this.state = "TRANSPARENT_ONLY";
        } else {
          this.commitCall(callWithMostMessages);
        }
      }
      isStatusCodeInList(list2, code) {
        return list2.some((value) => {
          var _a12;
          return value === code || value.toString().toLowerCase() === ((_a12 = constants_1.Status[code]) === null || _a12 === void 0 ? void 0 : _a12.toLowerCase());
        });
      }
      getNextRetryBackoffMs() {
        var _a12;
        const retryPolicy = (_a12 = this.callConfig) === null || _a12 === void 0 ? void 0 : _a12.methodConfig.retryPolicy;
        if (!retryPolicy) {
          return 0;
        }
        const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1e3;
        const maxBackoffSec = Number(retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1));
        this.nextRetryBackoffSec = Math.min(this.nextRetryBackoffSec * retryPolicy.backoffMultiplier, maxBackoffSec);
        return nextBackoffMs;
      }
      maybeRetryCall(pushback, callback) {
        if (this.state !== "RETRY") {
          callback(false);
          return;
        }
        if (this.attempts >= this.maxAttempts) {
          callback(false);
          return;
        }
        let retryDelayMs;
        if (pushback === null) {
          retryDelayMs = this.getNextRetryBackoffMs();
        } else if (pushback < 0) {
          this.state = "TRANSPARENT_ONLY";
          callback(false);
          return;
        } else {
          retryDelayMs = pushback;
          this.nextRetryBackoffSec = this.initialRetryBackoffSec;
        }
        setTimeout(() => {
          var _a12, _b5;
          if (this.state !== "RETRY") {
            callback(false);
            return;
          }
          if ((_b5 = (_a12 = this.retryThrottler) === null || _a12 === void 0 ? void 0 : _a12.canRetryCall()) !== null && _b5 !== void 0 ? _b5 : true) {
            callback(true);
            this.attempts += 1;
            this.startNewAttempt();
          }
        }, retryDelayMs);
      }
      countActiveCalls() {
        let count2 = 0;
        for (const call of this.underlyingCalls) {
          if ((call === null || call === void 0 ? void 0 : call.state) === "ACTIVE") {
            count2 += 1;
          }
        }
        return count2;
      }
      handleProcessedStatus(status, callIndex, pushback) {
        var _a12, _b5, _c4;
        switch (this.state) {
          case "COMMITTED":
          case "TRANSPARENT_ONLY":
            this.commitCall(callIndex);
            this.reportStatus(status);
            break;
          case "HEDGING":
            if (this.isStatusCodeInList((_a12 = this.callConfig.methodConfig.hedgingPolicy.nonFatalStatusCodes) !== null && _a12 !== void 0 ? _a12 : [], status.code)) {
              (_b5 = this.retryThrottler) === null || _b5 === void 0 ? void 0 : _b5.addCallFailed();
              let delayMs;
              if (pushback === null) {
                delayMs = 0;
              } else if (pushback < 0) {
                this.state = "TRANSPARENT_ONLY";
                this.commitCall(callIndex);
                this.reportStatus(status);
                return;
              } else {
                delayMs = pushback;
              }
              setTimeout(() => {
                this.maybeStartHedgingAttempt();
                if (this.countActiveCalls() === 0) {
                  this.commitCall(callIndex);
                  this.reportStatus(status);
                }
              }, delayMs);
            } else {
              this.commitCall(callIndex);
              this.reportStatus(status);
            }
            break;
          case "RETRY":
            if (this.isStatusCodeInList(this.callConfig.methodConfig.retryPolicy.retryableStatusCodes, status.code)) {
              (_c4 = this.retryThrottler) === null || _c4 === void 0 ? void 0 : _c4.addCallFailed();
              this.maybeRetryCall(pushback, (retried) => {
                if (!retried) {
                  this.commitCall(callIndex);
                  this.reportStatus(status);
                }
              });
            } else {
              this.commitCall(callIndex);
              this.reportStatus(status);
            }
            break;
        }
      }
      getPushback(metadata) {
        const mdValue = metadata.get("grpc-retry-pushback-ms");
        if (mdValue.length === 0) {
          return null;
        }
        try {
          return parseInt(mdValue[0]);
        } catch (e2) {
          return -1;
        }
      }
      handleChildStatus(status, callIndex) {
        var _a12;
        if (this.underlyingCalls[callIndex].state === "COMPLETED") {
          return;
        }
        this.trace("state=" + this.state + " handling status with progress " + status.progress + " from child [" + this.underlyingCalls[callIndex].call.getCallNumber() + "] in state " + this.underlyingCalls[callIndex].state);
        this.underlyingCalls[callIndex].state = "COMPLETED";
        if (status.code === constants_1.Status.OK) {
          (_a12 = this.retryThrottler) === null || _a12 === void 0 ? void 0 : _a12.addCallSucceeded();
          this.commitCall(callIndex);
          this.reportStatus(status);
          return;
        }
        if (this.state === "COMMITTED") {
          this.reportStatus(status);
          return;
        }
        const pushback = this.getPushback(status.metadata);
        switch (status.progress) {
          case "NOT_STARTED":
            this.startNewAttempt();
            break;
          case "REFUSED":
            if (this.transparentRetryUsed) {
              this.handleProcessedStatus(status, callIndex, pushback);
            } else {
              this.transparentRetryUsed = true;
              this.startNewAttempt();
            }
            break;
          case "DROP":
            this.commitCall(callIndex);
            this.reportStatus(status);
            break;
          case "PROCESSED":
            this.handleProcessedStatus(status, callIndex, pushback);
            break;
        }
      }
      maybeStartHedgingAttempt() {
        if (this.state !== "HEDGING") {
          return;
        }
        if (!this.callConfig.methodConfig.hedgingPolicy) {
          return;
        }
        if (this.attempts >= this.maxAttempts) {
          return;
        }
        this.attempts += 1;
        this.startNewAttempt();
        this.maybeStartHedgingTimer();
      }
      maybeStartHedgingTimer() {
        var _a12, _b5, _c4;
        if (this.hedgingTimer) {
          clearTimeout(this.hedgingTimer);
        }
        if (this.state !== "HEDGING") {
          return;
        }
        if (!this.callConfig.methodConfig.hedgingPolicy) {
          return;
        }
        const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;
        if (this.attempts >= this.maxAttempts) {
          return;
        }
        const hedgingDelayString = (_a12 = hedgingPolicy.hedgingDelay) !== null && _a12 !== void 0 ? _a12 : "0s";
        const hedgingDelaySec = Number(hedgingDelayString.substring(0, hedgingDelayString.length - 1));
        this.hedgingTimer = setTimeout(() => {
          this.maybeStartHedgingAttempt();
        }, hedgingDelaySec * 1e3);
        (_c4 = (_b5 = this.hedgingTimer).unref) === null || _c4 === void 0 ? void 0 : _c4.call(_b5);
      }
      startNewAttempt() {
        const child = this.channel.createLoadBalancingCall(this.callConfig, this.methodName, this.host, this.credentials, this.deadline);
        this.trace("Created child call [" + child.getCallNumber() + "] for attempt " + this.attempts);
        const index = this.underlyingCalls.length;
        this.underlyingCalls.push({
          state: "ACTIVE",
          call: child,
          nextMessageToSend: 0,
          startTime: /* @__PURE__ */ new Date()
        });
        const previousAttempts = this.attempts - 1;
        const initialMetadata = this.initialMetadata.clone();
        if (previousAttempts > 0) {
          initialMetadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);
        }
        let receivedMetadata = false;
        child.start(initialMetadata, {
          onReceiveMetadata: (metadata) => {
            this.trace("Received metadata from child [" + child.getCallNumber() + "]");
            this.commitCall(index);
            receivedMetadata = true;
            if (previousAttempts > 0) {
              metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);
            }
            if (this.underlyingCalls[index].state === "ACTIVE") {
              this.listener.onReceiveMetadata(metadata);
            }
          },
          onReceiveMessage: (message) => {
            this.trace("Received message from child [" + child.getCallNumber() + "]");
            this.commitCall(index);
            if (this.underlyingCalls[index].state === "ACTIVE") {
              this.listener.onReceiveMessage(message);
            }
          },
          onReceiveStatus: (status) => {
            this.trace("Received status from child [" + child.getCallNumber() + "]");
            if (!receivedMetadata && previousAttempts > 0) {
              status.metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);
            }
            this.handleChildStatus(status, index);
          }
        });
        this.sendNextChildMessage(index);
        if (this.readStarted) {
          child.startRead();
        }
      }
      start(metadata, listener) {
        this.trace("start called");
        this.listener = listener;
        this.initialMetadata = metadata;
        this.attempts += 1;
        this.startNewAttempt();
        this.maybeStartHedgingTimer();
      }
      handleChildWriteCompleted(childIndex) {
        var _a12, _b5;
        const childCall = this.underlyingCalls[childIndex];
        const messageIndex = childCall.nextMessageToSend;
        (_b5 = (_a12 = this.getBufferEntry(messageIndex)).callback) === null || _b5 === void 0 ? void 0 : _b5.call(_a12);
        this.clearSentMessages();
        childCall.nextMessageToSend += 1;
        this.sendNextChildMessage(childIndex);
      }
      sendNextChildMessage(childIndex) {
        const childCall = this.underlyingCalls[childIndex];
        if (childCall.state === "COMPLETED") {
          return;
        }
        if (this.getBufferEntry(childCall.nextMessageToSend)) {
          const bufferEntry = this.getBufferEntry(childCall.nextMessageToSend);
          switch (bufferEntry.entryType) {
            case "MESSAGE":
              childCall.call.sendMessageWithContext({
                callback: (error) => {
                  this.handleChildWriteCompleted(childIndex);
                }
              }, bufferEntry.message.message);
              break;
            case "HALF_CLOSE":
              childCall.nextMessageToSend += 1;
              childCall.call.halfClose();
              break;
            case "FREED":
              break;
          }
        }
      }
      sendMessageWithContext(context3, message) {
        var _a12;
        this.trace("write() called with message of length " + message.length);
        const writeObj = {
          message,
          flags: context3.flags
        };
        const messageIndex = this.getNextBufferIndex();
        const bufferEntry = {
          entryType: "MESSAGE",
          message: writeObj,
          allocated: this.bufferTracker.allocate(message.length, this.callNumber)
        };
        this.writeBuffer.push(bufferEntry);
        if (bufferEntry.allocated) {
          (_a12 = context3.callback) === null || _a12 === void 0 ? void 0 : _a12.call(context3);
          for (const [callIndex, call] of this.underlyingCalls.entries()) {
            if (call.state === "ACTIVE" && call.nextMessageToSend === messageIndex) {
              call.call.sendMessageWithContext({
                callback: (error) => {
                  this.handleChildWriteCompleted(callIndex);
                }
              }, message);
            }
          }
        } else {
          this.commitCallWithMostMessages();
          if (this.committedCallIndex === null) {
            return;
          }
          const call = this.underlyingCalls[this.committedCallIndex];
          bufferEntry.callback = context3.callback;
          if (call.state === "ACTIVE" && call.nextMessageToSend === messageIndex) {
            call.call.sendMessageWithContext({
              callback: (error) => {
                this.handleChildWriteCompleted(this.committedCallIndex);
              }
            }, message);
          }
        }
      }
      startRead() {
        this.trace("startRead called");
        this.readStarted = true;
        for (const underlyingCall of this.underlyingCalls) {
          if ((underlyingCall === null || underlyingCall === void 0 ? void 0 : underlyingCall.state) === "ACTIVE") {
            underlyingCall.call.startRead();
          }
        }
      }
      halfClose() {
        this.trace("halfClose called");
        const halfCloseIndex = this.getNextBufferIndex();
        this.writeBuffer.push({
          entryType: "HALF_CLOSE",
          allocated: false
        });
        for (const call of this.underlyingCalls) {
          if ((call === null || call === void 0 ? void 0 : call.state) === "ACTIVE" && call.nextMessageToSend === halfCloseIndex) {
            call.nextMessageToSend += 1;
            call.call.halfClose();
          }
        }
      }
      setCredentials(newCredentials) {
        throw new Error("Method not implemented.");
      }
      getMethod() {
        return this.methodName;
      }
      getHost() {
        return this.host;
      }
    };
    exports.RetryingCall = RetryingCall;
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel-interface.js
var require_subchannel_interface = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/subchannel-interface.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseSubchannelWrapper = void 0;
    var BaseSubchannelWrapper = class {
      constructor(child) {
        this.child = child;
        this.healthy = true;
        this.healthListeners = /* @__PURE__ */ new Set();
        child.addHealthStateWatcher((childHealthy) => {
          if (this.healthy) {
            this.updateHealthListeners();
          }
        });
      }
      updateHealthListeners() {
        for (const listener of this.healthListeners) {
          listener(this.isHealthy());
        }
      }
      getConnectivityState() {
        return this.child.getConnectivityState();
      }
      addConnectivityStateListener(listener) {
        this.child.addConnectivityStateListener(listener);
      }
      removeConnectivityStateListener(listener) {
        this.child.removeConnectivityStateListener(listener);
      }
      startConnecting() {
        this.child.startConnecting();
      }
      getAddress() {
        return this.child.getAddress();
      }
      throttleKeepalive(newKeepaliveTime) {
        this.child.throttleKeepalive(newKeepaliveTime);
      }
      ref() {
        this.child.ref();
      }
      unref() {
        this.child.unref();
      }
      getChannelzRef() {
        return this.child.getChannelzRef();
      }
      isHealthy() {
        return this.healthy && this.child.isHealthy();
      }
      addHealthStateWatcher(listener) {
        this.healthListeners.add(listener);
      }
      removeHealthStateWatcher(listener) {
        this.healthListeners.delete(listener);
      }
      setHealthy(healthy) {
        if (healthy !== this.healthy) {
          this.healthy = healthy;
          if (this.child.isHealthy()) {
            this.updateHealthListeners();
          }
        }
      }
      getRealSubchannel() {
        return this.child.getRealSubchannel();
      }
      realSubchannelEquals(other) {
        return this.getRealSubchannel() === other.getRealSubchannel();
      }
    };
    exports.BaseSubchannelWrapper = BaseSubchannelWrapper;
  }
});

// node_modules/@grpc/grpc-js/build/src/internal-channel.js
var require_internal_channel = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/internal-channel.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InternalChannel = void 0;
    var channel_credentials_1 = require_channel_credentials();
    var resolving_load_balancer_1 = require_resolving_load_balancer();
    var subchannel_pool_1 = require_subchannel_pool();
    var picker_1 = require_picker();
    var metadata_1 = require_metadata();
    var constants_1 = require_constants5();
    var filter_stack_1 = require_filter_stack();
    var compression_filter_1 = require_compression_filter();
    var resolver_1 = require_resolver();
    var logging_1 = require_logging();
    var http_proxy_1 = require_http_proxy();
    var uri_parser_1 = require_uri_parser();
    var connectivity_state_1 = require_connectivity_state();
    var channelz_1 = require_channelz();
    var load_balancing_call_1 = require_load_balancing_call();
    var deadline_1 = require_deadline();
    var resolving_call_1 = require_resolving_call();
    var call_number_1 = require_call_number();
    var control_plane_status_1 = require_control_plane_status();
    var retrying_call_1 = require_retrying_call();
    var subchannel_interface_1 = require_subchannel_interface();
    var MAX_TIMEOUT_TIME = 2147483647;
    var MIN_IDLE_TIMEOUT_MS = 1e3;
    var DEFAULT_IDLE_TIMEOUT_MS = 30 * 60 * 1e3;
    var RETRY_THROTTLER_MAP = /* @__PURE__ */ new Map();
    var DEFAULT_RETRY_BUFFER_SIZE_BYTES = 1 << 24;
    var DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES = 1 << 20;
    var ChannelSubchannelWrapper = class extends subchannel_interface_1.BaseSubchannelWrapper {
      constructor(childSubchannel, channel) {
        super(childSubchannel);
        this.channel = channel;
        this.refCount = 0;
        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime) => {
          channel.throttleKeepalive(keepaliveTime);
        };
        childSubchannel.addConnectivityStateListener(this.subchannelStateListener);
      }
      ref() {
        this.child.ref();
        this.refCount += 1;
      }
      unref() {
        this.child.unref();
        this.refCount -= 1;
        if (this.refCount <= 0) {
          this.child.removeConnectivityStateListener(this.subchannelStateListener);
          this.channel.removeWrappedSubchannel(this);
        }
      }
    };
    var ShutdownPicker = class {
      pick(pickArgs) {
        return {
          pickResultType: picker_1.PickResultType.DROP,
          status: {
            code: constants_1.Status.UNAVAILABLE,
            details: "Channel closed before call started",
            metadata: new metadata_1.Metadata()
          },
          subchannel: null,
          onCallStarted: null,
          onCallEnded: null
        };
      }
    };
    var InternalChannel = class {
      constructor(target, credentials, options) {
        var _a12, _b5, _c4, _d4, _e4, _f3, _g2, _h;
        this.credentials = credentials;
        this.options = options;
        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;
        this.currentPicker = new picker_1.UnavailablePicker();
        this.configSelectionQueue = [];
        this.pickQueue = [];
        this.connectivityStateWatchers = [];
        this.configSelector = null;
        this.currentResolutionError = null;
        this.wrappedSubchannels = /* @__PURE__ */ new Set();
        this.callCount = 0;
        this.idleTimer = null;
        this.channelzEnabled = true;
        this.callTracker = new channelz_1.ChannelzCallTracker();
        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();
        this.randomChannelId = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
        if (typeof target !== "string") {
          throw new TypeError("Channel target must be a string");
        }
        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {
          throw new TypeError("Channel credentials must be a ChannelCredentials object");
        }
        if (options) {
          if (typeof options !== "object") {
            throw new TypeError("Channel options must be an object");
          }
        }
        this.originalTarget = target;
        const originalTargetUri = (0, uri_parser_1.parseUri)(target);
        if (originalTargetUri === null) {
          throw new Error(`Could not parse target name "${target}"`);
        }
        const defaultSchemeMapResult = (0, resolver_1.mapUriDefaultScheme)(originalTargetUri);
        if (defaultSchemeMapResult === null) {
          throw new Error(`Could not find a default scheme for target name "${target}"`);
        }
        this.callRefTimer = setInterval(() => {
        }, MAX_TIMEOUT_TIME);
        (_b5 = (_a12 = this.callRefTimer).unref) === null || _b5 === void 0 ? void 0 : _b5.call(_a12);
        if (this.options["grpc.enable_channelz"] === 0) {
          this.channelzEnabled = false;
        }
        this.channelzTrace = new channelz_1.ChannelzTrace();
        this.channelzRef = (0, channelz_1.registerChannelzChannel)(target, () => this.getChannelzInfo(), this.channelzEnabled);
        if (this.channelzEnabled) {
          this.channelzTrace.addTrace("CT_INFO", "Channel created");
        }
        if (this.options["grpc.default_authority"]) {
          this.defaultAuthority = this.options["grpc.default_authority"];
        } else {
          this.defaultAuthority = (0, resolver_1.getDefaultAuthority)(defaultSchemeMapResult);
        }
        const proxyMapResult = (0, http_proxy_1.mapProxyName)(defaultSchemeMapResult, options);
        this.target = proxyMapResult.target;
        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);
        this.subchannelPool = (0, subchannel_pool_1.getSubchannelPool)(((_c4 = options["grpc.use_local_subchannel_pool"]) !== null && _c4 !== void 0 ? _c4 : 0) === 0);
        this.retryBufferTracker = new retrying_call_1.MessageBufferTracker((_d4 = options["grpc.retry_buffer_size"]) !== null && _d4 !== void 0 ? _d4 : DEFAULT_RETRY_BUFFER_SIZE_BYTES, (_e4 = options["grpc.per_rpc_retry_buffer_size"]) !== null && _e4 !== void 0 ? _e4 : DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES);
        this.keepaliveTime = (_f3 = options["grpc.keepalive_time_ms"]) !== null && _f3 !== void 0 ? _f3 : -1;
        this.idleTimeoutMs = Math.max((_g2 = options["grpc.client_idle_timeout_ms"]) !== null && _g2 !== void 0 ? _g2 : DEFAULT_IDLE_TIMEOUT_MS, MIN_IDLE_TIMEOUT_MS);
        const channelControlHelper = {
          createSubchannel: (subchannelAddress, subchannelArgs, credentialsOverride) => {
            const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), credentialsOverride !== null && credentialsOverride !== void 0 ? credentialsOverride : this.credentials);
            subchannel.throttleKeepalive(this.keepaliveTime);
            if (this.channelzEnabled) {
              this.channelzTrace.addTrace("CT_INFO", "Created subchannel or used existing subchannel", subchannel.getChannelzRef());
            }
            const wrappedSubchannel = new ChannelSubchannelWrapper(subchannel, this);
            this.wrappedSubchannels.add(wrappedSubchannel);
            return wrappedSubchannel;
          },
          updateState: (connectivityState, picker) => {
            this.currentPicker = picker;
            const queueCopy = this.pickQueue.slice();
            this.pickQueue = [];
            if (queueCopy.length > 0) {
              this.callRefTimerUnref();
            }
            for (const call of queueCopy) {
              call.doPick();
            }
            this.updateState(connectivityState);
          },
          requestReresolution: () => {
            throw new Error("Resolving load balancer should never call requestReresolution");
          },
          addChannelzChild: (child) => {
            if (this.channelzEnabled) {
              this.childrenTracker.refChild(child);
            }
          },
          removeChannelzChild: (child) => {
            if (this.channelzEnabled) {
              this.childrenTracker.unrefChild(child);
            }
          }
        };
        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, credentials, options, (serviceConfig, configSelector) => {
          if (serviceConfig.retryThrottling) {
            RETRY_THROTTLER_MAP.set(this.getTarget(), new retrying_call_1.RetryThrottler(serviceConfig.retryThrottling.maxTokens, serviceConfig.retryThrottling.tokenRatio, RETRY_THROTTLER_MAP.get(this.getTarget())));
          } else {
            RETRY_THROTTLER_MAP.delete(this.getTarget());
          }
          if (this.channelzEnabled) {
            this.channelzTrace.addTrace("CT_INFO", "Address resolution succeeded");
          }
          this.configSelector = configSelector;
          this.currentResolutionError = null;
          process.nextTick(() => {
            const localQueue = this.configSelectionQueue;
            this.configSelectionQueue = [];
            if (localQueue.length > 0) {
              this.callRefTimerUnref();
            }
            for (const call of localQueue) {
              call.getConfig();
            }
          });
        }, (status) => {
          if (this.channelzEnabled) {
            this.channelzTrace.addTrace("CT_WARNING", "Address resolution failed with code " + status.code + ' and details "' + status.details + '"');
          }
          if (this.configSelectionQueue.length > 0) {
            this.trace("Name resolution failed with calls queued for config selection");
          }
          if (this.configSelector === null) {
            this.currentResolutionError = Object.assign(Object.assign({}, (0, control_plane_status_1.restrictControlPlaneStatusCode)(status.code, status.details)), { metadata: status.metadata });
          }
          const localQueue = this.configSelectionQueue;
          this.configSelectionQueue = [];
          if (localQueue.length > 0) {
            this.callRefTimerUnref();
          }
          for (const call of localQueue) {
            call.reportResolverError(status);
          }
        });
        this.filterStackFactory = new filter_stack_1.FilterStackFactory([
          new compression_filter_1.CompressionFilterFactory(this, this.options)
        ]);
        this.trace("Channel constructed with options " + JSON.stringify(options, void 0, 2));
        const error = new Error();
        if ((0, logging_1.isTracerEnabled)("channel_stacktrace")) {
          (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, "channel_stacktrace", "(" + this.channelzRef.id + ") Channel constructed \n" + ((_h = error.stack) === null || _h === void 0 ? void 0 : _h.substring(error.stack.indexOf("\n") + 1)));
        }
        this.lastActivityTimestamp = /* @__PURE__ */ new Date();
      }
      getChannelzInfo() {
        return {
          target: this.originalTarget,
          state: this.connectivityState,
          trace: this.channelzTrace,
          callTracker: this.callTracker,
          children: this.childrenTracker.getChildLists()
        };
      }
      trace(text, verbosityOverride) {
        (0, logging_1.trace)(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, "channel", "(" + this.channelzRef.id + ") " + (0, uri_parser_1.uriToString)(this.target) + " " + text);
      }
      callRefTimerRef() {
        var _a12, _b5, _c4, _d4;
        if (!((_b5 = (_a12 = this.callRefTimer).hasRef) === null || _b5 === void 0 ? void 0 : _b5.call(_a12))) {
          this.trace("callRefTimer.ref | configSelectionQueue.length=" + this.configSelectionQueue.length + " pickQueue.length=" + this.pickQueue.length);
          (_d4 = (_c4 = this.callRefTimer).ref) === null || _d4 === void 0 ? void 0 : _d4.call(_c4);
        }
      }
      callRefTimerUnref() {
        var _a12, _b5;
        if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {
          this.trace("callRefTimer.unref | configSelectionQueue.length=" + this.configSelectionQueue.length + " pickQueue.length=" + this.pickQueue.length);
          (_b5 = (_a12 = this.callRefTimer).unref) === null || _b5 === void 0 ? void 0 : _b5.call(_a12);
        }
      }
      removeConnectivityStateWatcher(watcherObject) {
        const watcherIndex = this.connectivityStateWatchers.findIndex((value) => value === watcherObject);
        if (watcherIndex >= 0) {
          this.connectivityStateWatchers.splice(watcherIndex, 1);
        }
      }
      updateState(newState) {
        (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, "connectivity_state", "(" + this.channelzRef.id + ") " + (0, uri_parser_1.uriToString)(this.target) + " " + connectivity_state_1.ConnectivityState[this.connectivityState] + " -> " + connectivity_state_1.ConnectivityState[newState]);
        if (this.channelzEnabled) {
          this.channelzTrace.addTrace("CT_INFO", "Connectivity state change to " + connectivity_state_1.ConnectivityState[newState]);
        }
        this.connectivityState = newState;
        const watchersCopy = this.connectivityStateWatchers.slice();
        for (const watcherObject of watchersCopy) {
          if (newState !== watcherObject.currentState) {
            if (watcherObject.timer) {
              clearTimeout(watcherObject.timer);
            }
            this.removeConnectivityStateWatcher(watcherObject);
            watcherObject.callback();
          }
        }
        if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
          this.currentResolutionError = null;
        }
      }
      throttleKeepalive(newKeepaliveTime) {
        if (newKeepaliveTime > this.keepaliveTime) {
          this.keepaliveTime = newKeepaliveTime;
          for (const wrappedSubchannel of this.wrappedSubchannels) {
            wrappedSubchannel.throttleKeepalive(newKeepaliveTime);
          }
        }
      }
      removeWrappedSubchannel(wrappedSubchannel) {
        this.wrappedSubchannels.delete(wrappedSubchannel);
      }
      doPick(metadata, extraPickInfo) {
        return this.currentPicker.pick({
          metadata,
          extraPickInfo
        });
      }
      queueCallForPick(call) {
        this.pickQueue.push(call);
        this.callRefTimerRef();
      }
      getConfig(method, metadata) {
        if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN) {
          this.resolvingLoadBalancer.exitIdle();
        }
        if (this.configSelector) {
          return {
            type: "SUCCESS",
            config: this.configSelector(method, metadata, this.randomChannelId)
          };
        } else {
          if (this.currentResolutionError) {
            return {
              type: "ERROR",
              error: this.currentResolutionError
            };
          } else {
            return {
              type: "NONE"
            };
          }
        }
      }
      queueCallForConfig(call) {
        this.configSelectionQueue.push(call);
        this.callRefTimerRef();
      }
      enterIdle() {
        this.resolvingLoadBalancer.destroy();
        this.updateState(connectivity_state_1.ConnectivityState.IDLE);
        this.currentPicker = new picker_1.QueuePicker(this.resolvingLoadBalancer);
        if (this.idleTimer) {
          clearTimeout(this.idleTimer);
          this.idleTimer = null;
        }
      }
      startIdleTimeout(timeoutMs) {
        var _a12, _b5;
        this.idleTimer = setTimeout(() => {
          if (this.callCount > 0) {
            this.startIdleTimeout(this.idleTimeoutMs);
            return;
          }
          const now = /* @__PURE__ */ new Date();
          const timeSinceLastActivity = now.valueOf() - this.lastActivityTimestamp.valueOf();
          if (timeSinceLastActivity >= this.idleTimeoutMs) {
            this.trace("Idle timer triggered after " + this.idleTimeoutMs + "ms of inactivity");
            this.enterIdle();
          } else {
            this.startIdleTimeout(this.idleTimeoutMs - timeSinceLastActivity);
          }
        }, timeoutMs);
        (_b5 = (_a12 = this.idleTimer).unref) === null || _b5 === void 0 ? void 0 : _b5.call(_a12);
      }
      maybeStartIdleTimer() {
        if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN && !this.idleTimer) {
          this.startIdleTimeout(this.idleTimeoutMs);
        }
      }
      onCallStart() {
        if (this.channelzEnabled) {
          this.callTracker.addCallStarted();
        }
        this.callCount += 1;
      }
      onCallEnd(status) {
        if (this.channelzEnabled) {
          if (status.code === constants_1.Status.OK) {
            this.callTracker.addCallSucceeded();
          } else {
            this.callTracker.addCallFailed();
          }
        }
        this.callCount -= 1;
        this.lastActivityTimestamp = /* @__PURE__ */ new Date();
        this.maybeStartIdleTimer();
      }
      createLoadBalancingCall(callConfig, method, host, credentials, deadline) {
        const callNumber = (0, call_number_1.getNextCallNumber)();
        this.trace("createLoadBalancingCall [" + callNumber + '] method="' + method + '"');
        return new load_balancing_call_1.LoadBalancingCall(this, callConfig, method, host, credentials, deadline, callNumber);
      }
      createRetryingCall(callConfig, method, host, credentials, deadline) {
        const callNumber = (0, call_number_1.getNextCallNumber)();
        this.trace("createRetryingCall [" + callNumber + '] method="' + method + '"');
        return new retrying_call_1.RetryingCall(this, callConfig, method, host, credentials, deadline, callNumber, this.retryBufferTracker, RETRY_THROTTLER_MAP.get(this.getTarget()));
      }
      createInnerCall(callConfig, method, host, credentials, deadline) {
        if (this.options["grpc.enable_retries"] === 0) {
          return this.createLoadBalancingCall(callConfig, method, host, credentials, deadline);
        } else {
          return this.createRetryingCall(callConfig, method, host, credentials, deadline);
        }
      }
      createResolvingCall(method, deadline, host, parentCall, propagateFlags) {
        const callNumber = (0, call_number_1.getNextCallNumber)();
        this.trace("createResolvingCall [" + callNumber + '] method="' + method + '", deadline=' + (0, deadline_1.deadlineToString)(deadline));
        const finalOptions = {
          deadline,
          flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,
          host: host !== null && host !== void 0 ? host : this.defaultAuthority,
          parentCall
        };
        const call = new resolving_call_1.ResolvingCall(this, method, finalOptions, this.filterStackFactory.clone(), this.credentials._getCallCredentials(), callNumber);
        this.onCallStart();
        call.addStatusWatcher((status) => {
          this.onCallEnd(status);
        });
        return call;
      }
      close() {
        this.resolvingLoadBalancer.destroy();
        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);
        this.currentPicker = new ShutdownPicker();
        for (const call of this.configSelectionQueue) {
          call.cancelWithStatus(constants_1.Status.UNAVAILABLE, "Channel closed before call started");
        }
        this.configSelectionQueue = [];
        for (const call of this.pickQueue) {
          call.cancelWithStatus(constants_1.Status.UNAVAILABLE, "Channel closed before call started");
        }
        this.pickQueue = [];
        clearInterval(this.callRefTimer);
        if (this.idleTimer) {
          clearTimeout(this.idleTimer);
        }
        if (this.channelzEnabled) {
          (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
        }
        this.subchannelPool.unrefUnusedSubchannels();
      }
      getTarget() {
        return (0, uri_parser_1.uriToString)(this.target);
      }
      getConnectivityState(tryToConnect) {
        const connectivityState = this.connectivityState;
        if (tryToConnect) {
          this.resolvingLoadBalancer.exitIdle();
          this.lastActivityTimestamp = /* @__PURE__ */ new Date();
          this.maybeStartIdleTimer();
        }
        return connectivityState;
      }
      watchConnectivityState(currentState, deadline, callback) {
        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {
          throw new Error("Channel has been shut down");
        }
        let timer = null;
        if (deadline !== Infinity) {
          const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);
          const now = /* @__PURE__ */ new Date();
          if (deadline === -Infinity || deadlineDate <= now) {
            process.nextTick(callback, new Error("Deadline passed without connectivity state change"));
            return;
          }
          timer = setTimeout(() => {
            this.removeConnectivityStateWatcher(watcherObject);
            callback(new Error("Deadline passed without connectivity state change"));
          }, deadlineDate.getTime() - now.getTime());
        }
        const watcherObject = {
          currentState,
          callback,
          timer
        };
        this.connectivityStateWatchers.push(watcherObject);
      }
      /**
       * Get the channelz reference object for this channel. The returned value is
       * garbage if channelz is disabled for this channel.
       * @returns
       */
      getChannelzRef() {
        return this.channelzRef;
      }
      createCall(method, deadline, host, parentCall, propagateFlags) {
        if (typeof method !== "string") {
          throw new TypeError("Channel#createCall: method must be a string");
        }
        if (!(typeof deadline === "number" || deadline instanceof Date)) {
          throw new TypeError("Channel#createCall: deadline must be a number or Date");
        }
        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {
          throw new Error("Channel has been shut down");
        }
        return this.createResolvingCall(method, deadline, host, parentCall, propagateFlags);
      }
      getOptions() {
        return this.options;
      }
    };
    exports.InternalChannel = InternalChannel;
  }
});

// node_modules/@grpc/grpc-js/build/src/channel.js
var require_channel = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/channel.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChannelImplementation = void 0;
    var channel_credentials_1 = require_channel_credentials();
    var internal_channel_1 = require_internal_channel();
    var ChannelImplementation = class {
      constructor(target, credentials, options) {
        if (typeof target !== "string") {
          throw new TypeError("Channel target must be a string");
        }
        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {
          throw new TypeError("Channel credentials must be a ChannelCredentials object");
        }
        if (options) {
          if (typeof options !== "object") {
            throw new TypeError("Channel options must be an object");
          }
        }
        this.internalChannel = new internal_channel_1.InternalChannel(target, credentials, options);
      }
      close() {
        this.internalChannel.close();
      }
      getTarget() {
        return this.internalChannel.getTarget();
      }
      getConnectivityState(tryToConnect) {
        return this.internalChannel.getConnectivityState(tryToConnect);
      }
      watchConnectivityState(currentState, deadline, callback) {
        this.internalChannel.watchConnectivityState(currentState, deadline, callback);
      }
      /**
       * Get the channelz reference object for this channel. The returned value is
       * garbage if channelz is disabled for this channel.
       * @returns
       */
      getChannelzRef() {
        return this.internalChannel.getChannelzRef();
      }
      createCall(method, deadline, host, parentCall, propagateFlags) {
        if (typeof method !== "string") {
          throw new TypeError("Channel#createCall: method must be a string");
        }
        if (!(typeof deadline === "number" || deadline instanceof Date)) {
          throw new TypeError("Channel#createCall: deadline must be a number or Date");
        }
        return this.internalChannel.createCall(method, deadline, host, parentCall, propagateFlags);
      }
    };
    exports.ChannelImplementation = ChannelImplementation;
  }
});

// node_modules/@grpc/grpc-js/build/src/server-call.js
var require_server_call = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/server-call.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = exports.serverErrorToStatus = void 0;
    var events_1 = __require("events");
    var stream_1 = __require("stream");
    var constants_1 = require_constants5();
    var metadata_1 = require_metadata();
    function serverErrorToStatus(error, overrideTrailers) {
      var _a12;
      const status = {
        code: constants_1.Status.UNKNOWN,
        details: "message" in error ? error.message : "Unknown Error",
        metadata: (_a12 = overrideTrailers !== null && overrideTrailers !== void 0 ? overrideTrailers : error.metadata) !== null && _a12 !== void 0 ? _a12 : null
      };
      if ("code" in error && typeof error.code === "number" && Number.isInteger(error.code)) {
        status.code = error.code;
        if ("details" in error && typeof error.details === "string") {
          status.details = error.details;
        }
      }
      return status;
    }
    exports.serverErrorToStatus = serverErrorToStatus;
    var ServerUnaryCallImpl = class extends events_1.EventEmitter {
      constructor(path9, call, metadata, request) {
        super();
        this.path = path9;
        this.call = call;
        this.metadata = metadata;
        this.request = request;
        this.cancelled = false;
      }
      getPeer() {
        return this.call.getPeer();
      }
      sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
      }
      getDeadline() {
        return this.call.getDeadline();
      }
      getPath() {
        return this.path;
      }
      getHost() {
        return this.call.getHost();
      }
    };
    exports.ServerUnaryCallImpl = ServerUnaryCallImpl;
    var ServerReadableStreamImpl = class extends stream_1.Readable {
      constructor(path9, call, metadata) {
        super({ objectMode: true });
        this.path = path9;
        this.call = call;
        this.metadata = metadata;
        this.cancelled = false;
      }
      _read(size7) {
        this.call.startRead();
      }
      getPeer() {
        return this.call.getPeer();
      }
      sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
      }
      getDeadline() {
        return this.call.getDeadline();
      }
      getPath() {
        return this.path;
      }
      getHost() {
        return this.call.getHost();
      }
    };
    exports.ServerReadableStreamImpl = ServerReadableStreamImpl;
    var ServerWritableStreamImpl = class extends stream_1.Writable {
      constructor(path9, call, metadata, request) {
        super({ objectMode: true });
        this.path = path9;
        this.call = call;
        this.metadata = metadata;
        this.request = request;
        this.pendingStatus = {
          code: constants_1.Status.OK,
          details: "OK"
        };
        this.cancelled = false;
        this.trailingMetadata = new metadata_1.Metadata();
        this.on("error", (err) => {
          this.pendingStatus = serverErrorToStatus(err);
          this.end();
        });
      }
      getPeer() {
        return this.call.getPeer();
      }
      sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
      }
      getDeadline() {
        return this.call.getDeadline();
      }
      getPath() {
        return this.path;
      }
      getHost() {
        return this.call.getHost();
      }
      _write(chunk2, encoding, callback) {
        this.call.sendMessage(chunk2, callback);
      }
      _final(callback) {
        var _a12;
        callback(null);
        this.call.sendStatus(Object.assign(Object.assign({}, this.pendingStatus), { metadata: (_a12 = this.pendingStatus.metadata) !== null && _a12 !== void 0 ? _a12 : this.trailingMetadata }));
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      end(metadata) {
        if (metadata) {
          this.trailingMetadata = metadata;
        }
        return super.end();
      }
    };
    exports.ServerWritableStreamImpl = ServerWritableStreamImpl;
    var ServerDuplexStreamImpl = class extends stream_1.Duplex {
      constructor(path9, call, metadata) {
        super({ objectMode: true });
        this.path = path9;
        this.call = call;
        this.metadata = metadata;
        this.pendingStatus = {
          code: constants_1.Status.OK,
          details: "OK"
        };
        this.cancelled = false;
        this.trailingMetadata = new metadata_1.Metadata();
        this.on("error", (err) => {
          this.pendingStatus = serverErrorToStatus(err);
          this.end();
        });
      }
      getPeer() {
        return this.call.getPeer();
      }
      sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
      }
      getDeadline() {
        return this.call.getDeadline();
      }
      getPath() {
        return this.path;
      }
      getHost() {
        return this.call.getHost();
      }
      _read(size7) {
        this.call.startRead();
      }
      _write(chunk2, encoding, callback) {
        this.call.sendMessage(chunk2, callback);
      }
      _final(callback) {
        var _a12;
        callback(null);
        this.call.sendStatus(Object.assign(Object.assign({}, this.pendingStatus), { metadata: (_a12 = this.pendingStatus.metadata) !== null && _a12 !== void 0 ? _a12 : this.trailingMetadata }));
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      end(metadata) {
        if (metadata) {
          this.trailingMetadata = metadata;
        }
        return super.end();
      }
    };
    exports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;
  }
});

// node_modules/@grpc/grpc-js/build/src/server-credentials.js
var require_server_credentials = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/server-credentials.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createServerCredentialsWithInterceptors = exports.createCertificateProviderServerCredentials = exports.ServerCredentials = void 0;
    var tls_helpers_1 = require_tls_helpers();
    var ServerCredentials = class {
      constructor() {
        this.watchers = /* @__PURE__ */ new Set();
        this.latestContextOptions = null;
      }
      _addWatcher(watcher) {
        this.watchers.add(watcher);
      }
      _removeWatcher(watcher) {
        this.watchers.delete(watcher);
      }
      getWatcherCount() {
        return this.watchers.size;
      }
      updateSecureContextOptions(options) {
        this.latestContextOptions = options;
        for (const watcher of this.watchers) {
          watcher(this.latestContextOptions);
        }
      }
      _getSettings() {
        return this.latestContextOptions;
      }
      _getInterceptors() {
        return [];
      }
      static createInsecure() {
        return new InsecureServerCredentials();
      }
      static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {
        var _a12;
        if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {
          throw new TypeError("rootCerts must be null or a Buffer");
        }
        if (!Array.isArray(keyCertPairs)) {
          throw new TypeError("keyCertPairs must be an array");
        }
        if (typeof checkClientCertificate !== "boolean") {
          throw new TypeError("checkClientCertificate must be a boolean");
        }
        const cert = [];
        const key = [];
        for (let i2 = 0; i2 < keyCertPairs.length; i2++) {
          const pair = keyCertPairs[i2];
          if (pair === null || typeof pair !== "object") {
            throw new TypeError(`keyCertPair[${i2}] must be an object`);
          }
          if (!Buffer.isBuffer(pair.private_key)) {
            throw new TypeError(`keyCertPair[${i2}].private_key must be a Buffer`);
          }
          if (!Buffer.isBuffer(pair.cert_chain)) {
            throw new TypeError(`keyCertPair[${i2}].cert_chain must be a Buffer`);
          }
          cert.push(pair.cert_chain);
          key.push(pair.private_key);
        }
        return new SecureServerCredentials({
          ca: (_a12 = rootCerts !== null && rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a12 !== void 0 ? _a12 : void 0,
          cert,
          key,
          requestCert: checkClientCertificate,
          ciphers: tls_helpers_1.CIPHER_SUITES
        });
      }
    };
    exports.ServerCredentials = ServerCredentials;
    var InsecureServerCredentials = class _InsecureServerCredentials extends ServerCredentials {
      _isSecure() {
        return false;
      }
      _getSettings() {
        return null;
      }
      _equals(other) {
        return other instanceof _InsecureServerCredentials;
      }
    };
    var SecureServerCredentials = class _SecureServerCredentials extends ServerCredentials {
      constructor(options) {
        super();
        this.options = options;
      }
      _isSecure() {
        return true;
      }
      _getSettings() {
        return this.options;
      }
      /**
       * Checks equality by checking the options that are actually set by
       * createSsl.
       * @param other
       * @returns
       */
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (!(other instanceof _SecureServerCredentials)) {
          return false;
        }
        if (Buffer.isBuffer(this.options.ca) && Buffer.isBuffer(other.options.ca)) {
          if (!this.options.ca.equals(other.options.ca)) {
            return false;
          }
        } else {
          if (this.options.ca !== other.options.ca) {
            return false;
          }
        }
        if (Array.isArray(this.options.cert) && Array.isArray(other.options.cert)) {
          if (this.options.cert.length !== other.options.cert.length) {
            return false;
          }
          for (let i2 = 0; i2 < this.options.cert.length; i2++) {
            const thisCert = this.options.cert[i2];
            const otherCert = other.options.cert[i2];
            if (Buffer.isBuffer(thisCert) && Buffer.isBuffer(otherCert)) {
              if (!thisCert.equals(otherCert)) {
                return false;
              }
            } else {
              if (thisCert !== otherCert) {
                return false;
              }
            }
          }
        } else {
          if (this.options.cert !== other.options.cert) {
            return false;
          }
        }
        if (Array.isArray(this.options.key) && Array.isArray(other.options.key)) {
          if (this.options.key.length !== other.options.key.length) {
            return false;
          }
          for (let i2 = 0; i2 < this.options.key.length; i2++) {
            const thisKey = this.options.key[i2];
            const otherKey = other.options.key[i2];
            if (Buffer.isBuffer(thisKey) && Buffer.isBuffer(otherKey)) {
              if (!thisKey.equals(otherKey)) {
                return false;
              }
            } else {
              if (thisKey !== otherKey) {
                return false;
              }
            }
          }
        } else {
          if (this.options.key !== other.options.key) {
            return false;
          }
        }
        if (this.options.requestCert !== other.options.requestCert) {
          return false;
        }
        return true;
      }
    };
    var CertificateProviderServerCredentials = class _CertificateProviderServerCredentials extends ServerCredentials {
      constructor(identityCertificateProvider, caCertificateProvider, requireClientCertificate) {
        super();
        this.identityCertificateProvider = identityCertificateProvider;
        this.caCertificateProvider = caCertificateProvider;
        this.requireClientCertificate = requireClientCertificate;
        this.latestCaUpdate = null;
        this.latestIdentityUpdate = null;
        this.caCertificateUpdateListener = this.handleCaCertificateUpdate.bind(this);
        this.identityCertificateUpdateListener = this.handleIdentityCertitificateUpdate.bind(this);
      }
      _addWatcher(watcher) {
        var _a12;
        if (this.getWatcherCount() === 0) {
          (_a12 = this.caCertificateProvider) === null || _a12 === void 0 ? void 0 : _a12.addCaCertificateListener(this.caCertificateUpdateListener);
          this.identityCertificateProvider.addIdentityCertificateListener(this.identityCertificateUpdateListener);
        }
        super._addWatcher(watcher);
      }
      _removeWatcher(watcher) {
        var _a12;
        super._removeWatcher(watcher);
        if (this.getWatcherCount() === 0) {
          (_a12 = this.caCertificateProvider) === null || _a12 === void 0 ? void 0 : _a12.removeCaCertificateListener(this.caCertificateUpdateListener);
          this.identityCertificateProvider.removeIdentityCertificateListener(this.identityCertificateUpdateListener);
        }
      }
      _isSecure() {
        return true;
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (!(other instanceof _CertificateProviderServerCredentials)) {
          return false;
        }
        return this.caCertificateProvider === other.caCertificateProvider && this.identityCertificateProvider === other.identityCertificateProvider && this.requireClientCertificate === other.requireClientCertificate;
      }
      calculateSecureContextOptions() {
        var _a12;
        if (this.latestIdentityUpdate === null) {
          return null;
        }
        if (this.caCertificateProvider !== null && this.latestCaUpdate === null) {
          return null;
        }
        return {
          ca: (_a12 = this.latestCaUpdate) === null || _a12 === void 0 ? void 0 : _a12.caCertificate,
          cert: this.latestIdentityUpdate.certificate,
          key: this.latestIdentityUpdate.privateKey,
          requestCert: this.latestIdentityUpdate !== null,
          rejectUnauthorized: this.requireClientCertificate
        };
      }
      finalizeUpdate() {
        this.updateSecureContextOptions(this.calculateSecureContextOptions());
      }
      handleCaCertificateUpdate(update4) {
        this.latestCaUpdate = update4;
        this.finalizeUpdate();
      }
      handleIdentityCertitificateUpdate(update4) {
        this.latestIdentityUpdate = update4;
        this.finalizeUpdate();
      }
    };
    function createCertificateProviderServerCredentials(caCertificateProvider, identityCertificateProvider, requireClientCertificate) {
      return new CertificateProviderServerCredentials(caCertificateProvider, identityCertificateProvider, requireClientCertificate);
    }
    exports.createCertificateProviderServerCredentials = createCertificateProviderServerCredentials;
    var InterceptorServerCredentials = class _InterceptorServerCredentials extends ServerCredentials {
      constructor(childCredentials, interceptors) {
        super();
        this.childCredentials = childCredentials;
        this.interceptors = interceptors;
      }
      _isSecure() {
        return this.childCredentials._isSecure();
      }
      _equals(other) {
        if (!(other instanceof _InterceptorServerCredentials)) {
          return false;
        }
        if (!this.childCredentials._equals(other.childCredentials)) {
          return false;
        }
        if (this.interceptors.length !== other.interceptors.length) {
          return false;
        }
        for (let i2 = 0; i2 < this.interceptors.length; i2++) {
          if (this.interceptors[i2] !== other.interceptors[i2]) {
            return false;
          }
        }
        return true;
      }
      _getInterceptors() {
        return this.interceptors;
      }
      _addWatcher(watcher) {
        this.childCredentials._addWatcher(watcher);
      }
      _removeWatcher(watcher) {
        this.childCredentials._removeWatcher(watcher);
      }
    };
    function createServerCredentialsWithInterceptors(credentials, interceptors) {
      return new InterceptorServerCredentials(credentials, interceptors);
    }
    exports.createServerCredentialsWithInterceptors = createServerCredentialsWithInterceptors;
  }
});

// node_modules/@grpc/grpc-js/build/src/server-interceptors.js
var require_server_interceptors = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/server-interceptors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getServerInterceptingCall = exports.BaseServerInterceptingCall = exports.ServerInterceptingCall = exports.ResponderBuilder = exports.isInterceptingServerListener = exports.ServerListenerBuilder = void 0;
    var metadata_1 = require_metadata();
    var constants_1 = require_constants5();
    var http2 = __require("http2");
    var error_1 = require_error();
    var zlib = __require("zlib");
    var stream_decoder_1 = require_stream_decoder();
    var logging = require_logging();
    var TRACER_NAME = "server_call";
    function trace3(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var ServerListenerBuilder = class {
      constructor() {
        this.metadata = void 0;
        this.message = void 0;
        this.halfClose = void 0;
        this.cancel = void 0;
      }
      withOnReceiveMetadata(onReceiveMetadata) {
        this.metadata = onReceiveMetadata;
        return this;
      }
      withOnReceiveMessage(onReceiveMessage) {
        this.message = onReceiveMessage;
        return this;
      }
      withOnReceiveHalfClose(onReceiveHalfClose) {
        this.halfClose = onReceiveHalfClose;
        return this;
      }
      withOnCancel(onCancel) {
        this.cancel = onCancel;
        return this;
      }
      build() {
        return {
          onReceiveMetadata: this.metadata,
          onReceiveMessage: this.message,
          onReceiveHalfClose: this.halfClose,
          onCancel: this.cancel
        };
      }
    };
    exports.ServerListenerBuilder = ServerListenerBuilder;
    function isInterceptingServerListener(listener) {
      return listener.onReceiveMetadata !== void 0 && listener.onReceiveMetadata.length === 1;
    }
    exports.isInterceptingServerListener = isInterceptingServerListener;
    var InterceptingServerListenerImpl = class {
      constructor(listener, nextListener) {
        this.listener = listener;
        this.nextListener = nextListener;
        this.cancelled = false;
        this.processingMetadata = false;
        this.hasPendingMessage = false;
        this.pendingMessage = null;
        this.processingMessage = false;
        this.hasPendingHalfClose = false;
      }
      processPendingMessage() {
        if (this.hasPendingMessage) {
          this.nextListener.onReceiveMessage(this.pendingMessage);
          this.pendingMessage = null;
          this.hasPendingMessage = false;
        }
      }
      processPendingHalfClose() {
        if (this.hasPendingHalfClose) {
          this.nextListener.onReceiveHalfClose();
          this.hasPendingHalfClose = false;
        }
      }
      onReceiveMetadata(metadata) {
        if (this.cancelled) {
          return;
        }
        this.processingMetadata = true;
        this.listener.onReceiveMetadata(metadata, (interceptedMetadata) => {
          this.processingMetadata = false;
          if (this.cancelled) {
            return;
          }
          this.nextListener.onReceiveMetadata(interceptedMetadata);
          this.processPendingMessage();
          this.processPendingHalfClose();
        });
      }
      onReceiveMessage(message) {
        if (this.cancelled) {
          return;
        }
        this.processingMessage = true;
        this.listener.onReceiveMessage(message, (msg) => {
          this.processingMessage = false;
          if (this.cancelled) {
            return;
          }
          if (this.processingMetadata) {
            this.pendingMessage = msg;
            this.hasPendingMessage = true;
          } else {
            this.nextListener.onReceiveMessage(msg);
            this.processPendingHalfClose();
          }
        });
      }
      onReceiveHalfClose() {
        if (this.cancelled) {
          return;
        }
        this.listener.onReceiveHalfClose(() => {
          if (this.cancelled) {
            return;
          }
          if (this.processingMetadata || this.processingMessage) {
            this.hasPendingHalfClose = true;
          } else {
            this.nextListener.onReceiveHalfClose();
          }
        });
      }
      onCancel() {
        this.cancelled = true;
        this.listener.onCancel();
        this.nextListener.onCancel();
      }
    };
    var ResponderBuilder = class {
      constructor() {
        this.start = void 0;
        this.metadata = void 0;
        this.message = void 0;
        this.status = void 0;
      }
      withStart(start) {
        this.start = start;
        return this;
      }
      withSendMetadata(sendMetadata) {
        this.metadata = sendMetadata;
        return this;
      }
      withSendMessage(sendMessage) {
        this.message = sendMessage;
        return this;
      }
      withSendStatus(sendStatus) {
        this.status = sendStatus;
        return this;
      }
      build() {
        return {
          start: this.start,
          sendMetadata: this.metadata,
          sendMessage: this.message,
          sendStatus: this.status
        };
      }
    };
    exports.ResponderBuilder = ResponderBuilder;
    var defaultServerListener = {
      onReceiveMetadata: (metadata, next2) => {
        next2(metadata);
      },
      onReceiveMessage: (message, next2) => {
        next2(message);
      },
      onReceiveHalfClose: (next2) => {
        next2();
      },
      onCancel: () => {
      }
    };
    var defaultResponder = {
      start: (next2) => {
        next2();
      },
      sendMetadata: (metadata, next2) => {
        next2(metadata);
      },
      sendMessage: (message, next2) => {
        next2(message);
      },
      sendStatus: (status, next2) => {
        next2(status);
      }
    };
    var ServerInterceptingCall = class {
      constructor(nextCall, responder) {
        var _a12, _b5, _c4, _d4;
        this.nextCall = nextCall;
        this.processingMetadata = false;
        this.processingMessage = false;
        this.pendingMessage = null;
        this.pendingMessageCallback = null;
        this.pendingStatus = null;
        this.responder = {
          start: (_a12 = responder === null || responder === void 0 ? void 0 : responder.start) !== null && _a12 !== void 0 ? _a12 : defaultResponder.start,
          sendMetadata: (_b5 = responder === null || responder === void 0 ? void 0 : responder.sendMetadata) !== null && _b5 !== void 0 ? _b5 : defaultResponder.sendMetadata,
          sendMessage: (_c4 = responder === null || responder === void 0 ? void 0 : responder.sendMessage) !== null && _c4 !== void 0 ? _c4 : defaultResponder.sendMessage,
          sendStatus: (_d4 = responder === null || responder === void 0 ? void 0 : responder.sendStatus) !== null && _d4 !== void 0 ? _d4 : defaultResponder.sendStatus
        };
      }
      processPendingMessage() {
        if (this.pendingMessageCallback) {
          this.nextCall.sendMessage(this.pendingMessage, this.pendingMessageCallback);
          this.pendingMessage = null;
          this.pendingMessageCallback = null;
        }
      }
      processPendingStatus() {
        if (this.pendingStatus) {
          this.nextCall.sendStatus(this.pendingStatus);
          this.pendingStatus = null;
        }
      }
      start(listener) {
        this.responder.start((interceptedListener) => {
          var _a12, _b5, _c4, _d4;
          const fullInterceptedListener = {
            onReceiveMetadata: (_a12 = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveMetadata) !== null && _a12 !== void 0 ? _a12 : defaultServerListener.onReceiveMetadata,
            onReceiveMessage: (_b5 = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveMessage) !== null && _b5 !== void 0 ? _b5 : defaultServerListener.onReceiveMessage,
            onReceiveHalfClose: (_c4 = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveHalfClose) !== null && _c4 !== void 0 ? _c4 : defaultServerListener.onReceiveHalfClose,
            onCancel: (_d4 = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onCancel) !== null && _d4 !== void 0 ? _d4 : defaultServerListener.onCancel
          };
          const finalInterceptingListener = new InterceptingServerListenerImpl(fullInterceptedListener, listener);
          this.nextCall.start(finalInterceptingListener);
        });
      }
      sendMetadata(metadata) {
        this.processingMetadata = true;
        this.responder.sendMetadata(metadata, (interceptedMetadata) => {
          this.processingMetadata = false;
          this.nextCall.sendMetadata(interceptedMetadata);
          this.processPendingMessage();
          this.processPendingStatus();
        });
      }
      sendMessage(message, callback) {
        this.processingMessage = true;
        this.responder.sendMessage(message, (interceptedMessage) => {
          this.processingMessage = false;
          if (this.processingMetadata) {
            this.pendingMessage = interceptedMessage;
            this.pendingMessageCallback = callback;
          } else {
            this.nextCall.sendMessage(interceptedMessage, callback);
          }
        });
      }
      sendStatus(status) {
        this.responder.sendStatus(status, (interceptedStatus) => {
          if (this.processingMetadata || this.processingMessage) {
            this.pendingStatus = interceptedStatus;
          } else {
            this.nextCall.sendStatus(interceptedStatus);
          }
        });
      }
      startRead() {
        this.nextCall.startRead();
      }
      getPeer() {
        return this.nextCall.getPeer();
      }
      getDeadline() {
        return this.nextCall.getDeadline();
      }
      getHost() {
        return this.nextCall.getHost();
      }
    };
    exports.ServerInterceptingCall = ServerInterceptingCall;
    var GRPC_ACCEPT_ENCODING_HEADER = "grpc-accept-encoding";
    var GRPC_ENCODING_HEADER = "grpc-encoding";
    var GRPC_MESSAGE_HEADER = "grpc-message";
    var GRPC_STATUS_HEADER = "grpc-status";
    var GRPC_TIMEOUT_HEADER = "grpc-timeout";
    var DEADLINE_REGEX = /(\d{1,8})\s*([HMSmun])/;
    var deadlineUnitsToMs = {
      H: 36e5,
      M: 6e4,
      S: 1e3,
      m: 1,
      u: 1e-3,
      n: 1e-6
    };
    var defaultCompressionHeaders = {
      // TODO(cjihrig): Remove these encoding headers from the default response
      // once compression is integrated.
      [GRPC_ACCEPT_ENCODING_HEADER]: "identity,deflate,gzip",
      [GRPC_ENCODING_HEADER]: "identity"
    };
    var defaultResponseHeaders = {
      [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,
      [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: "application/grpc+proto"
    };
    var defaultResponseOptions = {
      waitForTrailers: true
    };
    var BaseServerInterceptingCall = class {
      constructor(stream, headers, callEventTracker, handler, options) {
        var _a12;
        this.stream = stream;
        this.callEventTracker = callEventTracker;
        this.handler = handler;
        this.listener = null;
        this.deadlineTimer = null;
        this.deadline = Infinity;
        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
        this.cancelled = false;
        this.metadataSent = false;
        this.wantTrailers = false;
        this.cancelNotified = false;
        this.incomingEncoding = "identity";
        this.readQueue = [];
        this.isReadPending = false;
        this.receivedHalfClose = false;
        this.streamEnded = false;
        this.stream.once("error", (err) => {
        });
        this.stream.once("close", () => {
          var _a13;
          trace3("Request to method " + ((_a13 = this.handler) === null || _a13 === void 0 ? void 0 : _a13.path) + " stream closed with rstCode " + this.stream.rstCode);
          if (this.callEventTracker && !this.streamEnded) {
            this.streamEnded = true;
            this.callEventTracker.onStreamEnd(false);
            this.callEventTracker.onCallEnd({
              code: constants_1.Status.CANCELLED,
              details: "Stream closed before sending status",
              metadata: null
            });
          }
          this.notifyOnCancel();
        });
        this.stream.on("data", (data) => {
          this.handleDataFrame(data);
        });
        this.stream.pause();
        this.stream.on("end", () => {
          this.handleEndEvent();
        });
        if ("grpc.max_send_message_length" in options) {
          this.maxSendMessageSize = options["grpc.max_send_message_length"];
        }
        if ("grpc.max_receive_message_length" in options) {
          this.maxReceiveMessageSize = options["grpc.max_receive_message_length"];
        }
        this.host = (_a12 = headers[":authority"]) !== null && _a12 !== void 0 ? _a12 : headers.host;
        this.decoder = new stream_decoder_1.StreamDecoder(this.maxReceiveMessageSize);
        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);
        if (logging.isTracerEnabled(TRACER_NAME)) {
          trace3("Request to " + this.handler.path + " received headers " + JSON.stringify(metadata.toJSON()));
        }
        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);
        if (timeoutHeader.length > 0) {
          this.handleTimeoutHeader(timeoutHeader[0]);
        }
        const encodingHeader = metadata.get(GRPC_ENCODING_HEADER);
        if (encodingHeader.length > 0) {
          this.incomingEncoding = encodingHeader[0];
        }
        metadata.remove(GRPC_TIMEOUT_HEADER);
        metadata.remove(GRPC_ENCODING_HEADER);
        metadata.remove(GRPC_ACCEPT_ENCODING_HEADER);
        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);
        metadata.remove(http2.constants.HTTP2_HEADER_TE);
        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);
        this.metadata = metadata;
      }
      handleTimeoutHeader(timeoutHeader) {
        const match4 = timeoutHeader.toString().match(DEADLINE_REGEX);
        if (match4 === null) {
          const status = {
            code: constants_1.Status.INTERNAL,
            details: `Invalid ${GRPC_TIMEOUT_HEADER} value "${timeoutHeader}"`,
            metadata: null
          };
          process.nextTick(() => {
            this.sendStatus(status);
          });
          return;
        }
        const timeout4 = +match4[1] * deadlineUnitsToMs[match4[2]] | 0;
        const now = /* @__PURE__ */ new Date();
        this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout4);
        this.deadlineTimer = setTimeout(() => {
          const status = {
            code: constants_1.Status.DEADLINE_EXCEEDED,
            details: "Deadline exceeded",
            metadata: null
          };
          this.sendStatus(status);
        }, timeout4);
      }
      checkCancelled() {
        if (!this.cancelled && (this.stream.destroyed || this.stream.closed)) {
          this.notifyOnCancel();
          this.cancelled = true;
        }
        return this.cancelled;
      }
      notifyOnCancel() {
        if (this.cancelNotified) {
          return;
        }
        this.cancelNotified = true;
        this.cancelled = true;
        process.nextTick(() => {
          var _a12;
          (_a12 = this.listener) === null || _a12 === void 0 ? void 0 : _a12.onCancel();
        });
        if (this.deadlineTimer) {
          clearTimeout(this.deadlineTimer);
        }
        this.stream.resume();
      }
      /**
       * A server handler can start sending messages without explicitly sending
       * metadata. In that case, we need to send headers before sending any
       * messages. This function does that if necessary.
       */
      maybeSendMetadata() {
        if (!this.metadataSent) {
          this.sendMetadata(new metadata_1.Metadata());
        }
      }
      /**
       * Serialize a message to a length-delimited byte string.
       * @param value
       * @returns
       */
      serializeMessage(value) {
        const messageBuffer = this.handler.serialize(value);
        const byteLength = messageBuffer.byteLength;
        const output = Buffer.allocUnsafe(byteLength + 5);
        output.writeUInt8(0, 0);
        output.writeUInt32BE(byteLength, 1);
        messageBuffer.copy(output, 5);
        return output;
      }
      decompressMessage(message, encoding) {
        const messageContents = message.subarray(5);
        if (encoding === "identity") {
          return messageContents;
        } else if (encoding === "deflate" || encoding === "gzip") {
          let decompresser;
          if (encoding === "deflate") {
            decompresser = zlib.createInflate();
          } else {
            decompresser = zlib.createGunzip();
          }
          return new Promise((resolve, reject3) => {
            let totalLength = 0;
            const messageParts = [];
            decompresser.on("data", (chunk2) => {
              messageParts.push(chunk2);
              totalLength += chunk2.byteLength;
              if (this.maxReceiveMessageSize !== -1 && totalLength > this.maxReceiveMessageSize) {
                decompresser.destroy();
                reject3({
                  code: constants_1.Status.RESOURCE_EXHAUSTED,
                  details: `Received message that decompresses to a size larger than ${this.maxReceiveMessageSize}`
                });
              }
            });
            decompresser.on("end", () => {
              resolve(Buffer.concat(messageParts));
            });
            decompresser.write(messageContents);
            decompresser.end();
          });
        } else {
          return Promise.reject({
            code: constants_1.Status.UNIMPLEMENTED,
            details: `Received message compressed with unsupported encoding "${encoding}"`
          });
        }
      }
      async decompressAndMaybePush(queueEntry) {
        if (queueEntry.type !== "COMPRESSED") {
          throw new Error(`Invalid queue entry type: ${queueEntry.type}`);
        }
        const compressed = queueEntry.compressedMessage.readUInt8(0) === 1;
        const compressedMessageEncoding = compressed ? this.incomingEncoding : "identity";
        let decompressedMessage;
        try {
          decompressedMessage = await this.decompressMessage(queueEntry.compressedMessage, compressedMessageEncoding);
        } catch (err) {
          this.sendStatus(err);
          return;
        }
        try {
          queueEntry.parsedMessage = this.handler.deserialize(decompressedMessage);
        } catch (err) {
          this.sendStatus({
            code: constants_1.Status.INTERNAL,
            details: `Error deserializing request: ${err.message}`
          });
          return;
        }
        queueEntry.type = "READABLE";
        this.maybePushNextMessage();
      }
      maybePushNextMessage() {
        if (this.listener && this.isReadPending && this.readQueue.length > 0 && this.readQueue[0].type !== "COMPRESSED") {
          this.isReadPending = false;
          const nextQueueEntry = this.readQueue.shift();
          if (nextQueueEntry.type === "READABLE") {
            this.listener.onReceiveMessage(nextQueueEntry.parsedMessage);
          } else {
            this.listener.onReceiveHalfClose();
          }
        }
      }
      handleDataFrame(data) {
        var _a12;
        if (this.checkCancelled()) {
          return;
        }
        trace3("Request to " + this.handler.path + " received data frame of size " + data.length);
        let rawMessages;
        try {
          rawMessages = this.decoder.write(data);
        } catch (e2) {
          this.sendStatus({ code: constants_1.Status.RESOURCE_EXHAUSTED, details: e2.message });
          return;
        }
        for (const messageBytes of rawMessages) {
          this.stream.pause();
          const queueEntry = {
            type: "COMPRESSED",
            compressedMessage: messageBytes,
            parsedMessage: null
          };
          this.readQueue.push(queueEntry);
          this.decompressAndMaybePush(queueEntry);
          (_a12 = this.callEventTracker) === null || _a12 === void 0 ? void 0 : _a12.addMessageReceived();
        }
      }
      handleEndEvent() {
        this.readQueue.push({
          type: "HALF_CLOSE",
          compressedMessage: null,
          parsedMessage: null
        });
        this.receivedHalfClose = true;
        this.maybePushNextMessage();
      }
      start(listener) {
        trace3("Request to " + this.handler.path + " start called");
        if (this.checkCancelled()) {
          return;
        }
        this.listener = listener;
        listener.onReceiveMetadata(this.metadata);
      }
      sendMetadata(metadata) {
        if (this.checkCancelled()) {
          return;
        }
        if (this.metadataSent) {
          return;
        }
        this.metadataSent = true;
        const custom = metadata ? metadata.toHttp2Headers() : null;
        const headers = Object.assign(Object.assign(Object.assign({}, defaultResponseHeaders), defaultCompressionHeaders), custom);
        this.stream.respond(headers, defaultResponseOptions);
      }
      sendMessage(message, callback) {
        if (this.checkCancelled()) {
          return;
        }
        let response;
        try {
          response = this.serializeMessage(message);
        } catch (e2) {
          this.sendStatus({
            code: constants_1.Status.INTERNAL,
            details: `Error serializing response: ${(0, error_1.getErrorMessage)(e2)}`,
            metadata: null
          });
          return;
        }
        if (this.maxSendMessageSize !== -1 && response.length - 5 > this.maxSendMessageSize) {
          this.sendStatus({
            code: constants_1.Status.RESOURCE_EXHAUSTED,
            details: `Sent message larger than max (${response.length} vs. ${this.maxSendMessageSize})`,
            metadata: null
          });
          return;
        }
        this.maybeSendMetadata();
        trace3("Request to " + this.handler.path + " sent data frame of size " + response.length);
        this.stream.write(response, (error) => {
          var _a12;
          if (error) {
            this.sendStatus({
              code: constants_1.Status.INTERNAL,
              details: `Error writing message: ${(0, error_1.getErrorMessage)(error)}`,
              metadata: null
            });
            return;
          }
          (_a12 = this.callEventTracker) === null || _a12 === void 0 ? void 0 : _a12.addMessageSent();
          callback();
        });
      }
      sendStatus(status) {
        var _a12, _b5;
        if (this.checkCancelled()) {
          return;
        }
        trace3("Request to method " + ((_a12 = this.handler) === null || _a12 === void 0 ? void 0 : _a12.path) + " ended with status code: " + constants_1.Status[status.code] + " details: " + status.details);
        if (this.metadataSent) {
          if (!this.wantTrailers) {
            this.wantTrailers = true;
            this.stream.once("wantTrailers", () => {
              var _a13;
              if (this.callEventTracker && !this.streamEnded) {
                this.streamEnded = true;
                this.callEventTracker.onStreamEnd(true);
                this.callEventTracker.onCallEnd(status);
              }
              const trailersToSend = Object.assign({ [GRPC_STATUS_HEADER]: status.code, [GRPC_MESSAGE_HEADER]: encodeURI(status.details) }, (_a13 = status.metadata) === null || _a13 === void 0 ? void 0 : _a13.toHttp2Headers());
              this.stream.sendTrailers(trailersToSend);
              this.notifyOnCancel();
            });
            this.stream.end();
          } else {
            this.notifyOnCancel();
          }
        } else {
          if (this.callEventTracker && !this.streamEnded) {
            this.streamEnded = true;
            this.callEventTracker.onStreamEnd(true);
            this.callEventTracker.onCallEnd(status);
          }
          const trailersToSend = Object.assign(Object.assign({ [GRPC_STATUS_HEADER]: status.code, [GRPC_MESSAGE_HEADER]: encodeURI(status.details) }, defaultResponseHeaders), (_b5 = status.metadata) === null || _b5 === void 0 ? void 0 : _b5.toHttp2Headers());
          this.stream.respond(trailersToSend, { endStream: true });
          this.notifyOnCancel();
        }
      }
      startRead() {
        trace3("Request to " + this.handler.path + " startRead called");
        if (this.checkCancelled()) {
          return;
        }
        this.isReadPending = true;
        if (this.readQueue.length === 0) {
          if (!this.receivedHalfClose) {
            this.stream.resume();
          }
        } else {
          this.maybePushNextMessage();
        }
      }
      getPeer() {
        var _a12;
        const socket = (_a12 = this.stream.session) === null || _a12 === void 0 ? void 0 : _a12.socket;
        if (socket === null || socket === void 0 ? void 0 : socket.remoteAddress) {
          if (socket.remotePort) {
            return `${socket.remoteAddress}:${socket.remotePort}`;
          } else {
            return socket.remoteAddress;
          }
        } else {
          return "unknown";
        }
      }
      getDeadline() {
        return this.deadline;
      }
      getHost() {
        return this.host;
      }
    };
    exports.BaseServerInterceptingCall = BaseServerInterceptingCall;
    function getServerInterceptingCall(interceptors, stream, headers, callEventTracker, handler, options) {
      const methodDefinition = {
        path: handler.path,
        requestStream: handler.type === "clientStream" || handler.type === "bidi",
        responseStream: handler.type === "serverStream" || handler.type === "bidi",
        requestDeserialize: handler.deserialize,
        responseSerialize: handler.serialize
      };
      const baseCall = new BaseServerInterceptingCall(stream, headers, callEventTracker, handler, options);
      return interceptors.reduce((call, interceptor) => {
        return interceptor(methodDefinition, call);
      }, baseCall);
    }
    exports.getServerInterceptingCall = getServerInterceptingCall;
  }
});

// node_modules/@grpc/grpc-js/build/src/server.js
var require_server = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/server.js"(exports) {
    "use strict";
    var __runInitializers = exports && exports.__runInitializers || function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i2 = 0; i2 < initializers.length; i2++) {
        value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
      }
      return useValue ? value : void 0;
    };
    var __esDecorate = exports && exports.__esDecorate || function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f2) {
        if (f2 !== void 0 && typeof f2 !== "function")
          throw new TypeError("Function expected");
        return f2;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor3 = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _2, done7 = false;
      for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
        var context3 = {};
        for (var p2 in contextIn)
          context3[p2] = p2 === "access" ? {} : contextIn[p2];
        for (var p2 in contextIn.access)
          context3.access[p2] = contextIn.access[p2];
        context3.addInitializer = function(f2) {
          if (done7)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f2 || null));
        };
        var result4 = (0, decorators[i2])(kind === "accessor" ? { get: descriptor3.get, set: descriptor3.set } : descriptor3[key], context3);
        if (kind === "accessor") {
          if (result4 === void 0)
            continue;
          if (result4 === null || typeof result4 !== "object")
            throw new TypeError("Object expected");
          if (_2 = accept(result4.get))
            descriptor3.get = _2;
          if (_2 = accept(result4.set))
            descriptor3.set = _2;
          if (_2 = accept(result4.init))
            initializers.unshift(_2);
        } else if (_2 = accept(result4)) {
          if (kind === "field")
            initializers.unshift(_2);
          else
            descriptor3[key] = _2;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor3);
      done7 = true;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Server = void 0;
    var http2 = __require("http2");
    var util = __require("util");
    var constants_1 = require_constants5();
    var server_call_1 = require_server_call();
    var server_credentials_1 = require_server_credentials();
    var resolver_1 = require_resolver();
    var logging = require_logging();
    var subchannel_address_1 = require_subchannel_address();
    var uri_parser_1 = require_uri_parser();
    var channelz_1 = require_channelz();
    var server_interceptors_1 = require_server_interceptors();
    var UNLIMITED_CONNECTION_AGE_MS = ~(1 << 31);
    var KEEPALIVE_MAX_TIME_MS = ~(1 << 31);
    var KEEPALIVE_TIMEOUT_MS = 2e4;
    var MAX_CONNECTION_IDLE_MS = ~(1 << 31);
    var { HTTP2_HEADER_PATH } = http2.constants;
    var TRACER_NAME = "server";
    var kMaxAge = Buffer.from("max_age");
    function noop2() {
    }
    function deprecate(message) {
      return function(target, context3) {
        return util.deprecate(target, message);
      };
    }
    function getUnimplementedStatusResponse(methodName) {
      return {
        code: constants_1.Status.UNIMPLEMENTED,
        details: `The server does not implement the method ${methodName}`
      };
    }
    function getDefaultHandler(handlerType, methodName) {
      const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);
      switch (handlerType) {
        case "unary":
          return (call, callback) => {
            callback(unimplementedStatusResponse, null);
          };
        case "clientStream":
          return (call, callback) => {
            callback(unimplementedStatusResponse, null);
          };
        case "serverStream":
          return (call) => {
            call.emit("error", unimplementedStatusResponse);
          };
        case "bidi":
          return (call) => {
            call.emit("error", unimplementedStatusResponse);
          };
        default:
          throw new Error(`Invalid handlerType ${handlerType}`);
      }
    }
    var Server = (() => {
      var _a12;
      let _instanceExtraInitializers = [];
      let _start_decorators;
      return _a12 = class Server {
        constructor(options) {
          var _b5, _c4, _d4, _e4, _f3, _g2;
          this.boundPorts = (__runInitializers(this, _instanceExtraInitializers), /* @__PURE__ */ new Map());
          this.http2Servers = /* @__PURE__ */ new Map();
          this.sessionIdleTimeouts = /* @__PURE__ */ new Map();
          this.handlers = /* @__PURE__ */ new Map();
          this.sessions = /* @__PURE__ */ new Map();
          this.started = false;
          this.shutdown = false;
          this.serverAddressString = "null";
          this.channelzEnabled = true;
          this.options = options !== null && options !== void 0 ? options : {};
          if (this.options["grpc.enable_channelz"] === 0) {
            this.channelzEnabled = false;
            this.channelzTrace = new channelz_1.ChannelzTraceStub();
            this.callTracker = new channelz_1.ChannelzCallTrackerStub();
            this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub();
            this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub();
          } else {
            this.channelzTrace = new channelz_1.ChannelzTrace();
            this.callTracker = new channelz_1.ChannelzCallTracker();
            this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();
            this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();
          }
          this.channelzRef = (0, channelz_1.registerChannelzServer)("server", () => this.getChannelzInfo(), this.channelzEnabled);
          this.channelzTrace.addTrace("CT_INFO", "Server created");
          this.maxConnectionAgeMs = (_b5 = this.options["grpc.max_connection_age_ms"]) !== null && _b5 !== void 0 ? _b5 : UNLIMITED_CONNECTION_AGE_MS;
          this.maxConnectionAgeGraceMs = (_c4 = this.options["grpc.max_connection_age_grace_ms"]) !== null && _c4 !== void 0 ? _c4 : UNLIMITED_CONNECTION_AGE_MS;
          this.keepaliveTimeMs = (_d4 = this.options["grpc.keepalive_time_ms"]) !== null && _d4 !== void 0 ? _d4 : KEEPALIVE_MAX_TIME_MS;
          this.keepaliveTimeoutMs = (_e4 = this.options["grpc.keepalive_timeout_ms"]) !== null && _e4 !== void 0 ? _e4 : KEEPALIVE_TIMEOUT_MS;
          this.sessionIdleTimeout = (_f3 = this.options["grpc.max_connection_idle_ms"]) !== null && _f3 !== void 0 ? _f3 : MAX_CONNECTION_IDLE_MS;
          this.commonServerOptions = {
            maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER
          };
          if ("grpc-node.max_session_memory" in this.options) {
            this.commonServerOptions.maxSessionMemory = this.options["grpc-node.max_session_memory"];
          } else {
            this.commonServerOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;
          }
          if ("grpc.max_concurrent_streams" in this.options) {
            this.commonServerOptions.settings = {
              maxConcurrentStreams: this.options["grpc.max_concurrent_streams"]
            };
          }
          this.interceptors = (_g2 = this.options.interceptors) !== null && _g2 !== void 0 ? _g2 : [];
          this.trace("Server constructed");
        }
        getChannelzInfo() {
          return {
            trace: this.channelzTrace,
            callTracker: this.callTracker,
            listenerChildren: this.listenerChildrenTracker.getChildLists(),
            sessionChildren: this.sessionChildrenTracker.getChildLists()
          };
        }
        getChannelzSessionInfo(session) {
          var _b5, _c4, _d4;
          const sessionInfo = this.sessions.get(session);
          const sessionSocket = session.socket;
          const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;
          const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;
          let tlsInfo;
          if (session.encrypted) {
            const tlsSocket = sessionSocket;
            const cipherInfo = tlsSocket.getCipher();
            const certificate = tlsSocket.getCertificate();
            const peerCertificate = tlsSocket.getPeerCertificate();
            tlsInfo = {
              cipherSuiteStandardName: (_b5 = cipherInfo.standardName) !== null && _b5 !== void 0 ? _b5 : null,
              cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,
              localCertificate: certificate && "raw" in certificate ? certificate.raw : null,
              remoteCertificate: peerCertificate && "raw" in peerCertificate ? peerCertificate.raw : null
            };
          } else {
            tlsInfo = null;
          }
          const socketInfo = {
            remoteAddress,
            localAddress,
            security: tlsInfo,
            remoteName: null,
            streamsStarted: sessionInfo.streamTracker.callsStarted,
            streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,
            streamsFailed: sessionInfo.streamTracker.callsFailed,
            messagesSent: sessionInfo.messagesSent,
            messagesReceived: sessionInfo.messagesReceived,
            keepAlivesSent: sessionInfo.keepAlivesSent,
            lastLocalStreamCreatedTimestamp: null,
            lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,
            lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,
            lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,
            localFlowControlWindow: (_c4 = session.state.localWindowSize) !== null && _c4 !== void 0 ? _c4 : null,
            remoteFlowControlWindow: (_d4 = session.state.remoteWindowSize) !== null && _d4 !== void 0 ? _d4 : null
          };
          return socketInfo;
        }
        trace(text) {
          logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "(" + this.channelzRef.id + ") " + text);
        }
        keepaliveTrace(text) {
          logging.trace(constants_1.LogVerbosity.DEBUG, "keepalive", "(" + this.channelzRef.id + ") " + text);
        }
        addProtoService() {
          throw new Error("Not implemented. Use addService() instead");
        }
        addService(service4, implementation) {
          if (service4 === null || typeof service4 !== "object" || implementation === null || typeof implementation !== "object") {
            throw new Error("addService() requires two objects as arguments");
          }
          const serviceKeys = Object.keys(service4);
          if (serviceKeys.length === 0) {
            throw new Error("Cannot add an empty service to a server");
          }
          serviceKeys.forEach((name) => {
            const attrs = service4[name];
            let methodType;
            if (attrs.requestStream) {
              if (attrs.responseStream) {
                methodType = "bidi";
              } else {
                methodType = "clientStream";
              }
            } else {
              if (attrs.responseStream) {
                methodType = "serverStream";
              } else {
                methodType = "unary";
              }
            }
            let implFn = implementation[name];
            let impl;
            if (implFn === void 0 && typeof attrs.originalName === "string") {
              implFn = implementation[attrs.originalName];
            }
            if (implFn !== void 0) {
              impl = implFn.bind(implementation);
            } else {
              impl = getDefaultHandler(methodType, name);
            }
            const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);
            if (success === false) {
              throw new Error(`Method handler for ${attrs.path} already provided.`);
            }
          });
        }
        removeService(service4) {
          if (service4 === null || typeof service4 !== "object") {
            throw new Error("removeService() requires object as argument");
          }
          const serviceKeys = Object.keys(service4);
          serviceKeys.forEach((name) => {
            const attrs = service4[name];
            this.unregister(attrs.path);
          });
        }
        bind(port, creds) {
          throw new Error("Not implemented. Use bindAsync() instead");
        }
        registerListenerToChannelz(boundAddress) {
          return (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundAddress), () => {
            return {
              localAddress: boundAddress,
              remoteAddress: null,
              security: null,
              remoteName: null,
              streamsStarted: 0,
              streamsSucceeded: 0,
              streamsFailed: 0,
              messagesSent: 0,
              messagesReceived: 0,
              keepAlivesSent: 0,
              lastLocalStreamCreatedTimestamp: null,
              lastRemoteStreamCreatedTimestamp: null,
              lastMessageSentTimestamp: null,
              lastMessageReceivedTimestamp: null,
              localFlowControlWindow: null,
              remoteFlowControlWindow: null
            };
          }, this.channelzEnabled);
        }
        createHttp2Server(credentials) {
          let http2Server;
          if (credentials._isSecure()) {
            const credentialsSettings = credentials._getSettings();
            const secureServerOptions = Object.assign(Object.assign(Object.assign({}, this.commonServerOptions), credentialsSettings), { enableTrace: this.options["grpc-node.tls_enable_trace"] === 1 });
            let areCredentialsValid = credentialsSettings !== null;
            http2Server = http2.createSecureServer(secureServerOptions);
            http2Server.on("connection", (socket) => {
              if (!areCredentialsValid) {
                socket.destroy();
              }
            });
            http2Server.on("secureConnection", (socket) => {
              socket.on("error", (e2) => {
                this.trace("An incoming TLS connection closed with error: " + e2.message);
              });
            });
            const credsWatcher = (options) => {
              if (options) {
                http2Server.setSecureContext(options);
              }
              areCredentialsValid = options !== null;
            };
            credentials._addWatcher(credsWatcher);
            http2Server.on("close", () => {
              credentials._removeWatcher(credsWatcher);
            });
          } else {
            http2Server = http2.createServer(this.commonServerOptions);
          }
          http2Server.setTimeout(0, noop2);
          this._setupHandlers(http2Server, credentials._getInterceptors());
          return http2Server;
        }
        bindOneAddress(address, boundPortObject) {
          this.trace("Attempting to bind " + (0, subchannel_address_1.subchannelAddressToString)(address));
          const http2Server = this.createHttp2Server(boundPortObject.credentials);
          return new Promise((resolve, reject3) => {
            const onError3 = (err) => {
              this.trace("Failed to bind " + (0, subchannel_address_1.subchannelAddressToString)(address) + " with error " + err.message);
              resolve({
                port: "port" in address ? address.port : 1,
                error: err.message
              });
            };
            http2Server.once("error", onError3);
            http2Server.listen(address, () => {
              const boundAddress = http2Server.address();
              let boundSubchannelAddress;
              if (typeof boundAddress === "string") {
                boundSubchannelAddress = {
                  path: boundAddress
                };
              } else {
                boundSubchannelAddress = {
                  host: boundAddress.address,
                  port: boundAddress.port
                };
              }
              const channelzRef = this.registerListenerToChannelz(boundSubchannelAddress);
              this.listenerChildrenTracker.refChild(channelzRef);
              this.http2Servers.set(http2Server, {
                channelzRef,
                sessions: /* @__PURE__ */ new Set()
              });
              boundPortObject.listeningServers.add(http2Server);
              this.trace("Successfully bound " + (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));
              resolve({
                port: "port" in boundSubchannelAddress ? boundSubchannelAddress.port : 1
              });
              http2Server.removeListener("error", onError3);
            });
          });
        }
        async bindManyPorts(addressList, boundPortObject) {
          if (addressList.length === 0) {
            return {
              count: 0,
              port: 0,
              errors: []
            };
          }
          if ((0, subchannel_address_1.isTcpSubchannelAddress)(addressList[0]) && addressList[0].port === 0) {
            const firstAddressResult = await this.bindOneAddress(addressList[0], boundPortObject);
            if (firstAddressResult.error) {
              const restAddressResult = await this.bindManyPorts(addressList.slice(1), boundPortObject);
              return Object.assign(Object.assign({}, restAddressResult), { errors: [firstAddressResult.error, ...restAddressResult.errors] });
            } else {
              const restAddresses = addressList.slice(1).map((address) => (0, subchannel_address_1.isTcpSubchannelAddress)(address) ? { host: address.host, port: firstAddressResult.port } : address);
              const restAddressResult = await Promise.all(restAddresses.map((address) => this.bindOneAddress(address, boundPortObject)));
              const allResults = [firstAddressResult, ...restAddressResult];
              return {
                count: allResults.filter((result4) => result4.error === void 0).length,
                port: firstAddressResult.port,
                errors: allResults.filter((result4) => result4.error).map((result4) => result4.error)
              };
            }
          } else {
            const allResults = await Promise.all(addressList.map((address) => this.bindOneAddress(address, boundPortObject)));
            return {
              count: allResults.filter((result4) => result4.error === void 0).length,
              port: allResults[0].port,
              errors: allResults.filter((result4) => result4.error).map((result4) => result4.error)
            };
          }
        }
        async bindAddressList(addressList, boundPortObject) {
          const bindResult = await this.bindManyPorts(addressList, boundPortObject);
          if (bindResult.count > 0) {
            if (bindResult.count < addressList.length) {
              logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);
            }
            return bindResult.port;
          } else {
            const errorString = `No address added out of total ${addressList.length} resolved`;
            logging.log(constants_1.LogVerbosity.ERROR, errorString);
            throw new Error(`${errorString} errors: [${bindResult.errors.join(",")}]`);
          }
        }
        resolvePort(port) {
          return new Promise((resolve, reject3) => {
            const resolverListener = {
              onSuccessfulResolution: (endpointList, serviceConfig, serviceConfigError) => {
                resolverListener.onSuccessfulResolution = () => {
                };
                const addressList = [].concat(...endpointList.map((endpoint) => endpoint.addresses));
                if (addressList.length === 0) {
                  reject3(new Error(`No addresses resolved for port ${port}`));
                  return;
                }
                resolve(addressList);
              },
              onError: (error) => {
                reject3(new Error(error.details));
              }
            };
            const resolver = (0, resolver_1.createResolver)(port, resolverListener, this.options);
            resolver.updateResolution();
          });
        }
        async bindPort(port, boundPortObject) {
          const addressList = await this.resolvePort(port);
          if (boundPortObject.cancelled) {
            this.completeUnbind(boundPortObject);
            throw new Error("bindAsync operation cancelled by unbind call");
          }
          const portNumber = await this.bindAddressList(addressList, boundPortObject);
          if (boundPortObject.cancelled) {
            this.completeUnbind(boundPortObject);
            throw new Error("bindAsync operation cancelled by unbind call");
          }
          return portNumber;
        }
        normalizePort(port) {
          const initialPortUri = (0, uri_parser_1.parseUri)(port);
          if (initialPortUri === null) {
            throw new Error(`Could not parse port "${port}"`);
          }
          const portUri = (0, resolver_1.mapUriDefaultScheme)(initialPortUri);
          if (portUri === null) {
            throw new Error(`Could not get a default scheme for port "${port}"`);
          }
          return portUri;
        }
        bindAsync(port, creds, callback) {
          if (this.shutdown) {
            throw new Error("bindAsync called after shutdown");
          }
          if (typeof port !== "string") {
            throw new TypeError("port must be a string");
          }
          if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {
            throw new TypeError("creds must be a ServerCredentials object");
          }
          if (typeof callback !== "function") {
            throw new TypeError("callback must be a function");
          }
          this.trace("bindAsync port=" + port);
          const portUri = this.normalizePort(port);
          const deferredCallback = (error, port2) => {
            process.nextTick(() => callback(error, port2));
          };
          let boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));
          if (boundPortObject) {
            if (!creds._equals(boundPortObject.credentials)) {
              deferredCallback(new Error(`${port} already bound with incompatible credentials`), 0);
              return;
            }
            boundPortObject.cancelled = false;
            if (boundPortObject.completionPromise) {
              boundPortObject.completionPromise.then((portNum) => callback(null, portNum), (error) => callback(error, 0));
            } else {
              deferredCallback(null, boundPortObject.portNumber);
            }
            return;
          }
          boundPortObject = {
            mapKey: (0, uri_parser_1.uriToString)(portUri),
            originalUri: portUri,
            completionPromise: null,
            cancelled: false,
            portNumber: 0,
            credentials: creds,
            listeningServers: /* @__PURE__ */ new Set()
          };
          const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);
          const completionPromise = this.bindPort(portUri, boundPortObject);
          boundPortObject.completionPromise = completionPromise;
          if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {
            completionPromise.then((portNum) => {
              const finalUri = {
                scheme: portUri.scheme,
                authority: portUri.authority,
                path: (0, uri_parser_1.combineHostPort)({ host: splitPort.host, port: portNum })
              };
              boundPortObject.mapKey = (0, uri_parser_1.uriToString)(finalUri);
              boundPortObject.completionPromise = null;
              boundPortObject.portNumber = portNum;
              this.boundPorts.set(boundPortObject.mapKey, boundPortObject);
              callback(null, portNum);
            }, (error) => {
              callback(error, 0);
            });
          } else {
            this.boundPorts.set(boundPortObject.mapKey, boundPortObject);
            completionPromise.then((portNum) => {
              boundPortObject.completionPromise = null;
              boundPortObject.portNumber = portNum;
              callback(null, portNum);
            }, (error) => {
              callback(error, 0);
            });
          }
        }
        registerInjectorToChannelz() {
          return (0, channelz_1.registerChannelzSocket)("injector", () => {
            return {
              localAddress: null,
              remoteAddress: null,
              security: null,
              remoteName: null,
              streamsStarted: 0,
              streamsSucceeded: 0,
              streamsFailed: 0,
              messagesSent: 0,
              messagesReceived: 0,
              keepAlivesSent: 0,
              lastLocalStreamCreatedTimestamp: null,
              lastRemoteStreamCreatedTimestamp: null,
              lastMessageSentTimestamp: null,
              lastMessageReceivedTimestamp: null,
              localFlowControlWindow: null,
              remoteFlowControlWindow: null
            };
          }, this.channelzEnabled);
        }
        createConnectionInjector(credentials) {
          if (credentials === null || !(credentials instanceof server_credentials_1.ServerCredentials)) {
            throw new TypeError("creds must be a ServerCredentials object");
          }
          const server = this.createHttp2Server(credentials);
          const channelzRef = this.registerInjectorToChannelz();
          if (this.channelzEnabled) {
            this.listenerChildrenTracker.refChild(channelzRef);
          }
          const sessionsSet = /* @__PURE__ */ new Set();
          this.http2Servers.set(server, {
            channelzRef,
            sessions: sessionsSet
          });
          return {
            injectConnection: (connection) => {
              server.emit("connection", connection);
            },
            drain: (graceTimeMs) => {
              var _b5, _c4;
              for (const session of sessionsSet) {
                this.closeSession(session);
              }
              (_c4 = (_b5 = setTimeout(() => {
                for (const session of sessionsSet) {
                  session.destroy(http2.constants.NGHTTP2_CANCEL);
                }
              }, graceTimeMs)).unref) === null || _c4 === void 0 ? void 0 : _c4.call(_b5);
            },
            destroy: () => {
              this.closeServer(server);
              for (const session of sessionsSet) {
                this.closeSession(session);
              }
            }
          };
        }
        closeServer(server, callback) {
          this.trace("Closing server with address " + JSON.stringify(server.address()));
          const serverInfo = this.http2Servers.get(server);
          server.close(() => {
            if (serverInfo) {
              this.listenerChildrenTracker.unrefChild(serverInfo.channelzRef);
              (0, channelz_1.unregisterChannelzRef)(serverInfo.channelzRef);
            }
            this.http2Servers.delete(server);
            callback === null || callback === void 0 ? void 0 : callback();
          });
        }
        closeSession(session, callback) {
          var _b5;
          this.trace("Closing session initiated by " + ((_b5 = session.socket) === null || _b5 === void 0 ? void 0 : _b5.remoteAddress));
          const sessionInfo = this.sessions.get(session);
          const closeCallback = () => {
            if (sessionInfo) {
              this.sessionChildrenTracker.unrefChild(sessionInfo.ref);
              (0, channelz_1.unregisterChannelzRef)(sessionInfo.ref);
            }
            callback === null || callback === void 0 ? void 0 : callback();
          };
          if (session.closed) {
            queueMicrotask(closeCallback);
          } else {
            session.close(closeCallback);
          }
        }
        completeUnbind(boundPortObject) {
          for (const server of boundPortObject.listeningServers) {
            const serverInfo = this.http2Servers.get(server);
            this.closeServer(server, () => {
              boundPortObject.listeningServers.delete(server);
            });
            if (serverInfo) {
              for (const session of serverInfo.sessions) {
                this.closeSession(session);
              }
            }
          }
          this.boundPorts.delete(boundPortObject.mapKey);
        }
        /**
         * Unbind a previously bound port, or cancel an in-progress bindAsync
         * operation. If port 0 was bound, only the actual bound port can be
         * unbound. For example, if bindAsync was called with "localhost:0" and the
         * bound port result was 54321, it can be unbound as "localhost:54321".
         * @param port
         */
        unbind(port) {
          this.trace("unbind port=" + port);
          const portUri = this.normalizePort(port);
          const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);
          if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {
            throw new Error("Cannot unbind port 0");
          }
          const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));
          if (boundPortObject) {
            this.trace("unbinding " + boundPortObject.mapKey + " originally bound as " + (0, uri_parser_1.uriToString)(boundPortObject.originalUri));
            if (boundPortObject.completionPromise) {
              boundPortObject.cancelled = true;
            } else {
              this.completeUnbind(boundPortObject);
            }
          }
        }
        /**
         * Gracefully close all connections associated with a previously bound port.
         * After the grace time, forcefully close all remaining open connections.
         *
         * If port 0 was bound, only the actual bound port can be
         * drained. For example, if bindAsync was called with "localhost:0" and the
         * bound port result was 54321, it can be drained as "localhost:54321".
         * @param port
         * @param graceTimeMs
         * @returns
         */
        drain(port, graceTimeMs) {
          var _b5, _c4;
          this.trace("drain port=" + port + " graceTimeMs=" + graceTimeMs);
          const portUri = this.normalizePort(port);
          const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);
          if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {
            throw new Error("Cannot drain port 0");
          }
          const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));
          if (!boundPortObject) {
            return;
          }
          const allSessions = /* @__PURE__ */ new Set();
          for (const http2Server of boundPortObject.listeningServers) {
            const serverEntry = this.http2Servers.get(http2Server);
            if (serverEntry) {
              for (const session of serverEntry.sessions) {
                allSessions.add(session);
                this.closeSession(session, () => {
                  allSessions.delete(session);
                });
              }
            }
          }
          (_c4 = (_b5 = setTimeout(() => {
            for (const session of allSessions) {
              session.destroy(http2.constants.NGHTTP2_CANCEL);
            }
          }, graceTimeMs)).unref) === null || _c4 === void 0 ? void 0 : _c4.call(_b5);
        }
        forceShutdown() {
          for (const boundPortObject of this.boundPorts.values()) {
            boundPortObject.cancelled = true;
          }
          this.boundPorts.clear();
          for (const server of this.http2Servers.keys()) {
            this.closeServer(server);
          }
          this.sessions.forEach((channelzInfo, session) => {
            this.closeSession(session);
            session.destroy(http2.constants.NGHTTP2_CANCEL);
          });
          this.sessions.clear();
          (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
          this.shutdown = true;
        }
        register(name, handler, serialize, deserialize, type) {
          if (this.handlers.has(name)) {
            return false;
          }
          this.handlers.set(name, {
            func: handler,
            serialize,
            deserialize,
            type,
            path: name
          });
          return true;
        }
        unregister(name) {
          return this.handlers.delete(name);
        }
        /**
         * @deprecated No longer needed as of version 1.10.x
         */
        start() {
          if (this.http2Servers.size === 0 || [...this.http2Servers.keys()].every((server) => !server.listening)) {
            throw new Error("server must be bound in order to start");
          }
          if (this.started === true) {
            throw new Error("server is already started");
          }
          this.started = true;
        }
        tryShutdown(callback) {
          var _b5;
          const wrappedCallback = (error) => {
            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
            callback(error);
          };
          let pendingChecks = 0;
          function maybeCallback() {
            pendingChecks--;
            if (pendingChecks === 0) {
              wrappedCallback();
            }
          }
          this.shutdown = true;
          for (const [serverKey, server] of this.http2Servers.entries()) {
            pendingChecks++;
            const serverString = server.channelzRef.name;
            this.trace("Waiting for server " + serverString + " to close");
            this.closeServer(serverKey, () => {
              this.trace("Server " + serverString + " finished closing");
              maybeCallback();
            });
            for (const session of server.sessions.keys()) {
              pendingChecks++;
              const sessionString = (_b5 = session.socket) === null || _b5 === void 0 ? void 0 : _b5.remoteAddress;
              this.trace("Waiting for session " + sessionString + " to close");
              this.closeSession(session, () => {
                this.trace("Session " + sessionString + " finished closing");
                maybeCallback();
              });
            }
          }
          if (pendingChecks === 0) {
            wrappedCallback();
          }
        }
        addHttp2Port() {
          throw new Error("Not yet implemented");
        }
        /**
         * Get the channelz reference object for this server. The returned value is
         * garbage if channelz is disabled for this server.
         * @returns
         */
        getChannelzRef() {
          return this.channelzRef;
        }
        _verifyContentType(stream, headers) {
          const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];
          if (typeof contentType !== "string" || !contentType.startsWith("application/grpc")) {
            stream.respond({
              [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE
            }, { endStream: true });
            return false;
          }
          return true;
        }
        _retrieveHandler(path9) {
          this.trace("Received call to method " + path9 + " at address " + this.serverAddressString);
          const handler = this.handlers.get(path9);
          if (handler === void 0) {
            this.trace("No handler registered for method " + path9 + ". Sending UNIMPLEMENTED status.");
            return null;
          }
          return handler;
        }
        _respondWithError(err, stream, channelzSessionInfo = null) {
          var _b5, _c4;
          const trailersToSend = Object.assign({ "grpc-status": (_b5 = err.code) !== null && _b5 !== void 0 ? _b5 : constants_1.Status.INTERNAL, "grpc-message": err.details, [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK, [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: "application/grpc+proto" }, (_c4 = err.metadata) === null || _c4 === void 0 ? void 0 : _c4.toHttp2Headers());
          stream.respond(trailersToSend, { endStream: true });
          this.callTracker.addCallFailed();
          channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();
        }
        _channelzHandler(extraInterceptors, stream, headers) {
          this.onStreamOpened(stream);
          const channelzSessionInfo = this.sessions.get(stream.session);
          this.callTracker.addCallStarted();
          channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();
          if (!this._verifyContentType(stream, headers)) {
            this.callTracker.addCallFailed();
            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();
            return;
          }
          const path9 = headers[HTTP2_HEADER_PATH];
          const handler = this._retrieveHandler(path9);
          if (!handler) {
            this._respondWithError(getUnimplementedStatusResponse(path9), stream, channelzSessionInfo);
            return;
          }
          const callEventTracker = {
            addMessageSent: () => {
              if (channelzSessionInfo) {
                channelzSessionInfo.messagesSent += 1;
                channelzSessionInfo.lastMessageSentTimestamp = /* @__PURE__ */ new Date();
              }
            },
            addMessageReceived: () => {
              if (channelzSessionInfo) {
                channelzSessionInfo.messagesReceived += 1;
                channelzSessionInfo.lastMessageReceivedTimestamp = /* @__PURE__ */ new Date();
              }
            },
            onCallEnd: (status) => {
              if (status.code === constants_1.Status.OK) {
                this.callTracker.addCallSucceeded();
              } else {
                this.callTracker.addCallFailed();
              }
            },
            onStreamEnd: (success) => {
              if (channelzSessionInfo) {
                if (success) {
                  channelzSessionInfo.streamTracker.addCallSucceeded();
                } else {
                  channelzSessionInfo.streamTracker.addCallFailed();
                }
              }
            }
          };
          const call = (0, server_interceptors_1.getServerInterceptingCall)([...extraInterceptors, ...this.interceptors], stream, headers, callEventTracker, handler, this.options);
          if (!this._runHandlerForCall(call, handler)) {
            this.callTracker.addCallFailed();
            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();
            call.sendStatus({
              code: constants_1.Status.INTERNAL,
              details: `Unknown handler type: ${handler.type}`
            });
          }
        }
        _streamHandler(extraInterceptors, stream, headers) {
          this.onStreamOpened(stream);
          if (this._verifyContentType(stream, headers) !== true) {
            return;
          }
          const path9 = headers[HTTP2_HEADER_PATH];
          const handler = this._retrieveHandler(path9);
          if (!handler) {
            this._respondWithError(getUnimplementedStatusResponse(path9), stream, null);
            return;
          }
          const call = (0, server_interceptors_1.getServerInterceptingCall)([...extraInterceptors, ...this.interceptors], stream, headers, null, handler, this.options);
          if (!this._runHandlerForCall(call, handler)) {
            call.sendStatus({
              code: constants_1.Status.INTERNAL,
              details: `Unknown handler type: ${handler.type}`
            });
          }
        }
        _runHandlerForCall(call, handler) {
          const { type } = handler;
          if (type === "unary") {
            handleUnary(call, handler);
          } else if (type === "clientStream") {
            handleClientStreaming(call, handler);
          } else if (type === "serverStream") {
            handleServerStreaming(call, handler);
          } else if (type === "bidi") {
            handleBidiStreaming(call, handler);
          } else {
            return false;
          }
          return true;
        }
        _setupHandlers(http2Server, extraInterceptors) {
          if (http2Server === null) {
            return;
          }
          const serverAddress = http2Server.address();
          let serverAddressString = "null";
          if (serverAddress) {
            if (typeof serverAddress === "string") {
              serverAddressString = serverAddress;
            } else {
              serverAddressString = serverAddress.address + ":" + serverAddress.port;
            }
          }
          this.serverAddressString = serverAddressString;
          const handler = this.channelzEnabled ? this._channelzHandler : this._streamHandler;
          const sessionHandler = this.channelzEnabled ? this._channelzSessionHandler(http2Server) : this._sessionHandler(http2Server);
          http2Server.on("stream", handler.bind(this, extraInterceptors));
          http2Server.on("session", sessionHandler);
        }
        _sessionHandler(http2Server) {
          return (session) => {
            var _b5, _c4;
            (_b5 = this.http2Servers.get(http2Server)) === null || _b5 === void 0 ? void 0 : _b5.sessions.add(session);
            let connectionAgeTimer = null;
            let connectionAgeGraceTimer = null;
            let keepaliveTimer = null;
            let sessionClosedByServer = false;
            const idleTimeoutObj = this.enableIdleTimeout(session);
            if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {
              const jitterMagnitude = this.maxConnectionAgeMs / 10;
              const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;
              connectionAgeTimer = setTimeout(() => {
                var _b6, _c5;
                sessionClosedByServer = true;
                this.trace("Connection dropped by max connection age: " + ((_b6 = session.socket) === null || _b6 === void 0 ? void 0 : _b6.remoteAddress));
                try {
                  session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), kMaxAge);
                } catch (e2) {
                  session.destroy();
                  return;
                }
                session.close();
                if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {
                  connectionAgeGraceTimer = setTimeout(() => {
                    session.destroy();
                  }, this.maxConnectionAgeGraceMs);
                  (_c5 = connectionAgeGraceTimer.unref) === null || _c5 === void 0 ? void 0 : _c5.call(connectionAgeGraceTimer);
                }
              }, this.maxConnectionAgeMs + jitter);
              (_c4 = connectionAgeTimer.unref) === null || _c4 === void 0 ? void 0 : _c4.call(connectionAgeTimer);
            }
            const clearKeepaliveTimeout = () => {
              if (keepaliveTimer) {
                clearTimeout(keepaliveTimer);
                keepaliveTimer = null;
              }
            };
            const canSendPing = () => {
              return !session.destroyed && this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS && this.keepaliveTimeMs > 0;
            };
            let sendPing;
            const maybeStartKeepalivePingTimer = () => {
              var _b6;
              if (!canSendPing()) {
                return;
              }
              this.keepaliveTrace("Starting keepalive timer for " + this.keepaliveTimeMs + "ms");
              keepaliveTimer = setTimeout(() => {
                clearKeepaliveTimeout();
                sendPing();
              }, this.keepaliveTimeMs);
              (_b6 = keepaliveTimer.unref) === null || _b6 === void 0 ? void 0 : _b6.call(keepaliveTimer);
            };
            sendPing = () => {
              var _b6;
              if (!canSendPing()) {
                return;
              }
              this.keepaliveTrace("Sending ping with timeout " + this.keepaliveTimeoutMs + "ms");
              let pingSendError = "";
              try {
                const pingSentSuccessfully = session.ping((err, duration, payload) => {
                  clearKeepaliveTimeout();
                  if (err) {
                    this.keepaliveTrace("Ping failed with error: " + err.message);
                    sessionClosedByServer = true;
                    session.close();
                  } else {
                    this.keepaliveTrace("Received ping response");
                    maybeStartKeepalivePingTimer();
                  }
                });
                if (!pingSentSuccessfully) {
                  pingSendError = "Ping returned false";
                }
              } catch (e2) {
                pingSendError = (e2 instanceof Error ? e2.message : "") || "Unknown error";
              }
              if (pingSendError) {
                this.keepaliveTrace("Ping send failed: " + pingSendError);
                this.trace("Connection dropped due to ping send error: " + pingSendError);
                sessionClosedByServer = true;
                session.close();
                return;
              }
              keepaliveTimer = setTimeout(() => {
                clearKeepaliveTimeout();
                this.keepaliveTrace("Ping timeout passed without response");
                this.trace("Connection dropped by keepalive timeout");
                sessionClosedByServer = true;
                session.close();
              }, this.keepaliveTimeoutMs);
              (_b6 = keepaliveTimer.unref) === null || _b6 === void 0 ? void 0 : _b6.call(keepaliveTimer);
            };
            maybeStartKeepalivePingTimer();
            session.on("close", () => {
              var _b6, _c5;
              if (!sessionClosedByServer) {
                this.trace(`Connection dropped by client ${(_b6 = session.socket) === null || _b6 === void 0 ? void 0 : _b6.remoteAddress}`);
              }
              if (connectionAgeTimer) {
                clearTimeout(connectionAgeTimer);
              }
              if (connectionAgeGraceTimer) {
                clearTimeout(connectionAgeGraceTimer);
              }
              clearKeepaliveTimeout();
              if (idleTimeoutObj !== null) {
                clearTimeout(idleTimeoutObj.timeout);
                this.sessionIdleTimeouts.delete(session);
              }
              (_c5 = this.http2Servers.get(http2Server)) === null || _c5 === void 0 ? void 0 : _c5.sessions.delete(session);
            });
          };
        }
        _channelzSessionHandler(http2Server) {
          return (session) => {
            var _b5, _c4, _d4, _e4;
            const channelzRef = (0, channelz_1.registerChannelzSocket)((_c4 = (_b5 = session.socket) === null || _b5 === void 0 ? void 0 : _b5.remoteAddress) !== null && _c4 !== void 0 ? _c4 : "unknown", this.getChannelzSessionInfo.bind(this, session), this.channelzEnabled);
            const channelzSessionInfo = {
              ref: channelzRef,
              streamTracker: new channelz_1.ChannelzCallTracker(),
              messagesSent: 0,
              messagesReceived: 0,
              keepAlivesSent: 0,
              lastMessageSentTimestamp: null,
              lastMessageReceivedTimestamp: null
            };
            (_d4 = this.http2Servers.get(http2Server)) === null || _d4 === void 0 ? void 0 : _d4.sessions.add(session);
            this.sessions.set(session, channelzSessionInfo);
            const clientAddress = `${session.socket.remoteAddress}:${session.socket.remotePort}`;
            this.channelzTrace.addTrace("CT_INFO", "Connection established by client " + clientAddress);
            this.trace("Connection established by client " + clientAddress);
            this.sessionChildrenTracker.refChild(channelzRef);
            let connectionAgeTimer = null;
            let connectionAgeGraceTimer = null;
            let keepaliveTimeout = null;
            let sessionClosedByServer = false;
            const idleTimeoutObj = this.enableIdleTimeout(session);
            if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {
              const jitterMagnitude = this.maxConnectionAgeMs / 10;
              const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;
              connectionAgeTimer = setTimeout(() => {
                var _b6;
                sessionClosedByServer = true;
                this.channelzTrace.addTrace("CT_INFO", "Connection dropped by max connection age from " + clientAddress);
                try {
                  session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), kMaxAge);
                } catch (e2) {
                  session.destroy();
                  return;
                }
                session.close();
                if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {
                  connectionAgeGraceTimer = setTimeout(() => {
                    session.destroy();
                  }, this.maxConnectionAgeGraceMs);
                  (_b6 = connectionAgeGraceTimer.unref) === null || _b6 === void 0 ? void 0 : _b6.call(connectionAgeGraceTimer);
                }
              }, this.maxConnectionAgeMs + jitter);
              (_e4 = connectionAgeTimer.unref) === null || _e4 === void 0 ? void 0 : _e4.call(connectionAgeTimer);
            }
            const clearKeepaliveTimeout = () => {
              if (keepaliveTimeout) {
                clearTimeout(keepaliveTimeout);
                keepaliveTimeout = null;
              }
            };
            const canSendPing = () => {
              return !session.destroyed && this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS && this.keepaliveTimeMs > 0;
            };
            let sendPing;
            const maybeStartKeepalivePingTimer = () => {
              var _b6;
              if (!canSendPing()) {
                return;
              }
              this.keepaliveTrace("Starting keepalive timer for " + this.keepaliveTimeMs + "ms");
              keepaliveTimeout = setTimeout(() => {
                clearKeepaliveTimeout();
                sendPing();
              }, this.keepaliveTimeMs);
              (_b6 = keepaliveTimeout.unref) === null || _b6 === void 0 ? void 0 : _b6.call(keepaliveTimeout);
            };
            sendPing = () => {
              var _b6;
              if (!canSendPing()) {
                return;
              }
              this.keepaliveTrace("Sending ping with timeout " + this.keepaliveTimeoutMs + "ms");
              let pingSendError = "";
              try {
                const pingSentSuccessfully = session.ping((err, duration, payload) => {
                  clearKeepaliveTimeout();
                  if (err) {
                    this.keepaliveTrace("Ping failed with error: " + err.message);
                    this.channelzTrace.addTrace("CT_INFO", "Connection dropped due to error of a ping frame " + err.message + " return in " + duration);
                    sessionClosedByServer = true;
                    session.close();
                  } else {
                    this.keepaliveTrace("Received ping response");
                    maybeStartKeepalivePingTimer();
                  }
                });
                if (!pingSentSuccessfully) {
                  pingSendError = "Ping returned false";
                }
              } catch (e2) {
                pingSendError = (e2 instanceof Error ? e2.message : "") || "Unknown error";
              }
              if (pingSendError) {
                this.keepaliveTrace("Ping send failed: " + pingSendError);
                this.channelzTrace.addTrace("CT_INFO", "Connection dropped due to ping send error: " + pingSendError);
                sessionClosedByServer = true;
                session.close();
                return;
              }
              channelzSessionInfo.keepAlivesSent += 1;
              keepaliveTimeout = setTimeout(() => {
                clearKeepaliveTimeout();
                this.keepaliveTrace("Ping timeout passed without response");
                this.channelzTrace.addTrace("CT_INFO", "Connection dropped by keepalive timeout from " + clientAddress);
                sessionClosedByServer = true;
                session.close();
              }, this.keepaliveTimeoutMs);
              (_b6 = keepaliveTimeout.unref) === null || _b6 === void 0 ? void 0 : _b6.call(keepaliveTimeout);
            };
            maybeStartKeepalivePingTimer();
            session.on("close", () => {
              var _b6;
              if (!sessionClosedByServer) {
                this.channelzTrace.addTrace("CT_INFO", "Connection dropped by client " + clientAddress);
              }
              this.sessionChildrenTracker.unrefChild(channelzRef);
              (0, channelz_1.unregisterChannelzRef)(channelzRef);
              if (connectionAgeTimer) {
                clearTimeout(connectionAgeTimer);
              }
              if (connectionAgeGraceTimer) {
                clearTimeout(connectionAgeGraceTimer);
              }
              clearKeepaliveTimeout();
              if (idleTimeoutObj !== null) {
                clearTimeout(idleTimeoutObj.timeout);
                this.sessionIdleTimeouts.delete(session);
              }
              (_b6 = this.http2Servers.get(http2Server)) === null || _b6 === void 0 ? void 0 : _b6.sessions.delete(session);
              this.sessions.delete(session);
            });
          };
        }
        enableIdleTimeout(session) {
          var _b5, _c4;
          if (this.sessionIdleTimeout >= MAX_CONNECTION_IDLE_MS) {
            return null;
          }
          const idleTimeoutObj = {
            activeStreams: 0,
            lastIdle: Date.now(),
            onClose: this.onStreamClose.bind(this, session),
            timeout: setTimeout(this.onIdleTimeout, this.sessionIdleTimeout, this, session)
          };
          (_c4 = (_b5 = idleTimeoutObj.timeout).unref) === null || _c4 === void 0 ? void 0 : _c4.call(_b5);
          this.sessionIdleTimeouts.set(session, idleTimeoutObj);
          const { socket } = session;
          this.trace("Enable idle timeout for " + socket.remoteAddress + ":" + socket.remotePort);
          return idleTimeoutObj;
        }
        onIdleTimeout(ctx, session) {
          const { socket } = session;
          const sessionInfo = ctx.sessionIdleTimeouts.get(session);
          if (sessionInfo !== void 0 && sessionInfo.activeStreams === 0) {
            if (Date.now() - sessionInfo.lastIdle >= ctx.sessionIdleTimeout) {
              ctx.trace("Session idle timeout triggered for " + (socket === null || socket === void 0 ? void 0 : socket.remoteAddress) + ":" + (socket === null || socket === void 0 ? void 0 : socket.remotePort) + " last idle at " + sessionInfo.lastIdle);
              ctx.closeSession(session);
            } else {
              sessionInfo.timeout.refresh();
            }
          }
        }
        onStreamOpened(stream) {
          const session = stream.session;
          const idleTimeoutObj = this.sessionIdleTimeouts.get(session);
          if (idleTimeoutObj) {
            idleTimeoutObj.activeStreams += 1;
            stream.once("close", idleTimeoutObj.onClose);
          }
        }
        onStreamClose(session) {
          var _b5, _c4;
          const idleTimeoutObj = this.sessionIdleTimeouts.get(session);
          if (idleTimeoutObj) {
            idleTimeoutObj.activeStreams -= 1;
            if (idleTimeoutObj.activeStreams === 0) {
              idleTimeoutObj.lastIdle = Date.now();
              idleTimeoutObj.timeout.refresh();
              this.trace("Session onStreamClose" + ((_b5 = session.socket) === null || _b5 === void 0 ? void 0 : _b5.remoteAddress) + ":" + ((_c4 = session.socket) === null || _c4 === void 0 ? void 0 : _c4.remotePort) + " at " + idleTimeoutObj.lastIdle);
            }
          }
        }
      }, (() => {
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
        _start_decorators = [deprecate("Calling start() is no longer necessary. It can be safely omitted.")];
        __esDecorate(_a12, null, _start_decorators, { kind: "method", name: "start", static: false, private: false, access: { has: (obj) => "start" in obj, get: (obj) => obj.start }, metadata: _metadata }, null, _instanceExtraInitializers);
        if (_metadata)
          Object.defineProperty(_a12, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
      })(), _a12;
    })();
    exports.Server = Server;
    async function handleUnary(call, handler) {
      let stream;
      function respond(err, value, trailer, flags) {
        if (err) {
          call.sendStatus((0, server_call_1.serverErrorToStatus)(err, trailer));
          return;
        }
        call.sendMessage(value, () => {
          call.sendStatus({
            code: constants_1.Status.OK,
            details: "OK",
            metadata: trailer !== null && trailer !== void 0 ? trailer : null
          });
        });
      }
      let requestMetadata;
      let requestMessage = null;
      call.start({
        onReceiveMetadata(metadata) {
          requestMetadata = metadata;
          call.startRead();
        },
        onReceiveMessage(message) {
          if (requestMessage) {
            call.sendStatus({
              code: constants_1.Status.UNIMPLEMENTED,
              details: `Received a second request message for server streaming method ${handler.path}`,
              metadata: null
            });
            return;
          }
          requestMessage = message;
          call.startRead();
        },
        onReceiveHalfClose() {
          if (!requestMessage) {
            call.sendStatus({
              code: constants_1.Status.UNIMPLEMENTED,
              details: `Received no request message for server streaming method ${handler.path}`,
              metadata: null
            });
            return;
          }
          stream = new server_call_1.ServerWritableStreamImpl(handler.path, call, requestMetadata, requestMessage);
          try {
            handler.func(stream, respond);
          } catch (err) {
            call.sendStatus({
              code: constants_1.Status.UNKNOWN,
              details: `Server method handler threw error ${err.message}`,
              metadata: null
            });
          }
        },
        onCancel() {
          if (stream) {
            stream.cancelled = true;
            stream.emit("cancelled", "cancelled");
          }
        }
      });
    }
    function handleClientStreaming(call, handler) {
      let stream;
      function respond(err, value, trailer, flags) {
        if (err) {
          call.sendStatus((0, server_call_1.serverErrorToStatus)(err, trailer));
          return;
        }
        call.sendMessage(value, () => {
          call.sendStatus({
            code: constants_1.Status.OK,
            details: "OK",
            metadata: trailer !== null && trailer !== void 0 ? trailer : null
          });
        });
      }
      call.start({
        onReceiveMetadata(metadata) {
          stream = new server_call_1.ServerDuplexStreamImpl(handler.path, call, metadata);
          try {
            handler.func(stream, respond);
          } catch (err) {
            call.sendStatus({
              code: constants_1.Status.UNKNOWN,
              details: `Server method handler threw error ${err.message}`,
              metadata: null
            });
          }
        },
        onReceiveMessage(message) {
          stream.push(message);
        },
        onReceiveHalfClose() {
          stream.push(null);
        },
        onCancel() {
          if (stream) {
            stream.cancelled = true;
            stream.emit("cancelled", "cancelled");
            stream.destroy();
          }
        }
      });
    }
    function handleServerStreaming(call, handler) {
      let stream;
      let requestMetadata;
      let requestMessage = null;
      call.start({
        onReceiveMetadata(metadata) {
          requestMetadata = metadata;
          call.startRead();
        },
        onReceiveMessage(message) {
          if (requestMessage) {
            call.sendStatus({
              code: constants_1.Status.UNIMPLEMENTED,
              details: `Received a second request message for server streaming method ${handler.path}`,
              metadata: null
            });
            return;
          }
          requestMessage = message;
          call.startRead();
        },
        onReceiveHalfClose() {
          if (!requestMessage) {
            call.sendStatus({
              code: constants_1.Status.UNIMPLEMENTED,
              details: `Received no request message for server streaming method ${handler.path}`,
              metadata: null
            });
            return;
          }
          stream = new server_call_1.ServerWritableStreamImpl(handler.path, call, requestMetadata, requestMessage);
          try {
            handler.func(stream);
          } catch (err) {
            call.sendStatus({
              code: constants_1.Status.UNKNOWN,
              details: `Server method handler threw error ${err.message}`,
              metadata: null
            });
          }
        },
        onCancel() {
          if (stream) {
            stream.cancelled = true;
            stream.emit("cancelled", "cancelled");
            stream.destroy();
          }
        }
      });
    }
    function handleBidiStreaming(call, handler) {
      let stream;
      call.start({
        onReceiveMetadata(metadata) {
          stream = new server_call_1.ServerDuplexStreamImpl(handler.path, call, metadata);
          try {
            handler.func(stream);
          } catch (err) {
            call.sendStatus({
              code: constants_1.Status.UNKNOWN,
              details: `Server method handler threw error ${err.message}`,
              metadata: null
            });
          }
        },
        onReceiveMessage(message) {
          stream.push(message);
        },
        onReceiveHalfClose() {
          stream.push(null);
        },
        onCancel() {
          if (stream) {
            stream.cancelled = true;
            stream.emit("cancelled", "cancelled");
            stream.destroy();
          }
        }
      });
    }
  }
});

// node_modules/@grpc/grpc-js/build/src/status-builder.js
var require_status_builder = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/status-builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatusBuilder = void 0;
    var StatusBuilder = class {
      constructor() {
        this.code = null;
        this.details = null;
        this.metadata = null;
      }
      /**
       * Adds a status code to the builder.
       */
      withCode(code) {
        this.code = code;
        return this;
      }
      /**
       * Adds details to the builder.
       */
      withDetails(details) {
        this.details = details;
        return this;
      }
      /**
       * Adds metadata to the builder.
       */
      withMetadata(metadata) {
        this.metadata = metadata;
        return this;
      }
      /**
       * Builds the status object.
       */
      build() {
        const status = {};
        if (this.code !== null) {
          status.code = this.code;
        }
        if (this.details !== null) {
          status.details = this.details;
        }
        if (this.metadata !== null) {
          status.metadata = this.metadata;
        }
        return status;
      }
    };
    exports.StatusBuilder = StatusBuilder;
  }
});

// node_modules/@grpc/grpc-js/build/src/duration.js
var require_duration = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/duration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseDuration = exports.isDuration = exports.durationToMs = exports.msToDuration = void 0;
    function msToDuration(millis) {
      return {
        seconds: millis / 1e3 | 0,
        nanos: millis % 1e3 * 1e6 | 0
      };
    }
    exports.msToDuration = msToDuration;
    function durationToMs(duration) {
      return duration.seconds * 1e3 + duration.nanos / 1e6 | 0;
    }
    exports.durationToMs = durationToMs;
    function isDuration(value) {
      return typeof value.seconds === "number" && typeof value.nanos === "number";
    }
    exports.isDuration = isDuration;
    var durationRegex = /^(\d+)(?:\.(\d+))?s$/;
    function parseDuration(value) {
      const match4 = value.match(durationRegex);
      if (!match4) {
        return null;
      }
      return {
        seconds: Number.parseInt(match4[1], 10),
        nanos: match4[2] ? Number.parseInt(match4[2].padEnd(9, "0"), 10) : 0
      };
    }
    exports.parseDuration = parseDuration;
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js
var require_load_balancer_pick_first = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setup = exports.LeafLoadBalancer = exports.PickFirstLoadBalancer = exports.shuffled = exports.PickFirstLoadBalancingConfig = void 0;
    var load_balancer_1 = require_load_balancer();
    var connectivity_state_1 = require_connectivity_state();
    var picker_1 = require_picker();
    var subchannel_address_1 = require_subchannel_address();
    var logging = require_logging();
    var constants_1 = require_constants5();
    var subchannel_address_2 = require_subchannel_address();
    var net_1 = __require("net");
    var TRACER_NAME = "pick_first";
    function trace3(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var TYPE_NAME = "pick_first";
    var CONNECTION_DELAY_INTERVAL_MS = 250;
    var PickFirstLoadBalancingConfig = class _PickFirstLoadBalancingConfig {
      constructor(shuffleAddressList) {
        this.shuffleAddressList = shuffleAddressList;
      }
      getLoadBalancerName() {
        return TYPE_NAME;
      }
      toJsonObject() {
        return {
          [TYPE_NAME]: {
            shuffleAddressList: this.shuffleAddressList
          }
        };
      }
      getShuffleAddressList() {
        return this.shuffleAddressList;
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static createFromJson(obj) {
        if ("shuffleAddressList" in obj && !(typeof obj.shuffleAddressList === "boolean")) {
          throw new Error("pick_first config field shuffleAddressList must be a boolean if provided");
        }
        return new _PickFirstLoadBalancingConfig(obj.shuffleAddressList === true);
      }
    };
    exports.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;
    var PickFirstPicker = class {
      constructor(subchannel) {
        this.subchannel = subchannel;
      }
      pick(pickArgs) {
        return {
          pickResultType: picker_1.PickResultType.COMPLETE,
          subchannel: this.subchannel,
          status: null,
          onCallStarted: null,
          onCallEnded: null
        };
      }
    };
    function shuffled(list2) {
      const result4 = list2.slice();
      for (let i2 = result4.length - 1; i2 > 1; i2--) {
        const j2 = Math.floor(Math.random() * (i2 + 1));
        const temp = result4[i2];
        result4[i2] = result4[j2];
        result4[j2] = temp;
      }
      return result4;
    }
    exports.shuffled = shuffled;
    function interleaveAddressFamilies(addressList) {
      const result4 = [];
      const ipv6Addresses = [];
      const ipv4Addresses = [];
      const ipv6First = (0, subchannel_address_2.isTcpSubchannelAddress)(addressList[0]) && (0, net_1.isIPv6)(addressList[0].host);
      for (const address of addressList) {
        if ((0, subchannel_address_2.isTcpSubchannelAddress)(address) && (0, net_1.isIPv6)(address.host)) {
          ipv6Addresses.push(address);
        } else {
          ipv4Addresses.push(address);
        }
      }
      const firstList = ipv6First ? ipv6Addresses : ipv4Addresses;
      const secondList = ipv6First ? ipv4Addresses : ipv6Addresses;
      for (let i2 = 0; i2 < Math.max(firstList.length, secondList.length); i2++) {
        if (i2 < firstList.length) {
          result4.push(firstList[i2]);
        }
        if (i2 < secondList.length) {
          result4.push(secondList[i2]);
        }
      }
      return result4;
    }
    var REPORT_HEALTH_STATUS_OPTION_NAME = "grpc-node.internal.pick-first.report_health_status";
    var PickFirstLoadBalancer = class {
      /**
       * Load balancer that attempts to connect to each backend in the address list
       * in order, and picks the first one that connects, using it for every
       * request.
       * @param channelControlHelper `ChannelControlHelper` instance provided by
       *     this load balancer's owner.
       */
      constructor(channelControlHelper, credentials, options) {
        this.channelControlHelper = channelControlHelper;
        this.children = [];
        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
        this.currentSubchannelIndex = 0;
        this.currentPick = null;
        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime, errorMessage) => {
          this.onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage);
        };
        this.pickedSubchannelHealthListener = () => this.calculateAndReportNewState();
        this.stickyTransientFailureMode = false;
        this.lastError = null;
        this.latestAddressList = null;
        this.connectionDelayTimeout = setTimeout(() => {
        }, 0);
        clearTimeout(this.connectionDelayTimeout);
        this.reportHealthStatus = options[REPORT_HEALTH_STATUS_OPTION_NAME];
      }
      allChildrenHaveReportedTF() {
        return this.children.every((child) => child.hasReportedTransientFailure);
      }
      resetChildrenReportedTF() {
        this.children.every((child) => child.hasReportedTransientFailure = false);
      }
      calculateAndReportNewState() {
        if (this.currentPick) {
          if (this.reportHealthStatus && !this.currentPick.isHealthy()) {
            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({
              details: `Picked subchannel ${this.currentPick.getAddress()} is unhealthy`
            }));
          } else {
            this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(this.currentPick));
          }
        } else if (this.children.length === 0) {
          this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
        } else {
          if (this.stickyTransientFailureMode) {
            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({
              details: `No connection established. Last error: ${this.lastError}`
            }));
          } else {
            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
          }
        }
      }
      requestReresolution() {
        this.channelControlHelper.requestReresolution();
      }
      maybeEnterStickyTransientFailureMode() {
        if (!this.allChildrenHaveReportedTF()) {
          return;
        }
        this.requestReresolution();
        this.resetChildrenReportedTF();
        if (this.stickyTransientFailureMode) {
          this.calculateAndReportNewState();
          return;
        }
        this.stickyTransientFailureMode = true;
        for (const { subchannel } of this.children) {
          subchannel.startConnecting();
        }
        this.calculateAndReportNewState();
      }
      removeCurrentPick() {
        if (this.currentPick !== null) {
          this.currentPick.removeConnectivityStateListener(this.subchannelStateListener);
          this.channelControlHelper.removeChannelzChild(this.currentPick.getChannelzRef());
          this.currentPick.removeHealthStateWatcher(this.pickedSubchannelHealthListener);
          this.currentPick.unref();
          this.currentPick = null;
        }
      }
      onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage) {
        var _a12;
        if ((_a12 = this.currentPick) === null || _a12 === void 0 ? void 0 : _a12.realSubchannelEquals(subchannel)) {
          if (newState !== connectivity_state_1.ConnectivityState.READY) {
            this.removeCurrentPick();
            this.calculateAndReportNewState();
          }
          return;
        }
        for (const [index, child] of this.children.entries()) {
          if (subchannel.realSubchannelEquals(child.subchannel)) {
            if (newState === connectivity_state_1.ConnectivityState.READY) {
              this.pickSubchannel(child.subchannel);
            }
            if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
              child.hasReportedTransientFailure = true;
              if (errorMessage) {
                this.lastError = errorMessage;
              }
              this.maybeEnterStickyTransientFailureMode();
              if (index === this.currentSubchannelIndex) {
                this.startNextSubchannelConnecting(index + 1);
              }
            }
            child.subchannel.startConnecting();
            return;
          }
        }
      }
      startNextSubchannelConnecting(startIndex) {
        clearTimeout(this.connectionDelayTimeout);
        for (const [index, child] of this.children.entries()) {
          if (index >= startIndex) {
            const subchannelState = child.subchannel.getConnectivityState();
            if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {
              this.startConnecting(index);
              return;
            }
          }
        }
        this.maybeEnterStickyTransientFailureMode();
      }
      /**
       * Have a single subchannel in the `subchannels` list start connecting.
       * @param subchannelIndex The index into the `subchannels` list.
       */
      startConnecting(subchannelIndex) {
        var _a12, _b5;
        clearTimeout(this.connectionDelayTimeout);
        this.currentSubchannelIndex = subchannelIndex;
        if (this.children[subchannelIndex].subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {
          trace3("Start connecting to subchannel with address " + this.children[subchannelIndex].subchannel.getAddress());
          process.nextTick(() => {
            var _a13;
            (_a13 = this.children[subchannelIndex]) === null || _a13 === void 0 ? void 0 : _a13.subchannel.startConnecting();
          });
        }
        this.connectionDelayTimeout = setTimeout(() => {
          this.startNextSubchannelConnecting(subchannelIndex + 1);
        }, CONNECTION_DELAY_INTERVAL_MS);
        (_b5 = (_a12 = this.connectionDelayTimeout).unref) === null || _b5 === void 0 ? void 0 : _b5.call(_a12);
      }
      /**
       * Declare that the specified subchannel should be used to make requests.
       * This functions the same independent of whether subchannel is a member of
       * this.children and whether it is equal to this.currentPick.
       * Prerequisite: subchannel.getConnectivityState() === READY.
       * @param subchannel
       */
      pickSubchannel(subchannel) {
        trace3("Pick subchannel with address " + subchannel.getAddress());
        this.stickyTransientFailureMode = false;
        subchannel.ref();
        this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
        this.removeCurrentPick();
        this.resetSubchannelList();
        subchannel.addConnectivityStateListener(this.subchannelStateListener);
        subchannel.addHealthStateWatcher(this.pickedSubchannelHealthListener);
        this.currentPick = subchannel;
        clearTimeout(this.connectionDelayTimeout);
        this.calculateAndReportNewState();
      }
      updateState(newState, picker) {
        trace3(connectivity_state_1.ConnectivityState[this.currentState] + " -> " + connectivity_state_1.ConnectivityState[newState]);
        this.currentState = newState;
        this.channelControlHelper.updateState(newState, picker);
      }
      resetSubchannelList() {
        for (const child of this.children) {
          child.subchannel.removeConnectivityStateListener(this.subchannelStateListener);
          child.subchannel.unref();
          this.channelControlHelper.removeChannelzChild(child.subchannel.getChannelzRef());
        }
        this.currentSubchannelIndex = 0;
        this.children = [];
      }
      connectToAddressList(addressList) {
        trace3("connectToAddressList([" + addressList.map((address) => (0, subchannel_address_1.subchannelAddressToString)(address)) + "])");
        const newChildrenList = addressList.map((address) => ({
          subchannel: this.channelControlHelper.createSubchannel(address, {}, null),
          hasReportedTransientFailure: false
        }));
        for (const { subchannel } of newChildrenList) {
          if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {
            this.pickSubchannel(subchannel);
            return;
          }
        }
        for (const { subchannel } of newChildrenList) {
          subchannel.ref();
          this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
        }
        this.resetSubchannelList();
        this.children = newChildrenList;
        for (const { subchannel } of this.children) {
          subchannel.addConnectivityStateListener(this.subchannelStateListener);
        }
        for (const child of this.children) {
          if (child.subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
            child.hasReportedTransientFailure = true;
          }
        }
        this.startNextSubchannelConnecting(0);
        this.calculateAndReportNewState();
      }
      updateAddressList(endpointList, lbConfig) {
        if (!(lbConfig instanceof PickFirstLoadBalancingConfig)) {
          return;
        }
        if (lbConfig.getShuffleAddressList()) {
          endpointList = shuffled(endpointList);
        }
        const rawAddressList = [].concat(...endpointList.map((endpoint) => endpoint.addresses));
        trace3("updateAddressList([" + rawAddressList.map((address) => (0, subchannel_address_1.subchannelAddressToString)(address)) + "])");
        if (rawAddressList.length === 0) {
          throw new Error("No addresses in endpoint list passed to pick_first");
        }
        const addressList = interleaveAddressFamilies(rawAddressList);
        this.latestAddressList = addressList;
        this.connectToAddressList(addressList);
      }
      exitIdle() {
        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE && this.latestAddressList) {
          this.connectToAddressList(this.latestAddressList);
        }
      }
      resetBackoff() {
      }
      destroy() {
        this.resetSubchannelList();
        this.removeCurrentPick();
      }
      getTypeName() {
        return TYPE_NAME;
      }
    };
    exports.PickFirstLoadBalancer = PickFirstLoadBalancer;
    var LEAF_CONFIG = new PickFirstLoadBalancingConfig(false);
    var LeafLoadBalancer = class {
      constructor(endpoint, channelControlHelper, credentials, options) {
        this.endpoint = endpoint;
        this.latestState = connectivity_state_1.ConnectivityState.IDLE;
        const childChannelControlHelper = (0, load_balancer_1.createChildChannelControlHelper)(channelControlHelper, {
          updateState: (connectivityState, picker) => {
            this.latestState = connectivityState;
            this.latestPicker = picker;
            channelControlHelper.updateState(connectivityState, picker);
          }
        });
        this.pickFirstBalancer = new PickFirstLoadBalancer(childChannelControlHelper, credentials, Object.assign(Object.assign({}, options), { [REPORT_HEALTH_STATUS_OPTION_NAME]: true }));
        this.latestPicker = new picker_1.QueuePicker(this.pickFirstBalancer);
      }
      startConnecting() {
        this.pickFirstBalancer.updateAddressList([this.endpoint], LEAF_CONFIG);
      }
      /**
       * Update the endpoint associated with this LeafLoadBalancer to a new
       * endpoint. Does not trigger connection establishment if a connection
       * attempt is not already in progress.
       * @param newEndpoint
       */
      updateEndpoint(newEndpoint) {
        this.endpoint = newEndpoint;
        if (this.latestState !== connectivity_state_1.ConnectivityState.IDLE) {
          this.startConnecting();
        }
      }
      getConnectivityState() {
        return this.latestState;
      }
      getPicker() {
        return this.latestPicker;
      }
      getEndpoint() {
        return this.endpoint;
      }
      exitIdle() {
        this.pickFirstBalancer.exitIdle();
      }
      destroy() {
        this.pickFirstBalancer.destroy();
      }
    };
    exports.LeafLoadBalancer = LeafLoadBalancer;
    function setup() {
      (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);
      (0, load_balancer_1.registerDefaultLoadBalancerType)(TYPE_NAME);
    }
    exports.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/certificate-provider.js
var require_certificate_provider = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/certificate-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FileWatcherCertificateProvider = void 0;
    var fs3 = __require("fs");
    var logging = require_logging();
    var constants_1 = require_constants5();
    var util_1 = __require("util");
    var TRACER_NAME = "certificate_provider";
    function trace3(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var readFilePromise = (0, util_1.promisify)(fs3.readFile);
    var FileWatcherCertificateProvider = class {
      constructor(config) {
        this.config = config;
        this.refreshTimer = null;
        this.fileResultPromise = null;
        this.latestCaUpdate = null;
        this.caListeners = /* @__PURE__ */ new Set();
        this.latestIdentityUpdate = null;
        this.identityListeners = /* @__PURE__ */ new Set();
        this.lastUpdateTime = null;
        if (config.certificateFile === void 0 !== (config.privateKeyFile === void 0)) {
          throw new Error("certificateFile and privateKeyFile must be set or unset together");
        }
        if (config.certificateFile === void 0 && config.caCertificateFile === void 0) {
          throw new Error("At least one of certificateFile and caCertificateFile must be set");
        }
        trace3("File watcher constructed with config " + JSON.stringify(config));
      }
      updateCertificates() {
        if (this.fileResultPromise) {
          return;
        }
        this.fileResultPromise = Promise.allSettled([
          this.config.certificateFile ? readFilePromise(this.config.certificateFile) : Promise.reject(),
          this.config.privateKeyFile ? readFilePromise(this.config.privateKeyFile) : Promise.reject(),
          this.config.caCertificateFile ? readFilePromise(this.config.caCertificateFile) : Promise.reject()
        ]);
        this.fileResultPromise.then(([certificateResult, privateKeyResult, caCertificateResult]) => {
          if (!this.refreshTimer) {
            return;
          }
          trace3("File watcher read certificates certificate" + (certificateResult ? "!=" : "==") + "null, privateKey" + (privateKeyResult ? "!=" : "==") + "null, CA certificate" + (caCertificateResult ? "!=" : "==") + "null");
          this.lastUpdateTime = /* @__PURE__ */ new Date();
          this.fileResultPromise = null;
          if (certificateResult.status === "fulfilled" && privateKeyResult.status === "fulfilled") {
            this.latestIdentityUpdate = {
              certificate: certificateResult.value,
              privateKey: privateKeyResult.value
            };
          } else {
            this.latestIdentityUpdate = null;
          }
          if (caCertificateResult.status === "fulfilled") {
            this.latestCaUpdate = {
              caCertificate: caCertificateResult.value
            };
          }
          for (const listener of this.identityListeners) {
            listener(this.latestIdentityUpdate);
          }
          for (const listener of this.caListeners) {
            listener(this.latestCaUpdate);
          }
        });
        trace3("File watcher initiated certificate update");
      }
      maybeStartWatchingFiles() {
        if (!this.refreshTimer) {
          const timeSinceLastUpdate = this.lastUpdateTime ? (/* @__PURE__ */ new Date()).getTime() - this.lastUpdateTime.getTime() : Infinity;
          if (timeSinceLastUpdate > this.config.refreshIntervalMs) {
            this.updateCertificates();
          }
          if (timeSinceLastUpdate > this.config.refreshIntervalMs * 2) {
            this.latestCaUpdate = null;
            this.latestIdentityUpdate = null;
          }
          this.refreshTimer = setInterval(() => this.updateCertificates(), this.config.refreshIntervalMs);
          trace3("File watcher started watching");
        }
      }
      maybeStopWatchingFiles() {
        if (this.caListeners.size === 0 && this.identityListeners.size === 0) {
          this.fileResultPromise = null;
          if (this.refreshTimer) {
            clearInterval(this.refreshTimer);
            this.refreshTimer = null;
          }
        }
      }
      addCaCertificateListener(listener) {
        this.caListeners.add(listener);
        this.maybeStartWatchingFiles();
        process.nextTick(listener, this.latestCaUpdate);
      }
      removeCaCertificateListener(listener) {
        this.caListeners.delete(listener);
        this.maybeStopWatchingFiles();
      }
      addIdentityCertificateListener(listener) {
        this.identityListeners.add(listener);
        this.maybeStartWatchingFiles();
        process.nextTick(listener, this.latestIdentityUpdate);
      }
      removeIdentityCertificateListener(listener) {
        this.identityListeners.delete(listener);
        this.maybeStopWatchingFiles();
      }
    };
    exports.FileWatcherCertificateProvider = FileWatcherCertificateProvider;
  }
});

// node_modules/@grpc/grpc-js/build/src/experimental.js
var require_experimental = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/experimental.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCertificateProviderChannelCredentials = exports.FileWatcherCertificateProvider = exports.createCertificateProviderServerCredentials = exports.createServerCredentialsWithInterceptors = exports.BaseSubchannelWrapper = exports.registerAdminService = exports.FilterStackFactory = exports.BaseFilter = exports.PickResultType = exports.QueuePicker = exports.UnavailablePicker = exports.ChildLoadBalancerHandler = exports.EndpointMap = exports.endpointHasAddress = exports.endpointToString = exports.subchannelAddressToString = exports.LeafLoadBalancer = exports.isLoadBalancerNameRegistered = exports.parseLoadBalancingConfig = exports.selectLbConfigFromList = exports.registerLoadBalancerType = exports.createChildChannelControlHelper = exports.BackoffTimeout = exports.parseDuration = exports.durationToMs = exports.splitHostPort = exports.uriToString = exports.createResolver = exports.registerResolver = exports.log = exports.trace = void 0;
    var logging_1 = require_logging();
    Object.defineProperty(exports, "trace", { enumerable: true, get: function() {
      return logging_1.trace;
    } });
    Object.defineProperty(exports, "log", { enumerable: true, get: function() {
      return logging_1.log;
    } });
    var resolver_1 = require_resolver();
    Object.defineProperty(exports, "registerResolver", { enumerable: true, get: function() {
      return resolver_1.registerResolver;
    } });
    Object.defineProperty(exports, "createResolver", { enumerable: true, get: function() {
      return resolver_1.createResolver;
    } });
    var uri_parser_1 = require_uri_parser();
    Object.defineProperty(exports, "uriToString", { enumerable: true, get: function() {
      return uri_parser_1.uriToString;
    } });
    Object.defineProperty(exports, "splitHostPort", { enumerable: true, get: function() {
      return uri_parser_1.splitHostPort;
    } });
    var duration_1 = require_duration();
    Object.defineProperty(exports, "durationToMs", { enumerable: true, get: function() {
      return duration_1.durationToMs;
    } });
    Object.defineProperty(exports, "parseDuration", { enumerable: true, get: function() {
      return duration_1.parseDuration;
    } });
    var backoff_timeout_1 = require_backoff_timeout();
    Object.defineProperty(exports, "BackoffTimeout", { enumerable: true, get: function() {
      return backoff_timeout_1.BackoffTimeout;
    } });
    var load_balancer_1 = require_load_balancer();
    Object.defineProperty(exports, "createChildChannelControlHelper", { enumerable: true, get: function() {
      return load_balancer_1.createChildChannelControlHelper;
    } });
    Object.defineProperty(exports, "registerLoadBalancerType", { enumerable: true, get: function() {
      return load_balancer_1.registerLoadBalancerType;
    } });
    Object.defineProperty(exports, "selectLbConfigFromList", { enumerable: true, get: function() {
      return load_balancer_1.selectLbConfigFromList;
    } });
    Object.defineProperty(exports, "parseLoadBalancingConfig", { enumerable: true, get: function() {
      return load_balancer_1.parseLoadBalancingConfig;
    } });
    Object.defineProperty(exports, "isLoadBalancerNameRegistered", { enumerable: true, get: function() {
      return load_balancer_1.isLoadBalancerNameRegistered;
    } });
    var load_balancer_pick_first_1 = require_load_balancer_pick_first();
    Object.defineProperty(exports, "LeafLoadBalancer", { enumerable: true, get: function() {
      return load_balancer_pick_first_1.LeafLoadBalancer;
    } });
    var subchannel_address_1 = require_subchannel_address();
    Object.defineProperty(exports, "subchannelAddressToString", { enumerable: true, get: function() {
      return subchannel_address_1.subchannelAddressToString;
    } });
    Object.defineProperty(exports, "endpointToString", { enumerable: true, get: function() {
      return subchannel_address_1.endpointToString;
    } });
    Object.defineProperty(exports, "endpointHasAddress", { enumerable: true, get: function() {
      return subchannel_address_1.endpointHasAddress;
    } });
    Object.defineProperty(exports, "EndpointMap", { enumerable: true, get: function() {
      return subchannel_address_1.EndpointMap;
    } });
    var load_balancer_child_handler_1 = require_load_balancer_child_handler();
    Object.defineProperty(exports, "ChildLoadBalancerHandler", { enumerable: true, get: function() {
      return load_balancer_child_handler_1.ChildLoadBalancerHandler;
    } });
    var picker_1 = require_picker();
    Object.defineProperty(exports, "UnavailablePicker", { enumerable: true, get: function() {
      return picker_1.UnavailablePicker;
    } });
    Object.defineProperty(exports, "QueuePicker", { enumerable: true, get: function() {
      return picker_1.QueuePicker;
    } });
    Object.defineProperty(exports, "PickResultType", { enumerable: true, get: function() {
      return picker_1.PickResultType;
    } });
    var filter_1 = require_filter();
    Object.defineProperty(exports, "BaseFilter", { enumerable: true, get: function() {
      return filter_1.BaseFilter;
    } });
    var filter_stack_1 = require_filter_stack();
    Object.defineProperty(exports, "FilterStackFactory", { enumerable: true, get: function() {
      return filter_stack_1.FilterStackFactory;
    } });
    var admin_1 = require_admin();
    Object.defineProperty(exports, "registerAdminService", { enumerable: true, get: function() {
      return admin_1.registerAdminService;
    } });
    var subchannel_interface_1 = require_subchannel_interface();
    Object.defineProperty(exports, "BaseSubchannelWrapper", { enumerable: true, get: function() {
      return subchannel_interface_1.BaseSubchannelWrapper;
    } });
    var server_credentials_1 = require_server_credentials();
    Object.defineProperty(exports, "createServerCredentialsWithInterceptors", { enumerable: true, get: function() {
      return server_credentials_1.createServerCredentialsWithInterceptors;
    } });
    Object.defineProperty(exports, "createCertificateProviderServerCredentials", { enumerable: true, get: function() {
      return server_credentials_1.createCertificateProviderServerCredentials;
    } });
    var certificate_provider_1 = require_certificate_provider();
    Object.defineProperty(exports, "FileWatcherCertificateProvider", { enumerable: true, get: function() {
      return certificate_provider_1.FileWatcherCertificateProvider;
    } });
    var channel_credentials_1 = require_channel_credentials();
    Object.defineProperty(exports, "createCertificateProviderChannelCredentials", { enumerable: true, get: function() {
      return channel_credentials_1.createCertificateProviderChannelCredentials;
    } });
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver-uds.js
var require_resolver_uds = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolver-uds.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setup = void 0;
    var resolver_1 = require_resolver();
    var UdsResolver = class {
      constructor(target, listener, channelOptions) {
        this.listener = listener;
        this.hasReturnedResult = false;
        this.endpoints = [];
        let path9;
        if (target.authority === "") {
          path9 = "/" + target.path;
        } else {
          path9 = target.path;
        }
        this.endpoints = [{ addresses: [{ path: path9 }] }];
      }
      updateResolution() {
        if (!this.hasReturnedResult) {
          this.hasReturnedResult = true;
          process.nextTick(this.listener.onSuccessfulResolution, this.endpoints, null, null, null, {});
        }
      }
      destroy() {
        this.hasReturnedResult = false;
      }
      static getDefaultAuthority(target) {
        return "localhost";
      }
    };
    function setup() {
      (0, resolver_1.registerResolver)("unix", UdsResolver);
    }
    exports.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver-ip.js
var require_resolver_ip = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolver-ip.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setup = void 0;
    var net_1 = __require("net");
    var constants_1 = require_constants5();
    var metadata_1 = require_metadata();
    var resolver_1 = require_resolver();
    var uri_parser_1 = require_uri_parser();
    var logging = require_logging();
    var TRACER_NAME = "ip_resolver";
    function trace3(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var IPV4_SCHEME = "ipv4";
    var IPV6_SCHEME = "ipv6";
    var DEFAULT_PORT = 443;
    var IpResolver = class {
      constructor(target, listener, channelOptions) {
        var _a12;
        this.listener = listener;
        this.endpoints = [];
        this.error = null;
        this.hasReturnedResult = false;
        trace3("Resolver constructed for target " + (0, uri_parser_1.uriToString)(target));
        const addresses = [];
        if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {
          this.error = {
            code: constants_1.Status.UNAVAILABLE,
            details: `Unrecognized scheme ${target.scheme} in IP resolver`,
            metadata: new metadata_1.Metadata()
          };
          return;
        }
        const pathList = target.path.split(",");
        for (const path9 of pathList) {
          const hostPort = (0, uri_parser_1.splitHostPort)(path9);
          if (hostPort === null) {
            this.error = {
              code: constants_1.Status.UNAVAILABLE,
              details: `Failed to parse ${target.scheme} address ${path9}`,
              metadata: new metadata_1.Metadata()
            };
            return;
          }
          if (target.scheme === IPV4_SCHEME && !(0, net_1.isIPv4)(hostPort.host) || target.scheme === IPV6_SCHEME && !(0, net_1.isIPv6)(hostPort.host)) {
            this.error = {
              code: constants_1.Status.UNAVAILABLE,
              details: `Failed to parse ${target.scheme} address ${path9}`,
              metadata: new metadata_1.Metadata()
            };
            return;
          }
          addresses.push({
            host: hostPort.host,
            port: (_a12 = hostPort.port) !== null && _a12 !== void 0 ? _a12 : DEFAULT_PORT
          });
        }
        this.endpoints = addresses.map((address) => ({ addresses: [address] }));
        trace3("Parsed " + target.scheme + " address list " + addresses);
      }
      updateResolution() {
        if (!this.hasReturnedResult) {
          this.hasReturnedResult = true;
          process.nextTick(() => {
            if (this.error) {
              this.listener.onError(this.error);
            } else {
              this.listener.onSuccessfulResolution(this.endpoints, null, null, null, {});
            }
          });
        }
      }
      destroy() {
        this.hasReturnedResult = false;
      }
      static getDefaultAuthority(target) {
        return target.path.split(",")[0];
      }
    };
    function setup() {
      (0, resolver_1.registerResolver)(IPV4_SCHEME, IpResolver);
      (0, resolver_1.registerResolver)(IPV6_SCHEME, IpResolver);
    }
    exports.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js
var require_load_balancer_round_robin = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setup = exports.RoundRobinLoadBalancer = void 0;
    var load_balancer_1 = require_load_balancer();
    var connectivity_state_1 = require_connectivity_state();
    var picker_1 = require_picker();
    var logging = require_logging();
    var constants_1 = require_constants5();
    var subchannel_address_1 = require_subchannel_address();
    var load_balancer_pick_first_1 = require_load_balancer_pick_first();
    var TRACER_NAME = "round_robin";
    function trace3(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var TYPE_NAME = "round_robin";
    var RoundRobinLoadBalancingConfig = class _RoundRobinLoadBalancingConfig {
      getLoadBalancerName() {
        return TYPE_NAME;
      }
      constructor() {
      }
      toJsonObject() {
        return {
          [TYPE_NAME]: {}
        };
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static createFromJson(obj) {
        return new _RoundRobinLoadBalancingConfig();
      }
    };
    var RoundRobinPicker = class {
      constructor(children, nextIndex = 0) {
        this.children = children;
        this.nextIndex = nextIndex;
      }
      pick(pickArgs) {
        const childPicker = this.children[this.nextIndex].picker;
        this.nextIndex = (this.nextIndex + 1) % this.children.length;
        return childPicker.pick(pickArgs);
      }
      /**
       * Check what the next subchannel returned would be. Used by the load
       * balancer implementation to preserve this part of the picker state if
       * possible when a subchannel connects or disconnects.
       */
      peekNextEndpoint() {
        return this.children[this.nextIndex].endpoint;
      }
    };
    var RoundRobinLoadBalancer = class {
      constructor(channelControlHelper, credentials, options) {
        this.channelControlHelper = channelControlHelper;
        this.credentials = credentials;
        this.options = options;
        this.children = [];
        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
        this.currentReadyPicker = null;
        this.updatesPaused = false;
        this.lastError = null;
        this.childChannelControlHelper = (0, load_balancer_1.createChildChannelControlHelper)(channelControlHelper, {
          updateState: (connectivityState, picker) => {
            if (this.currentState === connectivity_state_1.ConnectivityState.READY && connectivityState !== connectivity_state_1.ConnectivityState.READY) {
              this.channelControlHelper.requestReresolution();
            }
            this.calculateAndUpdateState();
          }
        });
      }
      countChildrenWithState(state) {
        return this.children.filter((child) => child.getConnectivityState() === state).length;
      }
      calculateAndUpdateState() {
        if (this.updatesPaused) {
          return;
        }
        if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.READY) > 0) {
          const readyChildren = this.children.filter((child) => child.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);
          let index = 0;
          if (this.currentReadyPicker !== null) {
            const nextPickedEndpoint = this.currentReadyPicker.peekNextEndpoint();
            index = readyChildren.findIndex((child) => (0, subchannel_address_1.endpointEqual)(child.getEndpoint(), nextPickedEndpoint));
            if (index < 0) {
              index = 0;
            }
          }
          this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readyChildren.map((child) => ({
            endpoint: child.getEndpoint(),
            picker: child.getPicker()
          })), index));
        } else if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.CONNECTING) > 0) {
          this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
        } else if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) > 0) {
          this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({
            details: `No connection established. Last error: ${this.lastError}`
          }));
        } else {
          this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
        }
        for (const child of this.children) {
          if (child.getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {
            child.exitIdle();
          }
        }
      }
      updateState(newState, picker) {
        trace3(connectivity_state_1.ConnectivityState[this.currentState] + " -> " + connectivity_state_1.ConnectivityState[newState]);
        if (newState === connectivity_state_1.ConnectivityState.READY) {
          this.currentReadyPicker = picker;
        } else {
          this.currentReadyPicker = null;
        }
        this.currentState = newState;
        this.channelControlHelper.updateState(newState, picker);
      }
      resetSubchannelList() {
        for (const child of this.children) {
          child.destroy();
        }
      }
      updateAddressList(endpointList, lbConfig) {
        this.resetSubchannelList();
        trace3("Connect to endpoint list " + endpointList.map(subchannel_address_1.endpointToString));
        this.updatesPaused = true;
        this.children = endpointList.map((endpoint) => new load_balancer_pick_first_1.LeafLoadBalancer(endpoint, this.childChannelControlHelper, this.credentials, this.options));
        for (const child of this.children) {
          child.startConnecting();
        }
        this.updatesPaused = false;
        this.calculateAndUpdateState();
      }
      exitIdle() {
      }
      resetBackoff() {
      }
      destroy() {
        this.resetSubchannelList();
      }
      getTypeName() {
        return TYPE_NAME;
      }
    };
    exports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;
    function setup() {
      (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);
    }
    exports.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js
var require_load_balancer_outlier_detection = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js"(exports) {
    "use strict";
    var _a12;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setup = exports.OutlierDetectionLoadBalancer = exports.OutlierDetectionLoadBalancingConfig = void 0;
    var connectivity_state_1 = require_connectivity_state();
    var constants_1 = require_constants5();
    var duration_1 = require_duration();
    var experimental_1 = require_experimental();
    var load_balancer_1 = require_load_balancer();
    var load_balancer_child_handler_1 = require_load_balancer_child_handler();
    var picker_1 = require_picker();
    var subchannel_address_1 = require_subchannel_address();
    var subchannel_interface_1 = require_subchannel_interface();
    var logging = require_logging();
    var TRACER_NAME = "outlier_detection";
    function trace3(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var TYPE_NAME = "outlier_detection";
    var OUTLIER_DETECTION_ENABLED = ((_a12 = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION) !== null && _a12 !== void 0 ? _a12 : "true") === "true";
    var defaultSuccessRateEjectionConfig = {
      stdev_factor: 1900,
      enforcement_percentage: 100,
      minimum_hosts: 5,
      request_volume: 100
    };
    var defaultFailurePercentageEjectionConfig = {
      threshold: 85,
      enforcement_percentage: 100,
      minimum_hosts: 5,
      request_volume: 50
    };
    function validateFieldType(obj, fieldName, expectedType, objectName) {
      if (fieldName in obj && obj[fieldName] !== void 0 && typeof obj[fieldName] !== expectedType) {
        const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
        throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);
      }
    }
    function validatePositiveDuration(obj, fieldName, objectName) {
      const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
      if (fieldName in obj && obj[fieldName] !== void 0) {
        if (!(0, duration_1.isDuration)(obj[fieldName])) {
          throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);
        }
        if (!(obj[fieldName].seconds >= 0 && obj[fieldName].seconds <= 315576e6 && obj[fieldName].nanos >= 0 && obj[fieldName].nanos <= 999999999)) {
          throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);
        }
      }
    }
    function validatePercentage(obj, fieldName, objectName) {
      const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
      validateFieldType(obj, fieldName, "number", objectName);
      if (fieldName in obj && obj[fieldName] !== void 0 && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {
        throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);
      }
    }
    var OutlierDetectionLoadBalancingConfig = class _OutlierDetectionLoadBalancingConfig {
      constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy) {
        this.childPolicy = childPolicy;
        if (childPolicy.getLoadBalancerName() === "pick_first") {
          throw new Error("outlier_detection LB policy cannot have a pick_first child policy");
        }
        this.intervalMs = intervalMs !== null && intervalMs !== void 0 ? intervalMs : 1e4;
        this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== void 0 ? baseEjectionTimeMs : 3e4;
        this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== void 0 ? maxEjectionTimeMs : 3e5;
        this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== void 0 ? maxEjectionPercent : 10;
        this.successRateEjection = successRateEjection ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;
        this.failurePercentageEjection = failurePercentageEjection ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;
      }
      getLoadBalancerName() {
        return TYPE_NAME;
      }
      toJsonObject() {
        var _a13, _b5;
        return {
          outlier_detection: {
            interval: (0, duration_1.msToDuration)(this.intervalMs),
            base_ejection_time: (0, duration_1.msToDuration)(this.baseEjectionTimeMs),
            max_ejection_time: (0, duration_1.msToDuration)(this.maxEjectionTimeMs),
            max_ejection_percent: this.maxEjectionPercent,
            success_rate_ejection: (_a13 = this.successRateEjection) !== null && _a13 !== void 0 ? _a13 : void 0,
            failure_percentage_ejection: (_b5 = this.failurePercentageEjection) !== null && _b5 !== void 0 ? _b5 : void 0,
            child_policy: [this.childPolicy.toJsonObject()]
          }
        };
      }
      getIntervalMs() {
        return this.intervalMs;
      }
      getBaseEjectionTimeMs() {
        return this.baseEjectionTimeMs;
      }
      getMaxEjectionTimeMs() {
        return this.maxEjectionTimeMs;
      }
      getMaxEjectionPercent() {
        return this.maxEjectionPercent;
      }
      getSuccessRateEjectionConfig() {
        return this.successRateEjection;
      }
      getFailurePercentageEjectionConfig() {
        return this.failurePercentageEjection;
      }
      getChildPolicy() {
        return this.childPolicy;
      }
      static createFromJson(obj) {
        var _a13;
        validatePositiveDuration(obj, "interval");
        validatePositiveDuration(obj, "base_ejection_time");
        validatePositiveDuration(obj, "max_ejection_time");
        validatePercentage(obj, "max_ejection_percent");
        if ("success_rate_ejection" in obj && obj.success_rate_ejection !== void 0) {
          if (typeof obj.success_rate_ejection !== "object") {
            throw new Error("outlier detection config success_rate_ejection must be an object");
          }
          validateFieldType(obj.success_rate_ejection, "stdev_factor", "number", "success_rate_ejection");
          validatePercentage(obj.success_rate_ejection, "enforcement_percentage", "success_rate_ejection");
          validateFieldType(obj.success_rate_ejection, "minimum_hosts", "number", "success_rate_ejection");
          validateFieldType(obj.success_rate_ejection, "request_volume", "number", "success_rate_ejection");
        }
        if ("failure_percentage_ejection" in obj && obj.failure_percentage_ejection !== void 0) {
          if (typeof obj.failure_percentage_ejection !== "object") {
            throw new Error("outlier detection config failure_percentage_ejection must be an object");
          }
          validatePercentage(obj.failure_percentage_ejection, "threshold", "failure_percentage_ejection");
          validatePercentage(obj.failure_percentage_ejection, "enforcement_percentage", "failure_percentage_ejection");
          validateFieldType(obj.failure_percentage_ejection, "minimum_hosts", "number", "failure_percentage_ejection");
          validateFieldType(obj.failure_percentage_ejection, "request_volume", "number", "failure_percentage_ejection");
        }
        if (!("child_policy" in obj) || !Array.isArray(obj.child_policy)) {
          throw new Error("outlier detection config child_policy must be an array");
        }
        const childPolicy = (0, load_balancer_1.selectLbConfigFromList)(obj.child_policy);
        if (!childPolicy) {
          throw new Error("outlier detection config child_policy: no valid recognized policy found");
        }
        return new _OutlierDetectionLoadBalancingConfig(obj.interval ? (0, duration_1.durationToMs)(obj.interval) : null, obj.base_ejection_time ? (0, duration_1.durationToMs)(obj.base_ejection_time) : null, obj.max_ejection_time ? (0, duration_1.durationToMs)(obj.max_ejection_time) : null, (_a13 = obj.max_ejection_percent) !== null && _a13 !== void 0 ? _a13 : null, obj.success_rate_ejection, obj.failure_percentage_ejection, childPolicy);
      }
    };
    exports.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;
    var OutlierDetectionSubchannelWrapper = class extends subchannel_interface_1.BaseSubchannelWrapper {
      constructor(childSubchannel, mapEntry) {
        super(childSubchannel);
        this.mapEntry = mapEntry;
        this.refCount = 0;
      }
      ref() {
        this.child.ref();
        this.refCount += 1;
      }
      unref() {
        this.child.unref();
        this.refCount -= 1;
        if (this.refCount <= 0) {
          if (this.mapEntry) {
            const index = this.mapEntry.subchannelWrappers.indexOf(this);
            if (index >= 0) {
              this.mapEntry.subchannelWrappers.splice(index, 1);
            }
          }
        }
      }
      eject() {
        this.setHealthy(false);
      }
      uneject() {
        this.setHealthy(true);
      }
      getMapEntry() {
        return this.mapEntry;
      }
      getWrappedSubchannel() {
        return this.child;
      }
    };
    function createEmptyBucket() {
      return {
        success: 0,
        failure: 0
      };
    }
    var CallCounter = class {
      constructor() {
        this.activeBucket = createEmptyBucket();
        this.inactiveBucket = createEmptyBucket();
      }
      addSuccess() {
        this.activeBucket.success += 1;
      }
      addFailure() {
        this.activeBucket.failure += 1;
      }
      switchBuckets() {
        this.inactiveBucket = this.activeBucket;
        this.activeBucket = createEmptyBucket();
      }
      getLastSuccesses() {
        return this.inactiveBucket.success;
      }
      getLastFailures() {
        return this.inactiveBucket.failure;
      }
    };
    var OutlierDetectionPicker = class {
      constructor(wrappedPicker, countCalls) {
        this.wrappedPicker = wrappedPicker;
        this.countCalls = countCalls;
      }
      pick(pickArgs) {
        const wrappedPick = this.wrappedPicker.pick(pickArgs);
        if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {
          const subchannelWrapper = wrappedPick.subchannel;
          const mapEntry = subchannelWrapper.getMapEntry();
          if (mapEntry) {
            let onCallEnded = wrappedPick.onCallEnded;
            if (this.countCalls) {
              onCallEnded = (statusCode) => {
                var _a13;
                if (statusCode === constants_1.Status.OK) {
                  mapEntry.counter.addSuccess();
                } else {
                  mapEntry.counter.addFailure();
                }
                (_a13 = wrappedPick.onCallEnded) === null || _a13 === void 0 ? void 0 : _a13.call(wrappedPick, statusCode);
              };
            }
            return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel(), onCallEnded });
          } else {
            return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel() });
          }
        } else {
          return wrappedPick;
        }
      }
    };
    var OutlierDetectionLoadBalancer = class {
      constructor(channelControlHelper, credentials, options) {
        this.entryMap = new subchannel_address_1.EndpointMap();
        this.latestConfig = null;
        this.timerStartTime = null;
        this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler((0, experimental_1.createChildChannelControlHelper)(channelControlHelper, {
          createSubchannel: (subchannelAddress, subchannelArgs, credentialsOverride) => {
            const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs, credentialsOverride);
            const mapEntry = this.entryMap.getForSubchannelAddress(subchannelAddress);
            const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);
            if ((mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.currentEjectionTimestamp) !== null) {
              subchannelWrapper.eject();
            }
            mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.subchannelWrappers.push(subchannelWrapper);
            return subchannelWrapper;
          },
          updateState: (connectivityState, picker) => {
            if (connectivityState === connectivity_state_1.ConnectivityState.READY) {
              channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()));
            } else {
              channelControlHelper.updateState(connectivityState, picker);
            }
          }
        }), credentials, options);
        this.ejectionTimer = setInterval(() => {
        }, 0);
        clearInterval(this.ejectionTimer);
      }
      isCountingEnabled() {
        return this.latestConfig !== null && (this.latestConfig.getSuccessRateEjectionConfig() !== null || this.latestConfig.getFailurePercentageEjectionConfig() !== null);
      }
      getCurrentEjectionPercent() {
        let ejectionCount = 0;
        for (const mapEntry of this.entryMap.values()) {
          if (mapEntry.currentEjectionTimestamp !== null) {
            ejectionCount += 1;
          }
        }
        return ejectionCount * 100 / this.entryMap.size;
      }
      runSuccessRateCheck(ejectionTimestamp) {
        if (!this.latestConfig) {
          return;
        }
        const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();
        if (!successRateConfig) {
          return;
        }
        trace3("Running success rate check");
        const targetRequestVolume = successRateConfig.request_volume;
        let addresesWithTargetVolume = 0;
        const successRates = [];
        for (const [endpoint, mapEntry] of this.entryMap.entries()) {
          const successes = mapEntry.counter.getLastSuccesses();
          const failures2 = mapEntry.counter.getLastFailures();
          trace3("Stats for " + (0, subchannel_address_1.endpointToString)(endpoint) + ": successes=" + successes + " failures=" + failures2 + " targetRequestVolume=" + targetRequestVolume);
          if (successes + failures2 >= targetRequestVolume) {
            addresesWithTargetVolume += 1;
            successRates.push(successes / (successes + failures2));
          }
        }
        trace3("Found " + addresesWithTargetVolume + " success rate candidates; currentEjectionPercent=" + this.getCurrentEjectionPercent() + " successRates=[" + successRates + "]");
        if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {
          return;
        }
        const successRateMean = successRates.reduce((a2, b2) => a2 + b2) / successRates.length;
        let successRateDeviationSum = 0;
        for (const rate of successRates) {
          const deviation = rate - successRateMean;
          successRateDeviationSum += deviation * deviation;
        }
        const successRateVariance = successRateDeviationSum / successRates.length;
        const successRateStdev = Math.sqrt(successRateVariance);
        const ejectionThreshold = successRateMean - successRateStdev * (successRateConfig.stdev_factor / 1e3);
        trace3("stdev=" + successRateStdev + " ejectionThreshold=" + ejectionThreshold);
        for (const [address, mapEntry] of this.entryMap.entries()) {
          if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {
            break;
          }
          const successes = mapEntry.counter.getLastSuccesses();
          const failures2 = mapEntry.counter.getLastFailures();
          if (successes + failures2 < targetRequestVolume) {
            continue;
          }
          const successRate = successes / (successes + failures2);
          trace3("Checking candidate " + address + " successRate=" + successRate);
          if (successRate < ejectionThreshold) {
            const randomNumber = Math.random() * 100;
            trace3("Candidate " + address + " randomNumber=" + randomNumber + " enforcement_percentage=" + successRateConfig.enforcement_percentage);
            if (randomNumber < successRateConfig.enforcement_percentage) {
              trace3("Ejecting candidate " + address);
              this.eject(mapEntry, ejectionTimestamp);
            }
          }
        }
      }
      runFailurePercentageCheck(ejectionTimestamp) {
        if (!this.latestConfig) {
          return;
        }
        const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();
        if (!failurePercentageConfig) {
          return;
        }
        trace3("Running failure percentage check. threshold=" + failurePercentageConfig.threshold + " request volume threshold=" + failurePercentageConfig.request_volume);
        let addressesWithTargetVolume = 0;
        for (const mapEntry of this.entryMap.values()) {
          const successes = mapEntry.counter.getLastSuccesses();
          const failures2 = mapEntry.counter.getLastFailures();
          if (successes + failures2 >= failurePercentageConfig.request_volume) {
            addressesWithTargetVolume += 1;
          }
        }
        if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {
          return;
        }
        for (const [address, mapEntry] of this.entryMap.entries()) {
          if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {
            break;
          }
          const successes = mapEntry.counter.getLastSuccesses();
          const failures2 = mapEntry.counter.getLastFailures();
          trace3("Candidate successes=" + successes + " failures=" + failures2);
          if (successes + failures2 < failurePercentageConfig.request_volume) {
            continue;
          }
          const failurePercentage = failures2 * 100 / (failures2 + successes);
          if (failurePercentage > failurePercentageConfig.threshold) {
            const randomNumber = Math.random() * 100;
            trace3("Candidate " + address + " randomNumber=" + randomNumber + " enforcement_percentage=" + failurePercentageConfig.enforcement_percentage);
            if (randomNumber < failurePercentageConfig.enforcement_percentage) {
              trace3("Ejecting candidate " + address);
              this.eject(mapEntry, ejectionTimestamp);
            }
          }
        }
      }
      eject(mapEntry, ejectionTimestamp) {
        mapEntry.currentEjectionTimestamp = /* @__PURE__ */ new Date();
        mapEntry.ejectionTimeMultiplier += 1;
        for (const subchannelWrapper of mapEntry.subchannelWrappers) {
          subchannelWrapper.eject();
        }
      }
      uneject(mapEntry) {
        mapEntry.currentEjectionTimestamp = null;
        for (const subchannelWrapper of mapEntry.subchannelWrappers) {
          subchannelWrapper.uneject();
        }
      }
      switchAllBuckets() {
        for (const mapEntry of this.entryMap.values()) {
          mapEntry.counter.switchBuckets();
        }
      }
      startTimer(delayMs) {
        var _a13, _b5;
        this.ejectionTimer = setTimeout(() => this.runChecks(), delayMs);
        (_b5 = (_a13 = this.ejectionTimer).unref) === null || _b5 === void 0 ? void 0 : _b5.call(_a13);
      }
      runChecks() {
        const ejectionTimestamp = /* @__PURE__ */ new Date();
        trace3("Ejection timer running");
        this.switchAllBuckets();
        if (!this.latestConfig) {
          return;
        }
        this.timerStartTime = ejectionTimestamp;
        this.startTimer(this.latestConfig.getIntervalMs());
        this.runSuccessRateCheck(ejectionTimestamp);
        this.runFailurePercentageCheck(ejectionTimestamp);
        for (const [address, mapEntry] of this.entryMap.entries()) {
          if (mapEntry.currentEjectionTimestamp === null) {
            if (mapEntry.ejectionTimeMultiplier > 0) {
              mapEntry.ejectionTimeMultiplier -= 1;
            }
          } else {
            const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();
            const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();
            const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());
            returnTime.setMilliseconds(returnTime.getMilliseconds() + Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));
            if (returnTime < /* @__PURE__ */ new Date()) {
              trace3("Unejecting " + address);
              this.uneject(mapEntry);
            }
          }
        }
      }
      updateAddressList(endpointList, lbConfig, attributes) {
        if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {
          return;
        }
        for (const endpoint of endpointList) {
          if (!this.entryMap.has(endpoint)) {
            trace3("Adding map entry for " + (0, subchannel_address_1.endpointToString)(endpoint));
            this.entryMap.set(endpoint, {
              counter: new CallCounter(),
              currentEjectionTimestamp: null,
              ejectionTimeMultiplier: 0,
              subchannelWrappers: []
            });
          }
        }
        this.entryMap.deleteMissing(endpointList);
        const childPolicy = lbConfig.getChildPolicy();
        this.childBalancer.updateAddressList(endpointList, childPolicy, attributes);
        if (lbConfig.getSuccessRateEjectionConfig() || lbConfig.getFailurePercentageEjectionConfig()) {
          if (this.timerStartTime) {
            trace3("Previous timer existed. Replacing timer");
            clearTimeout(this.ejectionTimer);
            const remainingDelay = lbConfig.getIntervalMs() - ((/* @__PURE__ */ new Date()).getTime() - this.timerStartTime.getTime());
            this.startTimer(remainingDelay);
          } else {
            trace3("Starting new timer");
            this.timerStartTime = /* @__PURE__ */ new Date();
            this.startTimer(lbConfig.getIntervalMs());
            this.switchAllBuckets();
          }
        } else {
          trace3("Counting disabled. Cancelling timer.");
          this.timerStartTime = null;
          clearTimeout(this.ejectionTimer);
          for (const mapEntry of this.entryMap.values()) {
            this.uneject(mapEntry);
            mapEntry.ejectionTimeMultiplier = 0;
          }
        }
        this.latestConfig = lbConfig;
      }
      exitIdle() {
        this.childBalancer.exitIdle();
      }
      resetBackoff() {
        this.childBalancer.resetBackoff();
      }
      destroy() {
        clearTimeout(this.ejectionTimer);
        this.childBalancer.destroy();
      }
      getTypeName() {
        return TYPE_NAME;
      }
    };
    exports.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;
    function setup() {
      if (OUTLIER_DETECTION_ENABLED) {
        (0, experimental_1.registerLoadBalancerType)(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);
      }
    }
    exports.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/index.js
var require_src12 = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.experimental = exports.ServerInterceptingCall = exports.ResponderBuilder = exports.ServerListenerBuilder = exports.addAdminServicesToServer = exports.getChannelzHandlers = exports.getChannelzServiceDefinition = exports.InterceptorConfigurationError = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.StatusBuilder = exports.getClientChannel = exports.ServerCredentials = exports.Server = exports.setLogVerbosity = exports.setLogger = exports.load = exports.loadObject = exports.CallCredentials = exports.ChannelCredentials = exports.waitForClientReady = exports.closeClient = exports.Channel = exports.makeGenericClientConstructor = exports.makeClientConstructor = exports.loadPackageDefinition = exports.Client = exports.compressionAlgorithms = exports.propagate = exports.connectivityState = exports.status = exports.logVerbosity = exports.Metadata = exports.credentials = void 0;
    var call_credentials_1 = require_call_credentials();
    Object.defineProperty(exports, "CallCredentials", { enumerable: true, get: function() {
      return call_credentials_1.CallCredentials;
    } });
    var channel_1 = require_channel();
    Object.defineProperty(exports, "Channel", { enumerable: true, get: function() {
      return channel_1.ChannelImplementation;
    } });
    var compression_algorithms_1 = require_compression_algorithms();
    Object.defineProperty(exports, "compressionAlgorithms", { enumerable: true, get: function() {
      return compression_algorithms_1.CompressionAlgorithms;
    } });
    var connectivity_state_1 = require_connectivity_state();
    Object.defineProperty(exports, "connectivityState", { enumerable: true, get: function() {
      return connectivity_state_1.ConnectivityState;
    } });
    var channel_credentials_1 = require_channel_credentials();
    Object.defineProperty(exports, "ChannelCredentials", { enumerable: true, get: function() {
      return channel_credentials_1.ChannelCredentials;
    } });
    var client_1 = require_client();
    Object.defineProperty(exports, "Client", { enumerable: true, get: function() {
      return client_1.Client;
    } });
    var constants_1 = require_constants5();
    Object.defineProperty(exports, "logVerbosity", { enumerable: true, get: function() {
      return constants_1.LogVerbosity;
    } });
    Object.defineProperty(exports, "status", { enumerable: true, get: function() {
      return constants_1.Status;
    } });
    Object.defineProperty(exports, "propagate", { enumerable: true, get: function() {
      return constants_1.Propagate;
    } });
    var logging = require_logging();
    var make_client_1 = require_make_client();
    Object.defineProperty(exports, "loadPackageDefinition", { enumerable: true, get: function() {
      return make_client_1.loadPackageDefinition;
    } });
    Object.defineProperty(exports, "makeClientConstructor", { enumerable: true, get: function() {
      return make_client_1.makeClientConstructor;
    } });
    Object.defineProperty(exports, "makeGenericClientConstructor", { enumerable: true, get: function() {
      return make_client_1.makeClientConstructor;
    } });
    var metadata_1 = require_metadata();
    Object.defineProperty(exports, "Metadata", { enumerable: true, get: function() {
      return metadata_1.Metadata;
    } });
    var server_1 = require_server();
    Object.defineProperty(exports, "Server", { enumerable: true, get: function() {
      return server_1.Server;
    } });
    var server_credentials_1 = require_server_credentials();
    Object.defineProperty(exports, "ServerCredentials", { enumerable: true, get: function() {
      return server_credentials_1.ServerCredentials;
    } });
    var status_builder_1 = require_status_builder();
    Object.defineProperty(exports, "StatusBuilder", { enumerable: true, get: function() {
      return status_builder_1.StatusBuilder;
    } });
    exports.credentials = {
      /**
       * Combine a ChannelCredentials with any number of CallCredentials into a
       * single ChannelCredentials object.
       * @param channelCredentials The ChannelCredentials object.
       * @param callCredentials Any number of CallCredentials objects.
       * @return The resulting ChannelCredentials object.
       */
      combineChannelCredentials: (channelCredentials, ...callCredentials) => {
        return callCredentials.reduce((acc, other) => acc.compose(other), channelCredentials);
      },
      /**
       * Combine any number of CallCredentials into a single CallCredentials
       * object.
       * @param first The first CallCredentials object.
       * @param additional Any number of additional CallCredentials objects.
       * @return The resulting CallCredentials object.
       */
      combineCallCredentials: (first5, ...additional) => {
        return additional.reduce((acc, other) => acc.compose(other), first5);
      },
      // from channel-credentials.ts
      createInsecure: channel_credentials_1.ChannelCredentials.createInsecure,
      createSsl: channel_credentials_1.ChannelCredentials.createSsl,
      createFromSecureContext: channel_credentials_1.ChannelCredentials.createFromSecureContext,
      // from call-credentials.ts
      createFromMetadataGenerator: call_credentials_1.CallCredentials.createFromMetadataGenerator,
      createFromGoogleCredential: call_credentials_1.CallCredentials.createFromGoogleCredential,
      createEmpty: call_credentials_1.CallCredentials.createEmpty
    };
    var closeClient = (client) => client.close();
    exports.closeClient = closeClient;
    var waitForClientReady = (client, deadline, callback) => client.waitForReady(deadline, callback);
    exports.waitForClientReady = waitForClientReady;
    var loadObject = (value, options) => {
      throw new Error("Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead");
    };
    exports.loadObject = loadObject;
    var load = (filename, format3, options) => {
      throw new Error("Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead");
    };
    exports.load = load;
    var setLogger = (logger) => {
      logging.setLogger(logger);
    };
    exports.setLogger = setLogger;
    var setLogVerbosity = (verbosity) => {
      logging.setLoggerVerbosity(verbosity);
    };
    exports.setLogVerbosity = setLogVerbosity;
    var getClientChannel = (client) => {
      return client_1.Client.prototype.getChannel.call(client);
    };
    exports.getClientChannel = getClientChannel;
    var client_interceptors_1 = require_client_interceptors();
    Object.defineProperty(exports, "ListenerBuilder", { enumerable: true, get: function() {
      return client_interceptors_1.ListenerBuilder;
    } });
    Object.defineProperty(exports, "RequesterBuilder", { enumerable: true, get: function() {
      return client_interceptors_1.RequesterBuilder;
    } });
    Object.defineProperty(exports, "InterceptingCall", { enumerable: true, get: function() {
      return client_interceptors_1.InterceptingCall;
    } });
    Object.defineProperty(exports, "InterceptorConfigurationError", { enumerable: true, get: function() {
      return client_interceptors_1.InterceptorConfigurationError;
    } });
    var channelz_1 = require_channelz();
    Object.defineProperty(exports, "getChannelzServiceDefinition", { enumerable: true, get: function() {
      return channelz_1.getChannelzServiceDefinition;
    } });
    Object.defineProperty(exports, "getChannelzHandlers", { enumerable: true, get: function() {
      return channelz_1.getChannelzHandlers;
    } });
    var admin_1 = require_admin();
    Object.defineProperty(exports, "addAdminServicesToServer", { enumerable: true, get: function() {
      return admin_1.addAdminServicesToServer;
    } });
    var server_interceptors_1 = require_server_interceptors();
    Object.defineProperty(exports, "ServerListenerBuilder", { enumerable: true, get: function() {
      return server_interceptors_1.ServerListenerBuilder;
    } });
    Object.defineProperty(exports, "ResponderBuilder", { enumerable: true, get: function() {
      return server_interceptors_1.ResponderBuilder;
    } });
    Object.defineProperty(exports, "ServerInterceptingCall", { enumerable: true, get: function() {
      return server_interceptors_1.ServerInterceptingCall;
    } });
    var experimental = require_experimental();
    exports.experimental = experimental;
    var resolver_dns = require_resolver_dns();
    var resolver_uds = require_resolver_uds();
    var resolver_ip = require_resolver_ip();
    var load_balancer_pick_first = require_load_balancer_pick_first();
    var load_balancer_round_robin = require_load_balancer_round_robin();
    var load_balancer_outlier_detection = require_load_balancer_outlier_detection();
    var channelz = require_channelz();
    (() => {
      resolver_dns.setup();
      resolver_uds.setup();
      resolver_ip.setup();
      load_balancer_pick_first.setup();
      load_balancer_round_robin.setup();
      load_balancer_outlier_detection.setup();
      channelz.setup();
    })();
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/build/src/create-service-client-constructor.js
var require_create_service_client_constructor = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/build/src/create-service-client-constructor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createServiceClientConstructor = void 0;
    var grpc = require_src12();
    function createServiceClientConstructor(path9, name) {
      const serviceDefinition = {
        export: {
          path: path9,
          requestStream: false,
          responseStream: false,
          requestSerialize: (arg) => {
            return arg;
          },
          requestDeserialize: (arg) => {
            return arg;
          },
          responseSerialize: (arg) => {
            return arg;
          },
          responseDeserialize: (arg) => {
            return arg;
          }
        }
      };
      return grpc.makeGenericClientConstructor(serviceDefinition, name);
    }
    exports.createServiceClientConstructor = createServiceClientConstructor;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/build/src/grpc-exporter-transport.js
var require_grpc_exporter_transport = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/build/src/grpc-exporter-transport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GrpcExporterTransport = exports.createEmptyMetadata = exports.createSslCredentials = exports.createInsecureCredentials = void 0;
    var GRPC_COMPRESSION_NONE = 0;
    var GRPC_COMPRESSION_GZIP = 2;
    function toGrpcCompression(compression) {
      return compression === "gzip" ? GRPC_COMPRESSION_GZIP : GRPC_COMPRESSION_NONE;
    }
    function createInsecureCredentials() {
      const {
        credentials
        // eslint-disable-next-line @typescript-eslint/no-var-requires
      } = require_src12();
      return credentials.createInsecure();
    }
    exports.createInsecureCredentials = createInsecureCredentials;
    function createSslCredentials(rootCert, privateKey, certChain) {
      const {
        credentials
        // eslint-disable-next-line @typescript-eslint/no-var-requires
      } = require_src12();
      return credentials.createSsl(rootCert, privateKey, certChain);
    }
    exports.createSslCredentials = createSslCredentials;
    function createEmptyMetadata() {
      const {
        Metadata
        // eslint-disable-next-line @typescript-eslint/no-var-requires
      } = require_src12();
      return new Metadata();
    }
    exports.createEmptyMetadata = createEmptyMetadata;
    var GrpcExporterTransport = class {
      constructor(_parameters) {
        this._parameters = _parameters;
      }
      shutdown() {
        var _a12;
        (_a12 = this._client) === null || _a12 === void 0 ? void 0 : _a12.close();
      }
      send(data) {
        const buffer2 = Buffer.from(data);
        if (this._client == null) {
          const {
            createServiceClientConstructor
            // eslint-disable-next-line @typescript-eslint/no-var-requires
          } = require_create_service_client_constructor();
          try {
            this._metadata = this._parameters.metadata();
          } catch (error) {
            return Promise.resolve({
              status: "failure",
              error
            });
          }
          const clientConstructor = createServiceClientConstructor(this._parameters.grpcPath, this._parameters.grpcName);
          try {
            this._client = new clientConstructor(this._parameters.address, this._parameters.credentials(), {
              "grpc.default_compression_algorithm": toGrpcCompression(this._parameters.compression)
            });
          } catch (error) {
            return Promise.resolve({
              status: "failure",
              error
            });
          }
        }
        return new Promise((resolve) => {
          const deadline = Date.now() + this._parameters.timeoutMillis;
          if (this._metadata == null) {
            return resolve({
              error: new Error("metadata was null"),
              status: "failure"
            });
          }
          this._client.export(buffer2, this._metadata, { deadline }, (err, response) => {
            if (err) {
              resolve({
                status: "failure",
                error: err
              });
            } else {
              resolve({
                data: response,
                status: "success"
              });
            }
          });
        });
      }
    };
    exports.GrpcExporterTransport = GrpcExporterTransport;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/build/src/util.js
var require_util5 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/build/src/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.configureCompression = exports.getCredentialsFromEnvironment = exports.configureCredentials = exports.validateAndNormalizeUrl = exports.DEFAULT_COLLECTOR_URL = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src7();
    var path9 = __require("path");
    var url_1 = __require("url");
    var fs3 = __require("fs");
    var otlp_exporter_base_1 = require_src10();
    var grpc_exporter_transport_1 = require_grpc_exporter_transport();
    exports.DEFAULT_COLLECTOR_URL = "http://localhost:4317";
    function validateAndNormalizeUrl(url) {
      var _a12;
      const hasProtocol = url.match(/^([\w]{1,8}):\/\//);
      if (!hasProtocol) {
        url = `https://${url}`;
      }
      const target = new url_1.URL(url);
      if (target.protocol === "unix:") {
        return url;
      }
      if (target.pathname && target.pathname !== "/") {
        api_1.diag.warn("URL path should not be set when using grpc, the path part of the URL will be ignored.");
      }
      if (target.protocol !== "" && !((_a12 = target.protocol) === null || _a12 === void 0 ? void 0 : _a12.match(/^(http)s?:$/))) {
        api_1.diag.warn("URL protocol should be http(s)://. Using http://.");
      }
      return target.host;
    }
    exports.validateAndNormalizeUrl = validateAndNormalizeUrl;
    function configureCredentials(credentials, endpoint) {
      let insecure;
      if (credentials) {
        return credentials;
      } else if (endpoint.startsWith("https://")) {
        insecure = false;
      } else if (endpoint.startsWith("http://") || endpoint === exports.DEFAULT_COLLECTOR_URL) {
        insecure = true;
      } else {
        insecure = getSecurityFromEnv();
      }
      if (insecure) {
        return (0, grpc_exporter_transport_1.createInsecureCredentials)();
      } else {
        return getCredentialsFromEnvironment();
      }
    }
    exports.configureCredentials = configureCredentials;
    function getSecurityFromEnv() {
      const definedInsecure = (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_TRACES_INSECURE || (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_INSECURE;
      if (definedInsecure) {
        return definedInsecure.toLowerCase() === "true";
      } else {
        return false;
      }
    }
    function getCredentialsFromEnvironment() {
      const rootCert = retrieveRootCert();
      const privateKey = retrievePrivateKey();
      const certChain = retrieveCertChain();
      return (0, grpc_exporter_transport_1.createSslCredentials)(rootCert, privateKey, certChain);
    }
    exports.getCredentialsFromEnvironment = getCredentialsFromEnvironment;
    function retrieveRootCert() {
      const rootCertificate = (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE || (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_CERTIFICATE;
      if (rootCertificate) {
        try {
          return fs3.readFileSync(path9.resolve(process.cwd(), rootCertificate));
        } catch (_a12) {
          api_1.diag.warn("Failed to read root certificate file");
          return void 0;
        }
      } else {
        return void 0;
      }
    }
    function retrievePrivateKey() {
      const clientKey = (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY || (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_CLIENT_KEY;
      if (clientKey) {
        try {
          return fs3.readFileSync(path9.resolve(process.cwd(), clientKey));
        } catch (_a12) {
          api_1.diag.warn("Failed to read client certificate private key file");
          return void 0;
        }
      } else {
        return void 0;
      }
    }
    function retrieveCertChain() {
      const clientChain = (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE || (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE;
      if (clientChain) {
        try {
          return fs3.readFileSync(path9.resolve(process.cwd(), clientChain));
        } catch (_a12) {
          api_1.diag.warn("Failed to read client certificate chain file");
          return void 0;
        }
      } else {
        return void 0;
      }
    }
    function configureCompression(compression) {
      if (compression != null) {
        return compression;
      }
      const envCompression = (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_TRACES_COMPRESSION || (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_COMPRESSION;
      if (envCompression === "gzip") {
        return otlp_exporter_base_1.CompressionAlgorithm.GZIP;
      } else if (envCompression === "none") {
        return otlp_exporter_base_1.CompressionAlgorithm.NONE;
      }
      api_1.diag.warn('Unknown compression "' + envCompression + '", falling back to "none"');
      return otlp_exporter_base_1.CompressionAlgorithm.NONE;
    }
    exports.configureCompression = configureCompression;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/build/src/OTLPGRPCExporterNodeBase.js
var require_OTLPGRPCExporterNodeBase = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/build/src/OTLPGRPCExporterNodeBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OTLPGRPCExporterNodeBase = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src7();
    var otlp_exporter_base_1 = require_src10();
    var grpc_exporter_transport_1 = require_grpc_exporter_transport();
    var util_1 = require_util5();
    var OTLPGRPCExporterNodeBase = class extends otlp_exporter_base_1.OTLPExporterBase {
      constructor(config = {}, signalSpecificMetadata, grpcName, grpcPath, serializer) {
        var _a12;
        super(config);
        this.grpcQueue = [];
        this._serializer = serializer;
        if (config.headers) {
          api_1.diag.warn("Headers cannot be set when using grpc");
        }
        const nonSignalSpecificMetadata = core_1.baggageUtils.parseKeyPairsIntoRecord((0, core_1.getEnv)().OTEL_EXPORTER_OTLP_HEADERS);
        const rawMetadata = Object.assign({}, nonSignalSpecificMetadata, signalSpecificMetadata);
        let credentialProvider = () => {
          return (0, util_1.configureCredentials)(void 0, this.getUrlFromConfig(config));
        };
        if (config.credentials != null) {
          const credentials = config.credentials;
          credentialProvider = () => {
            return credentials;
          };
        }
        const configMetadata = (_a12 = config.metadata) === null || _a12 === void 0 ? void 0 : _a12.clone();
        const metadataProvider = () => {
          const metadata = configMetadata !== null && configMetadata !== void 0 ? configMetadata : (0, grpc_exporter_transport_1.createEmptyMetadata)();
          for (const [key, value] of Object.entries(rawMetadata)) {
            if (metadata.get(key).length < 1) {
              metadata.set(key, value);
            }
          }
          return metadata;
        };
        this.compression = (0, util_1.configureCompression)(config.compression);
        this._transport = new grpc_exporter_transport_1.GrpcExporterTransport({
          address: this.getDefaultUrl(config),
          compression: this.compression,
          credentials: credentialProvider,
          grpcName,
          grpcPath,
          metadata: metadataProvider,
          timeoutMillis: this.timeoutMillis
        });
      }
      onInit() {
      }
      onShutdown() {
        this._transport.shutdown();
      }
      send(objects, onSuccess, onError3) {
        if (this._shutdownOnce.isCalled) {
          api_1.diag.debug("Shutdown already started. Cannot send objects");
          return;
        }
        const converted = this.convert(objects);
        const data = this._serializer.serializeRequest(converted);
        if (data == null) {
          onError3(new Error("Could not serialize message"));
          return;
        }
        const promise2 = this._transport.send(data).then((response) => {
          if (response.status === "success") {
            onSuccess();
            return;
          }
          if (response.status === "failure" && response.error) {
            onError3(response.error);
          }
          onError3(new otlp_exporter_base_1.OTLPExporterError("Export failed with unknown error"));
        }, onError3);
        this._sendingPromises.push(promise2);
        const popPromise = () => {
          const index = this._sendingPromises.indexOf(promise2);
          this._sendingPromises.splice(index, 1);
        };
        promise2.then(popPromise, popPromise);
      }
    };
    exports.OTLPGRPCExporterNodeBase = OTLPGRPCExporterNodeBase;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/build/src/generated/root.js
var require_root = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/build/src/generated/root.js"(exports, module) {
    "use strict";
    var $protobuf = __require("protobufjs/minimal");
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    $root.opentelemetry = function() {
      var opentelemetry = {};
      opentelemetry.proto = function() {
        var proto = {};
        proto.common = function() {
          var common = {};
          common.v1 = function() {
            var v1 = {};
            v1.AnyValue = function() {
              function AnyValue(properties) {
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              AnyValue.prototype.stringValue = null;
              AnyValue.prototype.boolValue = null;
              AnyValue.prototype.intValue = null;
              AnyValue.prototype.doubleValue = null;
              AnyValue.prototype.arrayValue = null;
              AnyValue.prototype.kvlistValue = null;
              AnyValue.prototype.bytesValue = null;
              var $oneOfFields;
              Object.defineProperty(AnyValue.prototype, "value", {
                get: $util.oneOfGetter($oneOfFields = ["stringValue", "boolValue", "intValue", "doubleValue", "arrayValue", "kvlistValue", "bytesValue"]),
                set: $util.oneOfSetter($oneOfFields)
              });
              AnyValue.create = function create2(properties) {
                return new AnyValue(properties);
              };
              AnyValue.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                  writer.uint32(
                    /* id 1, wireType 2 =*/
                    10
                  ).string(message.stringValue);
                if (message.boolValue != null && Object.hasOwnProperty.call(message, "boolValue"))
                  writer.uint32(
                    /* id 2, wireType 0 =*/
                    16
                  ).bool(message.boolValue);
                if (message.intValue != null && Object.hasOwnProperty.call(message, "intValue"))
                  writer.uint32(
                    /* id 3, wireType 0 =*/
                    24
                  ).int64(message.intValue);
                if (message.doubleValue != null && Object.hasOwnProperty.call(message, "doubleValue"))
                  writer.uint32(
                    /* id 4, wireType 1 =*/
                    33
                  ).double(message.doubleValue);
                if (message.arrayValue != null && Object.hasOwnProperty.call(message, "arrayValue"))
                  $root.opentelemetry.proto.common.v1.ArrayValue.encode(message.arrayValue, writer.uint32(
                    /* id 5, wireType 2 =*/
                    42
                  ).fork()).ldelim();
                if (message.kvlistValue != null && Object.hasOwnProperty.call(message, "kvlistValue"))
                  $root.opentelemetry.proto.common.v1.KeyValueList.encode(message.kvlistValue, writer.uint32(
                    /* id 6, wireType 2 =*/
                    50
                  ).fork()).ldelim();
                if (message.bytesValue != null && Object.hasOwnProperty.call(message, "bytesValue"))
                  writer.uint32(
                    /* id 7, wireType 2 =*/
                    58
                  ).bytes(message.bytesValue);
                return writer;
              };
              AnyValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              AnyValue.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.AnyValue();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 1: {
                      message.stringValue = reader.string();
                      break;
                    }
                    case 2: {
                      message.boolValue = reader.bool();
                      break;
                    }
                    case 3: {
                      message.intValue = reader.int64();
                      break;
                    }
                    case 4: {
                      message.doubleValue = reader.double();
                      break;
                    }
                    case 5: {
                      message.arrayValue = $root.opentelemetry.proto.common.v1.ArrayValue.decode(reader, reader.uint32());
                      break;
                    }
                    case 6: {
                      message.kvlistValue = $root.opentelemetry.proto.common.v1.KeyValueList.decode(reader, reader.uint32());
                      break;
                    }
                    case 7: {
                      message.bytesValue = reader.bytes();
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              AnyValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              AnyValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                var properties = {};
                if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                  properties.value = 1;
                  if (!$util.isString(message.stringValue))
                    return "stringValue: string expected";
                }
                if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                  if (properties.value === 1)
                    return "value: multiple values";
                  properties.value = 1;
                  if (typeof message.boolValue !== "boolean")
                    return "boolValue: boolean expected";
                }
                if (message.intValue != null && message.hasOwnProperty("intValue")) {
                  if (properties.value === 1)
                    return "value: multiple values";
                  properties.value = 1;
                  if (!$util.isInteger(message.intValue) && !(message.intValue && $util.isInteger(message.intValue.low) && $util.isInteger(message.intValue.high)))
                    return "intValue: integer|Long expected";
                }
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                  if (properties.value === 1)
                    return "value: multiple values";
                  properties.value = 1;
                  if (typeof message.doubleValue !== "number")
                    return "doubleValue: number expected";
                }
                if (message.arrayValue != null && message.hasOwnProperty("arrayValue")) {
                  if (properties.value === 1)
                    return "value: multiple values";
                  properties.value = 1;
                  {
                    var error = $root.opentelemetry.proto.common.v1.ArrayValue.verify(message.arrayValue);
                    if (error)
                      return "arrayValue." + error;
                  }
                }
                if (message.kvlistValue != null && message.hasOwnProperty("kvlistValue")) {
                  if (properties.value === 1)
                    return "value: multiple values";
                  properties.value = 1;
                  {
                    var error = $root.opentelemetry.proto.common.v1.KeyValueList.verify(message.kvlistValue);
                    if (error)
                      return "kvlistValue." + error;
                  }
                }
                if (message.bytesValue != null && message.hasOwnProperty("bytesValue")) {
                  if (properties.value === 1)
                    return "value: multiple values";
                  properties.value = 1;
                  if (!(message.bytesValue && typeof message.bytesValue.length === "number" || $util.isString(message.bytesValue)))
                    return "bytesValue: buffer expected";
                }
                return null;
              };
              AnyValue.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.common.v1.AnyValue)
                  return object2;
                var message = new $root.opentelemetry.proto.common.v1.AnyValue();
                if (object2.stringValue != null)
                  message.stringValue = String(object2.stringValue);
                if (object2.boolValue != null)
                  message.boolValue = Boolean(object2.boolValue);
                if (object2.intValue != null) {
                  if ($util.Long)
                    (message.intValue = $util.Long.fromValue(object2.intValue)).unsigned = false;
                  else if (typeof object2.intValue === "string")
                    message.intValue = parseInt(object2.intValue, 10);
                  else if (typeof object2.intValue === "number")
                    message.intValue = object2.intValue;
                  else if (typeof object2.intValue === "object")
                    message.intValue = new $util.LongBits(object2.intValue.low >>> 0, object2.intValue.high >>> 0).toNumber();
                }
                if (object2.doubleValue != null)
                  message.doubleValue = Number(object2.doubleValue);
                if (object2.arrayValue != null) {
                  if (typeof object2.arrayValue !== "object")
                    throw TypeError(".opentelemetry.proto.common.v1.AnyValue.arrayValue: object expected");
                  message.arrayValue = $root.opentelemetry.proto.common.v1.ArrayValue.fromObject(object2.arrayValue);
                }
                if (object2.kvlistValue != null) {
                  if (typeof object2.kvlistValue !== "object")
                    throw TypeError(".opentelemetry.proto.common.v1.AnyValue.kvlistValue: object expected");
                  message.kvlistValue = $root.opentelemetry.proto.common.v1.KeyValueList.fromObject(object2.kvlistValue);
                }
                if (object2.bytesValue != null) {
                  if (typeof object2.bytesValue === "string")
                    $util.base64.decode(object2.bytesValue, message.bytesValue = $util.newBuffer($util.base64.length(object2.bytesValue)), 0);
                  else if (object2.bytesValue.length >= 0)
                    message.bytesValue = object2.bytesValue;
                }
                return message;
              };
              AnyValue.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                  object2.stringValue = message.stringValue;
                  if (options.oneofs)
                    object2.value = "stringValue";
                }
                if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                  object2.boolValue = message.boolValue;
                  if (options.oneofs)
                    object2.value = "boolValue";
                }
                if (message.intValue != null && message.hasOwnProperty("intValue")) {
                  if (typeof message.intValue === "number")
                    object2.intValue = options.longs === String ? String(message.intValue) : message.intValue;
                  else
                    object2.intValue = options.longs === String ? $util.Long.prototype.toString.call(message.intValue) : options.longs === Number ? new $util.LongBits(message.intValue.low >>> 0, message.intValue.high >>> 0).toNumber() : message.intValue;
                  if (options.oneofs)
                    object2.value = "intValue";
                }
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                  object2.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                  if (options.oneofs)
                    object2.value = "doubleValue";
                }
                if (message.arrayValue != null && message.hasOwnProperty("arrayValue")) {
                  object2.arrayValue = $root.opentelemetry.proto.common.v1.ArrayValue.toObject(message.arrayValue, options);
                  if (options.oneofs)
                    object2.value = "arrayValue";
                }
                if (message.kvlistValue != null && message.hasOwnProperty("kvlistValue")) {
                  object2.kvlistValue = $root.opentelemetry.proto.common.v1.KeyValueList.toObject(message.kvlistValue, options);
                  if (options.oneofs)
                    object2.value = "kvlistValue";
                }
                if (message.bytesValue != null && message.hasOwnProperty("bytesValue")) {
                  object2.bytesValue = options.bytes === String ? $util.base64.encode(message.bytesValue, 0, message.bytesValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.bytesValue) : message.bytesValue;
                  if (options.oneofs)
                    object2.value = "bytesValue";
                }
                return object2;
              };
              AnyValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              AnyValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.common.v1.AnyValue";
              };
              return AnyValue;
            }();
            v1.ArrayValue = function() {
              function ArrayValue(properties) {
                this.values = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              ArrayValue.prototype.values = $util.emptyArray;
              ArrayValue.create = function create2(properties) {
                return new ArrayValue(properties);
              };
              ArrayValue.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.values != null && message.values.length)
                  for (var i2 = 0; i2 < message.values.length; ++i2)
                    $root.opentelemetry.proto.common.v1.AnyValue.encode(message.values[i2], writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                return writer;
              };
              ArrayValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              ArrayValue.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.ArrayValue();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 1: {
                      if (!(message.values && message.values.length))
                        message.values = [];
                      message.values.push($root.opentelemetry.proto.common.v1.AnyValue.decode(reader, reader.uint32()));
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              ArrayValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              ArrayValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                  if (!Array.isArray(message.values))
                    return "values: array expected";
                  for (var i2 = 0; i2 < message.values.length; ++i2) {
                    var error = $root.opentelemetry.proto.common.v1.AnyValue.verify(message.values[i2]);
                    if (error)
                      return "values." + error;
                  }
                }
                return null;
              };
              ArrayValue.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.common.v1.ArrayValue)
                  return object2;
                var message = new $root.opentelemetry.proto.common.v1.ArrayValue();
                if (object2.values) {
                  if (!Array.isArray(object2.values))
                    throw TypeError(".opentelemetry.proto.common.v1.ArrayValue.values: array expected");
                  message.values = [];
                  for (var i2 = 0; i2 < object2.values.length; ++i2) {
                    if (typeof object2.values[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.common.v1.ArrayValue.values: object expected");
                    message.values[i2] = $root.opentelemetry.proto.common.v1.AnyValue.fromObject(object2.values[i2]);
                  }
                }
                return message;
              };
              ArrayValue.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults)
                  object2.values = [];
                if (message.values && message.values.length) {
                  object2.values = [];
                  for (var j2 = 0; j2 < message.values.length; ++j2)
                    object2.values[j2] = $root.opentelemetry.proto.common.v1.AnyValue.toObject(message.values[j2], options);
                }
                return object2;
              };
              ArrayValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              ArrayValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.common.v1.ArrayValue";
              };
              return ArrayValue;
            }();
            v1.KeyValueList = function() {
              function KeyValueList(properties) {
                this.values = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              KeyValueList.prototype.values = $util.emptyArray;
              KeyValueList.create = function create2(properties) {
                return new KeyValueList(properties);
              };
              KeyValueList.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.values != null && message.values.length)
                  for (var i2 = 0; i2 < message.values.length; ++i2)
                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.values[i2], writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                return writer;
              };
              KeyValueList.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              KeyValueList.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.KeyValueList();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 1: {
                      if (!(message.values && message.values.length))
                        message.values = [];
                      message.values.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              KeyValueList.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              KeyValueList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                  if (!Array.isArray(message.values))
                    return "values: array expected";
                  for (var i2 = 0; i2 < message.values.length; ++i2) {
                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.values[i2]);
                    if (error)
                      return "values." + error;
                  }
                }
                return null;
              };
              KeyValueList.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.common.v1.KeyValueList)
                  return object2;
                var message = new $root.opentelemetry.proto.common.v1.KeyValueList();
                if (object2.values) {
                  if (!Array.isArray(object2.values))
                    throw TypeError(".opentelemetry.proto.common.v1.KeyValueList.values: array expected");
                  message.values = [];
                  for (var i2 = 0; i2 < object2.values.length; ++i2) {
                    if (typeof object2.values[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.common.v1.KeyValueList.values: object expected");
                    message.values[i2] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object2.values[i2]);
                  }
                }
                return message;
              };
              KeyValueList.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults)
                  object2.values = [];
                if (message.values && message.values.length) {
                  object2.values = [];
                  for (var j2 = 0; j2 < message.values.length; ++j2)
                    object2.values[j2] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.values[j2], options);
                }
                return object2;
              };
              KeyValueList.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              KeyValueList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.common.v1.KeyValueList";
              };
              return KeyValueList;
            }();
            v1.KeyValue = function() {
              function KeyValue(properties) {
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              KeyValue.prototype.key = null;
              KeyValue.prototype.value = null;
              KeyValue.create = function create2(properties) {
                return new KeyValue(properties);
              };
              KeyValue.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                  writer.uint32(
                    /* id 1, wireType 2 =*/
                    10
                  ).string(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                  $root.opentelemetry.proto.common.v1.AnyValue.encode(message.value, writer.uint32(
                    /* id 2, wireType 2 =*/
                    18
                  ).fork()).ldelim();
                return writer;
              };
              KeyValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              KeyValue.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.KeyValue();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 1: {
                      message.key = reader.string();
                      break;
                    }
                    case 2: {
                      message.value = $root.opentelemetry.proto.common.v1.AnyValue.decode(reader, reader.uint32());
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              KeyValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              KeyValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.key != null && message.hasOwnProperty("key")) {
                  if (!$util.isString(message.key))
                    return "key: string expected";
                }
                if (message.value != null && message.hasOwnProperty("value")) {
                  var error = $root.opentelemetry.proto.common.v1.AnyValue.verify(message.value);
                  if (error)
                    return "value." + error;
                }
                return null;
              };
              KeyValue.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.common.v1.KeyValue)
                  return object2;
                var message = new $root.opentelemetry.proto.common.v1.KeyValue();
                if (object2.key != null)
                  message.key = String(object2.key);
                if (object2.value != null) {
                  if (typeof object2.value !== "object")
                    throw TypeError(".opentelemetry.proto.common.v1.KeyValue.value: object expected");
                  message.value = $root.opentelemetry.proto.common.v1.AnyValue.fromObject(object2.value);
                }
                return message;
              };
              KeyValue.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.defaults) {
                  object2.key = "";
                  object2.value = null;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                  object2.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                  object2.value = $root.opentelemetry.proto.common.v1.AnyValue.toObject(message.value, options);
                return object2;
              };
              KeyValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              KeyValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.common.v1.KeyValue";
              };
              return KeyValue;
            }();
            v1.InstrumentationScope = function() {
              function InstrumentationScope(properties) {
                this.attributes = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              InstrumentationScope.prototype.name = null;
              InstrumentationScope.prototype.version = null;
              InstrumentationScope.prototype.attributes = $util.emptyArray;
              InstrumentationScope.prototype.droppedAttributesCount = null;
              InstrumentationScope.create = function create2(properties) {
                return new InstrumentationScope(properties);
              };
              InstrumentationScope.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                  writer.uint32(
                    /* id 1, wireType 2 =*/
                    10
                  ).string(message.name);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                  writer.uint32(
                    /* id 2, wireType 2 =*/
                    18
                  ).string(message.version);
                if (message.attributes != null && message.attributes.length)
                  for (var i2 = 0; i2 < message.attributes.length; ++i2)
                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i2], writer.uint32(
                      /* id 3, wireType 2 =*/
                      26
                    ).fork()).ldelim();
                if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, "droppedAttributesCount"))
                  writer.uint32(
                    /* id 4, wireType 0 =*/
                    32
                  ).uint32(message.droppedAttributesCount);
                return writer;
              };
              InstrumentationScope.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              InstrumentationScope.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.InstrumentationScope();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 1: {
                      message.name = reader.string();
                      break;
                    }
                    case 2: {
                      message.version = reader.string();
                      break;
                    }
                    case 3: {
                      if (!(message.attributes && message.attributes.length))
                        message.attributes = [];
                      message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                      break;
                    }
                    case 4: {
                      message.droppedAttributesCount = reader.uint32();
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              InstrumentationScope.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              InstrumentationScope.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.name != null && message.hasOwnProperty("name")) {
                  if (!$util.isString(message.name))
                    return "name: string expected";
                }
                if (message.version != null && message.hasOwnProperty("version")) {
                  if (!$util.isString(message.version))
                    return "version: string expected";
                }
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                  if (!Array.isArray(message.attributes))
                    return "attributes: array expected";
                  for (var i2 = 0; i2 < message.attributes.length; ++i2) {
                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i2]);
                    if (error)
                      return "attributes." + error;
                  }
                }
                if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount")) {
                  if (!$util.isInteger(message.droppedAttributesCount))
                    return "droppedAttributesCount: integer expected";
                }
                return null;
              };
              InstrumentationScope.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.common.v1.InstrumentationScope)
                  return object2;
                var message = new $root.opentelemetry.proto.common.v1.InstrumentationScope();
                if (object2.name != null)
                  message.name = String(object2.name);
                if (object2.version != null)
                  message.version = String(object2.version);
                if (object2.attributes) {
                  if (!Array.isArray(object2.attributes))
                    throw TypeError(".opentelemetry.proto.common.v1.InstrumentationScope.attributes: array expected");
                  message.attributes = [];
                  for (var i2 = 0; i2 < object2.attributes.length; ++i2) {
                    if (typeof object2.attributes[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.common.v1.InstrumentationScope.attributes: object expected");
                    message.attributes[i2] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object2.attributes[i2]);
                  }
                }
                if (object2.droppedAttributesCount != null)
                  message.droppedAttributesCount = object2.droppedAttributesCount >>> 0;
                return message;
              };
              InstrumentationScope.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults)
                  object2.attributes = [];
                if (options.defaults) {
                  object2.name = "";
                  object2.version = "";
                  object2.droppedAttributesCount = 0;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                  object2.name = message.name;
                if (message.version != null && message.hasOwnProperty("version"))
                  object2.version = message.version;
                if (message.attributes && message.attributes.length) {
                  object2.attributes = [];
                  for (var j2 = 0; j2 < message.attributes.length; ++j2)
                    object2.attributes[j2] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j2], options);
                }
                if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount"))
                  object2.droppedAttributesCount = message.droppedAttributesCount;
                return object2;
              };
              InstrumentationScope.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              InstrumentationScope.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.common.v1.InstrumentationScope";
              };
              return InstrumentationScope;
            }();
            return v1;
          }();
          return common;
        }();
        proto.resource = function() {
          var resource = {};
          resource.v1 = function() {
            var v1 = {};
            v1.Resource = function() {
              function Resource(properties) {
                this.attributes = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              Resource.prototype.attributes = $util.emptyArray;
              Resource.prototype.droppedAttributesCount = null;
              Resource.create = function create2(properties) {
                return new Resource(properties);
              };
              Resource.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.attributes != null && message.attributes.length)
                  for (var i2 = 0; i2 < message.attributes.length; ++i2)
                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i2], writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, "droppedAttributesCount"))
                  writer.uint32(
                    /* id 2, wireType 0 =*/
                    16
                  ).uint32(message.droppedAttributesCount);
                return writer;
              };
              Resource.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              Resource.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.resource.v1.Resource();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 1: {
                      if (!(message.attributes && message.attributes.length))
                        message.attributes = [];
                      message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                      break;
                    }
                    case 2: {
                      message.droppedAttributesCount = reader.uint32();
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              Resource.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              Resource.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                  if (!Array.isArray(message.attributes))
                    return "attributes: array expected";
                  for (var i2 = 0; i2 < message.attributes.length; ++i2) {
                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i2]);
                    if (error)
                      return "attributes." + error;
                  }
                }
                if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount")) {
                  if (!$util.isInteger(message.droppedAttributesCount))
                    return "droppedAttributesCount: integer expected";
                }
                return null;
              };
              Resource.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.resource.v1.Resource)
                  return object2;
                var message = new $root.opentelemetry.proto.resource.v1.Resource();
                if (object2.attributes) {
                  if (!Array.isArray(object2.attributes))
                    throw TypeError(".opentelemetry.proto.resource.v1.Resource.attributes: array expected");
                  message.attributes = [];
                  for (var i2 = 0; i2 < object2.attributes.length; ++i2) {
                    if (typeof object2.attributes[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.resource.v1.Resource.attributes: object expected");
                    message.attributes[i2] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object2.attributes[i2]);
                  }
                }
                if (object2.droppedAttributesCount != null)
                  message.droppedAttributesCount = object2.droppedAttributesCount >>> 0;
                return message;
              };
              Resource.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults)
                  object2.attributes = [];
                if (options.defaults)
                  object2.droppedAttributesCount = 0;
                if (message.attributes && message.attributes.length) {
                  object2.attributes = [];
                  for (var j2 = 0; j2 < message.attributes.length; ++j2)
                    object2.attributes[j2] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j2], options);
                }
                if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount"))
                  object2.droppedAttributesCount = message.droppedAttributesCount;
                return object2;
              };
              Resource.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              Resource.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.resource.v1.Resource";
              };
              return Resource;
            }();
            return v1;
          }();
          return resource;
        }();
        proto.trace = function() {
          var trace3 = {};
          trace3.v1 = function() {
            var v1 = {};
            v1.TracesData = function() {
              function TracesData(properties) {
                this.resourceSpans = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              TracesData.prototype.resourceSpans = $util.emptyArray;
              TracesData.create = function create2(properties) {
                return new TracesData(properties);
              };
              TracesData.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.resourceSpans != null && message.resourceSpans.length)
                  for (var i2 = 0; i2 < message.resourceSpans.length; ++i2)
                    $root.opentelemetry.proto.trace.v1.ResourceSpans.encode(message.resourceSpans[i2], writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                return writer;
              };
              TracesData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              TracesData.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.TracesData();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 1: {
                      if (!(message.resourceSpans && message.resourceSpans.length))
                        message.resourceSpans = [];
                      message.resourceSpans.push($root.opentelemetry.proto.trace.v1.ResourceSpans.decode(reader, reader.uint32()));
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              TracesData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              TracesData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.resourceSpans != null && message.hasOwnProperty("resourceSpans")) {
                  if (!Array.isArray(message.resourceSpans))
                    return "resourceSpans: array expected";
                  for (var i2 = 0; i2 < message.resourceSpans.length; ++i2) {
                    var error = $root.opentelemetry.proto.trace.v1.ResourceSpans.verify(message.resourceSpans[i2]);
                    if (error)
                      return "resourceSpans." + error;
                  }
                }
                return null;
              };
              TracesData.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.trace.v1.TracesData)
                  return object2;
                var message = new $root.opentelemetry.proto.trace.v1.TracesData();
                if (object2.resourceSpans) {
                  if (!Array.isArray(object2.resourceSpans))
                    throw TypeError(".opentelemetry.proto.trace.v1.TracesData.resourceSpans: array expected");
                  message.resourceSpans = [];
                  for (var i2 = 0; i2 < object2.resourceSpans.length; ++i2) {
                    if (typeof object2.resourceSpans[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.trace.v1.TracesData.resourceSpans: object expected");
                    message.resourceSpans[i2] = $root.opentelemetry.proto.trace.v1.ResourceSpans.fromObject(object2.resourceSpans[i2]);
                  }
                }
                return message;
              };
              TracesData.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults)
                  object2.resourceSpans = [];
                if (message.resourceSpans && message.resourceSpans.length) {
                  object2.resourceSpans = [];
                  for (var j2 = 0; j2 < message.resourceSpans.length; ++j2)
                    object2.resourceSpans[j2] = $root.opentelemetry.proto.trace.v1.ResourceSpans.toObject(message.resourceSpans[j2], options);
                }
                return object2;
              };
              TracesData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              TracesData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.trace.v1.TracesData";
              };
              return TracesData;
            }();
            v1.ResourceSpans = function() {
              function ResourceSpans(properties) {
                this.scopeSpans = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              ResourceSpans.prototype.resource = null;
              ResourceSpans.prototype.scopeSpans = $util.emptyArray;
              ResourceSpans.prototype.schemaUrl = null;
              ResourceSpans.create = function create2(properties) {
                return new ResourceSpans(properties);
              };
              ResourceSpans.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.resource != null && Object.hasOwnProperty.call(message, "resource"))
                  $root.opentelemetry.proto.resource.v1.Resource.encode(message.resource, writer.uint32(
                    /* id 1, wireType 2 =*/
                    10
                  ).fork()).ldelim();
                if (message.scopeSpans != null && message.scopeSpans.length)
                  for (var i2 = 0; i2 < message.scopeSpans.length; ++i2)
                    $root.opentelemetry.proto.trace.v1.ScopeSpans.encode(message.scopeSpans[i2], writer.uint32(
                      /* id 2, wireType 2 =*/
                      18
                    ).fork()).ldelim();
                if (message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl"))
                  writer.uint32(
                    /* id 3, wireType 2 =*/
                    26
                  ).string(message.schemaUrl);
                return writer;
              };
              ResourceSpans.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              ResourceSpans.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.ResourceSpans();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 1: {
                      message.resource = $root.opentelemetry.proto.resource.v1.Resource.decode(reader, reader.uint32());
                      break;
                    }
                    case 2: {
                      if (!(message.scopeSpans && message.scopeSpans.length))
                        message.scopeSpans = [];
                      message.scopeSpans.push($root.opentelemetry.proto.trace.v1.ScopeSpans.decode(reader, reader.uint32()));
                      break;
                    }
                    case 3: {
                      message.schemaUrl = reader.string();
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              ResourceSpans.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              ResourceSpans.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.resource != null && message.hasOwnProperty("resource")) {
                  var error = $root.opentelemetry.proto.resource.v1.Resource.verify(message.resource);
                  if (error)
                    return "resource." + error;
                }
                if (message.scopeSpans != null && message.hasOwnProperty("scopeSpans")) {
                  if (!Array.isArray(message.scopeSpans))
                    return "scopeSpans: array expected";
                  for (var i2 = 0; i2 < message.scopeSpans.length; ++i2) {
                    var error = $root.opentelemetry.proto.trace.v1.ScopeSpans.verify(message.scopeSpans[i2]);
                    if (error)
                      return "scopeSpans." + error;
                  }
                }
                if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl")) {
                  if (!$util.isString(message.schemaUrl))
                    return "schemaUrl: string expected";
                }
                return null;
              };
              ResourceSpans.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.trace.v1.ResourceSpans)
                  return object2;
                var message = new $root.opentelemetry.proto.trace.v1.ResourceSpans();
                if (object2.resource != null) {
                  if (typeof object2.resource !== "object")
                    throw TypeError(".opentelemetry.proto.trace.v1.ResourceSpans.resource: object expected");
                  message.resource = $root.opentelemetry.proto.resource.v1.Resource.fromObject(object2.resource);
                }
                if (object2.scopeSpans) {
                  if (!Array.isArray(object2.scopeSpans))
                    throw TypeError(".opentelemetry.proto.trace.v1.ResourceSpans.scopeSpans: array expected");
                  message.scopeSpans = [];
                  for (var i2 = 0; i2 < object2.scopeSpans.length; ++i2) {
                    if (typeof object2.scopeSpans[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.trace.v1.ResourceSpans.scopeSpans: object expected");
                    message.scopeSpans[i2] = $root.opentelemetry.proto.trace.v1.ScopeSpans.fromObject(object2.scopeSpans[i2]);
                  }
                }
                if (object2.schemaUrl != null)
                  message.schemaUrl = String(object2.schemaUrl);
                return message;
              };
              ResourceSpans.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults)
                  object2.scopeSpans = [];
                if (options.defaults) {
                  object2.resource = null;
                  object2.schemaUrl = "";
                }
                if (message.resource != null && message.hasOwnProperty("resource"))
                  object2.resource = $root.opentelemetry.proto.resource.v1.Resource.toObject(message.resource, options);
                if (message.scopeSpans && message.scopeSpans.length) {
                  object2.scopeSpans = [];
                  for (var j2 = 0; j2 < message.scopeSpans.length; ++j2)
                    object2.scopeSpans[j2] = $root.opentelemetry.proto.trace.v1.ScopeSpans.toObject(message.scopeSpans[j2], options);
                }
                if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
                  object2.schemaUrl = message.schemaUrl;
                return object2;
              };
              ResourceSpans.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              ResourceSpans.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.trace.v1.ResourceSpans";
              };
              return ResourceSpans;
            }();
            v1.ScopeSpans = function() {
              function ScopeSpans(properties) {
                this.spans = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              ScopeSpans.prototype.scope = null;
              ScopeSpans.prototype.spans = $util.emptyArray;
              ScopeSpans.prototype.schemaUrl = null;
              ScopeSpans.create = function create2(properties) {
                return new ScopeSpans(properties);
              };
              ScopeSpans.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.scope != null && Object.hasOwnProperty.call(message, "scope"))
                  $root.opentelemetry.proto.common.v1.InstrumentationScope.encode(message.scope, writer.uint32(
                    /* id 1, wireType 2 =*/
                    10
                  ).fork()).ldelim();
                if (message.spans != null && message.spans.length)
                  for (var i2 = 0; i2 < message.spans.length; ++i2)
                    $root.opentelemetry.proto.trace.v1.Span.encode(message.spans[i2], writer.uint32(
                      /* id 2, wireType 2 =*/
                      18
                    ).fork()).ldelim();
                if (message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl"))
                  writer.uint32(
                    /* id 3, wireType 2 =*/
                    26
                  ).string(message.schemaUrl);
                return writer;
              };
              ScopeSpans.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              ScopeSpans.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.ScopeSpans();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 1: {
                      message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.decode(reader, reader.uint32());
                      break;
                    }
                    case 2: {
                      if (!(message.spans && message.spans.length))
                        message.spans = [];
                      message.spans.push($root.opentelemetry.proto.trace.v1.Span.decode(reader, reader.uint32()));
                      break;
                    }
                    case 3: {
                      message.schemaUrl = reader.string();
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              ScopeSpans.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              ScopeSpans.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.scope != null && message.hasOwnProperty("scope")) {
                  var error = $root.opentelemetry.proto.common.v1.InstrumentationScope.verify(message.scope);
                  if (error)
                    return "scope." + error;
                }
                if (message.spans != null && message.hasOwnProperty("spans")) {
                  if (!Array.isArray(message.spans))
                    return "spans: array expected";
                  for (var i2 = 0; i2 < message.spans.length; ++i2) {
                    var error = $root.opentelemetry.proto.trace.v1.Span.verify(message.spans[i2]);
                    if (error)
                      return "spans." + error;
                  }
                }
                if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl")) {
                  if (!$util.isString(message.schemaUrl))
                    return "schemaUrl: string expected";
                }
                return null;
              };
              ScopeSpans.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.trace.v1.ScopeSpans)
                  return object2;
                var message = new $root.opentelemetry.proto.trace.v1.ScopeSpans();
                if (object2.scope != null) {
                  if (typeof object2.scope !== "object")
                    throw TypeError(".opentelemetry.proto.trace.v1.ScopeSpans.scope: object expected");
                  message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.fromObject(object2.scope);
                }
                if (object2.spans) {
                  if (!Array.isArray(object2.spans))
                    throw TypeError(".opentelemetry.proto.trace.v1.ScopeSpans.spans: array expected");
                  message.spans = [];
                  for (var i2 = 0; i2 < object2.spans.length; ++i2) {
                    if (typeof object2.spans[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.trace.v1.ScopeSpans.spans: object expected");
                    message.spans[i2] = $root.opentelemetry.proto.trace.v1.Span.fromObject(object2.spans[i2]);
                  }
                }
                if (object2.schemaUrl != null)
                  message.schemaUrl = String(object2.schemaUrl);
                return message;
              };
              ScopeSpans.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults)
                  object2.spans = [];
                if (options.defaults) {
                  object2.scope = null;
                  object2.schemaUrl = "";
                }
                if (message.scope != null && message.hasOwnProperty("scope"))
                  object2.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.toObject(message.scope, options);
                if (message.spans && message.spans.length) {
                  object2.spans = [];
                  for (var j2 = 0; j2 < message.spans.length; ++j2)
                    object2.spans[j2] = $root.opentelemetry.proto.trace.v1.Span.toObject(message.spans[j2], options);
                }
                if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
                  object2.schemaUrl = message.schemaUrl;
                return object2;
              };
              ScopeSpans.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              ScopeSpans.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.trace.v1.ScopeSpans";
              };
              return ScopeSpans;
            }();
            v1.Span = function() {
              function Span2(properties) {
                this.attributes = [];
                this.events = [];
                this.links = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              Span2.prototype.traceId = null;
              Span2.prototype.spanId = null;
              Span2.prototype.traceState = null;
              Span2.prototype.parentSpanId = null;
              Span2.prototype.name = null;
              Span2.prototype.kind = null;
              Span2.prototype.startTimeUnixNano = null;
              Span2.prototype.endTimeUnixNano = null;
              Span2.prototype.attributes = $util.emptyArray;
              Span2.prototype.droppedAttributesCount = null;
              Span2.prototype.events = $util.emptyArray;
              Span2.prototype.droppedEventsCount = null;
              Span2.prototype.links = $util.emptyArray;
              Span2.prototype.droppedLinksCount = null;
              Span2.prototype.status = null;
              Span2.create = function create2(properties) {
                return new Span2(properties);
              };
              Span2.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.traceId != null && Object.hasOwnProperty.call(message, "traceId"))
                  writer.uint32(
                    /* id 1, wireType 2 =*/
                    10
                  ).bytes(message.traceId);
                if (message.spanId != null && Object.hasOwnProperty.call(message, "spanId"))
                  writer.uint32(
                    /* id 2, wireType 2 =*/
                    18
                  ).bytes(message.spanId);
                if (message.traceState != null && Object.hasOwnProperty.call(message, "traceState"))
                  writer.uint32(
                    /* id 3, wireType 2 =*/
                    26
                  ).string(message.traceState);
                if (message.parentSpanId != null && Object.hasOwnProperty.call(message, "parentSpanId"))
                  writer.uint32(
                    /* id 4, wireType 2 =*/
                    34
                  ).bytes(message.parentSpanId);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                  writer.uint32(
                    /* id 5, wireType 2 =*/
                    42
                  ).string(message.name);
                if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
                  writer.uint32(
                    /* id 6, wireType 0 =*/
                    48
                  ).int32(message.kind);
                if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, "startTimeUnixNano"))
                  writer.uint32(
                    /* id 7, wireType 1 =*/
                    57
                  ).fixed64(message.startTimeUnixNano);
                if (message.endTimeUnixNano != null && Object.hasOwnProperty.call(message, "endTimeUnixNano"))
                  writer.uint32(
                    /* id 8, wireType 1 =*/
                    65
                  ).fixed64(message.endTimeUnixNano);
                if (message.attributes != null && message.attributes.length)
                  for (var i2 = 0; i2 < message.attributes.length; ++i2)
                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i2], writer.uint32(
                      /* id 9, wireType 2 =*/
                      74
                    ).fork()).ldelim();
                if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, "droppedAttributesCount"))
                  writer.uint32(
                    /* id 10, wireType 0 =*/
                    80
                  ).uint32(message.droppedAttributesCount);
                if (message.events != null && message.events.length)
                  for (var i2 = 0; i2 < message.events.length; ++i2)
                    $root.opentelemetry.proto.trace.v1.Span.Event.encode(message.events[i2], writer.uint32(
                      /* id 11, wireType 2 =*/
                      90
                    ).fork()).ldelim();
                if (message.droppedEventsCount != null && Object.hasOwnProperty.call(message, "droppedEventsCount"))
                  writer.uint32(
                    /* id 12, wireType 0 =*/
                    96
                  ).uint32(message.droppedEventsCount);
                if (message.links != null && message.links.length)
                  for (var i2 = 0; i2 < message.links.length; ++i2)
                    $root.opentelemetry.proto.trace.v1.Span.Link.encode(message.links[i2], writer.uint32(
                      /* id 13, wireType 2 =*/
                      106
                    ).fork()).ldelim();
                if (message.droppedLinksCount != null && Object.hasOwnProperty.call(message, "droppedLinksCount"))
                  writer.uint32(
                    /* id 14, wireType 0 =*/
                    112
                  ).uint32(message.droppedLinksCount);
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                  $root.opentelemetry.proto.trace.v1.Status.encode(message.status, writer.uint32(
                    /* id 15, wireType 2 =*/
                    122
                  ).fork()).ldelim();
                return writer;
              };
              Span2.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              Span2.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.Span();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 1: {
                      message.traceId = reader.bytes();
                      break;
                    }
                    case 2: {
                      message.spanId = reader.bytes();
                      break;
                    }
                    case 3: {
                      message.traceState = reader.string();
                      break;
                    }
                    case 4: {
                      message.parentSpanId = reader.bytes();
                      break;
                    }
                    case 5: {
                      message.name = reader.string();
                      break;
                    }
                    case 6: {
                      message.kind = reader.int32();
                      break;
                    }
                    case 7: {
                      message.startTimeUnixNano = reader.fixed64();
                      break;
                    }
                    case 8: {
                      message.endTimeUnixNano = reader.fixed64();
                      break;
                    }
                    case 9: {
                      if (!(message.attributes && message.attributes.length))
                        message.attributes = [];
                      message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                      break;
                    }
                    case 10: {
                      message.droppedAttributesCount = reader.uint32();
                      break;
                    }
                    case 11: {
                      if (!(message.events && message.events.length))
                        message.events = [];
                      message.events.push($root.opentelemetry.proto.trace.v1.Span.Event.decode(reader, reader.uint32()));
                      break;
                    }
                    case 12: {
                      message.droppedEventsCount = reader.uint32();
                      break;
                    }
                    case 13: {
                      if (!(message.links && message.links.length))
                        message.links = [];
                      message.links.push($root.opentelemetry.proto.trace.v1.Span.Link.decode(reader, reader.uint32()));
                      break;
                    }
                    case 14: {
                      message.droppedLinksCount = reader.uint32();
                      break;
                    }
                    case 15: {
                      message.status = $root.opentelemetry.proto.trace.v1.Status.decode(reader, reader.uint32());
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              Span2.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              Span2.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.traceId != null && message.hasOwnProperty("traceId")) {
                  if (!(message.traceId && typeof message.traceId.length === "number" || $util.isString(message.traceId)))
                    return "traceId: buffer expected";
                }
                if (message.spanId != null && message.hasOwnProperty("spanId")) {
                  if (!(message.spanId && typeof message.spanId.length === "number" || $util.isString(message.spanId)))
                    return "spanId: buffer expected";
                }
                if (message.traceState != null && message.hasOwnProperty("traceState")) {
                  if (!$util.isString(message.traceState))
                    return "traceState: string expected";
                }
                if (message.parentSpanId != null && message.hasOwnProperty("parentSpanId")) {
                  if (!(message.parentSpanId && typeof message.parentSpanId.length === "number" || $util.isString(message.parentSpanId)))
                    return "parentSpanId: buffer expected";
                }
                if (message.name != null && message.hasOwnProperty("name")) {
                  if (!$util.isString(message.name))
                    return "name: string expected";
                }
                if (message.kind != null && message.hasOwnProperty("kind"))
                  switch (message.kind) {
                    default:
                      return "kind: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                      break;
                  }
                if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano")) {
                  if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))
                    return "startTimeUnixNano: integer|Long expected";
                }
                if (message.endTimeUnixNano != null && message.hasOwnProperty("endTimeUnixNano")) {
                  if (!$util.isInteger(message.endTimeUnixNano) && !(message.endTimeUnixNano && $util.isInteger(message.endTimeUnixNano.low) && $util.isInteger(message.endTimeUnixNano.high)))
                    return "endTimeUnixNano: integer|Long expected";
                }
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                  if (!Array.isArray(message.attributes))
                    return "attributes: array expected";
                  for (var i2 = 0; i2 < message.attributes.length; ++i2) {
                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i2]);
                    if (error)
                      return "attributes." + error;
                  }
                }
                if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount")) {
                  if (!$util.isInteger(message.droppedAttributesCount))
                    return "droppedAttributesCount: integer expected";
                }
                if (message.events != null && message.hasOwnProperty("events")) {
                  if (!Array.isArray(message.events))
                    return "events: array expected";
                  for (var i2 = 0; i2 < message.events.length; ++i2) {
                    var error = $root.opentelemetry.proto.trace.v1.Span.Event.verify(message.events[i2]);
                    if (error)
                      return "events." + error;
                  }
                }
                if (message.droppedEventsCount != null && message.hasOwnProperty("droppedEventsCount")) {
                  if (!$util.isInteger(message.droppedEventsCount))
                    return "droppedEventsCount: integer expected";
                }
                if (message.links != null && message.hasOwnProperty("links")) {
                  if (!Array.isArray(message.links))
                    return "links: array expected";
                  for (var i2 = 0; i2 < message.links.length; ++i2) {
                    var error = $root.opentelemetry.proto.trace.v1.Span.Link.verify(message.links[i2]);
                    if (error)
                      return "links." + error;
                  }
                }
                if (message.droppedLinksCount != null && message.hasOwnProperty("droppedLinksCount")) {
                  if (!$util.isInteger(message.droppedLinksCount))
                    return "droppedLinksCount: integer expected";
                }
                if (message.status != null && message.hasOwnProperty("status")) {
                  var error = $root.opentelemetry.proto.trace.v1.Status.verify(message.status);
                  if (error)
                    return "status." + error;
                }
                return null;
              };
              Span2.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.trace.v1.Span)
                  return object2;
                var message = new $root.opentelemetry.proto.trace.v1.Span();
                if (object2.traceId != null) {
                  if (typeof object2.traceId === "string")
                    $util.base64.decode(object2.traceId, message.traceId = $util.newBuffer($util.base64.length(object2.traceId)), 0);
                  else if (object2.traceId.length >= 0)
                    message.traceId = object2.traceId;
                }
                if (object2.spanId != null) {
                  if (typeof object2.spanId === "string")
                    $util.base64.decode(object2.spanId, message.spanId = $util.newBuffer($util.base64.length(object2.spanId)), 0);
                  else if (object2.spanId.length >= 0)
                    message.spanId = object2.spanId;
                }
                if (object2.traceState != null)
                  message.traceState = String(object2.traceState);
                if (object2.parentSpanId != null) {
                  if (typeof object2.parentSpanId === "string")
                    $util.base64.decode(object2.parentSpanId, message.parentSpanId = $util.newBuffer($util.base64.length(object2.parentSpanId)), 0);
                  else if (object2.parentSpanId.length >= 0)
                    message.parentSpanId = object2.parentSpanId;
                }
                if (object2.name != null)
                  message.name = String(object2.name);
                switch (object2.kind) {
                  default:
                    if (typeof object2.kind === "number") {
                      message.kind = object2.kind;
                      break;
                    }
                    break;
                  case "SPAN_KIND_UNSPECIFIED":
                  case 0:
                    message.kind = 0;
                    break;
                  case "SPAN_KIND_INTERNAL":
                  case 1:
                    message.kind = 1;
                    break;
                  case "SPAN_KIND_SERVER":
                  case 2:
                    message.kind = 2;
                    break;
                  case "SPAN_KIND_CLIENT":
                  case 3:
                    message.kind = 3;
                    break;
                  case "SPAN_KIND_PRODUCER":
                  case 4:
                    message.kind = 4;
                    break;
                  case "SPAN_KIND_CONSUMER":
                  case 5:
                    message.kind = 5;
                    break;
                }
                if (object2.startTimeUnixNano != null) {
                  if ($util.Long)
                    (message.startTimeUnixNano = $util.Long.fromValue(object2.startTimeUnixNano)).unsigned = false;
                  else if (typeof object2.startTimeUnixNano === "string")
                    message.startTimeUnixNano = parseInt(object2.startTimeUnixNano, 10);
                  else if (typeof object2.startTimeUnixNano === "number")
                    message.startTimeUnixNano = object2.startTimeUnixNano;
                  else if (typeof object2.startTimeUnixNano === "object")
                    message.startTimeUnixNano = new $util.LongBits(object2.startTimeUnixNano.low >>> 0, object2.startTimeUnixNano.high >>> 0).toNumber();
                }
                if (object2.endTimeUnixNano != null) {
                  if ($util.Long)
                    (message.endTimeUnixNano = $util.Long.fromValue(object2.endTimeUnixNano)).unsigned = false;
                  else if (typeof object2.endTimeUnixNano === "string")
                    message.endTimeUnixNano = parseInt(object2.endTimeUnixNano, 10);
                  else if (typeof object2.endTimeUnixNano === "number")
                    message.endTimeUnixNano = object2.endTimeUnixNano;
                  else if (typeof object2.endTimeUnixNano === "object")
                    message.endTimeUnixNano = new $util.LongBits(object2.endTimeUnixNano.low >>> 0, object2.endTimeUnixNano.high >>> 0).toNumber();
                }
                if (object2.attributes) {
                  if (!Array.isArray(object2.attributes))
                    throw TypeError(".opentelemetry.proto.trace.v1.Span.attributes: array expected");
                  message.attributes = [];
                  for (var i2 = 0; i2 < object2.attributes.length; ++i2) {
                    if (typeof object2.attributes[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.trace.v1.Span.attributes: object expected");
                    message.attributes[i2] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object2.attributes[i2]);
                  }
                }
                if (object2.droppedAttributesCount != null)
                  message.droppedAttributesCount = object2.droppedAttributesCount >>> 0;
                if (object2.events) {
                  if (!Array.isArray(object2.events))
                    throw TypeError(".opentelemetry.proto.trace.v1.Span.events: array expected");
                  message.events = [];
                  for (var i2 = 0; i2 < object2.events.length; ++i2) {
                    if (typeof object2.events[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.trace.v1.Span.events: object expected");
                    message.events[i2] = $root.opentelemetry.proto.trace.v1.Span.Event.fromObject(object2.events[i2]);
                  }
                }
                if (object2.droppedEventsCount != null)
                  message.droppedEventsCount = object2.droppedEventsCount >>> 0;
                if (object2.links) {
                  if (!Array.isArray(object2.links))
                    throw TypeError(".opentelemetry.proto.trace.v1.Span.links: array expected");
                  message.links = [];
                  for (var i2 = 0; i2 < object2.links.length; ++i2) {
                    if (typeof object2.links[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.trace.v1.Span.links: object expected");
                    message.links[i2] = $root.opentelemetry.proto.trace.v1.Span.Link.fromObject(object2.links[i2]);
                  }
                }
                if (object2.droppedLinksCount != null)
                  message.droppedLinksCount = object2.droppedLinksCount >>> 0;
                if (object2.status != null) {
                  if (typeof object2.status !== "object")
                    throw TypeError(".opentelemetry.proto.trace.v1.Span.status: object expected");
                  message.status = $root.opentelemetry.proto.trace.v1.Status.fromObject(object2.status);
                }
                return message;
              };
              Span2.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults) {
                  object2.attributes = [];
                  object2.events = [];
                  object2.links = [];
                }
                if (options.defaults) {
                  if (options.bytes === String)
                    object2.traceId = "";
                  else {
                    object2.traceId = [];
                    if (options.bytes !== Array)
                      object2.traceId = $util.newBuffer(object2.traceId);
                  }
                  if (options.bytes === String)
                    object2.spanId = "";
                  else {
                    object2.spanId = [];
                    if (options.bytes !== Array)
                      object2.spanId = $util.newBuffer(object2.spanId);
                  }
                  object2.traceState = "";
                  if (options.bytes === String)
                    object2.parentSpanId = "";
                  else {
                    object2.parentSpanId = [];
                    if (options.bytes !== Array)
                      object2.parentSpanId = $util.newBuffer(object2.parentSpanId);
                  }
                  object2.name = "";
                  object2.kind = options.enums === String ? "SPAN_KIND_UNSPECIFIED" : 0;
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object2.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object2.startTimeUnixNano = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object2.endTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object2.endTimeUnixNano = options.longs === String ? "0" : 0;
                  object2.droppedAttributesCount = 0;
                  object2.droppedEventsCount = 0;
                  object2.droppedLinksCount = 0;
                  object2.status = null;
                }
                if (message.traceId != null && message.hasOwnProperty("traceId"))
                  object2.traceId = options.bytes === String ? $util.base64.encode(message.traceId, 0, message.traceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.traceId) : message.traceId;
                if (message.spanId != null && message.hasOwnProperty("spanId"))
                  object2.spanId = options.bytes === String ? $util.base64.encode(message.spanId, 0, message.spanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spanId) : message.spanId;
                if (message.traceState != null && message.hasOwnProperty("traceState"))
                  object2.traceState = message.traceState;
                if (message.parentSpanId != null && message.hasOwnProperty("parentSpanId"))
                  object2.parentSpanId = options.bytes === String ? $util.base64.encode(message.parentSpanId, 0, message.parentSpanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.parentSpanId) : message.parentSpanId;
                if (message.name != null && message.hasOwnProperty("name"))
                  object2.name = message.name;
                if (message.kind != null && message.hasOwnProperty("kind"))
                  object2.kind = options.enums === String ? $root.opentelemetry.proto.trace.v1.Span.SpanKind[message.kind] === void 0 ? message.kind : $root.opentelemetry.proto.trace.v1.Span.SpanKind[message.kind] : message.kind;
                if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano"))
                  if (typeof message.startTimeUnixNano === "number")
                    object2.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;
                  else
                    object2.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;
                if (message.endTimeUnixNano != null && message.hasOwnProperty("endTimeUnixNano"))
                  if (typeof message.endTimeUnixNano === "number")
                    object2.endTimeUnixNano = options.longs === String ? String(message.endTimeUnixNano) : message.endTimeUnixNano;
                  else
                    object2.endTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.endTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.endTimeUnixNano.low >>> 0, message.endTimeUnixNano.high >>> 0).toNumber() : message.endTimeUnixNano;
                if (message.attributes && message.attributes.length) {
                  object2.attributes = [];
                  for (var j2 = 0; j2 < message.attributes.length; ++j2)
                    object2.attributes[j2] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j2], options);
                }
                if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount"))
                  object2.droppedAttributesCount = message.droppedAttributesCount;
                if (message.events && message.events.length) {
                  object2.events = [];
                  for (var j2 = 0; j2 < message.events.length; ++j2)
                    object2.events[j2] = $root.opentelemetry.proto.trace.v1.Span.Event.toObject(message.events[j2], options);
                }
                if (message.droppedEventsCount != null && message.hasOwnProperty("droppedEventsCount"))
                  object2.droppedEventsCount = message.droppedEventsCount;
                if (message.links && message.links.length) {
                  object2.links = [];
                  for (var j2 = 0; j2 < message.links.length; ++j2)
                    object2.links[j2] = $root.opentelemetry.proto.trace.v1.Span.Link.toObject(message.links[j2], options);
                }
                if (message.droppedLinksCount != null && message.hasOwnProperty("droppedLinksCount"))
                  object2.droppedLinksCount = message.droppedLinksCount;
                if (message.status != null && message.hasOwnProperty("status"))
                  object2.status = $root.opentelemetry.proto.trace.v1.Status.toObject(message.status, options);
                return object2;
              };
              Span2.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              Span2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.trace.v1.Span";
              };
              Span2.SpanKind = function() {
                var valuesById = {}, values3 = Object.create(valuesById);
                values3[valuesById[0] = "SPAN_KIND_UNSPECIFIED"] = 0;
                values3[valuesById[1] = "SPAN_KIND_INTERNAL"] = 1;
                values3[valuesById[2] = "SPAN_KIND_SERVER"] = 2;
                values3[valuesById[3] = "SPAN_KIND_CLIENT"] = 3;
                values3[valuesById[4] = "SPAN_KIND_PRODUCER"] = 4;
                values3[valuesById[5] = "SPAN_KIND_CONSUMER"] = 5;
                return values3;
              }();
              Span2.Event = function() {
                function Event(properties) {
                  this.attributes = [];
                  if (properties) {
                    for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                      if (properties[keys4[i2]] != null)
                        this[keys4[i2]] = properties[keys4[i2]];
                  }
                }
                Event.prototype.timeUnixNano = null;
                Event.prototype.name = null;
                Event.prototype.attributes = $util.emptyArray;
                Event.prototype.droppedAttributesCount = null;
                Event.create = function create2(properties) {
                  return new Event(properties);
                };
                Event.encode = function encode2(message, writer) {
                  if (!writer)
                    writer = $Writer.create();
                  if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano"))
                    writer.uint32(
                      /* id 1, wireType 1 =*/
                      9
                    ).fixed64(message.timeUnixNano);
                  if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(
                      /* id 2, wireType 2 =*/
                      18
                    ).string(message.name);
                  if (message.attributes != null && message.attributes.length)
                    for (var i2 = 0; i2 < message.attributes.length; ++i2)
                      $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i2], writer.uint32(
                        /* id 3, wireType 2 =*/
                        26
                      ).fork()).ldelim();
                  if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, "droppedAttributesCount"))
                    writer.uint32(
                      /* id 4, wireType 0 =*/
                      32
                    ).uint32(message.droppedAttributesCount);
                  return writer;
                };
                Event.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
                };
                Event.decode = function decode2(reader, length) {
                  if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                  var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.Span.Event();
                  while (reader.pos < end4) {
                    var tag2 = reader.uint32();
                    switch (tag2 >>> 3) {
                      case 1: {
                        message.timeUnixNano = reader.fixed64();
                        break;
                      }
                      case 2: {
                        message.name = reader.string();
                        break;
                      }
                      case 3: {
                        if (!(message.attributes && message.attributes.length))
                          message.attributes = [];
                        message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                        break;
                      }
                      case 4: {
                        message.droppedAttributesCount = reader.uint32();
                        break;
                      }
                      default:
                        reader.skipType(tag2 & 7);
                        break;
                    }
                  }
                  return message;
                };
                Event.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
                };
                Event.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                    return "object expected";
                  if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano")) {
                    if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
                      return "timeUnixNano: integer|Long expected";
                  }
                  if (message.name != null && message.hasOwnProperty("name")) {
                    if (!$util.isString(message.name))
                      return "name: string expected";
                  }
                  if (message.attributes != null && message.hasOwnProperty("attributes")) {
                    if (!Array.isArray(message.attributes))
                      return "attributes: array expected";
                    for (var i2 = 0; i2 < message.attributes.length; ++i2) {
                      var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i2]);
                      if (error)
                        return "attributes." + error;
                    }
                  }
                  if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount")) {
                    if (!$util.isInteger(message.droppedAttributesCount))
                      return "droppedAttributesCount: integer expected";
                  }
                  return null;
                };
                Event.fromObject = function fromObject(object2) {
                  if (object2 instanceof $root.opentelemetry.proto.trace.v1.Span.Event)
                    return object2;
                  var message = new $root.opentelemetry.proto.trace.v1.Span.Event();
                  if (object2.timeUnixNano != null) {
                    if ($util.Long)
                      (message.timeUnixNano = $util.Long.fromValue(object2.timeUnixNano)).unsigned = false;
                    else if (typeof object2.timeUnixNano === "string")
                      message.timeUnixNano = parseInt(object2.timeUnixNano, 10);
                    else if (typeof object2.timeUnixNano === "number")
                      message.timeUnixNano = object2.timeUnixNano;
                    else if (typeof object2.timeUnixNano === "object")
                      message.timeUnixNano = new $util.LongBits(object2.timeUnixNano.low >>> 0, object2.timeUnixNano.high >>> 0).toNumber();
                  }
                  if (object2.name != null)
                    message.name = String(object2.name);
                  if (object2.attributes) {
                    if (!Array.isArray(object2.attributes))
                      throw TypeError(".opentelemetry.proto.trace.v1.Span.Event.attributes: array expected");
                    message.attributes = [];
                    for (var i2 = 0; i2 < object2.attributes.length; ++i2) {
                      if (typeof object2.attributes[i2] !== "object")
                        throw TypeError(".opentelemetry.proto.trace.v1.Span.Event.attributes: object expected");
                      message.attributes[i2] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object2.attributes[i2]);
                    }
                  }
                  if (object2.droppedAttributesCount != null)
                    message.droppedAttributesCount = object2.droppedAttributesCount >>> 0;
                  return message;
                };
                Event.toObject = function toObject(message, options) {
                  if (!options)
                    options = {};
                  var object2 = {};
                  if (options.arrays || options.defaults)
                    object2.attributes = [];
                  if (options.defaults) {
                    if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object2.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                      object2.timeUnixNano = options.longs === String ? "0" : 0;
                    object2.name = "";
                    object2.droppedAttributesCount = 0;
                  }
                  if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
                    if (typeof message.timeUnixNano === "number")
                      object2.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;
                    else
                      object2.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;
                  if (message.name != null && message.hasOwnProperty("name"))
                    object2.name = message.name;
                  if (message.attributes && message.attributes.length) {
                    object2.attributes = [];
                    for (var j2 = 0; j2 < message.attributes.length; ++j2)
                      object2.attributes[j2] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j2], options);
                  }
                  if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount"))
                    object2.droppedAttributesCount = message.droppedAttributesCount;
                  return object2;
                };
                Event.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                Event.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/opentelemetry.proto.trace.v1.Span.Event";
                };
                return Event;
              }();
              Span2.Link = function() {
                function Link(properties) {
                  this.attributes = [];
                  if (properties) {
                    for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                      if (properties[keys4[i2]] != null)
                        this[keys4[i2]] = properties[keys4[i2]];
                  }
                }
                Link.prototype.traceId = null;
                Link.prototype.spanId = null;
                Link.prototype.traceState = null;
                Link.prototype.attributes = $util.emptyArray;
                Link.prototype.droppedAttributesCount = null;
                Link.create = function create2(properties) {
                  return new Link(properties);
                };
                Link.encode = function encode2(message, writer) {
                  if (!writer)
                    writer = $Writer.create();
                  if (message.traceId != null && Object.hasOwnProperty.call(message, "traceId"))
                    writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).bytes(message.traceId);
                  if (message.spanId != null && Object.hasOwnProperty.call(message, "spanId"))
                    writer.uint32(
                      /* id 2, wireType 2 =*/
                      18
                    ).bytes(message.spanId);
                  if (message.traceState != null && Object.hasOwnProperty.call(message, "traceState"))
                    writer.uint32(
                      /* id 3, wireType 2 =*/
                      26
                    ).string(message.traceState);
                  if (message.attributes != null && message.attributes.length)
                    for (var i2 = 0; i2 < message.attributes.length; ++i2)
                      $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i2], writer.uint32(
                        /* id 4, wireType 2 =*/
                        34
                      ).fork()).ldelim();
                  if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, "droppedAttributesCount"))
                    writer.uint32(
                      /* id 5, wireType 0 =*/
                      40
                    ).uint32(message.droppedAttributesCount);
                  return writer;
                };
                Link.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
                };
                Link.decode = function decode2(reader, length) {
                  if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                  var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.Span.Link();
                  while (reader.pos < end4) {
                    var tag2 = reader.uint32();
                    switch (tag2 >>> 3) {
                      case 1: {
                        message.traceId = reader.bytes();
                        break;
                      }
                      case 2: {
                        message.spanId = reader.bytes();
                        break;
                      }
                      case 3: {
                        message.traceState = reader.string();
                        break;
                      }
                      case 4: {
                        if (!(message.attributes && message.attributes.length))
                          message.attributes = [];
                        message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                        break;
                      }
                      case 5: {
                        message.droppedAttributesCount = reader.uint32();
                        break;
                      }
                      default:
                        reader.skipType(tag2 & 7);
                        break;
                    }
                  }
                  return message;
                };
                Link.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
                };
                Link.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                    return "object expected";
                  if (message.traceId != null && message.hasOwnProperty("traceId")) {
                    if (!(message.traceId && typeof message.traceId.length === "number" || $util.isString(message.traceId)))
                      return "traceId: buffer expected";
                  }
                  if (message.spanId != null && message.hasOwnProperty("spanId")) {
                    if (!(message.spanId && typeof message.spanId.length === "number" || $util.isString(message.spanId)))
                      return "spanId: buffer expected";
                  }
                  if (message.traceState != null && message.hasOwnProperty("traceState")) {
                    if (!$util.isString(message.traceState))
                      return "traceState: string expected";
                  }
                  if (message.attributes != null && message.hasOwnProperty("attributes")) {
                    if (!Array.isArray(message.attributes))
                      return "attributes: array expected";
                    for (var i2 = 0; i2 < message.attributes.length; ++i2) {
                      var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i2]);
                      if (error)
                        return "attributes." + error;
                    }
                  }
                  if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount")) {
                    if (!$util.isInteger(message.droppedAttributesCount))
                      return "droppedAttributesCount: integer expected";
                  }
                  return null;
                };
                Link.fromObject = function fromObject(object2) {
                  if (object2 instanceof $root.opentelemetry.proto.trace.v1.Span.Link)
                    return object2;
                  var message = new $root.opentelemetry.proto.trace.v1.Span.Link();
                  if (object2.traceId != null) {
                    if (typeof object2.traceId === "string")
                      $util.base64.decode(object2.traceId, message.traceId = $util.newBuffer($util.base64.length(object2.traceId)), 0);
                    else if (object2.traceId.length >= 0)
                      message.traceId = object2.traceId;
                  }
                  if (object2.spanId != null) {
                    if (typeof object2.spanId === "string")
                      $util.base64.decode(object2.spanId, message.spanId = $util.newBuffer($util.base64.length(object2.spanId)), 0);
                    else if (object2.spanId.length >= 0)
                      message.spanId = object2.spanId;
                  }
                  if (object2.traceState != null)
                    message.traceState = String(object2.traceState);
                  if (object2.attributes) {
                    if (!Array.isArray(object2.attributes))
                      throw TypeError(".opentelemetry.proto.trace.v1.Span.Link.attributes: array expected");
                    message.attributes = [];
                    for (var i2 = 0; i2 < object2.attributes.length; ++i2) {
                      if (typeof object2.attributes[i2] !== "object")
                        throw TypeError(".opentelemetry.proto.trace.v1.Span.Link.attributes: object expected");
                      message.attributes[i2] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object2.attributes[i2]);
                    }
                  }
                  if (object2.droppedAttributesCount != null)
                    message.droppedAttributesCount = object2.droppedAttributesCount >>> 0;
                  return message;
                };
                Link.toObject = function toObject(message, options) {
                  if (!options)
                    options = {};
                  var object2 = {};
                  if (options.arrays || options.defaults)
                    object2.attributes = [];
                  if (options.defaults) {
                    if (options.bytes === String)
                      object2.traceId = "";
                    else {
                      object2.traceId = [];
                      if (options.bytes !== Array)
                        object2.traceId = $util.newBuffer(object2.traceId);
                    }
                    if (options.bytes === String)
                      object2.spanId = "";
                    else {
                      object2.spanId = [];
                      if (options.bytes !== Array)
                        object2.spanId = $util.newBuffer(object2.spanId);
                    }
                    object2.traceState = "";
                    object2.droppedAttributesCount = 0;
                  }
                  if (message.traceId != null && message.hasOwnProperty("traceId"))
                    object2.traceId = options.bytes === String ? $util.base64.encode(message.traceId, 0, message.traceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.traceId) : message.traceId;
                  if (message.spanId != null && message.hasOwnProperty("spanId"))
                    object2.spanId = options.bytes === String ? $util.base64.encode(message.spanId, 0, message.spanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spanId) : message.spanId;
                  if (message.traceState != null && message.hasOwnProperty("traceState"))
                    object2.traceState = message.traceState;
                  if (message.attributes && message.attributes.length) {
                    object2.attributes = [];
                    for (var j2 = 0; j2 < message.attributes.length; ++j2)
                      object2.attributes[j2] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j2], options);
                  }
                  if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount"))
                    object2.droppedAttributesCount = message.droppedAttributesCount;
                  return object2;
                };
                Link.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                Link.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/opentelemetry.proto.trace.v1.Span.Link";
                };
                return Link;
              }();
              return Span2;
            }();
            v1.Status = function() {
              function Status(properties) {
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              Status.prototype.message = null;
              Status.prototype.code = null;
              Status.create = function create2(properties) {
                return new Status(properties);
              };
              Status.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                  writer.uint32(
                    /* id 2, wireType 2 =*/
                    18
                  ).string(message.message);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                  writer.uint32(
                    /* id 3, wireType 0 =*/
                    24
                  ).int32(message.code);
                return writer;
              };
              Status.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              Status.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.Status();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 2: {
                      message.message = reader.string();
                      break;
                    }
                    case 3: {
                      message.code = reader.int32();
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              Status.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              Status.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.message != null && message.hasOwnProperty("message")) {
                  if (!$util.isString(message.message))
                    return "message: string expected";
                }
                if (message.code != null && message.hasOwnProperty("code"))
                  switch (message.code) {
                    default:
                      return "code: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                      break;
                  }
                return null;
              };
              Status.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.trace.v1.Status)
                  return object2;
                var message = new $root.opentelemetry.proto.trace.v1.Status();
                if (object2.message != null)
                  message.message = String(object2.message);
                switch (object2.code) {
                  default:
                    if (typeof object2.code === "number") {
                      message.code = object2.code;
                      break;
                    }
                    break;
                  case "STATUS_CODE_UNSET":
                  case 0:
                    message.code = 0;
                    break;
                  case "STATUS_CODE_OK":
                  case 1:
                    message.code = 1;
                    break;
                  case "STATUS_CODE_ERROR":
                  case 2:
                    message.code = 2;
                    break;
                }
                return message;
              };
              Status.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.defaults) {
                  object2.message = "";
                  object2.code = options.enums === String ? "STATUS_CODE_UNSET" : 0;
                }
                if (message.message != null && message.hasOwnProperty("message"))
                  object2.message = message.message;
                if (message.code != null && message.hasOwnProperty("code"))
                  object2.code = options.enums === String ? $root.opentelemetry.proto.trace.v1.Status.StatusCode[message.code] === void 0 ? message.code : $root.opentelemetry.proto.trace.v1.Status.StatusCode[message.code] : message.code;
                return object2;
              };
              Status.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              Status.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.trace.v1.Status";
              };
              Status.StatusCode = function() {
                var valuesById = {}, values3 = Object.create(valuesById);
                values3[valuesById[0] = "STATUS_CODE_UNSET"] = 0;
                values3[valuesById[1] = "STATUS_CODE_OK"] = 1;
                values3[valuesById[2] = "STATUS_CODE_ERROR"] = 2;
                return values3;
              }();
              return Status;
            }();
            return v1;
          }();
          return trace3;
        }();
        proto.collector = function() {
          var collector = {};
          collector.trace = function() {
            var trace3 = {};
            trace3.v1 = function() {
              var v1 = {};
              v1.TraceService = function() {
                function TraceService(rpcImpl, requestDelimited, responseDelimited) {
                  $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
                (TraceService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = TraceService;
                TraceService.create = function create2(rpcImpl, requestDelimited, responseDelimited) {
                  return new this(rpcImpl, requestDelimited, responseDelimited);
                };
                Object.defineProperty(TraceService.prototype["export"] = function export_(request, callback) {
                  return this.rpcCall(export_, $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest, $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse, request, callback);
                }, "name", { value: "Export" });
                return TraceService;
              }();
              v1.ExportTraceServiceRequest = function() {
                function ExportTraceServiceRequest(properties) {
                  this.resourceSpans = [];
                  if (properties) {
                    for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                      if (properties[keys4[i2]] != null)
                        this[keys4[i2]] = properties[keys4[i2]];
                  }
                }
                ExportTraceServiceRequest.prototype.resourceSpans = $util.emptyArray;
                ExportTraceServiceRequest.create = function create2(properties) {
                  return new ExportTraceServiceRequest(properties);
                };
                ExportTraceServiceRequest.encode = function encode2(message, writer) {
                  if (!writer)
                    writer = $Writer.create();
                  if (message.resourceSpans != null && message.resourceSpans.length)
                    for (var i2 = 0; i2 < message.resourceSpans.length; ++i2)
                      $root.opentelemetry.proto.trace.v1.ResourceSpans.encode(message.resourceSpans[i2], writer.uint32(
                        /* id 1, wireType 2 =*/
                        10
                      ).fork()).ldelim();
                  return writer;
                };
                ExportTraceServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
                };
                ExportTraceServiceRequest.decode = function decode2(reader, length) {
                  if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                  var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest();
                  while (reader.pos < end4) {
                    var tag2 = reader.uint32();
                    switch (tag2 >>> 3) {
                      case 1: {
                        if (!(message.resourceSpans && message.resourceSpans.length))
                          message.resourceSpans = [];
                        message.resourceSpans.push($root.opentelemetry.proto.trace.v1.ResourceSpans.decode(reader, reader.uint32()));
                        break;
                      }
                      default:
                        reader.skipType(tag2 & 7);
                        break;
                    }
                  }
                  return message;
                };
                ExportTraceServiceRequest.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
                };
                ExportTraceServiceRequest.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                    return "object expected";
                  if (message.resourceSpans != null && message.hasOwnProperty("resourceSpans")) {
                    if (!Array.isArray(message.resourceSpans))
                      return "resourceSpans: array expected";
                    for (var i2 = 0; i2 < message.resourceSpans.length; ++i2) {
                      var error = $root.opentelemetry.proto.trace.v1.ResourceSpans.verify(message.resourceSpans[i2]);
                      if (error)
                        return "resourceSpans." + error;
                    }
                  }
                  return null;
                };
                ExportTraceServiceRequest.fromObject = function fromObject(object2) {
                  if (object2 instanceof $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest)
                    return object2;
                  var message = new $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest();
                  if (object2.resourceSpans) {
                    if (!Array.isArray(object2.resourceSpans))
                      throw TypeError(".opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest.resourceSpans: array expected");
                    message.resourceSpans = [];
                    for (var i2 = 0; i2 < object2.resourceSpans.length; ++i2) {
                      if (typeof object2.resourceSpans[i2] !== "object")
                        throw TypeError(".opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest.resourceSpans: object expected");
                      message.resourceSpans[i2] = $root.opentelemetry.proto.trace.v1.ResourceSpans.fromObject(object2.resourceSpans[i2]);
                    }
                  }
                  return message;
                };
                ExportTraceServiceRequest.toObject = function toObject(message, options) {
                  if (!options)
                    options = {};
                  var object2 = {};
                  if (options.arrays || options.defaults)
                    object2.resourceSpans = [];
                  if (message.resourceSpans && message.resourceSpans.length) {
                    object2.resourceSpans = [];
                    for (var j2 = 0; j2 < message.resourceSpans.length; ++j2)
                      object2.resourceSpans[j2] = $root.opentelemetry.proto.trace.v1.ResourceSpans.toObject(message.resourceSpans[j2], options);
                  }
                  return object2;
                };
                ExportTraceServiceRequest.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                ExportTraceServiceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest";
                };
                return ExportTraceServiceRequest;
              }();
              v1.ExportTraceServiceResponse = function() {
                function ExportTraceServiceResponse(properties) {
                  if (properties) {
                    for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                      if (properties[keys4[i2]] != null)
                        this[keys4[i2]] = properties[keys4[i2]];
                  }
                }
                ExportTraceServiceResponse.prototype.partialSuccess = null;
                ExportTraceServiceResponse.create = function create2(properties) {
                  return new ExportTraceServiceResponse(properties);
                };
                ExportTraceServiceResponse.encode = function encode2(message, writer) {
                  if (!writer)
                    writer = $Writer.create();
                  if (message.partialSuccess != null && Object.hasOwnProperty.call(message, "partialSuccess"))
                    $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.encode(message.partialSuccess, writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                  return writer;
                };
                ExportTraceServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
                };
                ExportTraceServiceResponse.decode = function decode2(reader, length) {
                  if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                  var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse();
                  while (reader.pos < end4) {
                    var tag2 = reader.uint32();
                    switch (tag2 >>> 3) {
                      case 1: {
                        message.partialSuccess = $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.decode(reader, reader.uint32());
                        break;
                      }
                      default:
                        reader.skipType(tag2 & 7);
                        break;
                    }
                  }
                  return message;
                };
                ExportTraceServiceResponse.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
                };
                ExportTraceServiceResponse.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                    return "object expected";
                  if (message.partialSuccess != null && message.hasOwnProperty("partialSuccess")) {
                    var error = $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.verify(message.partialSuccess);
                    if (error)
                      return "partialSuccess." + error;
                  }
                  return null;
                };
                ExportTraceServiceResponse.fromObject = function fromObject(object2) {
                  if (object2 instanceof $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse)
                    return object2;
                  var message = new $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse();
                  if (object2.partialSuccess != null) {
                    if (typeof object2.partialSuccess !== "object")
                      throw TypeError(".opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse.partialSuccess: object expected");
                    message.partialSuccess = $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.fromObject(object2.partialSuccess);
                  }
                  return message;
                };
                ExportTraceServiceResponse.toObject = function toObject(message, options) {
                  if (!options)
                    options = {};
                  var object2 = {};
                  if (options.defaults)
                    object2.partialSuccess = null;
                  if (message.partialSuccess != null && message.hasOwnProperty("partialSuccess"))
                    object2.partialSuccess = $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.toObject(message.partialSuccess, options);
                  return object2;
                };
                ExportTraceServiceResponse.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                ExportTraceServiceResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse";
                };
                return ExportTraceServiceResponse;
              }();
              v1.ExportTracePartialSuccess = function() {
                function ExportTracePartialSuccess(properties) {
                  if (properties) {
                    for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                      if (properties[keys4[i2]] != null)
                        this[keys4[i2]] = properties[keys4[i2]];
                  }
                }
                ExportTracePartialSuccess.prototype.rejectedSpans = null;
                ExportTracePartialSuccess.prototype.errorMessage = null;
                ExportTracePartialSuccess.create = function create2(properties) {
                  return new ExportTracePartialSuccess(properties);
                };
                ExportTracePartialSuccess.encode = function encode2(message, writer) {
                  if (!writer)
                    writer = $Writer.create();
                  if (message.rejectedSpans != null && Object.hasOwnProperty.call(message, "rejectedSpans"))
                    writer.uint32(
                      /* id 1, wireType 0 =*/
                      8
                    ).int64(message.rejectedSpans);
                  if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
                    writer.uint32(
                      /* id 2, wireType 2 =*/
                      18
                    ).string(message.errorMessage);
                  return writer;
                };
                ExportTracePartialSuccess.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
                };
                ExportTracePartialSuccess.decode = function decode2(reader, length) {
                  if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                  var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess();
                  while (reader.pos < end4) {
                    var tag2 = reader.uint32();
                    switch (tag2 >>> 3) {
                      case 1: {
                        message.rejectedSpans = reader.int64();
                        break;
                      }
                      case 2: {
                        message.errorMessage = reader.string();
                        break;
                      }
                      default:
                        reader.skipType(tag2 & 7);
                        break;
                    }
                  }
                  return message;
                };
                ExportTracePartialSuccess.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
                };
                ExportTracePartialSuccess.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                    return "object expected";
                  if (message.rejectedSpans != null && message.hasOwnProperty("rejectedSpans")) {
                    if (!$util.isInteger(message.rejectedSpans) && !(message.rejectedSpans && $util.isInteger(message.rejectedSpans.low) && $util.isInteger(message.rejectedSpans.high)))
                      return "rejectedSpans: integer|Long expected";
                  }
                  if (message.errorMessage != null && message.hasOwnProperty("errorMessage")) {
                    if (!$util.isString(message.errorMessage))
                      return "errorMessage: string expected";
                  }
                  return null;
                };
                ExportTracePartialSuccess.fromObject = function fromObject(object2) {
                  if (object2 instanceof $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess)
                    return object2;
                  var message = new $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess();
                  if (object2.rejectedSpans != null) {
                    if ($util.Long)
                      (message.rejectedSpans = $util.Long.fromValue(object2.rejectedSpans)).unsigned = false;
                    else if (typeof object2.rejectedSpans === "string")
                      message.rejectedSpans = parseInt(object2.rejectedSpans, 10);
                    else if (typeof object2.rejectedSpans === "number")
                      message.rejectedSpans = object2.rejectedSpans;
                    else if (typeof object2.rejectedSpans === "object")
                      message.rejectedSpans = new $util.LongBits(object2.rejectedSpans.low >>> 0, object2.rejectedSpans.high >>> 0).toNumber();
                  }
                  if (object2.errorMessage != null)
                    message.errorMessage = String(object2.errorMessage);
                  return message;
                };
                ExportTracePartialSuccess.toObject = function toObject(message, options) {
                  if (!options)
                    options = {};
                  var object2 = {};
                  if (options.defaults) {
                    if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object2.rejectedSpans = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                      object2.rejectedSpans = options.longs === String ? "0" : 0;
                    object2.errorMessage = "";
                  }
                  if (message.rejectedSpans != null && message.hasOwnProperty("rejectedSpans"))
                    if (typeof message.rejectedSpans === "number")
                      object2.rejectedSpans = options.longs === String ? String(message.rejectedSpans) : message.rejectedSpans;
                    else
                      object2.rejectedSpans = options.longs === String ? $util.Long.prototype.toString.call(message.rejectedSpans) : options.longs === Number ? new $util.LongBits(message.rejectedSpans.low >>> 0, message.rejectedSpans.high >>> 0).toNumber() : message.rejectedSpans;
                  if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                    object2.errorMessage = message.errorMessage;
                  return object2;
                };
                ExportTracePartialSuccess.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                ExportTracePartialSuccess.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess";
                };
                return ExportTracePartialSuccess;
              }();
              return v1;
            }();
            return trace3;
          }();
          collector.metrics = function() {
            var metrics2 = {};
            metrics2.v1 = function() {
              var v1 = {};
              v1.MetricsService = function() {
                function MetricsService(rpcImpl, requestDelimited, responseDelimited) {
                  $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
                (MetricsService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = MetricsService;
                MetricsService.create = function create2(rpcImpl, requestDelimited, responseDelimited) {
                  return new this(rpcImpl, requestDelimited, responseDelimited);
                };
                Object.defineProperty(MetricsService.prototype["export"] = function export_(request, callback) {
                  return this.rpcCall(export_, $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest, $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse, request, callback);
                }, "name", { value: "Export" });
                return MetricsService;
              }();
              v1.ExportMetricsServiceRequest = function() {
                function ExportMetricsServiceRequest(properties) {
                  this.resourceMetrics = [];
                  if (properties) {
                    for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                      if (properties[keys4[i2]] != null)
                        this[keys4[i2]] = properties[keys4[i2]];
                  }
                }
                ExportMetricsServiceRequest.prototype.resourceMetrics = $util.emptyArray;
                ExportMetricsServiceRequest.create = function create2(properties) {
                  return new ExportMetricsServiceRequest(properties);
                };
                ExportMetricsServiceRequest.encode = function encode2(message, writer) {
                  if (!writer)
                    writer = $Writer.create();
                  if (message.resourceMetrics != null && message.resourceMetrics.length)
                    for (var i2 = 0; i2 < message.resourceMetrics.length; ++i2)
                      $root.opentelemetry.proto.metrics.v1.ResourceMetrics.encode(message.resourceMetrics[i2], writer.uint32(
                        /* id 1, wireType 2 =*/
                        10
                      ).fork()).ldelim();
                  return writer;
                };
                ExportMetricsServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
                };
                ExportMetricsServiceRequest.decode = function decode2(reader, length) {
                  if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                  var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest();
                  while (reader.pos < end4) {
                    var tag2 = reader.uint32();
                    switch (tag2 >>> 3) {
                      case 1: {
                        if (!(message.resourceMetrics && message.resourceMetrics.length))
                          message.resourceMetrics = [];
                        message.resourceMetrics.push($root.opentelemetry.proto.metrics.v1.ResourceMetrics.decode(reader, reader.uint32()));
                        break;
                      }
                      default:
                        reader.skipType(tag2 & 7);
                        break;
                    }
                  }
                  return message;
                };
                ExportMetricsServiceRequest.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
                };
                ExportMetricsServiceRequest.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                    return "object expected";
                  if (message.resourceMetrics != null && message.hasOwnProperty("resourceMetrics")) {
                    if (!Array.isArray(message.resourceMetrics))
                      return "resourceMetrics: array expected";
                    for (var i2 = 0; i2 < message.resourceMetrics.length; ++i2) {
                      var error = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.verify(message.resourceMetrics[i2]);
                      if (error)
                        return "resourceMetrics." + error;
                    }
                  }
                  return null;
                };
                ExportMetricsServiceRequest.fromObject = function fromObject(object2) {
                  if (object2 instanceof $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest)
                    return object2;
                  var message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest();
                  if (object2.resourceMetrics) {
                    if (!Array.isArray(object2.resourceMetrics))
                      throw TypeError(".opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest.resourceMetrics: array expected");
                    message.resourceMetrics = [];
                    for (var i2 = 0; i2 < object2.resourceMetrics.length; ++i2) {
                      if (typeof object2.resourceMetrics[i2] !== "object")
                        throw TypeError(".opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest.resourceMetrics: object expected");
                      message.resourceMetrics[i2] = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.fromObject(object2.resourceMetrics[i2]);
                    }
                  }
                  return message;
                };
                ExportMetricsServiceRequest.toObject = function toObject(message, options) {
                  if (!options)
                    options = {};
                  var object2 = {};
                  if (options.arrays || options.defaults)
                    object2.resourceMetrics = [];
                  if (message.resourceMetrics && message.resourceMetrics.length) {
                    object2.resourceMetrics = [];
                    for (var j2 = 0; j2 < message.resourceMetrics.length; ++j2)
                      object2.resourceMetrics[j2] = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.toObject(message.resourceMetrics[j2], options);
                  }
                  return object2;
                };
                ExportMetricsServiceRequest.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                ExportMetricsServiceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest";
                };
                return ExportMetricsServiceRequest;
              }();
              v1.ExportMetricsServiceResponse = function() {
                function ExportMetricsServiceResponse(properties) {
                  if (properties) {
                    for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                      if (properties[keys4[i2]] != null)
                        this[keys4[i2]] = properties[keys4[i2]];
                  }
                }
                ExportMetricsServiceResponse.prototype.partialSuccess = null;
                ExportMetricsServiceResponse.create = function create2(properties) {
                  return new ExportMetricsServiceResponse(properties);
                };
                ExportMetricsServiceResponse.encode = function encode2(message, writer) {
                  if (!writer)
                    writer = $Writer.create();
                  if (message.partialSuccess != null && Object.hasOwnProperty.call(message, "partialSuccess"))
                    $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.encode(message.partialSuccess, writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                  return writer;
                };
                ExportMetricsServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
                };
                ExportMetricsServiceResponse.decode = function decode2(reader, length) {
                  if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                  var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse();
                  while (reader.pos < end4) {
                    var tag2 = reader.uint32();
                    switch (tag2 >>> 3) {
                      case 1: {
                        message.partialSuccess = $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.decode(reader, reader.uint32());
                        break;
                      }
                      default:
                        reader.skipType(tag2 & 7);
                        break;
                    }
                  }
                  return message;
                };
                ExportMetricsServiceResponse.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
                };
                ExportMetricsServiceResponse.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                    return "object expected";
                  if (message.partialSuccess != null && message.hasOwnProperty("partialSuccess")) {
                    var error = $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.verify(message.partialSuccess);
                    if (error)
                      return "partialSuccess." + error;
                  }
                  return null;
                };
                ExportMetricsServiceResponse.fromObject = function fromObject(object2) {
                  if (object2 instanceof $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse)
                    return object2;
                  var message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse();
                  if (object2.partialSuccess != null) {
                    if (typeof object2.partialSuccess !== "object")
                      throw TypeError(".opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse.partialSuccess: object expected");
                    message.partialSuccess = $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.fromObject(object2.partialSuccess);
                  }
                  return message;
                };
                ExportMetricsServiceResponse.toObject = function toObject(message, options) {
                  if (!options)
                    options = {};
                  var object2 = {};
                  if (options.defaults)
                    object2.partialSuccess = null;
                  if (message.partialSuccess != null && message.hasOwnProperty("partialSuccess"))
                    object2.partialSuccess = $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.toObject(message.partialSuccess, options);
                  return object2;
                };
                ExportMetricsServiceResponse.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                ExportMetricsServiceResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse";
                };
                return ExportMetricsServiceResponse;
              }();
              v1.ExportMetricsPartialSuccess = function() {
                function ExportMetricsPartialSuccess(properties) {
                  if (properties) {
                    for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                      if (properties[keys4[i2]] != null)
                        this[keys4[i2]] = properties[keys4[i2]];
                  }
                }
                ExportMetricsPartialSuccess.prototype.rejectedDataPoints = null;
                ExportMetricsPartialSuccess.prototype.errorMessage = null;
                ExportMetricsPartialSuccess.create = function create2(properties) {
                  return new ExportMetricsPartialSuccess(properties);
                };
                ExportMetricsPartialSuccess.encode = function encode2(message, writer) {
                  if (!writer)
                    writer = $Writer.create();
                  if (message.rejectedDataPoints != null && Object.hasOwnProperty.call(message, "rejectedDataPoints"))
                    writer.uint32(
                      /* id 1, wireType 0 =*/
                      8
                    ).int64(message.rejectedDataPoints);
                  if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
                    writer.uint32(
                      /* id 2, wireType 2 =*/
                      18
                    ).string(message.errorMessage);
                  return writer;
                };
                ExportMetricsPartialSuccess.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
                };
                ExportMetricsPartialSuccess.decode = function decode2(reader, length) {
                  if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                  var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess();
                  while (reader.pos < end4) {
                    var tag2 = reader.uint32();
                    switch (tag2 >>> 3) {
                      case 1: {
                        message.rejectedDataPoints = reader.int64();
                        break;
                      }
                      case 2: {
                        message.errorMessage = reader.string();
                        break;
                      }
                      default:
                        reader.skipType(tag2 & 7);
                        break;
                    }
                  }
                  return message;
                };
                ExportMetricsPartialSuccess.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
                };
                ExportMetricsPartialSuccess.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                    return "object expected";
                  if (message.rejectedDataPoints != null && message.hasOwnProperty("rejectedDataPoints")) {
                    if (!$util.isInteger(message.rejectedDataPoints) && !(message.rejectedDataPoints && $util.isInteger(message.rejectedDataPoints.low) && $util.isInteger(message.rejectedDataPoints.high)))
                      return "rejectedDataPoints: integer|Long expected";
                  }
                  if (message.errorMessage != null && message.hasOwnProperty("errorMessage")) {
                    if (!$util.isString(message.errorMessage))
                      return "errorMessage: string expected";
                  }
                  return null;
                };
                ExportMetricsPartialSuccess.fromObject = function fromObject(object2) {
                  if (object2 instanceof $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess)
                    return object2;
                  var message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess();
                  if (object2.rejectedDataPoints != null) {
                    if ($util.Long)
                      (message.rejectedDataPoints = $util.Long.fromValue(object2.rejectedDataPoints)).unsigned = false;
                    else if (typeof object2.rejectedDataPoints === "string")
                      message.rejectedDataPoints = parseInt(object2.rejectedDataPoints, 10);
                    else if (typeof object2.rejectedDataPoints === "number")
                      message.rejectedDataPoints = object2.rejectedDataPoints;
                    else if (typeof object2.rejectedDataPoints === "object")
                      message.rejectedDataPoints = new $util.LongBits(object2.rejectedDataPoints.low >>> 0, object2.rejectedDataPoints.high >>> 0).toNumber();
                  }
                  if (object2.errorMessage != null)
                    message.errorMessage = String(object2.errorMessage);
                  return message;
                };
                ExportMetricsPartialSuccess.toObject = function toObject(message, options) {
                  if (!options)
                    options = {};
                  var object2 = {};
                  if (options.defaults) {
                    if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object2.rejectedDataPoints = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                      object2.rejectedDataPoints = options.longs === String ? "0" : 0;
                    object2.errorMessage = "";
                  }
                  if (message.rejectedDataPoints != null && message.hasOwnProperty("rejectedDataPoints"))
                    if (typeof message.rejectedDataPoints === "number")
                      object2.rejectedDataPoints = options.longs === String ? String(message.rejectedDataPoints) : message.rejectedDataPoints;
                    else
                      object2.rejectedDataPoints = options.longs === String ? $util.Long.prototype.toString.call(message.rejectedDataPoints) : options.longs === Number ? new $util.LongBits(message.rejectedDataPoints.low >>> 0, message.rejectedDataPoints.high >>> 0).toNumber() : message.rejectedDataPoints;
                  if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                    object2.errorMessage = message.errorMessage;
                  return object2;
                };
                ExportMetricsPartialSuccess.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                ExportMetricsPartialSuccess.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess";
                };
                return ExportMetricsPartialSuccess;
              }();
              return v1;
            }();
            return metrics2;
          }();
          collector.logs = function() {
            var logs = {};
            logs.v1 = function() {
              var v1 = {};
              v1.LogsService = function() {
                function LogsService(rpcImpl, requestDelimited, responseDelimited) {
                  $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
                (LogsService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = LogsService;
                LogsService.create = function create2(rpcImpl, requestDelimited, responseDelimited) {
                  return new this(rpcImpl, requestDelimited, responseDelimited);
                };
                Object.defineProperty(LogsService.prototype["export"] = function export_(request, callback) {
                  return this.rpcCall(export_, $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest, $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse, request, callback);
                }, "name", { value: "Export" });
                return LogsService;
              }();
              v1.ExportLogsServiceRequest = function() {
                function ExportLogsServiceRequest(properties) {
                  this.resourceLogs = [];
                  if (properties) {
                    for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                      if (properties[keys4[i2]] != null)
                        this[keys4[i2]] = properties[keys4[i2]];
                  }
                }
                ExportLogsServiceRequest.prototype.resourceLogs = $util.emptyArray;
                ExportLogsServiceRequest.create = function create2(properties) {
                  return new ExportLogsServiceRequest(properties);
                };
                ExportLogsServiceRequest.encode = function encode2(message, writer) {
                  if (!writer)
                    writer = $Writer.create();
                  if (message.resourceLogs != null && message.resourceLogs.length)
                    for (var i2 = 0; i2 < message.resourceLogs.length; ++i2)
                      $root.opentelemetry.proto.logs.v1.ResourceLogs.encode(message.resourceLogs[i2], writer.uint32(
                        /* id 1, wireType 2 =*/
                        10
                      ).fork()).ldelim();
                  return writer;
                };
                ExportLogsServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
                };
                ExportLogsServiceRequest.decode = function decode2(reader, length) {
                  if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                  var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest();
                  while (reader.pos < end4) {
                    var tag2 = reader.uint32();
                    switch (tag2 >>> 3) {
                      case 1: {
                        if (!(message.resourceLogs && message.resourceLogs.length))
                          message.resourceLogs = [];
                        message.resourceLogs.push($root.opentelemetry.proto.logs.v1.ResourceLogs.decode(reader, reader.uint32()));
                        break;
                      }
                      default:
                        reader.skipType(tag2 & 7);
                        break;
                    }
                  }
                  return message;
                };
                ExportLogsServiceRequest.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
                };
                ExportLogsServiceRequest.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                    return "object expected";
                  if (message.resourceLogs != null && message.hasOwnProperty("resourceLogs")) {
                    if (!Array.isArray(message.resourceLogs))
                      return "resourceLogs: array expected";
                    for (var i2 = 0; i2 < message.resourceLogs.length; ++i2) {
                      var error = $root.opentelemetry.proto.logs.v1.ResourceLogs.verify(message.resourceLogs[i2]);
                      if (error)
                        return "resourceLogs." + error;
                    }
                  }
                  return null;
                };
                ExportLogsServiceRequest.fromObject = function fromObject(object2) {
                  if (object2 instanceof $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest)
                    return object2;
                  var message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest();
                  if (object2.resourceLogs) {
                    if (!Array.isArray(object2.resourceLogs))
                      throw TypeError(".opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest.resourceLogs: array expected");
                    message.resourceLogs = [];
                    for (var i2 = 0; i2 < object2.resourceLogs.length; ++i2) {
                      if (typeof object2.resourceLogs[i2] !== "object")
                        throw TypeError(".opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest.resourceLogs: object expected");
                      message.resourceLogs[i2] = $root.opentelemetry.proto.logs.v1.ResourceLogs.fromObject(object2.resourceLogs[i2]);
                    }
                  }
                  return message;
                };
                ExportLogsServiceRequest.toObject = function toObject(message, options) {
                  if (!options)
                    options = {};
                  var object2 = {};
                  if (options.arrays || options.defaults)
                    object2.resourceLogs = [];
                  if (message.resourceLogs && message.resourceLogs.length) {
                    object2.resourceLogs = [];
                    for (var j2 = 0; j2 < message.resourceLogs.length; ++j2)
                      object2.resourceLogs[j2] = $root.opentelemetry.proto.logs.v1.ResourceLogs.toObject(message.resourceLogs[j2], options);
                  }
                  return object2;
                };
                ExportLogsServiceRequest.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                ExportLogsServiceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest";
                };
                return ExportLogsServiceRequest;
              }();
              v1.ExportLogsServiceResponse = function() {
                function ExportLogsServiceResponse(properties) {
                  if (properties) {
                    for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                      if (properties[keys4[i2]] != null)
                        this[keys4[i2]] = properties[keys4[i2]];
                  }
                }
                ExportLogsServiceResponse.prototype.partialSuccess = null;
                ExportLogsServiceResponse.create = function create2(properties) {
                  return new ExportLogsServiceResponse(properties);
                };
                ExportLogsServiceResponse.encode = function encode2(message, writer) {
                  if (!writer)
                    writer = $Writer.create();
                  if (message.partialSuccess != null && Object.hasOwnProperty.call(message, "partialSuccess"))
                    $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.encode(message.partialSuccess, writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                  return writer;
                };
                ExportLogsServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
                };
                ExportLogsServiceResponse.decode = function decode2(reader, length) {
                  if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                  var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse();
                  while (reader.pos < end4) {
                    var tag2 = reader.uint32();
                    switch (tag2 >>> 3) {
                      case 1: {
                        message.partialSuccess = $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.decode(reader, reader.uint32());
                        break;
                      }
                      default:
                        reader.skipType(tag2 & 7);
                        break;
                    }
                  }
                  return message;
                };
                ExportLogsServiceResponse.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
                };
                ExportLogsServiceResponse.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                    return "object expected";
                  if (message.partialSuccess != null && message.hasOwnProperty("partialSuccess")) {
                    var error = $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.verify(message.partialSuccess);
                    if (error)
                      return "partialSuccess." + error;
                  }
                  return null;
                };
                ExportLogsServiceResponse.fromObject = function fromObject(object2) {
                  if (object2 instanceof $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse)
                    return object2;
                  var message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse();
                  if (object2.partialSuccess != null) {
                    if (typeof object2.partialSuccess !== "object")
                      throw TypeError(".opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse.partialSuccess: object expected");
                    message.partialSuccess = $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.fromObject(object2.partialSuccess);
                  }
                  return message;
                };
                ExportLogsServiceResponse.toObject = function toObject(message, options) {
                  if (!options)
                    options = {};
                  var object2 = {};
                  if (options.defaults)
                    object2.partialSuccess = null;
                  if (message.partialSuccess != null && message.hasOwnProperty("partialSuccess"))
                    object2.partialSuccess = $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.toObject(message.partialSuccess, options);
                  return object2;
                };
                ExportLogsServiceResponse.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                ExportLogsServiceResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse";
                };
                return ExportLogsServiceResponse;
              }();
              v1.ExportLogsPartialSuccess = function() {
                function ExportLogsPartialSuccess(properties) {
                  if (properties) {
                    for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                      if (properties[keys4[i2]] != null)
                        this[keys4[i2]] = properties[keys4[i2]];
                  }
                }
                ExportLogsPartialSuccess.prototype.rejectedLogRecords = null;
                ExportLogsPartialSuccess.prototype.errorMessage = null;
                ExportLogsPartialSuccess.create = function create2(properties) {
                  return new ExportLogsPartialSuccess(properties);
                };
                ExportLogsPartialSuccess.encode = function encode2(message, writer) {
                  if (!writer)
                    writer = $Writer.create();
                  if (message.rejectedLogRecords != null && Object.hasOwnProperty.call(message, "rejectedLogRecords"))
                    writer.uint32(
                      /* id 1, wireType 0 =*/
                      8
                    ).int64(message.rejectedLogRecords);
                  if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
                    writer.uint32(
                      /* id 2, wireType 2 =*/
                      18
                    ).string(message.errorMessage);
                  return writer;
                };
                ExportLogsPartialSuccess.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
                };
                ExportLogsPartialSuccess.decode = function decode2(reader, length) {
                  if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                  var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess();
                  while (reader.pos < end4) {
                    var tag2 = reader.uint32();
                    switch (tag2 >>> 3) {
                      case 1: {
                        message.rejectedLogRecords = reader.int64();
                        break;
                      }
                      case 2: {
                        message.errorMessage = reader.string();
                        break;
                      }
                      default:
                        reader.skipType(tag2 & 7);
                        break;
                    }
                  }
                  return message;
                };
                ExportLogsPartialSuccess.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
                };
                ExportLogsPartialSuccess.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                    return "object expected";
                  if (message.rejectedLogRecords != null && message.hasOwnProperty("rejectedLogRecords")) {
                    if (!$util.isInteger(message.rejectedLogRecords) && !(message.rejectedLogRecords && $util.isInteger(message.rejectedLogRecords.low) && $util.isInteger(message.rejectedLogRecords.high)))
                      return "rejectedLogRecords: integer|Long expected";
                  }
                  if (message.errorMessage != null && message.hasOwnProperty("errorMessage")) {
                    if (!$util.isString(message.errorMessage))
                      return "errorMessage: string expected";
                  }
                  return null;
                };
                ExportLogsPartialSuccess.fromObject = function fromObject(object2) {
                  if (object2 instanceof $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess)
                    return object2;
                  var message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess();
                  if (object2.rejectedLogRecords != null) {
                    if ($util.Long)
                      (message.rejectedLogRecords = $util.Long.fromValue(object2.rejectedLogRecords)).unsigned = false;
                    else if (typeof object2.rejectedLogRecords === "string")
                      message.rejectedLogRecords = parseInt(object2.rejectedLogRecords, 10);
                    else if (typeof object2.rejectedLogRecords === "number")
                      message.rejectedLogRecords = object2.rejectedLogRecords;
                    else if (typeof object2.rejectedLogRecords === "object")
                      message.rejectedLogRecords = new $util.LongBits(object2.rejectedLogRecords.low >>> 0, object2.rejectedLogRecords.high >>> 0).toNumber();
                  }
                  if (object2.errorMessage != null)
                    message.errorMessage = String(object2.errorMessage);
                  return message;
                };
                ExportLogsPartialSuccess.toObject = function toObject(message, options) {
                  if (!options)
                    options = {};
                  var object2 = {};
                  if (options.defaults) {
                    if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object2.rejectedLogRecords = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                      object2.rejectedLogRecords = options.longs === String ? "0" : 0;
                    object2.errorMessage = "";
                  }
                  if (message.rejectedLogRecords != null && message.hasOwnProperty("rejectedLogRecords"))
                    if (typeof message.rejectedLogRecords === "number")
                      object2.rejectedLogRecords = options.longs === String ? String(message.rejectedLogRecords) : message.rejectedLogRecords;
                    else
                      object2.rejectedLogRecords = options.longs === String ? $util.Long.prototype.toString.call(message.rejectedLogRecords) : options.longs === Number ? new $util.LongBits(message.rejectedLogRecords.low >>> 0, message.rejectedLogRecords.high >>> 0).toNumber() : message.rejectedLogRecords;
                  if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                    object2.errorMessage = message.errorMessage;
                  return object2;
                };
                ExportLogsPartialSuccess.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                ExportLogsPartialSuccess.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess";
                };
                return ExportLogsPartialSuccess;
              }();
              return v1;
            }();
            return logs;
          }();
          return collector;
        }();
        proto.metrics = function() {
          var metrics2 = {};
          metrics2.v1 = function() {
            var v1 = {};
            v1.MetricsData = function() {
              function MetricsData(properties) {
                this.resourceMetrics = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              MetricsData.prototype.resourceMetrics = $util.emptyArray;
              MetricsData.create = function create2(properties) {
                return new MetricsData(properties);
              };
              MetricsData.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.resourceMetrics != null && message.resourceMetrics.length)
                  for (var i2 = 0; i2 < message.resourceMetrics.length; ++i2)
                    $root.opentelemetry.proto.metrics.v1.ResourceMetrics.encode(message.resourceMetrics[i2], writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                return writer;
              };
              MetricsData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              MetricsData.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.MetricsData();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 1: {
                      if (!(message.resourceMetrics && message.resourceMetrics.length))
                        message.resourceMetrics = [];
                      message.resourceMetrics.push($root.opentelemetry.proto.metrics.v1.ResourceMetrics.decode(reader, reader.uint32()));
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              MetricsData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              MetricsData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.resourceMetrics != null && message.hasOwnProperty("resourceMetrics")) {
                  if (!Array.isArray(message.resourceMetrics))
                    return "resourceMetrics: array expected";
                  for (var i2 = 0; i2 < message.resourceMetrics.length; ++i2) {
                    var error = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.verify(message.resourceMetrics[i2]);
                    if (error)
                      return "resourceMetrics." + error;
                  }
                }
                return null;
              };
              MetricsData.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.metrics.v1.MetricsData)
                  return object2;
                var message = new $root.opentelemetry.proto.metrics.v1.MetricsData();
                if (object2.resourceMetrics) {
                  if (!Array.isArray(object2.resourceMetrics))
                    throw TypeError(".opentelemetry.proto.metrics.v1.MetricsData.resourceMetrics: array expected");
                  message.resourceMetrics = [];
                  for (var i2 = 0; i2 < object2.resourceMetrics.length; ++i2) {
                    if (typeof object2.resourceMetrics[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.MetricsData.resourceMetrics: object expected");
                    message.resourceMetrics[i2] = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.fromObject(object2.resourceMetrics[i2]);
                  }
                }
                return message;
              };
              MetricsData.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults)
                  object2.resourceMetrics = [];
                if (message.resourceMetrics && message.resourceMetrics.length) {
                  object2.resourceMetrics = [];
                  for (var j2 = 0; j2 < message.resourceMetrics.length; ++j2)
                    object2.resourceMetrics[j2] = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.toObject(message.resourceMetrics[j2], options);
                }
                return object2;
              };
              MetricsData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              MetricsData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.MetricsData";
              };
              return MetricsData;
            }();
            v1.ResourceMetrics = function() {
              function ResourceMetrics(properties) {
                this.scopeMetrics = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              ResourceMetrics.prototype.resource = null;
              ResourceMetrics.prototype.scopeMetrics = $util.emptyArray;
              ResourceMetrics.prototype.schemaUrl = null;
              ResourceMetrics.create = function create2(properties) {
                return new ResourceMetrics(properties);
              };
              ResourceMetrics.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.resource != null && Object.hasOwnProperty.call(message, "resource"))
                  $root.opentelemetry.proto.resource.v1.Resource.encode(message.resource, writer.uint32(
                    /* id 1, wireType 2 =*/
                    10
                  ).fork()).ldelim();
                if (message.scopeMetrics != null && message.scopeMetrics.length)
                  for (var i2 = 0; i2 < message.scopeMetrics.length; ++i2)
                    $root.opentelemetry.proto.metrics.v1.ScopeMetrics.encode(message.scopeMetrics[i2], writer.uint32(
                      /* id 2, wireType 2 =*/
                      18
                    ).fork()).ldelim();
                if (message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl"))
                  writer.uint32(
                    /* id 3, wireType 2 =*/
                    26
                  ).string(message.schemaUrl);
                return writer;
              };
              ResourceMetrics.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              ResourceMetrics.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ResourceMetrics();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 1: {
                      message.resource = $root.opentelemetry.proto.resource.v1.Resource.decode(reader, reader.uint32());
                      break;
                    }
                    case 2: {
                      if (!(message.scopeMetrics && message.scopeMetrics.length))
                        message.scopeMetrics = [];
                      message.scopeMetrics.push($root.opentelemetry.proto.metrics.v1.ScopeMetrics.decode(reader, reader.uint32()));
                      break;
                    }
                    case 3: {
                      message.schemaUrl = reader.string();
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              ResourceMetrics.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              ResourceMetrics.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.resource != null && message.hasOwnProperty("resource")) {
                  var error = $root.opentelemetry.proto.resource.v1.Resource.verify(message.resource);
                  if (error)
                    return "resource." + error;
                }
                if (message.scopeMetrics != null && message.hasOwnProperty("scopeMetrics")) {
                  if (!Array.isArray(message.scopeMetrics))
                    return "scopeMetrics: array expected";
                  for (var i2 = 0; i2 < message.scopeMetrics.length; ++i2) {
                    var error = $root.opentelemetry.proto.metrics.v1.ScopeMetrics.verify(message.scopeMetrics[i2]);
                    if (error)
                      return "scopeMetrics." + error;
                  }
                }
                if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl")) {
                  if (!$util.isString(message.schemaUrl))
                    return "schemaUrl: string expected";
                }
                return null;
              };
              ResourceMetrics.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.metrics.v1.ResourceMetrics)
                  return object2;
                var message = new $root.opentelemetry.proto.metrics.v1.ResourceMetrics();
                if (object2.resource != null) {
                  if (typeof object2.resource !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.ResourceMetrics.resource: object expected");
                  message.resource = $root.opentelemetry.proto.resource.v1.Resource.fromObject(object2.resource);
                }
                if (object2.scopeMetrics) {
                  if (!Array.isArray(object2.scopeMetrics))
                    throw TypeError(".opentelemetry.proto.metrics.v1.ResourceMetrics.scopeMetrics: array expected");
                  message.scopeMetrics = [];
                  for (var i2 = 0; i2 < object2.scopeMetrics.length; ++i2) {
                    if (typeof object2.scopeMetrics[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.ResourceMetrics.scopeMetrics: object expected");
                    message.scopeMetrics[i2] = $root.opentelemetry.proto.metrics.v1.ScopeMetrics.fromObject(object2.scopeMetrics[i2]);
                  }
                }
                if (object2.schemaUrl != null)
                  message.schemaUrl = String(object2.schemaUrl);
                return message;
              };
              ResourceMetrics.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults)
                  object2.scopeMetrics = [];
                if (options.defaults) {
                  object2.resource = null;
                  object2.schemaUrl = "";
                }
                if (message.resource != null && message.hasOwnProperty("resource"))
                  object2.resource = $root.opentelemetry.proto.resource.v1.Resource.toObject(message.resource, options);
                if (message.scopeMetrics && message.scopeMetrics.length) {
                  object2.scopeMetrics = [];
                  for (var j2 = 0; j2 < message.scopeMetrics.length; ++j2)
                    object2.scopeMetrics[j2] = $root.opentelemetry.proto.metrics.v1.ScopeMetrics.toObject(message.scopeMetrics[j2], options);
                }
                if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
                  object2.schemaUrl = message.schemaUrl;
                return object2;
              };
              ResourceMetrics.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              ResourceMetrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.ResourceMetrics";
              };
              return ResourceMetrics;
            }();
            v1.ScopeMetrics = function() {
              function ScopeMetrics(properties) {
                this.metrics = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              ScopeMetrics.prototype.scope = null;
              ScopeMetrics.prototype.metrics = $util.emptyArray;
              ScopeMetrics.prototype.schemaUrl = null;
              ScopeMetrics.create = function create2(properties) {
                return new ScopeMetrics(properties);
              };
              ScopeMetrics.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.scope != null && Object.hasOwnProperty.call(message, "scope"))
                  $root.opentelemetry.proto.common.v1.InstrumentationScope.encode(message.scope, writer.uint32(
                    /* id 1, wireType 2 =*/
                    10
                  ).fork()).ldelim();
                if (message.metrics != null && message.metrics.length)
                  for (var i2 = 0; i2 < message.metrics.length; ++i2)
                    $root.opentelemetry.proto.metrics.v1.Metric.encode(message.metrics[i2], writer.uint32(
                      /* id 2, wireType 2 =*/
                      18
                    ).fork()).ldelim();
                if (message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl"))
                  writer.uint32(
                    /* id 3, wireType 2 =*/
                    26
                  ).string(message.schemaUrl);
                return writer;
              };
              ScopeMetrics.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              ScopeMetrics.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ScopeMetrics();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 1: {
                      message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.decode(reader, reader.uint32());
                      break;
                    }
                    case 2: {
                      if (!(message.metrics && message.metrics.length))
                        message.metrics = [];
                      message.metrics.push($root.opentelemetry.proto.metrics.v1.Metric.decode(reader, reader.uint32()));
                      break;
                    }
                    case 3: {
                      message.schemaUrl = reader.string();
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              ScopeMetrics.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              ScopeMetrics.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.scope != null && message.hasOwnProperty("scope")) {
                  var error = $root.opentelemetry.proto.common.v1.InstrumentationScope.verify(message.scope);
                  if (error)
                    return "scope." + error;
                }
                if (message.metrics != null && message.hasOwnProperty("metrics")) {
                  if (!Array.isArray(message.metrics))
                    return "metrics: array expected";
                  for (var i2 = 0; i2 < message.metrics.length; ++i2) {
                    var error = $root.opentelemetry.proto.metrics.v1.Metric.verify(message.metrics[i2]);
                    if (error)
                      return "metrics." + error;
                  }
                }
                if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl")) {
                  if (!$util.isString(message.schemaUrl))
                    return "schemaUrl: string expected";
                }
                return null;
              };
              ScopeMetrics.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.metrics.v1.ScopeMetrics)
                  return object2;
                var message = new $root.opentelemetry.proto.metrics.v1.ScopeMetrics();
                if (object2.scope != null) {
                  if (typeof object2.scope !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.ScopeMetrics.scope: object expected");
                  message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.fromObject(object2.scope);
                }
                if (object2.metrics) {
                  if (!Array.isArray(object2.metrics))
                    throw TypeError(".opentelemetry.proto.metrics.v1.ScopeMetrics.metrics: array expected");
                  message.metrics = [];
                  for (var i2 = 0; i2 < object2.metrics.length; ++i2) {
                    if (typeof object2.metrics[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.ScopeMetrics.metrics: object expected");
                    message.metrics[i2] = $root.opentelemetry.proto.metrics.v1.Metric.fromObject(object2.metrics[i2]);
                  }
                }
                if (object2.schemaUrl != null)
                  message.schemaUrl = String(object2.schemaUrl);
                return message;
              };
              ScopeMetrics.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults)
                  object2.metrics = [];
                if (options.defaults) {
                  object2.scope = null;
                  object2.schemaUrl = "";
                }
                if (message.scope != null && message.hasOwnProperty("scope"))
                  object2.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.toObject(message.scope, options);
                if (message.metrics && message.metrics.length) {
                  object2.metrics = [];
                  for (var j2 = 0; j2 < message.metrics.length; ++j2)
                    object2.metrics[j2] = $root.opentelemetry.proto.metrics.v1.Metric.toObject(message.metrics[j2], options);
                }
                if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
                  object2.schemaUrl = message.schemaUrl;
                return object2;
              };
              ScopeMetrics.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              ScopeMetrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.ScopeMetrics";
              };
              return ScopeMetrics;
            }();
            v1.Metric = function() {
              function Metric(properties) {
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              Metric.prototype.name = null;
              Metric.prototype.description = null;
              Metric.prototype.unit = null;
              Metric.prototype.gauge = null;
              Metric.prototype.sum = null;
              Metric.prototype.histogram = null;
              Metric.prototype.exponentialHistogram = null;
              Metric.prototype.summary = null;
              var $oneOfFields;
              Object.defineProperty(Metric.prototype, "data", {
                get: $util.oneOfGetter($oneOfFields = ["gauge", "sum", "histogram", "exponentialHistogram", "summary"]),
                set: $util.oneOfSetter($oneOfFields)
              });
              Metric.create = function create2(properties) {
                return new Metric(properties);
              };
              Metric.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                  writer.uint32(
                    /* id 1, wireType 2 =*/
                    10
                  ).string(message.name);
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                  writer.uint32(
                    /* id 2, wireType 2 =*/
                    18
                  ).string(message.description);
                if (message.unit != null && Object.hasOwnProperty.call(message, "unit"))
                  writer.uint32(
                    /* id 3, wireType 2 =*/
                    26
                  ).string(message.unit);
                if (message.gauge != null && Object.hasOwnProperty.call(message, "gauge"))
                  $root.opentelemetry.proto.metrics.v1.Gauge.encode(message.gauge, writer.uint32(
                    /* id 5, wireType 2 =*/
                    42
                  ).fork()).ldelim();
                if (message.sum != null && Object.hasOwnProperty.call(message, "sum"))
                  $root.opentelemetry.proto.metrics.v1.Sum.encode(message.sum, writer.uint32(
                    /* id 7, wireType 2 =*/
                    58
                  ).fork()).ldelim();
                if (message.histogram != null && Object.hasOwnProperty.call(message, "histogram"))
                  $root.opentelemetry.proto.metrics.v1.Histogram.encode(message.histogram, writer.uint32(
                    /* id 9, wireType 2 =*/
                    74
                  ).fork()).ldelim();
                if (message.exponentialHistogram != null && Object.hasOwnProperty.call(message, "exponentialHistogram"))
                  $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.encode(message.exponentialHistogram, writer.uint32(
                    /* id 10, wireType 2 =*/
                    82
                  ).fork()).ldelim();
                if (message.summary != null && Object.hasOwnProperty.call(message, "summary"))
                  $root.opentelemetry.proto.metrics.v1.Summary.encode(message.summary, writer.uint32(
                    /* id 11, wireType 2 =*/
                    90
                  ).fork()).ldelim();
                return writer;
              };
              Metric.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              Metric.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Metric();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 1: {
                      message.name = reader.string();
                      break;
                    }
                    case 2: {
                      message.description = reader.string();
                      break;
                    }
                    case 3: {
                      message.unit = reader.string();
                      break;
                    }
                    case 5: {
                      message.gauge = $root.opentelemetry.proto.metrics.v1.Gauge.decode(reader, reader.uint32());
                      break;
                    }
                    case 7: {
                      message.sum = $root.opentelemetry.proto.metrics.v1.Sum.decode(reader, reader.uint32());
                      break;
                    }
                    case 9: {
                      message.histogram = $root.opentelemetry.proto.metrics.v1.Histogram.decode(reader, reader.uint32());
                      break;
                    }
                    case 10: {
                      message.exponentialHistogram = $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.decode(reader, reader.uint32());
                      break;
                    }
                    case 11: {
                      message.summary = $root.opentelemetry.proto.metrics.v1.Summary.decode(reader, reader.uint32());
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              Metric.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              Metric.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                var properties = {};
                if (message.name != null && message.hasOwnProperty("name")) {
                  if (!$util.isString(message.name))
                    return "name: string expected";
                }
                if (message.description != null && message.hasOwnProperty("description")) {
                  if (!$util.isString(message.description))
                    return "description: string expected";
                }
                if (message.unit != null && message.hasOwnProperty("unit")) {
                  if (!$util.isString(message.unit))
                    return "unit: string expected";
                }
                if (message.gauge != null && message.hasOwnProperty("gauge")) {
                  properties.data = 1;
                  {
                    var error = $root.opentelemetry.proto.metrics.v1.Gauge.verify(message.gauge);
                    if (error)
                      return "gauge." + error;
                  }
                }
                if (message.sum != null && message.hasOwnProperty("sum")) {
                  if (properties.data === 1)
                    return "data: multiple values";
                  properties.data = 1;
                  {
                    var error = $root.opentelemetry.proto.metrics.v1.Sum.verify(message.sum);
                    if (error)
                      return "sum." + error;
                  }
                }
                if (message.histogram != null && message.hasOwnProperty("histogram")) {
                  if (properties.data === 1)
                    return "data: multiple values";
                  properties.data = 1;
                  {
                    var error = $root.opentelemetry.proto.metrics.v1.Histogram.verify(message.histogram);
                    if (error)
                      return "histogram." + error;
                  }
                }
                if (message.exponentialHistogram != null && message.hasOwnProperty("exponentialHistogram")) {
                  if (properties.data === 1)
                    return "data: multiple values";
                  properties.data = 1;
                  {
                    var error = $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.verify(message.exponentialHistogram);
                    if (error)
                      return "exponentialHistogram." + error;
                  }
                }
                if (message.summary != null && message.hasOwnProperty("summary")) {
                  if (properties.data === 1)
                    return "data: multiple values";
                  properties.data = 1;
                  {
                    var error = $root.opentelemetry.proto.metrics.v1.Summary.verify(message.summary);
                    if (error)
                      return "summary." + error;
                  }
                }
                return null;
              };
              Metric.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.metrics.v1.Metric)
                  return object2;
                var message = new $root.opentelemetry.proto.metrics.v1.Metric();
                if (object2.name != null)
                  message.name = String(object2.name);
                if (object2.description != null)
                  message.description = String(object2.description);
                if (object2.unit != null)
                  message.unit = String(object2.unit);
                if (object2.gauge != null) {
                  if (typeof object2.gauge !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.Metric.gauge: object expected");
                  message.gauge = $root.opentelemetry.proto.metrics.v1.Gauge.fromObject(object2.gauge);
                }
                if (object2.sum != null) {
                  if (typeof object2.sum !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.Metric.sum: object expected");
                  message.sum = $root.opentelemetry.proto.metrics.v1.Sum.fromObject(object2.sum);
                }
                if (object2.histogram != null) {
                  if (typeof object2.histogram !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.Metric.histogram: object expected");
                  message.histogram = $root.opentelemetry.proto.metrics.v1.Histogram.fromObject(object2.histogram);
                }
                if (object2.exponentialHistogram != null) {
                  if (typeof object2.exponentialHistogram !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.Metric.exponentialHistogram: object expected");
                  message.exponentialHistogram = $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.fromObject(object2.exponentialHistogram);
                }
                if (object2.summary != null) {
                  if (typeof object2.summary !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.Metric.summary: object expected");
                  message.summary = $root.opentelemetry.proto.metrics.v1.Summary.fromObject(object2.summary);
                }
                return message;
              };
              Metric.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.defaults) {
                  object2.name = "";
                  object2.description = "";
                  object2.unit = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                  object2.name = message.name;
                if (message.description != null && message.hasOwnProperty("description"))
                  object2.description = message.description;
                if (message.unit != null && message.hasOwnProperty("unit"))
                  object2.unit = message.unit;
                if (message.gauge != null && message.hasOwnProperty("gauge")) {
                  object2.gauge = $root.opentelemetry.proto.metrics.v1.Gauge.toObject(message.gauge, options);
                  if (options.oneofs)
                    object2.data = "gauge";
                }
                if (message.sum != null && message.hasOwnProperty("sum")) {
                  object2.sum = $root.opentelemetry.proto.metrics.v1.Sum.toObject(message.sum, options);
                  if (options.oneofs)
                    object2.data = "sum";
                }
                if (message.histogram != null && message.hasOwnProperty("histogram")) {
                  object2.histogram = $root.opentelemetry.proto.metrics.v1.Histogram.toObject(message.histogram, options);
                  if (options.oneofs)
                    object2.data = "histogram";
                }
                if (message.exponentialHistogram != null && message.hasOwnProperty("exponentialHistogram")) {
                  object2.exponentialHistogram = $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.toObject(message.exponentialHistogram, options);
                  if (options.oneofs)
                    object2.data = "exponentialHistogram";
                }
                if (message.summary != null && message.hasOwnProperty("summary")) {
                  object2.summary = $root.opentelemetry.proto.metrics.v1.Summary.toObject(message.summary, options);
                  if (options.oneofs)
                    object2.data = "summary";
                }
                return object2;
              };
              Metric.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              Metric.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.Metric";
              };
              return Metric;
            }();
            v1.Gauge = function() {
              function Gauge(properties) {
                this.dataPoints = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              Gauge.prototype.dataPoints = $util.emptyArray;
              Gauge.create = function create2(properties) {
                return new Gauge(properties);
              };
              Gauge.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.dataPoints != null && message.dataPoints.length)
                  for (var i2 = 0; i2 < message.dataPoints.length; ++i2)
                    $root.opentelemetry.proto.metrics.v1.NumberDataPoint.encode(message.dataPoints[i2], writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                return writer;
              };
              Gauge.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              Gauge.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Gauge();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 1: {
                      if (!(message.dataPoints && message.dataPoints.length))
                        message.dataPoints = [];
                      message.dataPoints.push($root.opentelemetry.proto.metrics.v1.NumberDataPoint.decode(reader, reader.uint32()));
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              Gauge.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              Gauge.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.dataPoints != null && message.hasOwnProperty("dataPoints")) {
                  if (!Array.isArray(message.dataPoints))
                    return "dataPoints: array expected";
                  for (var i2 = 0; i2 < message.dataPoints.length; ++i2) {
                    var error = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.verify(message.dataPoints[i2]);
                    if (error)
                      return "dataPoints." + error;
                  }
                }
                return null;
              };
              Gauge.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.metrics.v1.Gauge)
                  return object2;
                var message = new $root.opentelemetry.proto.metrics.v1.Gauge();
                if (object2.dataPoints) {
                  if (!Array.isArray(object2.dataPoints))
                    throw TypeError(".opentelemetry.proto.metrics.v1.Gauge.dataPoints: array expected");
                  message.dataPoints = [];
                  for (var i2 = 0; i2 < object2.dataPoints.length; ++i2) {
                    if (typeof object2.dataPoints[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.Gauge.dataPoints: object expected");
                    message.dataPoints[i2] = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.fromObject(object2.dataPoints[i2]);
                  }
                }
                return message;
              };
              Gauge.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults)
                  object2.dataPoints = [];
                if (message.dataPoints && message.dataPoints.length) {
                  object2.dataPoints = [];
                  for (var j2 = 0; j2 < message.dataPoints.length; ++j2)
                    object2.dataPoints[j2] = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.toObject(message.dataPoints[j2], options);
                }
                return object2;
              };
              Gauge.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              Gauge.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.Gauge";
              };
              return Gauge;
            }();
            v1.Sum = function() {
              function Sum(properties) {
                this.dataPoints = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              Sum.prototype.dataPoints = $util.emptyArray;
              Sum.prototype.aggregationTemporality = null;
              Sum.prototype.isMonotonic = null;
              Sum.create = function create2(properties) {
                return new Sum(properties);
              };
              Sum.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.dataPoints != null && message.dataPoints.length)
                  for (var i2 = 0; i2 < message.dataPoints.length; ++i2)
                    $root.opentelemetry.proto.metrics.v1.NumberDataPoint.encode(message.dataPoints[i2], writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                if (message.aggregationTemporality != null && Object.hasOwnProperty.call(message, "aggregationTemporality"))
                  writer.uint32(
                    /* id 2, wireType 0 =*/
                    16
                  ).int32(message.aggregationTemporality);
                if (message.isMonotonic != null && Object.hasOwnProperty.call(message, "isMonotonic"))
                  writer.uint32(
                    /* id 3, wireType 0 =*/
                    24
                  ).bool(message.isMonotonic);
                return writer;
              };
              Sum.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              Sum.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Sum();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 1: {
                      if (!(message.dataPoints && message.dataPoints.length))
                        message.dataPoints = [];
                      message.dataPoints.push($root.opentelemetry.proto.metrics.v1.NumberDataPoint.decode(reader, reader.uint32()));
                      break;
                    }
                    case 2: {
                      message.aggregationTemporality = reader.int32();
                      break;
                    }
                    case 3: {
                      message.isMonotonic = reader.bool();
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              Sum.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              Sum.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.dataPoints != null && message.hasOwnProperty("dataPoints")) {
                  if (!Array.isArray(message.dataPoints))
                    return "dataPoints: array expected";
                  for (var i2 = 0; i2 < message.dataPoints.length; ++i2) {
                    var error = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.verify(message.dataPoints[i2]);
                    if (error)
                      return "dataPoints." + error;
                  }
                }
                if (message.aggregationTemporality != null && message.hasOwnProperty("aggregationTemporality"))
                  switch (message.aggregationTemporality) {
                    default:
                      return "aggregationTemporality: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                      break;
                  }
                if (message.isMonotonic != null && message.hasOwnProperty("isMonotonic")) {
                  if (typeof message.isMonotonic !== "boolean")
                    return "isMonotonic: boolean expected";
                }
                return null;
              };
              Sum.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.metrics.v1.Sum)
                  return object2;
                var message = new $root.opentelemetry.proto.metrics.v1.Sum();
                if (object2.dataPoints) {
                  if (!Array.isArray(object2.dataPoints))
                    throw TypeError(".opentelemetry.proto.metrics.v1.Sum.dataPoints: array expected");
                  message.dataPoints = [];
                  for (var i2 = 0; i2 < object2.dataPoints.length; ++i2) {
                    if (typeof object2.dataPoints[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.Sum.dataPoints: object expected");
                    message.dataPoints[i2] = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.fromObject(object2.dataPoints[i2]);
                  }
                }
                switch (object2.aggregationTemporality) {
                  default:
                    if (typeof object2.aggregationTemporality === "number") {
                      message.aggregationTemporality = object2.aggregationTemporality;
                      break;
                    }
                    break;
                  case "AGGREGATION_TEMPORALITY_UNSPECIFIED":
                  case 0:
                    message.aggregationTemporality = 0;
                    break;
                  case "AGGREGATION_TEMPORALITY_DELTA":
                  case 1:
                    message.aggregationTemporality = 1;
                    break;
                  case "AGGREGATION_TEMPORALITY_CUMULATIVE":
                  case 2:
                    message.aggregationTemporality = 2;
                    break;
                }
                if (object2.isMonotonic != null)
                  message.isMonotonic = Boolean(object2.isMonotonic);
                return message;
              };
              Sum.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults)
                  object2.dataPoints = [];
                if (options.defaults) {
                  object2.aggregationTemporality = options.enums === String ? "AGGREGATION_TEMPORALITY_UNSPECIFIED" : 0;
                  object2.isMonotonic = false;
                }
                if (message.dataPoints && message.dataPoints.length) {
                  object2.dataPoints = [];
                  for (var j2 = 0; j2 < message.dataPoints.length; ++j2)
                    object2.dataPoints[j2] = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.toObject(message.dataPoints[j2], options);
                }
                if (message.aggregationTemporality != null && message.hasOwnProperty("aggregationTemporality"))
                  object2.aggregationTemporality = options.enums === String ? $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] === void 0 ? message.aggregationTemporality : $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] : message.aggregationTemporality;
                if (message.isMonotonic != null && message.hasOwnProperty("isMonotonic"))
                  object2.isMonotonic = message.isMonotonic;
                return object2;
              };
              Sum.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              Sum.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.Sum";
              };
              return Sum;
            }();
            v1.Histogram = function() {
              function Histogram(properties) {
                this.dataPoints = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              Histogram.prototype.dataPoints = $util.emptyArray;
              Histogram.prototype.aggregationTemporality = null;
              Histogram.create = function create2(properties) {
                return new Histogram(properties);
              };
              Histogram.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.dataPoints != null && message.dataPoints.length)
                  for (var i2 = 0; i2 < message.dataPoints.length; ++i2)
                    $root.opentelemetry.proto.metrics.v1.HistogramDataPoint.encode(message.dataPoints[i2], writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                if (message.aggregationTemporality != null && Object.hasOwnProperty.call(message, "aggregationTemporality"))
                  writer.uint32(
                    /* id 2, wireType 0 =*/
                    16
                  ).int32(message.aggregationTemporality);
                return writer;
              };
              Histogram.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              Histogram.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Histogram();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 1: {
                      if (!(message.dataPoints && message.dataPoints.length))
                        message.dataPoints = [];
                      message.dataPoints.push($root.opentelemetry.proto.metrics.v1.HistogramDataPoint.decode(reader, reader.uint32()));
                      break;
                    }
                    case 2: {
                      message.aggregationTemporality = reader.int32();
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              Histogram.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              Histogram.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.dataPoints != null && message.hasOwnProperty("dataPoints")) {
                  if (!Array.isArray(message.dataPoints))
                    return "dataPoints: array expected";
                  for (var i2 = 0; i2 < message.dataPoints.length; ++i2) {
                    var error = $root.opentelemetry.proto.metrics.v1.HistogramDataPoint.verify(message.dataPoints[i2]);
                    if (error)
                      return "dataPoints." + error;
                  }
                }
                if (message.aggregationTemporality != null && message.hasOwnProperty("aggregationTemporality"))
                  switch (message.aggregationTemporality) {
                    default:
                      return "aggregationTemporality: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                      break;
                  }
                return null;
              };
              Histogram.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.metrics.v1.Histogram)
                  return object2;
                var message = new $root.opentelemetry.proto.metrics.v1.Histogram();
                if (object2.dataPoints) {
                  if (!Array.isArray(object2.dataPoints))
                    throw TypeError(".opentelemetry.proto.metrics.v1.Histogram.dataPoints: array expected");
                  message.dataPoints = [];
                  for (var i2 = 0; i2 < object2.dataPoints.length; ++i2) {
                    if (typeof object2.dataPoints[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.Histogram.dataPoints: object expected");
                    message.dataPoints[i2] = $root.opentelemetry.proto.metrics.v1.HistogramDataPoint.fromObject(object2.dataPoints[i2]);
                  }
                }
                switch (object2.aggregationTemporality) {
                  default:
                    if (typeof object2.aggregationTemporality === "number") {
                      message.aggregationTemporality = object2.aggregationTemporality;
                      break;
                    }
                    break;
                  case "AGGREGATION_TEMPORALITY_UNSPECIFIED":
                  case 0:
                    message.aggregationTemporality = 0;
                    break;
                  case "AGGREGATION_TEMPORALITY_DELTA":
                  case 1:
                    message.aggregationTemporality = 1;
                    break;
                  case "AGGREGATION_TEMPORALITY_CUMULATIVE":
                  case 2:
                    message.aggregationTemporality = 2;
                    break;
                }
                return message;
              };
              Histogram.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults)
                  object2.dataPoints = [];
                if (options.defaults)
                  object2.aggregationTemporality = options.enums === String ? "AGGREGATION_TEMPORALITY_UNSPECIFIED" : 0;
                if (message.dataPoints && message.dataPoints.length) {
                  object2.dataPoints = [];
                  for (var j2 = 0; j2 < message.dataPoints.length; ++j2)
                    object2.dataPoints[j2] = $root.opentelemetry.proto.metrics.v1.HistogramDataPoint.toObject(message.dataPoints[j2], options);
                }
                if (message.aggregationTemporality != null && message.hasOwnProperty("aggregationTemporality"))
                  object2.aggregationTemporality = options.enums === String ? $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] === void 0 ? message.aggregationTemporality : $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] : message.aggregationTemporality;
                return object2;
              };
              Histogram.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              Histogram.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.Histogram";
              };
              return Histogram;
            }();
            v1.ExponentialHistogram = function() {
              function ExponentialHistogram(properties) {
                this.dataPoints = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              ExponentialHistogram.prototype.dataPoints = $util.emptyArray;
              ExponentialHistogram.prototype.aggregationTemporality = null;
              ExponentialHistogram.create = function create2(properties) {
                return new ExponentialHistogram(properties);
              };
              ExponentialHistogram.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.dataPoints != null && message.dataPoints.length)
                  for (var i2 = 0; i2 < message.dataPoints.length; ++i2)
                    $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.encode(message.dataPoints[i2], writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                if (message.aggregationTemporality != null && Object.hasOwnProperty.call(message, "aggregationTemporality"))
                  writer.uint32(
                    /* id 2, wireType 0 =*/
                    16
                  ).int32(message.aggregationTemporality);
                return writer;
              };
              ExponentialHistogram.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              ExponentialHistogram.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogram();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 1: {
                      if (!(message.dataPoints && message.dataPoints.length))
                        message.dataPoints = [];
                      message.dataPoints.push($root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.decode(reader, reader.uint32()));
                      break;
                    }
                    case 2: {
                      message.aggregationTemporality = reader.int32();
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              ExponentialHistogram.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              ExponentialHistogram.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.dataPoints != null && message.hasOwnProperty("dataPoints")) {
                  if (!Array.isArray(message.dataPoints))
                    return "dataPoints: array expected";
                  for (var i2 = 0; i2 < message.dataPoints.length; ++i2) {
                    var error = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.verify(message.dataPoints[i2]);
                    if (error)
                      return "dataPoints." + error;
                  }
                }
                if (message.aggregationTemporality != null && message.hasOwnProperty("aggregationTemporality"))
                  switch (message.aggregationTemporality) {
                    default:
                      return "aggregationTemporality: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                      break;
                  }
                return null;
              };
              ExponentialHistogram.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.metrics.v1.ExponentialHistogram)
                  return object2;
                var message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogram();
                if (object2.dataPoints) {
                  if (!Array.isArray(object2.dataPoints))
                    throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogram.dataPoints: array expected");
                  message.dataPoints = [];
                  for (var i2 = 0; i2 < object2.dataPoints.length; ++i2) {
                    if (typeof object2.dataPoints[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogram.dataPoints: object expected");
                    message.dataPoints[i2] = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.fromObject(object2.dataPoints[i2]);
                  }
                }
                switch (object2.aggregationTemporality) {
                  default:
                    if (typeof object2.aggregationTemporality === "number") {
                      message.aggregationTemporality = object2.aggregationTemporality;
                      break;
                    }
                    break;
                  case "AGGREGATION_TEMPORALITY_UNSPECIFIED":
                  case 0:
                    message.aggregationTemporality = 0;
                    break;
                  case "AGGREGATION_TEMPORALITY_DELTA":
                  case 1:
                    message.aggregationTemporality = 1;
                    break;
                  case "AGGREGATION_TEMPORALITY_CUMULATIVE":
                  case 2:
                    message.aggregationTemporality = 2;
                    break;
                }
                return message;
              };
              ExponentialHistogram.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults)
                  object2.dataPoints = [];
                if (options.defaults)
                  object2.aggregationTemporality = options.enums === String ? "AGGREGATION_TEMPORALITY_UNSPECIFIED" : 0;
                if (message.dataPoints && message.dataPoints.length) {
                  object2.dataPoints = [];
                  for (var j2 = 0; j2 < message.dataPoints.length; ++j2)
                    object2.dataPoints[j2] = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.toObject(message.dataPoints[j2], options);
                }
                if (message.aggregationTemporality != null && message.hasOwnProperty("aggregationTemporality"))
                  object2.aggregationTemporality = options.enums === String ? $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] === void 0 ? message.aggregationTemporality : $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] : message.aggregationTemporality;
                return object2;
              };
              ExponentialHistogram.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              ExponentialHistogram.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.ExponentialHistogram";
              };
              return ExponentialHistogram;
            }();
            v1.Summary = function() {
              function Summary(properties) {
                this.dataPoints = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              Summary.prototype.dataPoints = $util.emptyArray;
              Summary.create = function create2(properties) {
                return new Summary(properties);
              };
              Summary.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.dataPoints != null && message.dataPoints.length)
                  for (var i2 = 0; i2 < message.dataPoints.length; ++i2)
                    $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.encode(message.dataPoints[i2], writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                return writer;
              };
              Summary.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              Summary.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Summary();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 1: {
                      if (!(message.dataPoints && message.dataPoints.length))
                        message.dataPoints = [];
                      message.dataPoints.push($root.opentelemetry.proto.metrics.v1.SummaryDataPoint.decode(reader, reader.uint32()));
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              Summary.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              Summary.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.dataPoints != null && message.hasOwnProperty("dataPoints")) {
                  if (!Array.isArray(message.dataPoints))
                    return "dataPoints: array expected";
                  for (var i2 = 0; i2 < message.dataPoints.length; ++i2) {
                    var error = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.verify(message.dataPoints[i2]);
                    if (error)
                      return "dataPoints." + error;
                  }
                }
                return null;
              };
              Summary.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.metrics.v1.Summary)
                  return object2;
                var message = new $root.opentelemetry.proto.metrics.v1.Summary();
                if (object2.dataPoints) {
                  if (!Array.isArray(object2.dataPoints))
                    throw TypeError(".opentelemetry.proto.metrics.v1.Summary.dataPoints: array expected");
                  message.dataPoints = [];
                  for (var i2 = 0; i2 < object2.dataPoints.length; ++i2) {
                    if (typeof object2.dataPoints[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.Summary.dataPoints: object expected");
                    message.dataPoints[i2] = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.fromObject(object2.dataPoints[i2]);
                  }
                }
                return message;
              };
              Summary.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults)
                  object2.dataPoints = [];
                if (message.dataPoints && message.dataPoints.length) {
                  object2.dataPoints = [];
                  for (var j2 = 0; j2 < message.dataPoints.length; ++j2)
                    object2.dataPoints[j2] = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.toObject(message.dataPoints[j2], options);
                }
                return object2;
              };
              Summary.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              Summary.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.Summary";
              };
              return Summary;
            }();
            v1.AggregationTemporality = function() {
              var valuesById = {}, values3 = Object.create(valuesById);
              values3[valuesById[0] = "AGGREGATION_TEMPORALITY_UNSPECIFIED"] = 0;
              values3[valuesById[1] = "AGGREGATION_TEMPORALITY_DELTA"] = 1;
              values3[valuesById[2] = "AGGREGATION_TEMPORALITY_CUMULATIVE"] = 2;
              return values3;
            }();
            v1.DataPointFlags = function() {
              var valuesById = {}, values3 = Object.create(valuesById);
              values3[valuesById[0] = "DATA_POINT_FLAGS_DO_NOT_USE"] = 0;
              values3[valuesById[1] = "DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK"] = 1;
              return values3;
            }();
            v1.NumberDataPoint = function() {
              function NumberDataPoint(properties) {
                this.attributes = [];
                this.exemplars = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              NumberDataPoint.prototype.attributes = $util.emptyArray;
              NumberDataPoint.prototype.startTimeUnixNano = null;
              NumberDataPoint.prototype.timeUnixNano = null;
              NumberDataPoint.prototype.asDouble = null;
              NumberDataPoint.prototype.asInt = null;
              NumberDataPoint.prototype.exemplars = $util.emptyArray;
              NumberDataPoint.prototype.flags = null;
              var $oneOfFields;
              Object.defineProperty(NumberDataPoint.prototype, "value", {
                get: $util.oneOfGetter($oneOfFields = ["asDouble", "asInt"]),
                set: $util.oneOfSetter($oneOfFields)
              });
              NumberDataPoint.create = function create2(properties) {
                return new NumberDataPoint(properties);
              };
              NumberDataPoint.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, "startTimeUnixNano"))
                  writer.uint32(
                    /* id 2, wireType 1 =*/
                    17
                  ).fixed64(message.startTimeUnixNano);
                if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano"))
                  writer.uint32(
                    /* id 3, wireType 1 =*/
                    25
                  ).fixed64(message.timeUnixNano);
                if (message.asDouble != null && Object.hasOwnProperty.call(message, "asDouble"))
                  writer.uint32(
                    /* id 4, wireType 1 =*/
                    33
                  ).double(message.asDouble);
                if (message.exemplars != null && message.exemplars.length)
                  for (var i2 = 0; i2 < message.exemplars.length; ++i2)
                    $root.opentelemetry.proto.metrics.v1.Exemplar.encode(message.exemplars[i2], writer.uint32(
                      /* id 5, wireType 2 =*/
                      42
                    ).fork()).ldelim();
                if (message.asInt != null && Object.hasOwnProperty.call(message, "asInt"))
                  writer.uint32(
                    /* id 6, wireType 1 =*/
                    49
                  ).sfixed64(message.asInt);
                if (message.attributes != null && message.attributes.length)
                  for (var i2 = 0; i2 < message.attributes.length; ++i2)
                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i2], writer.uint32(
                      /* id 7, wireType 2 =*/
                      58
                    ).fork()).ldelim();
                if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                  writer.uint32(
                    /* id 8, wireType 0 =*/
                    64
                  ).uint32(message.flags);
                return writer;
              };
              NumberDataPoint.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              NumberDataPoint.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.NumberDataPoint();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 7: {
                      if (!(message.attributes && message.attributes.length))
                        message.attributes = [];
                      message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                      break;
                    }
                    case 2: {
                      message.startTimeUnixNano = reader.fixed64();
                      break;
                    }
                    case 3: {
                      message.timeUnixNano = reader.fixed64();
                      break;
                    }
                    case 4: {
                      message.asDouble = reader.double();
                      break;
                    }
                    case 6: {
                      message.asInt = reader.sfixed64();
                      break;
                    }
                    case 5: {
                      if (!(message.exemplars && message.exemplars.length))
                        message.exemplars = [];
                      message.exemplars.push($root.opentelemetry.proto.metrics.v1.Exemplar.decode(reader, reader.uint32()));
                      break;
                    }
                    case 8: {
                      message.flags = reader.uint32();
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              NumberDataPoint.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              NumberDataPoint.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                var properties = {};
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                  if (!Array.isArray(message.attributes))
                    return "attributes: array expected";
                  for (var i2 = 0; i2 < message.attributes.length; ++i2) {
                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i2]);
                    if (error)
                      return "attributes." + error;
                  }
                }
                if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano")) {
                  if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))
                    return "startTimeUnixNano: integer|Long expected";
                }
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano")) {
                  if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
                    return "timeUnixNano: integer|Long expected";
                }
                if (message.asDouble != null && message.hasOwnProperty("asDouble")) {
                  properties.value = 1;
                  if (typeof message.asDouble !== "number")
                    return "asDouble: number expected";
                }
                if (message.asInt != null && message.hasOwnProperty("asInt")) {
                  if (properties.value === 1)
                    return "value: multiple values";
                  properties.value = 1;
                  if (!$util.isInteger(message.asInt) && !(message.asInt && $util.isInteger(message.asInt.low) && $util.isInteger(message.asInt.high)))
                    return "asInt: integer|Long expected";
                }
                if (message.exemplars != null && message.hasOwnProperty("exemplars")) {
                  if (!Array.isArray(message.exemplars))
                    return "exemplars: array expected";
                  for (var i2 = 0; i2 < message.exemplars.length; ++i2) {
                    var error = $root.opentelemetry.proto.metrics.v1.Exemplar.verify(message.exemplars[i2]);
                    if (error)
                      return "exemplars." + error;
                  }
                }
                if (message.flags != null && message.hasOwnProperty("flags")) {
                  if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
                }
                return null;
              };
              NumberDataPoint.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.metrics.v1.NumberDataPoint)
                  return object2;
                var message = new $root.opentelemetry.proto.metrics.v1.NumberDataPoint();
                if (object2.attributes) {
                  if (!Array.isArray(object2.attributes))
                    throw TypeError(".opentelemetry.proto.metrics.v1.NumberDataPoint.attributes: array expected");
                  message.attributes = [];
                  for (var i2 = 0; i2 < object2.attributes.length; ++i2) {
                    if (typeof object2.attributes[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.NumberDataPoint.attributes: object expected");
                    message.attributes[i2] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object2.attributes[i2]);
                  }
                }
                if (object2.startTimeUnixNano != null) {
                  if ($util.Long)
                    (message.startTimeUnixNano = $util.Long.fromValue(object2.startTimeUnixNano)).unsigned = false;
                  else if (typeof object2.startTimeUnixNano === "string")
                    message.startTimeUnixNano = parseInt(object2.startTimeUnixNano, 10);
                  else if (typeof object2.startTimeUnixNano === "number")
                    message.startTimeUnixNano = object2.startTimeUnixNano;
                  else if (typeof object2.startTimeUnixNano === "object")
                    message.startTimeUnixNano = new $util.LongBits(object2.startTimeUnixNano.low >>> 0, object2.startTimeUnixNano.high >>> 0).toNumber();
                }
                if (object2.timeUnixNano != null) {
                  if ($util.Long)
                    (message.timeUnixNano = $util.Long.fromValue(object2.timeUnixNano)).unsigned = false;
                  else if (typeof object2.timeUnixNano === "string")
                    message.timeUnixNano = parseInt(object2.timeUnixNano, 10);
                  else if (typeof object2.timeUnixNano === "number")
                    message.timeUnixNano = object2.timeUnixNano;
                  else if (typeof object2.timeUnixNano === "object")
                    message.timeUnixNano = new $util.LongBits(object2.timeUnixNano.low >>> 0, object2.timeUnixNano.high >>> 0).toNumber();
                }
                if (object2.asDouble != null)
                  message.asDouble = Number(object2.asDouble);
                if (object2.asInt != null) {
                  if ($util.Long)
                    (message.asInt = $util.Long.fromValue(object2.asInt)).unsigned = false;
                  else if (typeof object2.asInt === "string")
                    message.asInt = parseInt(object2.asInt, 10);
                  else if (typeof object2.asInt === "number")
                    message.asInt = object2.asInt;
                  else if (typeof object2.asInt === "object")
                    message.asInt = new $util.LongBits(object2.asInt.low >>> 0, object2.asInt.high >>> 0).toNumber();
                }
                if (object2.exemplars) {
                  if (!Array.isArray(object2.exemplars))
                    throw TypeError(".opentelemetry.proto.metrics.v1.NumberDataPoint.exemplars: array expected");
                  message.exemplars = [];
                  for (var i2 = 0; i2 < object2.exemplars.length; ++i2) {
                    if (typeof object2.exemplars[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.NumberDataPoint.exemplars: object expected");
                    message.exemplars[i2] = $root.opentelemetry.proto.metrics.v1.Exemplar.fromObject(object2.exemplars[i2]);
                  }
                }
                if (object2.flags != null)
                  message.flags = object2.flags >>> 0;
                return message;
              };
              NumberDataPoint.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults) {
                  object2.exemplars = [];
                  object2.attributes = [];
                }
                if (options.defaults) {
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object2.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object2.startTimeUnixNano = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object2.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object2.timeUnixNano = options.longs === String ? "0" : 0;
                  object2.flags = 0;
                }
                if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano"))
                  if (typeof message.startTimeUnixNano === "number")
                    object2.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;
                  else
                    object2.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
                  if (typeof message.timeUnixNano === "number")
                    object2.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;
                  else
                    object2.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;
                if (message.asDouble != null && message.hasOwnProperty("asDouble")) {
                  object2.asDouble = options.json && !isFinite(message.asDouble) ? String(message.asDouble) : message.asDouble;
                  if (options.oneofs)
                    object2.value = "asDouble";
                }
                if (message.exemplars && message.exemplars.length) {
                  object2.exemplars = [];
                  for (var j2 = 0; j2 < message.exemplars.length; ++j2)
                    object2.exemplars[j2] = $root.opentelemetry.proto.metrics.v1.Exemplar.toObject(message.exemplars[j2], options);
                }
                if (message.asInt != null && message.hasOwnProperty("asInt")) {
                  if (typeof message.asInt === "number")
                    object2.asInt = options.longs === String ? String(message.asInt) : message.asInt;
                  else
                    object2.asInt = options.longs === String ? $util.Long.prototype.toString.call(message.asInt) : options.longs === Number ? new $util.LongBits(message.asInt.low >>> 0, message.asInt.high >>> 0).toNumber() : message.asInt;
                  if (options.oneofs)
                    object2.value = "asInt";
                }
                if (message.attributes && message.attributes.length) {
                  object2.attributes = [];
                  for (var j2 = 0; j2 < message.attributes.length; ++j2)
                    object2.attributes[j2] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j2], options);
                }
                if (message.flags != null && message.hasOwnProperty("flags"))
                  object2.flags = message.flags;
                return object2;
              };
              NumberDataPoint.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              NumberDataPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.NumberDataPoint";
              };
              return NumberDataPoint;
            }();
            v1.HistogramDataPoint = function() {
              function HistogramDataPoint(properties) {
                this.attributes = [];
                this.bucketCounts = [];
                this.explicitBounds = [];
                this.exemplars = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              HistogramDataPoint.prototype.attributes = $util.emptyArray;
              HistogramDataPoint.prototype.startTimeUnixNano = null;
              HistogramDataPoint.prototype.timeUnixNano = null;
              HistogramDataPoint.prototype.count = null;
              HistogramDataPoint.prototype.sum = null;
              HistogramDataPoint.prototype.bucketCounts = $util.emptyArray;
              HistogramDataPoint.prototype.explicitBounds = $util.emptyArray;
              HistogramDataPoint.prototype.exemplars = $util.emptyArray;
              HistogramDataPoint.prototype.flags = null;
              HistogramDataPoint.prototype.min = null;
              HistogramDataPoint.prototype.max = null;
              var $oneOfFields;
              Object.defineProperty(HistogramDataPoint.prototype, "_sum", {
                get: $util.oneOfGetter($oneOfFields = ["sum"]),
                set: $util.oneOfSetter($oneOfFields)
              });
              Object.defineProperty(HistogramDataPoint.prototype, "_min", {
                get: $util.oneOfGetter($oneOfFields = ["min"]),
                set: $util.oneOfSetter($oneOfFields)
              });
              Object.defineProperty(HistogramDataPoint.prototype, "_max", {
                get: $util.oneOfGetter($oneOfFields = ["max"]),
                set: $util.oneOfSetter($oneOfFields)
              });
              HistogramDataPoint.create = function create2(properties) {
                return new HistogramDataPoint(properties);
              };
              HistogramDataPoint.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, "startTimeUnixNano"))
                  writer.uint32(
                    /* id 2, wireType 1 =*/
                    17
                  ).fixed64(message.startTimeUnixNano);
                if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano"))
                  writer.uint32(
                    /* id 3, wireType 1 =*/
                    25
                  ).fixed64(message.timeUnixNano);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                  writer.uint32(
                    /* id 4, wireType 1 =*/
                    33
                  ).fixed64(message.count);
                if (message.sum != null && Object.hasOwnProperty.call(message, "sum"))
                  writer.uint32(
                    /* id 5, wireType 1 =*/
                    41
                  ).double(message.sum);
                if (message.bucketCounts != null && message.bucketCounts.length) {
                  writer.uint32(
                    /* id 6, wireType 2 =*/
                    50
                  ).fork();
                  for (var i2 = 0; i2 < message.bucketCounts.length; ++i2)
                    writer.fixed64(message.bucketCounts[i2]);
                  writer.ldelim();
                }
                if (message.explicitBounds != null && message.explicitBounds.length) {
                  writer.uint32(
                    /* id 7, wireType 2 =*/
                    58
                  ).fork();
                  for (var i2 = 0; i2 < message.explicitBounds.length; ++i2)
                    writer.double(message.explicitBounds[i2]);
                  writer.ldelim();
                }
                if (message.exemplars != null && message.exemplars.length)
                  for (var i2 = 0; i2 < message.exemplars.length; ++i2)
                    $root.opentelemetry.proto.metrics.v1.Exemplar.encode(message.exemplars[i2], writer.uint32(
                      /* id 8, wireType 2 =*/
                      66
                    ).fork()).ldelim();
                if (message.attributes != null && message.attributes.length)
                  for (var i2 = 0; i2 < message.attributes.length; ++i2)
                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i2], writer.uint32(
                      /* id 9, wireType 2 =*/
                      74
                    ).fork()).ldelim();
                if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                  writer.uint32(
                    /* id 10, wireType 0 =*/
                    80
                  ).uint32(message.flags);
                if (message.min != null && Object.hasOwnProperty.call(message, "min"))
                  writer.uint32(
                    /* id 11, wireType 1 =*/
                    89
                  ).double(message.min);
                if (message.max != null && Object.hasOwnProperty.call(message, "max"))
                  writer.uint32(
                    /* id 12, wireType 1 =*/
                    97
                  ).double(message.max);
                return writer;
              };
              HistogramDataPoint.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              HistogramDataPoint.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.HistogramDataPoint();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 9: {
                      if (!(message.attributes && message.attributes.length))
                        message.attributes = [];
                      message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                      break;
                    }
                    case 2: {
                      message.startTimeUnixNano = reader.fixed64();
                      break;
                    }
                    case 3: {
                      message.timeUnixNano = reader.fixed64();
                      break;
                    }
                    case 4: {
                      message.count = reader.fixed64();
                      break;
                    }
                    case 5: {
                      message.sum = reader.double();
                      break;
                    }
                    case 6: {
                      if (!(message.bucketCounts && message.bucketCounts.length))
                        message.bucketCounts = [];
                      if ((tag2 & 7) === 2) {
                        var end22 = reader.uint32() + reader.pos;
                        while (reader.pos < end22)
                          message.bucketCounts.push(reader.fixed64());
                      } else
                        message.bucketCounts.push(reader.fixed64());
                      break;
                    }
                    case 7: {
                      if (!(message.explicitBounds && message.explicitBounds.length))
                        message.explicitBounds = [];
                      if ((tag2 & 7) === 2) {
                        var end22 = reader.uint32() + reader.pos;
                        while (reader.pos < end22)
                          message.explicitBounds.push(reader.double());
                      } else
                        message.explicitBounds.push(reader.double());
                      break;
                    }
                    case 8: {
                      if (!(message.exemplars && message.exemplars.length))
                        message.exemplars = [];
                      message.exemplars.push($root.opentelemetry.proto.metrics.v1.Exemplar.decode(reader, reader.uint32()));
                      break;
                    }
                    case 10: {
                      message.flags = reader.uint32();
                      break;
                    }
                    case 11: {
                      message.min = reader.double();
                      break;
                    }
                    case 12: {
                      message.max = reader.double();
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              HistogramDataPoint.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              HistogramDataPoint.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                var properties = {};
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                  if (!Array.isArray(message.attributes))
                    return "attributes: array expected";
                  for (var i2 = 0; i2 < message.attributes.length; ++i2) {
                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i2]);
                    if (error)
                      return "attributes." + error;
                  }
                }
                if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano")) {
                  if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))
                    return "startTimeUnixNano: integer|Long expected";
                }
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano")) {
                  if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
                    return "timeUnixNano: integer|Long expected";
                }
                if (message.count != null && message.hasOwnProperty("count")) {
                  if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
                    return "count: integer|Long expected";
                }
                if (message.sum != null && message.hasOwnProperty("sum")) {
                  properties._sum = 1;
                  if (typeof message.sum !== "number")
                    return "sum: number expected";
                }
                if (message.bucketCounts != null && message.hasOwnProperty("bucketCounts")) {
                  if (!Array.isArray(message.bucketCounts))
                    return "bucketCounts: array expected";
                  for (var i2 = 0; i2 < message.bucketCounts.length; ++i2)
                    if (!$util.isInteger(message.bucketCounts[i2]) && !(message.bucketCounts[i2] && $util.isInteger(message.bucketCounts[i2].low) && $util.isInteger(message.bucketCounts[i2].high)))
                      return "bucketCounts: integer|Long[] expected";
                }
                if (message.explicitBounds != null && message.hasOwnProperty("explicitBounds")) {
                  if (!Array.isArray(message.explicitBounds))
                    return "explicitBounds: array expected";
                  for (var i2 = 0; i2 < message.explicitBounds.length; ++i2)
                    if (typeof message.explicitBounds[i2] !== "number")
                      return "explicitBounds: number[] expected";
                }
                if (message.exemplars != null && message.hasOwnProperty("exemplars")) {
                  if (!Array.isArray(message.exemplars))
                    return "exemplars: array expected";
                  for (var i2 = 0; i2 < message.exemplars.length; ++i2) {
                    var error = $root.opentelemetry.proto.metrics.v1.Exemplar.verify(message.exemplars[i2]);
                    if (error)
                      return "exemplars." + error;
                  }
                }
                if (message.flags != null && message.hasOwnProperty("flags")) {
                  if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
                }
                if (message.min != null && message.hasOwnProperty("min")) {
                  properties._min = 1;
                  if (typeof message.min !== "number")
                    return "min: number expected";
                }
                if (message.max != null && message.hasOwnProperty("max")) {
                  properties._max = 1;
                  if (typeof message.max !== "number")
                    return "max: number expected";
                }
                return null;
              };
              HistogramDataPoint.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.metrics.v1.HistogramDataPoint)
                  return object2;
                var message = new $root.opentelemetry.proto.metrics.v1.HistogramDataPoint();
                if (object2.attributes) {
                  if (!Array.isArray(object2.attributes))
                    throw TypeError(".opentelemetry.proto.metrics.v1.HistogramDataPoint.attributes: array expected");
                  message.attributes = [];
                  for (var i2 = 0; i2 < object2.attributes.length; ++i2) {
                    if (typeof object2.attributes[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.HistogramDataPoint.attributes: object expected");
                    message.attributes[i2] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object2.attributes[i2]);
                  }
                }
                if (object2.startTimeUnixNano != null) {
                  if ($util.Long)
                    (message.startTimeUnixNano = $util.Long.fromValue(object2.startTimeUnixNano)).unsigned = false;
                  else if (typeof object2.startTimeUnixNano === "string")
                    message.startTimeUnixNano = parseInt(object2.startTimeUnixNano, 10);
                  else if (typeof object2.startTimeUnixNano === "number")
                    message.startTimeUnixNano = object2.startTimeUnixNano;
                  else if (typeof object2.startTimeUnixNano === "object")
                    message.startTimeUnixNano = new $util.LongBits(object2.startTimeUnixNano.low >>> 0, object2.startTimeUnixNano.high >>> 0).toNumber();
                }
                if (object2.timeUnixNano != null) {
                  if ($util.Long)
                    (message.timeUnixNano = $util.Long.fromValue(object2.timeUnixNano)).unsigned = false;
                  else if (typeof object2.timeUnixNano === "string")
                    message.timeUnixNano = parseInt(object2.timeUnixNano, 10);
                  else if (typeof object2.timeUnixNano === "number")
                    message.timeUnixNano = object2.timeUnixNano;
                  else if (typeof object2.timeUnixNano === "object")
                    message.timeUnixNano = new $util.LongBits(object2.timeUnixNano.low >>> 0, object2.timeUnixNano.high >>> 0).toNumber();
                }
                if (object2.count != null) {
                  if ($util.Long)
                    (message.count = $util.Long.fromValue(object2.count)).unsigned = false;
                  else if (typeof object2.count === "string")
                    message.count = parseInt(object2.count, 10);
                  else if (typeof object2.count === "number")
                    message.count = object2.count;
                  else if (typeof object2.count === "object")
                    message.count = new $util.LongBits(object2.count.low >>> 0, object2.count.high >>> 0).toNumber();
                }
                if (object2.sum != null)
                  message.sum = Number(object2.sum);
                if (object2.bucketCounts) {
                  if (!Array.isArray(object2.bucketCounts))
                    throw TypeError(".opentelemetry.proto.metrics.v1.HistogramDataPoint.bucketCounts: array expected");
                  message.bucketCounts = [];
                  for (var i2 = 0; i2 < object2.bucketCounts.length; ++i2)
                    if ($util.Long)
                      (message.bucketCounts[i2] = $util.Long.fromValue(object2.bucketCounts[i2])).unsigned = false;
                    else if (typeof object2.bucketCounts[i2] === "string")
                      message.bucketCounts[i2] = parseInt(object2.bucketCounts[i2], 10);
                    else if (typeof object2.bucketCounts[i2] === "number")
                      message.bucketCounts[i2] = object2.bucketCounts[i2];
                    else if (typeof object2.bucketCounts[i2] === "object")
                      message.bucketCounts[i2] = new $util.LongBits(object2.bucketCounts[i2].low >>> 0, object2.bucketCounts[i2].high >>> 0).toNumber();
                }
                if (object2.explicitBounds) {
                  if (!Array.isArray(object2.explicitBounds))
                    throw TypeError(".opentelemetry.proto.metrics.v1.HistogramDataPoint.explicitBounds: array expected");
                  message.explicitBounds = [];
                  for (var i2 = 0; i2 < object2.explicitBounds.length; ++i2)
                    message.explicitBounds[i2] = Number(object2.explicitBounds[i2]);
                }
                if (object2.exemplars) {
                  if (!Array.isArray(object2.exemplars))
                    throw TypeError(".opentelemetry.proto.metrics.v1.HistogramDataPoint.exemplars: array expected");
                  message.exemplars = [];
                  for (var i2 = 0; i2 < object2.exemplars.length; ++i2) {
                    if (typeof object2.exemplars[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.HistogramDataPoint.exemplars: object expected");
                    message.exemplars[i2] = $root.opentelemetry.proto.metrics.v1.Exemplar.fromObject(object2.exemplars[i2]);
                  }
                }
                if (object2.flags != null)
                  message.flags = object2.flags >>> 0;
                if (object2.min != null)
                  message.min = Number(object2.min);
                if (object2.max != null)
                  message.max = Number(object2.max);
                return message;
              };
              HistogramDataPoint.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults) {
                  object2.bucketCounts = [];
                  object2.explicitBounds = [];
                  object2.exemplars = [];
                  object2.attributes = [];
                }
                if (options.defaults) {
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object2.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object2.startTimeUnixNano = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object2.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object2.timeUnixNano = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object2.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object2.count = options.longs === String ? "0" : 0;
                  object2.flags = 0;
                }
                if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano"))
                  if (typeof message.startTimeUnixNano === "number")
                    object2.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;
                  else
                    object2.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
                  if (typeof message.timeUnixNano === "number")
                    object2.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;
                  else
                    object2.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;
                if (message.count != null && message.hasOwnProperty("count"))
                  if (typeof message.count === "number")
                    object2.count = options.longs === String ? String(message.count) : message.count;
                  else
                    object2.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count;
                if (message.sum != null && message.hasOwnProperty("sum")) {
                  object2.sum = options.json && !isFinite(message.sum) ? String(message.sum) : message.sum;
                  if (options.oneofs)
                    object2._sum = "sum";
                }
                if (message.bucketCounts && message.bucketCounts.length) {
                  object2.bucketCounts = [];
                  for (var j2 = 0; j2 < message.bucketCounts.length; ++j2)
                    if (typeof message.bucketCounts[j2] === "number")
                      object2.bucketCounts[j2] = options.longs === String ? String(message.bucketCounts[j2]) : message.bucketCounts[j2];
                    else
                      object2.bucketCounts[j2] = options.longs === String ? $util.Long.prototype.toString.call(message.bucketCounts[j2]) : options.longs === Number ? new $util.LongBits(message.bucketCounts[j2].low >>> 0, message.bucketCounts[j2].high >>> 0).toNumber() : message.bucketCounts[j2];
                }
                if (message.explicitBounds && message.explicitBounds.length) {
                  object2.explicitBounds = [];
                  for (var j2 = 0; j2 < message.explicitBounds.length; ++j2)
                    object2.explicitBounds[j2] = options.json && !isFinite(message.explicitBounds[j2]) ? String(message.explicitBounds[j2]) : message.explicitBounds[j2];
                }
                if (message.exemplars && message.exemplars.length) {
                  object2.exemplars = [];
                  for (var j2 = 0; j2 < message.exemplars.length; ++j2)
                    object2.exemplars[j2] = $root.opentelemetry.proto.metrics.v1.Exemplar.toObject(message.exemplars[j2], options);
                }
                if (message.attributes && message.attributes.length) {
                  object2.attributes = [];
                  for (var j2 = 0; j2 < message.attributes.length; ++j2)
                    object2.attributes[j2] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j2], options);
                }
                if (message.flags != null && message.hasOwnProperty("flags"))
                  object2.flags = message.flags;
                if (message.min != null && message.hasOwnProperty("min")) {
                  object2.min = options.json && !isFinite(message.min) ? String(message.min) : message.min;
                  if (options.oneofs)
                    object2._min = "min";
                }
                if (message.max != null && message.hasOwnProperty("max")) {
                  object2.max = options.json && !isFinite(message.max) ? String(message.max) : message.max;
                  if (options.oneofs)
                    object2._max = "max";
                }
                return object2;
              };
              HistogramDataPoint.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              HistogramDataPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.HistogramDataPoint";
              };
              return HistogramDataPoint;
            }();
            v1.ExponentialHistogramDataPoint = function() {
              function ExponentialHistogramDataPoint(properties) {
                this.attributes = [];
                this.exemplars = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              ExponentialHistogramDataPoint.prototype.attributes = $util.emptyArray;
              ExponentialHistogramDataPoint.prototype.startTimeUnixNano = null;
              ExponentialHistogramDataPoint.prototype.timeUnixNano = null;
              ExponentialHistogramDataPoint.prototype.count = null;
              ExponentialHistogramDataPoint.prototype.sum = null;
              ExponentialHistogramDataPoint.prototype.scale = null;
              ExponentialHistogramDataPoint.prototype.zeroCount = null;
              ExponentialHistogramDataPoint.prototype.positive = null;
              ExponentialHistogramDataPoint.prototype.negative = null;
              ExponentialHistogramDataPoint.prototype.flags = null;
              ExponentialHistogramDataPoint.prototype.exemplars = $util.emptyArray;
              ExponentialHistogramDataPoint.prototype.min = null;
              ExponentialHistogramDataPoint.prototype.max = null;
              ExponentialHistogramDataPoint.prototype.zeroThreshold = null;
              var $oneOfFields;
              Object.defineProperty(ExponentialHistogramDataPoint.prototype, "_sum", {
                get: $util.oneOfGetter($oneOfFields = ["sum"]),
                set: $util.oneOfSetter($oneOfFields)
              });
              Object.defineProperty(ExponentialHistogramDataPoint.prototype, "_min", {
                get: $util.oneOfGetter($oneOfFields = ["min"]),
                set: $util.oneOfSetter($oneOfFields)
              });
              Object.defineProperty(ExponentialHistogramDataPoint.prototype, "_max", {
                get: $util.oneOfGetter($oneOfFields = ["max"]),
                set: $util.oneOfSetter($oneOfFields)
              });
              ExponentialHistogramDataPoint.create = function create2(properties) {
                return new ExponentialHistogramDataPoint(properties);
              };
              ExponentialHistogramDataPoint.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.attributes != null && message.attributes.length)
                  for (var i2 = 0; i2 < message.attributes.length; ++i2)
                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i2], writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, "startTimeUnixNano"))
                  writer.uint32(
                    /* id 2, wireType 1 =*/
                    17
                  ).fixed64(message.startTimeUnixNano);
                if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano"))
                  writer.uint32(
                    /* id 3, wireType 1 =*/
                    25
                  ).fixed64(message.timeUnixNano);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                  writer.uint32(
                    /* id 4, wireType 1 =*/
                    33
                  ).fixed64(message.count);
                if (message.sum != null && Object.hasOwnProperty.call(message, "sum"))
                  writer.uint32(
                    /* id 5, wireType 1 =*/
                    41
                  ).double(message.sum);
                if (message.scale != null && Object.hasOwnProperty.call(message, "scale"))
                  writer.uint32(
                    /* id 6, wireType 0 =*/
                    48
                  ).sint32(message.scale);
                if (message.zeroCount != null && Object.hasOwnProperty.call(message, "zeroCount"))
                  writer.uint32(
                    /* id 7, wireType 1 =*/
                    57
                  ).fixed64(message.zeroCount);
                if (message.positive != null && Object.hasOwnProperty.call(message, "positive"))
                  $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.encode(message.positive, writer.uint32(
                    /* id 8, wireType 2 =*/
                    66
                  ).fork()).ldelim();
                if (message.negative != null && Object.hasOwnProperty.call(message, "negative"))
                  $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.encode(message.negative, writer.uint32(
                    /* id 9, wireType 2 =*/
                    74
                  ).fork()).ldelim();
                if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                  writer.uint32(
                    /* id 10, wireType 0 =*/
                    80
                  ).uint32(message.flags);
                if (message.exemplars != null && message.exemplars.length)
                  for (var i2 = 0; i2 < message.exemplars.length; ++i2)
                    $root.opentelemetry.proto.metrics.v1.Exemplar.encode(message.exemplars[i2], writer.uint32(
                      /* id 11, wireType 2 =*/
                      90
                    ).fork()).ldelim();
                if (message.min != null && Object.hasOwnProperty.call(message, "min"))
                  writer.uint32(
                    /* id 12, wireType 1 =*/
                    97
                  ).double(message.min);
                if (message.max != null && Object.hasOwnProperty.call(message, "max"))
                  writer.uint32(
                    /* id 13, wireType 1 =*/
                    105
                  ).double(message.max);
                if (message.zeroThreshold != null && Object.hasOwnProperty.call(message, "zeroThreshold"))
                  writer.uint32(
                    /* id 14, wireType 1 =*/
                    113
                  ).double(message.zeroThreshold);
                return writer;
              };
              ExponentialHistogramDataPoint.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              ExponentialHistogramDataPoint.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 1: {
                      if (!(message.attributes && message.attributes.length))
                        message.attributes = [];
                      message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                      break;
                    }
                    case 2: {
                      message.startTimeUnixNano = reader.fixed64();
                      break;
                    }
                    case 3: {
                      message.timeUnixNano = reader.fixed64();
                      break;
                    }
                    case 4: {
                      message.count = reader.fixed64();
                      break;
                    }
                    case 5: {
                      message.sum = reader.double();
                      break;
                    }
                    case 6: {
                      message.scale = reader.sint32();
                      break;
                    }
                    case 7: {
                      message.zeroCount = reader.fixed64();
                      break;
                    }
                    case 8: {
                      message.positive = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.decode(reader, reader.uint32());
                      break;
                    }
                    case 9: {
                      message.negative = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.decode(reader, reader.uint32());
                      break;
                    }
                    case 10: {
                      message.flags = reader.uint32();
                      break;
                    }
                    case 11: {
                      if (!(message.exemplars && message.exemplars.length))
                        message.exemplars = [];
                      message.exemplars.push($root.opentelemetry.proto.metrics.v1.Exemplar.decode(reader, reader.uint32()));
                      break;
                    }
                    case 12: {
                      message.min = reader.double();
                      break;
                    }
                    case 13: {
                      message.max = reader.double();
                      break;
                    }
                    case 14: {
                      message.zeroThreshold = reader.double();
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              ExponentialHistogramDataPoint.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              ExponentialHistogramDataPoint.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                var properties = {};
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                  if (!Array.isArray(message.attributes))
                    return "attributes: array expected";
                  for (var i2 = 0; i2 < message.attributes.length; ++i2) {
                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i2]);
                    if (error)
                      return "attributes." + error;
                  }
                }
                if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano")) {
                  if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))
                    return "startTimeUnixNano: integer|Long expected";
                }
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano")) {
                  if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
                    return "timeUnixNano: integer|Long expected";
                }
                if (message.count != null && message.hasOwnProperty("count")) {
                  if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
                    return "count: integer|Long expected";
                }
                if (message.sum != null && message.hasOwnProperty("sum")) {
                  properties._sum = 1;
                  if (typeof message.sum !== "number")
                    return "sum: number expected";
                }
                if (message.scale != null && message.hasOwnProperty("scale")) {
                  if (!$util.isInteger(message.scale))
                    return "scale: integer expected";
                }
                if (message.zeroCount != null && message.hasOwnProperty("zeroCount")) {
                  if (!$util.isInteger(message.zeroCount) && !(message.zeroCount && $util.isInteger(message.zeroCount.low) && $util.isInteger(message.zeroCount.high)))
                    return "zeroCount: integer|Long expected";
                }
                if (message.positive != null && message.hasOwnProperty("positive")) {
                  var error = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.verify(message.positive);
                  if (error)
                    return "positive." + error;
                }
                if (message.negative != null && message.hasOwnProperty("negative")) {
                  var error = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.verify(message.negative);
                  if (error)
                    return "negative." + error;
                }
                if (message.flags != null && message.hasOwnProperty("flags")) {
                  if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
                }
                if (message.exemplars != null && message.hasOwnProperty("exemplars")) {
                  if (!Array.isArray(message.exemplars))
                    return "exemplars: array expected";
                  for (var i2 = 0; i2 < message.exemplars.length; ++i2) {
                    var error = $root.opentelemetry.proto.metrics.v1.Exemplar.verify(message.exemplars[i2]);
                    if (error)
                      return "exemplars." + error;
                  }
                }
                if (message.min != null && message.hasOwnProperty("min")) {
                  properties._min = 1;
                  if (typeof message.min !== "number")
                    return "min: number expected";
                }
                if (message.max != null && message.hasOwnProperty("max")) {
                  properties._max = 1;
                  if (typeof message.max !== "number")
                    return "max: number expected";
                }
                if (message.zeroThreshold != null && message.hasOwnProperty("zeroThreshold")) {
                  if (typeof message.zeroThreshold !== "number")
                    return "zeroThreshold: number expected";
                }
                return null;
              };
              ExponentialHistogramDataPoint.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint)
                  return object2;
                var message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint();
                if (object2.attributes) {
                  if (!Array.isArray(object2.attributes))
                    throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.attributes: array expected");
                  message.attributes = [];
                  for (var i2 = 0; i2 < object2.attributes.length; ++i2) {
                    if (typeof object2.attributes[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.attributes: object expected");
                    message.attributes[i2] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object2.attributes[i2]);
                  }
                }
                if (object2.startTimeUnixNano != null) {
                  if ($util.Long)
                    (message.startTimeUnixNano = $util.Long.fromValue(object2.startTimeUnixNano)).unsigned = false;
                  else if (typeof object2.startTimeUnixNano === "string")
                    message.startTimeUnixNano = parseInt(object2.startTimeUnixNano, 10);
                  else if (typeof object2.startTimeUnixNano === "number")
                    message.startTimeUnixNano = object2.startTimeUnixNano;
                  else if (typeof object2.startTimeUnixNano === "object")
                    message.startTimeUnixNano = new $util.LongBits(object2.startTimeUnixNano.low >>> 0, object2.startTimeUnixNano.high >>> 0).toNumber();
                }
                if (object2.timeUnixNano != null) {
                  if ($util.Long)
                    (message.timeUnixNano = $util.Long.fromValue(object2.timeUnixNano)).unsigned = false;
                  else if (typeof object2.timeUnixNano === "string")
                    message.timeUnixNano = parseInt(object2.timeUnixNano, 10);
                  else if (typeof object2.timeUnixNano === "number")
                    message.timeUnixNano = object2.timeUnixNano;
                  else if (typeof object2.timeUnixNano === "object")
                    message.timeUnixNano = new $util.LongBits(object2.timeUnixNano.low >>> 0, object2.timeUnixNano.high >>> 0).toNumber();
                }
                if (object2.count != null) {
                  if ($util.Long)
                    (message.count = $util.Long.fromValue(object2.count)).unsigned = false;
                  else if (typeof object2.count === "string")
                    message.count = parseInt(object2.count, 10);
                  else if (typeof object2.count === "number")
                    message.count = object2.count;
                  else if (typeof object2.count === "object")
                    message.count = new $util.LongBits(object2.count.low >>> 0, object2.count.high >>> 0).toNumber();
                }
                if (object2.sum != null)
                  message.sum = Number(object2.sum);
                if (object2.scale != null)
                  message.scale = object2.scale | 0;
                if (object2.zeroCount != null) {
                  if ($util.Long)
                    (message.zeroCount = $util.Long.fromValue(object2.zeroCount)).unsigned = false;
                  else if (typeof object2.zeroCount === "string")
                    message.zeroCount = parseInt(object2.zeroCount, 10);
                  else if (typeof object2.zeroCount === "number")
                    message.zeroCount = object2.zeroCount;
                  else if (typeof object2.zeroCount === "object")
                    message.zeroCount = new $util.LongBits(object2.zeroCount.low >>> 0, object2.zeroCount.high >>> 0).toNumber();
                }
                if (object2.positive != null) {
                  if (typeof object2.positive !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.positive: object expected");
                  message.positive = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.fromObject(object2.positive);
                }
                if (object2.negative != null) {
                  if (typeof object2.negative !== "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.negative: object expected");
                  message.negative = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.fromObject(object2.negative);
                }
                if (object2.flags != null)
                  message.flags = object2.flags >>> 0;
                if (object2.exemplars) {
                  if (!Array.isArray(object2.exemplars))
                    throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.exemplars: array expected");
                  message.exemplars = [];
                  for (var i2 = 0; i2 < object2.exemplars.length; ++i2) {
                    if (typeof object2.exemplars[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.exemplars: object expected");
                    message.exemplars[i2] = $root.opentelemetry.proto.metrics.v1.Exemplar.fromObject(object2.exemplars[i2]);
                  }
                }
                if (object2.min != null)
                  message.min = Number(object2.min);
                if (object2.max != null)
                  message.max = Number(object2.max);
                if (object2.zeroThreshold != null)
                  message.zeroThreshold = Number(object2.zeroThreshold);
                return message;
              };
              ExponentialHistogramDataPoint.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults) {
                  object2.attributes = [];
                  object2.exemplars = [];
                }
                if (options.defaults) {
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object2.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object2.startTimeUnixNano = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object2.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object2.timeUnixNano = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object2.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object2.count = options.longs === String ? "0" : 0;
                  object2.scale = 0;
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object2.zeroCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object2.zeroCount = options.longs === String ? "0" : 0;
                  object2.positive = null;
                  object2.negative = null;
                  object2.flags = 0;
                  object2.zeroThreshold = 0;
                }
                if (message.attributes && message.attributes.length) {
                  object2.attributes = [];
                  for (var j2 = 0; j2 < message.attributes.length; ++j2)
                    object2.attributes[j2] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j2], options);
                }
                if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano"))
                  if (typeof message.startTimeUnixNano === "number")
                    object2.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;
                  else
                    object2.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
                  if (typeof message.timeUnixNano === "number")
                    object2.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;
                  else
                    object2.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;
                if (message.count != null && message.hasOwnProperty("count"))
                  if (typeof message.count === "number")
                    object2.count = options.longs === String ? String(message.count) : message.count;
                  else
                    object2.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count;
                if (message.sum != null && message.hasOwnProperty("sum")) {
                  object2.sum = options.json && !isFinite(message.sum) ? String(message.sum) : message.sum;
                  if (options.oneofs)
                    object2._sum = "sum";
                }
                if (message.scale != null && message.hasOwnProperty("scale"))
                  object2.scale = message.scale;
                if (message.zeroCount != null && message.hasOwnProperty("zeroCount"))
                  if (typeof message.zeroCount === "number")
                    object2.zeroCount = options.longs === String ? String(message.zeroCount) : message.zeroCount;
                  else
                    object2.zeroCount = options.longs === String ? $util.Long.prototype.toString.call(message.zeroCount) : options.longs === Number ? new $util.LongBits(message.zeroCount.low >>> 0, message.zeroCount.high >>> 0).toNumber() : message.zeroCount;
                if (message.positive != null && message.hasOwnProperty("positive"))
                  object2.positive = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.toObject(message.positive, options);
                if (message.negative != null && message.hasOwnProperty("negative"))
                  object2.negative = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.toObject(message.negative, options);
                if (message.flags != null && message.hasOwnProperty("flags"))
                  object2.flags = message.flags;
                if (message.exemplars && message.exemplars.length) {
                  object2.exemplars = [];
                  for (var j2 = 0; j2 < message.exemplars.length; ++j2)
                    object2.exemplars[j2] = $root.opentelemetry.proto.metrics.v1.Exemplar.toObject(message.exemplars[j2], options);
                }
                if (message.min != null && message.hasOwnProperty("min")) {
                  object2.min = options.json && !isFinite(message.min) ? String(message.min) : message.min;
                  if (options.oneofs)
                    object2._min = "min";
                }
                if (message.max != null && message.hasOwnProperty("max")) {
                  object2.max = options.json && !isFinite(message.max) ? String(message.max) : message.max;
                  if (options.oneofs)
                    object2._max = "max";
                }
                if (message.zeroThreshold != null && message.hasOwnProperty("zeroThreshold"))
                  object2.zeroThreshold = options.json && !isFinite(message.zeroThreshold) ? String(message.zeroThreshold) : message.zeroThreshold;
                return object2;
              };
              ExponentialHistogramDataPoint.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              ExponentialHistogramDataPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint";
              };
              ExponentialHistogramDataPoint.Buckets = function() {
                function Buckets(properties) {
                  this.bucketCounts = [];
                  if (properties) {
                    for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                      if (properties[keys4[i2]] != null)
                        this[keys4[i2]] = properties[keys4[i2]];
                  }
                }
                Buckets.prototype.offset = null;
                Buckets.prototype.bucketCounts = $util.emptyArray;
                Buckets.create = function create2(properties) {
                  return new Buckets(properties);
                };
                Buckets.encode = function encode2(message, writer) {
                  if (!writer)
                    writer = $Writer.create();
                  if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    writer.uint32(
                      /* id 1, wireType 0 =*/
                      8
                    ).sint32(message.offset);
                  if (message.bucketCounts != null && message.bucketCounts.length) {
                    writer.uint32(
                      /* id 2, wireType 2 =*/
                      18
                    ).fork();
                    for (var i2 = 0; i2 < message.bucketCounts.length; ++i2)
                      writer.uint64(message.bucketCounts[i2]);
                    writer.ldelim();
                  }
                  return writer;
                };
                Buckets.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
                };
                Buckets.decode = function decode2(reader, length) {
                  if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                  var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets();
                  while (reader.pos < end4) {
                    var tag2 = reader.uint32();
                    switch (tag2 >>> 3) {
                      case 1: {
                        message.offset = reader.sint32();
                        break;
                      }
                      case 2: {
                        if (!(message.bucketCounts && message.bucketCounts.length))
                          message.bucketCounts = [];
                        if ((tag2 & 7) === 2) {
                          var end22 = reader.uint32() + reader.pos;
                          while (reader.pos < end22)
                            message.bucketCounts.push(reader.uint64());
                        } else
                          message.bucketCounts.push(reader.uint64());
                        break;
                      }
                      default:
                        reader.skipType(tag2 & 7);
                        break;
                    }
                  }
                  return message;
                };
                Buckets.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
                };
                Buckets.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                    return "object expected";
                  if (message.offset != null && message.hasOwnProperty("offset")) {
                    if (!$util.isInteger(message.offset))
                      return "offset: integer expected";
                  }
                  if (message.bucketCounts != null && message.hasOwnProperty("bucketCounts")) {
                    if (!Array.isArray(message.bucketCounts))
                      return "bucketCounts: array expected";
                    for (var i2 = 0; i2 < message.bucketCounts.length; ++i2)
                      if (!$util.isInteger(message.bucketCounts[i2]) && !(message.bucketCounts[i2] && $util.isInteger(message.bucketCounts[i2].low) && $util.isInteger(message.bucketCounts[i2].high)))
                        return "bucketCounts: integer|Long[] expected";
                  }
                  return null;
                };
                Buckets.fromObject = function fromObject(object2) {
                  if (object2 instanceof $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets)
                    return object2;
                  var message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets();
                  if (object2.offset != null)
                    message.offset = object2.offset | 0;
                  if (object2.bucketCounts) {
                    if (!Array.isArray(object2.bucketCounts))
                      throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.bucketCounts: array expected");
                    message.bucketCounts = [];
                    for (var i2 = 0; i2 < object2.bucketCounts.length; ++i2)
                      if ($util.Long)
                        (message.bucketCounts[i2] = $util.Long.fromValue(object2.bucketCounts[i2])).unsigned = true;
                      else if (typeof object2.bucketCounts[i2] === "string")
                        message.bucketCounts[i2] = parseInt(object2.bucketCounts[i2], 10);
                      else if (typeof object2.bucketCounts[i2] === "number")
                        message.bucketCounts[i2] = object2.bucketCounts[i2];
                      else if (typeof object2.bucketCounts[i2] === "object")
                        message.bucketCounts[i2] = new $util.LongBits(object2.bucketCounts[i2].low >>> 0, object2.bucketCounts[i2].high >>> 0).toNumber(true);
                  }
                  return message;
                };
                Buckets.toObject = function toObject(message, options) {
                  if (!options)
                    options = {};
                  var object2 = {};
                  if (options.arrays || options.defaults)
                    object2.bucketCounts = [];
                  if (options.defaults)
                    object2.offset = 0;
                  if (message.offset != null && message.hasOwnProperty("offset"))
                    object2.offset = message.offset;
                  if (message.bucketCounts && message.bucketCounts.length) {
                    object2.bucketCounts = [];
                    for (var j2 = 0; j2 < message.bucketCounts.length; ++j2)
                      if (typeof message.bucketCounts[j2] === "number")
                        object2.bucketCounts[j2] = options.longs === String ? String(message.bucketCounts[j2]) : message.bucketCounts[j2];
                      else
                        object2.bucketCounts[j2] = options.longs === String ? $util.Long.prototype.toString.call(message.bucketCounts[j2]) : options.longs === Number ? new $util.LongBits(message.bucketCounts[j2].low >>> 0, message.bucketCounts[j2].high >>> 0).toNumber(true) : message.bucketCounts[j2];
                  }
                  return object2;
                };
                Buckets.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                Buckets.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets";
                };
                return Buckets;
              }();
              return ExponentialHistogramDataPoint;
            }();
            v1.SummaryDataPoint = function() {
              function SummaryDataPoint(properties) {
                this.attributes = [];
                this.quantileValues = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              SummaryDataPoint.prototype.attributes = $util.emptyArray;
              SummaryDataPoint.prototype.startTimeUnixNano = null;
              SummaryDataPoint.prototype.timeUnixNano = null;
              SummaryDataPoint.prototype.count = null;
              SummaryDataPoint.prototype.sum = null;
              SummaryDataPoint.prototype.quantileValues = $util.emptyArray;
              SummaryDataPoint.prototype.flags = null;
              SummaryDataPoint.create = function create2(properties) {
                return new SummaryDataPoint(properties);
              };
              SummaryDataPoint.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, "startTimeUnixNano"))
                  writer.uint32(
                    /* id 2, wireType 1 =*/
                    17
                  ).fixed64(message.startTimeUnixNano);
                if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano"))
                  writer.uint32(
                    /* id 3, wireType 1 =*/
                    25
                  ).fixed64(message.timeUnixNano);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                  writer.uint32(
                    /* id 4, wireType 1 =*/
                    33
                  ).fixed64(message.count);
                if (message.sum != null && Object.hasOwnProperty.call(message, "sum"))
                  writer.uint32(
                    /* id 5, wireType 1 =*/
                    41
                  ).double(message.sum);
                if (message.quantileValues != null && message.quantileValues.length)
                  for (var i2 = 0; i2 < message.quantileValues.length; ++i2)
                    $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.encode(message.quantileValues[i2], writer.uint32(
                      /* id 6, wireType 2 =*/
                      50
                    ).fork()).ldelim();
                if (message.attributes != null && message.attributes.length)
                  for (var i2 = 0; i2 < message.attributes.length; ++i2)
                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i2], writer.uint32(
                      /* id 7, wireType 2 =*/
                      58
                    ).fork()).ldelim();
                if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                  writer.uint32(
                    /* id 8, wireType 0 =*/
                    64
                  ).uint32(message.flags);
                return writer;
              };
              SummaryDataPoint.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              SummaryDataPoint.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.SummaryDataPoint();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 7: {
                      if (!(message.attributes && message.attributes.length))
                        message.attributes = [];
                      message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                      break;
                    }
                    case 2: {
                      message.startTimeUnixNano = reader.fixed64();
                      break;
                    }
                    case 3: {
                      message.timeUnixNano = reader.fixed64();
                      break;
                    }
                    case 4: {
                      message.count = reader.fixed64();
                      break;
                    }
                    case 5: {
                      message.sum = reader.double();
                      break;
                    }
                    case 6: {
                      if (!(message.quantileValues && message.quantileValues.length))
                        message.quantileValues = [];
                      message.quantileValues.push($root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.decode(reader, reader.uint32()));
                      break;
                    }
                    case 8: {
                      message.flags = reader.uint32();
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              SummaryDataPoint.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              SummaryDataPoint.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                  if (!Array.isArray(message.attributes))
                    return "attributes: array expected";
                  for (var i2 = 0; i2 < message.attributes.length; ++i2) {
                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i2]);
                    if (error)
                      return "attributes." + error;
                  }
                }
                if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano")) {
                  if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))
                    return "startTimeUnixNano: integer|Long expected";
                }
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano")) {
                  if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
                    return "timeUnixNano: integer|Long expected";
                }
                if (message.count != null && message.hasOwnProperty("count")) {
                  if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
                    return "count: integer|Long expected";
                }
                if (message.sum != null && message.hasOwnProperty("sum")) {
                  if (typeof message.sum !== "number")
                    return "sum: number expected";
                }
                if (message.quantileValues != null && message.hasOwnProperty("quantileValues")) {
                  if (!Array.isArray(message.quantileValues))
                    return "quantileValues: array expected";
                  for (var i2 = 0; i2 < message.quantileValues.length; ++i2) {
                    var error = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.verify(message.quantileValues[i2]);
                    if (error)
                      return "quantileValues." + error;
                  }
                }
                if (message.flags != null && message.hasOwnProperty("flags")) {
                  if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
                }
                return null;
              };
              SummaryDataPoint.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.metrics.v1.SummaryDataPoint)
                  return object2;
                var message = new $root.opentelemetry.proto.metrics.v1.SummaryDataPoint();
                if (object2.attributes) {
                  if (!Array.isArray(object2.attributes))
                    throw TypeError(".opentelemetry.proto.metrics.v1.SummaryDataPoint.attributes: array expected");
                  message.attributes = [];
                  for (var i2 = 0; i2 < object2.attributes.length; ++i2) {
                    if (typeof object2.attributes[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.SummaryDataPoint.attributes: object expected");
                    message.attributes[i2] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object2.attributes[i2]);
                  }
                }
                if (object2.startTimeUnixNano != null) {
                  if ($util.Long)
                    (message.startTimeUnixNano = $util.Long.fromValue(object2.startTimeUnixNano)).unsigned = false;
                  else if (typeof object2.startTimeUnixNano === "string")
                    message.startTimeUnixNano = parseInt(object2.startTimeUnixNano, 10);
                  else if (typeof object2.startTimeUnixNano === "number")
                    message.startTimeUnixNano = object2.startTimeUnixNano;
                  else if (typeof object2.startTimeUnixNano === "object")
                    message.startTimeUnixNano = new $util.LongBits(object2.startTimeUnixNano.low >>> 0, object2.startTimeUnixNano.high >>> 0).toNumber();
                }
                if (object2.timeUnixNano != null) {
                  if ($util.Long)
                    (message.timeUnixNano = $util.Long.fromValue(object2.timeUnixNano)).unsigned = false;
                  else if (typeof object2.timeUnixNano === "string")
                    message.timeUnixNano = parseInt(object2.timeUnixNano, 10);
                  else if (typeof object2.timeUnixNano === "number")
                    message.timeUnixNano = object2.timeUnixNano;
                  else if (typeof object2.timeUnixNano === "object")
                    message.timeUnixNano = new $util.LongBits(object2.timeUnixNano.low >>> 0, object2.timeUnixNano.high >>> 0).toNumber();
                }
                if (object2.count != null) {
                  if ($util.Long)
                    (message.count = $util.Long.fromValue(object2.count)).unsigned = false;
                  else if (typeof object2.count === "string")
                    message.count = parseInt(object2.count, 10);
                  else if (typeof object2.count === "number")
                    message.count = object2.count;
                  else if (typeof object2.count === "object")
                    message.count = new $util.LongBits(object2.count.low >>> 0, object2.count.high >>> 0).toNumber();
                }
                if (object2.sum != null)
                  message.sum = Number(object2.sum);
                if (object2.quantileValues) {
                  if (!Array.isArray(object2.quantileValues))
                    throw TypeError(".opentelemetry.proto.metrics.v1.SummaryDataPoint.quantileValues: array expected");
                  message.quantileValues = [];
                  for (var i2 = 0; i2 < object2.quantileValues.length; ++i2) {
                    if (typeof object2.quantileValues[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.SummaryDataPoint.quantileValues: object expected");
                    message.quantileValues[i2] = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.fromObject(object2.quantileValues[i2]);
                  }
                }
                if (object2.flags != null)
                  message.flags = object2.flags >>> 0;
                return message;
              };
              SummaryDataPoint.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults) {
                  object2.quantileValues = [];
                  object2.attributes = [];
                }
                if (options.defaults) {
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object2.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object2.startTimeUnixNano = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object2.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object2.timeUnixNano = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object2.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object2.count = options.longs === String ? "0" : 0;
                  object2.sum = 0;
                  object2.flags = 0;
                }
                if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano"))
                  if (typeof message.startTimeUnixNano === "number")
                    object2.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;
                  else
                    object2.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
                  if (typeof message.timeUnixNano === "number")
                    object2.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;
                  else
                    object2.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;
                if (message.count != null && message.hasOwnProperty("count"))
                  if (typeof message.count === "number")
                    object2.count = options.longs === String ? String(message.count) : message.count;
                  else
                    object2.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count;
                if (message.sum != null && message.hasOwnProperty("sum"))
                  object2.sum = options.json && !isFinite(message.sum) ? String(message.sum) : message.sum;
                if (message.quantileValues && message.quantileValues.length) {
                  object2.quantileValues = [];
                  for (var j2 = 0; j2 < message.quantileValues.length; ++j2)
                    object2.quantileValues[j2] = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.toObject(message.quantileValues[j2], options);
                }
                if (message.attributes && message.attributes.length) {
                  object2.attributes = [];
                  for (var j2 = 0; j2 < message.attributes.length; ++j2)
                    object2.attributes[j2] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j2], options);
                }
                if (message.flags != null && message.hasOwnProperty("flags"))
                  object2.flags = message.flags;
                return object2;
              };
              SummaryDataPoint.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              SummaryDataPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.SummaryDataPoint";
              };
              SummaryDataPoint.ValueAtQuantile = function() {
                function ValueAtQuantile(properties) {
                  if (properties) {
                    for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                      if (properties[keys4[i2]] != null)
                        this[keys4[i2]] = properties[keys4[i2]];
                  }
                }
                ValueAtQuantile.prototype.quantile = null;
                ValueAtQuantile.prototype.value = null;
                ValueAtQuantile.create = function create2(properties) {
                  return new ValueAtQuantile(properties);
                };
                ValueAtQuantile.encode = function encode2(message, writer) {
                  if (!writer)
                    writer = $Writer.create();
                  if (message.quantile != null && Object.hasOwnProperty.call(message, "quantile"))
                    writer.uint32(
                      /* id 1, wireType 1 =*/
                      9
                    ).double(message.quantile);
                  if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(
                      /* id 2, wireType 1 =*/
                      17
                    ).double(message.value);
                  return writer;
                };
                ValueAtQuantile.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
                };
                ValueAtQuantile.decode = function decode2(reader, length) {
                  if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                  var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile();
                  while (reader.pos < end4) {
                    var tag2 = reader.uint32();
                    switch (tag2 >>> 3) {
                      case 1: {
                        message.quantile = reader.double();
                        break;
                      }
                      case 2: {
                        message.value = reader.double();
                        break;
                      }
                      default:
                        reader.skipType(tag2 & 7);
                        break;
                    }
                  }
                  return message;
                };
                ValueAtQuantile.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
                };
                ValueAtQuantile.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                    return "object expected";
                  if (message.quantile != null && message.hasOwnProperty("quantile")) {
                    if (typeof message.quantile !== "number")
                      return "quantile: number expected";
                  }
                  if (message.value != null && message.hasOwnProperty("value")) {
                    if (typeof message.value !== "number")
                      return "value: number expected";
                  }
                  return null;
                };
                ValueAtQuantile.fromObject = function fromObject(object2) {
                  if (object2 instanceof $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile)
                    return object2;
                  var message = new $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile();
                  if (object2.quantile != null)
                    message.quantile = Number(object2.quantile);
                  if (object2.value != null)
                    message.value = Number(object2.value);
                  return message;
                };
                ValueAtQuantile.toObject = function toObject(message, options) {
                  if (!options)
                    options = {};
                  var object2 = {};
                  if (options.defaults) {
                    object2.quantile = 0;
                    object2.value = 0;
                  }
                  if (message.quantile != null && message.hasOwnProperty("quantile"))
                    object2.quantile = options.json && !isFinite(message.quantile) ? String(message.quantile) : message.quantile;
                  if (message.value != null && message.hasOwnProperty("value"))
                    object2.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                  return object2;
                };
                ValueAtQuantile.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                ValueAtQuantile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile";
                };
                return ValueAtQuantile;
              }();
              return SummaryDataPoint;
            }();
            v1.Exemplar = function() {
              function Exemplar(properties) {
                this.filteredAttributes = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              Exemplar.prototype.filteredAttributes = $util.emptyArray;
              Exemplar.prototype.timeUnixNano = null;
              Exemplar.prototype.asDouble = null;
              Exemplar.prototype.asInt = null;
              Exemplar.prototype.spanId = null;
              Exemplar.prototype.traceId = null;
              var $oneOfFields;
              Object.defineProperty(Exemplar.prototype, "value", {
                get: $util.oneOfGetter($oneOfFields = ["asDouble", "asInt"]),
                set: $util.oneOfSetter($oneOfFields)
              });
              Exemplar.create = function create2(properties) {
                return new Exemplar(properties);
              };
              Exemplar.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano"))
                  writer.uint32(
                    /* id 2, wireType 1 =*/
                    17
                  ).fixed64(message.timeUnixNano);
                if (message.asDouble != null && Object.hasOwnProperty.call(message, "asDouble"))
                  writer.uint32(
                    /* id 3, wireType 1 =*/
                    25
                  ).double(message.asDouble);
                if (message.spanId != null && Object.hasOwnProperty.call(message, "spanId"))
                  writer.uint32(
                    /* id 4, wireType 2 =*/
                    34
                  ).bytes(message.spanId);
                if (message.traceId != null && Object.hasOwnProperty.call(message, "traceId"))
                  writer.uint32(
                    /* id 5, wireType 2 =*/
                    42
                  ).bytes(message.traceId);
                if (message.asInt != null && Object.hasOwnProperty.call(message, "asInt"))
                  writer.uint32(
                    /* id 6, wireType 1 =*/
                    49
                  ).sfixed64(message.asInt);
                if (message.filteredAttributes != null && message.filteredAttributes.length)
                  for (var i2 = 0; i2 < message.filteredAttributes.length; ++i2)
                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.filteredAttributes[i2], writer.uint32(
                      /* id 7, wireType 2 =*/
                      58
                    ).fork()).ldelim();
                return writer;
              };
              Exemplar.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              Exemplar.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Exemplar();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 7: {
                      if (!(message.filteredAttributes && message.filteredAttributes.length))
                        message.filteredAttributes = [];
                      message.filteredAttributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                      break;
                    }
                    case 2: {
                      message.timeUnixNano = reader.fixed64();
                      break;
                    }
                    case 3: {
                      message.asDouble = reader.double();
                      break;
                    }
                    case 6: {
                      message.asInt = reader.sfixed64();
                      break;
                    }
                    case 4: {
                      message.spanId = reader.bytes();
                      break;
                    }
                    case 5: {
                      message.traceId = reader.bytes();
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              Exemplar.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              Exemplar.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                var properties = {};
                if (message.filteredAttributes != null && message.hasOwnProperty("filteredAttributes")) {
                  if (!Array.isArray(message.filteredAttributes))
                    return "filteredAttributes: array expected";
                  for (var i2 = 0; i2 < message.filteredAttributes.length; ++i2) {
                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.filteredAttributes[i2]);
                    if (error)
                      return "filteredAttributes." + error;
                  }
                }
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano")) {
                  if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
                    return "timeUnixNano: integer|Long expected";
                }
                if (message.asDouble != null && message.hasOwnProperty("asDouble")) {
                  properties.value = 1;
                  if (typeof message.asDouble !== "number")
                    return "asDouble: number expected";
                }
                if (message.asInt != null && message.hasOwnProperty("asInt")) {
                  if (properties.value === 1)
                    return "value: multiple values";
                  properties.value = 1;
                  if (!$util.isInteger(message.asInt) && !(message.asInt && $util.isInteger(message.asInt.low) && $util.isInteger(message.asInt.high)))
                    return "asInt: integer|Long expected";
                }
                if (message.spanId != null && message.hasOwnProperty("spanId")) {
                  if (!(message.spanId && typeof message.spanId.length === "number" || $util.isString(message.spanId)))
                    return "spanId: buffer expected";
                }
                if (message.traceId != null && message.hasOwnProperty("traceId")) {
                  if (!(message.traceId && typeof message.traceId.length === "number" || $util.isString(message.traceId)))
                    return "traceId: buffer expected";
                }
                return null;
              };
              Exemplar.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.metrics.v1.Exemplar)
                  return object2;
                var message = new $root.opentelemetry.proto.metrics.v1.Exemplar();
                if (object2.filteredAttributes) {
                  if (!Array.isArray(object2.filteredAttributes))
                    throw TypeError(".opentelemetry.proto.metrics.v1.Exemplar.filteredAttributes: array expected");
                  message.filteredAttributes = [];
                  for (var i2 = 0; i2 < object2.filteredAttributes.length; ++i2) {
                    if (typeof object2.filteredAttributes[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.Exemplar.filteredAttributes: object expected");
                    message.filteredAttributes[i2] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object2.filteredAttributes[i2]);
                  }
                }
                if (object2.timeUnixNano != null) {
                  if ($util.Long)
                    (message.timeUnixNano = $util.Long.fromValue(object2.timeUnixNano)).unsigned = false;
                  else if (typeof object2.timeUnixNano === "string")
                    message.timeUnixNano = parseInt(object2.timeUnixNano, 10);
                  else if (typeof object2.timeUnixNano === "number")
                    message.timeUnixNano = object2.timeUnixNano;
                  else if (typeof object2.timeUnixNano === "object")
                    message.timeUnixNano = new $util.LongBits(object2.timeUnixNano.low >>> 0, object2.timeUnixNano.high >>> 0).toNumber();
                }
                if (object2.asDouble != null)
                  message.asDouble = Number(object2.asDouble);
                if (object2.asInt != null) {
                  if ($util.Long)
                    (message.asInt = $util.Long.fromValue(object2.asInt)).unsigned = false;
                  else if (typeof object2.asInt === "string")
                    message.asInt = parseInt(object2.asInt, 10);
                  else if (typeof object2.asInt === "number")
                    message.asInt = object2.asInt;
                  else if (typeof object2.asInt === "object")
                    message.asInt = new $util.LongBits(object2.asInt.low >>> 0, object2.asInt.high >>> 0).toNumber();
                }
                if (object2.spanId != null) {
                  if (typeof object2.spanId === "string")
                    $util.base64.decode(object2.spanId, message.spanId = $util.newBuffer($util.base64.length(object2.spanId)), 0);
                  else if (object2.spanId.length >= 0)
                    message.spanId = object2.spanId;
                }
                if (object2.traceId != null) {
                  if (typeof object2.traceId === "string")
                    $util.base64.decode(object2.traceId, message.traceId = $util.newBuffer($util.base64.length(object2.traceId)), 0);
                  else if (object2.traceId.length >= 0)
                    message.traceId = object2.traceId;
                }
                return message;
              };
              Exemplar.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults)
                  object2.filteredAttributes = [];
                if (options.defaults) {
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object2.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object2.timeUnixNano = options.longs === String ? "0" : 0;
                  if (options.bytes === String)
                    object2.spanId = "";
                  else {
                    object2.spanId = [];
                    if (options.bytes !== Array)
                      object2.spanId = $util.newBuffer(object2.spanId);
                  }
                  if (options.bytes === String)
                    object2.traceId = "";
                  else {
                    object2.traceId = [];
                    if (options.bytes !== Array)
                      object2.traceId = $util.newBuffer(object2.traceId);
                  }
                }
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
                  if (typeof message.timeUnixNano === "number")
                    object2.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;
                  else
                    object2.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;
                if (message.asDouble != null && message.hasOwnProperty("asDouble")) {
                  object2.asDouble = options.json && !isFinite(message.asDouble) ? String(message.asDouble) : message.asDouble;
                  if (options.oneofs)
                    object2.value = "asDouble";
                }
                if (message.spanId != null && message.hasOwnProperty("spanId"))
                  object2.spanId = options.bytes === String ? $util.base64.encode(message.spanId, 0, message.spanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spanId) : message.spanId;
                if (message.traceId != null && message.hasOwnProperty("traceId"))
                  object2.traceId = options.bytes === String ? $util.base64.encode(message.traceId, 0, message.traceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.traceId) : message.traceId;
                if (message.asInt != null && message.hasOwnProperty("asInt")) {
                  if (typeof message.asInt === "number")
                    object2.asInt = options.longs === String ? String(message.asInt) : message.asInt;
                  else
                    object2.asInt = options.longs === String ? $util.Long.prototype.toString.call(message.asInt) : options.longs === Number ? new $util.LongBits(message.asInt.low >>> 0, message.asInt.high >>> 0).toNumber() : message.asInt;
                  if (options.oneofs)
                    object2.value = "asInt";
                }
                if (message.filteredAttributes && message.filteredAttributes.length) {
                  object2.filteredAttributes = [];
                  for (var j2 = 0; j2 < message.filteredAttributes.length; ++j2)
                    object2.filteredAttributes[j2] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.filteredAttributes[j2], options);
                }
                return object2;
              };
              Exemplar.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              Exemplar.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.Exemplar";
              };
              return Exemplar;
            }();
            return v1;
          }();
          return metrics2;
        }();
        proto.logs = function() {
          var logs = {};
          logs.v1 = function() {
            var v1 = {};
            v1.LogsData = function() {
              function LogsData(properties) {
                this.resourceLogs = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              LogsData.prototype.resourceLogs = $util.emptyArray;
              LogsData.create = function create2(properties) {
                return new LogsData(properties);
              };
              LogsData.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.resourceLogs != null && message.resourceLogs.length)
                  for (var i2 = 0; i2 < message.resourceLogs.length; ++i2)
                    $root.opentelemetry.proto.logs.v1.ResourceLogs.encode(message.resourceLogs[i2], writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                return writer;
              };
              LogsData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              LogsData.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.logs.v1.LogsData();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 1: {
                      if (!(message.resourceLogs && message.resourceLogs.length))
                        message.resourceLogs = [];
                      message.resourceLogs.push($root.opentelemetry.proto.logs.v1.ResourceLogs.decode(reader, reader.uint32()));
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              LogsData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              LogsData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.resourceLogs != null && message.hasOwnProperty("resourceLogs")) {
                  if (!Array.isArray(message.resourceLogs))
                    return "resourceLogs: array expected";
                  for (var i2 = 0; i2 < message.resourceLogs.length; ++i2) {
                    var error = $root.opentelemetry.proto.logs.v1.ResourceLogs.verify(message.resourceLogs[i2]);
                    if (error)
                      return "resourceLogs." + error;
                  }
                }
                return null;
              };
              LogsData.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.logs.v1.LogsData)
                  return object2;
                var message = new $root.opentelemetry.proto.logs.v1.LogsData();
                if (object2.resourceLogs) {
                  if (!Array.isArray(object2.resourceLogs))
                    throw TypeError(".opentelemetry.proto.logs.v1.LogsData.resourceLogs: array expected");
                  message.resourceLogs = [];
                  for (var i2 = 0; i2 < object2.resourceLogs.length; ++i2) {
                    if (typeof object2.resourceLogs[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.logs.v1.LogsData.resourceLogs: object expected");
                    message.resourceLogs[i2] = $root.opentelemetry.proto.logs.v1.ResourceLogs.fromObject(object2.resourceLogs[i2]);
                  }
                }
                return message;
              };
              LogsData.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults)
                  object2.resourceLogs = [];
                if (message.resourceLogs && message.resourceLogs.length) {
                  object2.resourceLogs = [];
                  for (var j2 = 0; j2 < message.resourceLogs.length; ++j2)
                    object2.resourceLogs[j2] = $root.opentelemetry.proto.logs.v1.ResourceLogs.toObject(message.resourceLogs[j2], options);
                }
                return object2;
              };
              LogsData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              LogsData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.logs.v1.LogsData";
              };
              return LogsData;
            }();
            v1.ResourceLogs = function() {
              function ResourceLogs(properties) {
                this.scopeLogs = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              ResourceLogs.prototype.resource = null;
              ResourceLogs.prototype.scopeLogs = $util.emptyArray;
              ResourceLogs.prototype.schemaUrl = null;
              ResourceLogs.create = function create2(properties) {
                return new ResourceLogs(properties);
              };
              ResourceLogs.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.resource != null && Object.hasOwnProperty.call(message, "resource"))
                  $root.opentelemetry.proto.resource.v1.Resource.encode(message.resource, writer.uint32(
                    /* id 1, wireType 2 =*/
                    10
                  ).fork()).ldelim();
                if (message.scopeLogs != null && message.scopeLogs.length)
                  for (var i2 = 0; i2 < message.scopeLogs.length; ++i2)
                    $root.opentelemetry.proto.logs.v1.ScopeLogs.encode(message.scopeLogs[i2], writer.uint32(
                      /* id 2, wireType 2 =*/
                      18
                    ).fork()).ldelim();
                if (message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl"))
                  writer.uint32(
                    /* id 3, wireType 2 =*/
                    26
                  ).string(message.schemaUrl);
                return writer;
              };
              ResourceLogs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              ResourceLogs.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.logs.v1.ResourceLogs();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 1: {
                      message.resource = $root.opentelemetry.proto.resource.v1.Resource.decode(reader, reader.uint32());
                      break;
                    }
                    case 2: {
                      if (!(message.scopeLogs && message.scopeLogs.length))
                        message.scopeLogs = [];
                      message.scopeLogs.push($root.opentelemetry.proto.logs.v1.ScopeLogs.decode(reader, reader.uint32()));
                      break;
                    }
                    case 3: {
                      message.schemaUrl = reader.string();
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              ResourceLogs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              ResourceLogs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.resource != null && message.hasOwnProperty("resource")) {
                  var error = $root.opentelemetry.proto.resource.v1.Resource.verify(message.resource);
                  if (error)
                    return "resource." + error;
                }
                if (message.scopeLogs != null && message.hasOwnProperty("scopeLogs")) {
                  if (!Array.isArray(message.scopeLogs))
                    return "scopeLogs: array expected";
                  for (var i2 = 0; i2 < message.scopeLogs.length; ++i2) {
                    var error = $root.opentelemetry.proto.logs.v1.ScopeLogs.verify(message.scopeLogs[i2]);
                    if (error)
                      return "scopeLogs." + error;
                  }
                }
                if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl")) {
                  if (!$util.isString(message.schemaUrl))
                    return "schemaUrl: string expected";
                }
                return null;
              };
              ResourceLogs.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.logs.v1.ResourceLogs)
                  return object2;
                var message = new $root.opentelemetry.proto.logs.v1.ResourceLogs();
                if (object2.resource != null) {
                  if (typeof object2.resource !== "object")
                    throw TypeError(".opentelemetry.proto.logs.v1.ResourceLogs.resource: object expected");
                  message.resource = $root.opentelemetry.proto.resource.v1.Resource.fromObject(object2.resource);
                }
                if (object2.scopeLogs) {
                  if (!Array.isArray(object2.scopeLogs))
                    throw TypeError(".opentelemetry.proto.logs.v1.ResourceLogs.scopeLogs: array expected");
                  message.scopeLogs = [];
                  for (var i2 = 0; i2 < object2.scopeLogs.length; ++i2) {
                    if (typeof object2.scopeLogs[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.logs.v1.ResourceLogs.scopeLogs: object expected");
                    message.scopeLogs[i2] = $root.opentelemetry.proto.logs.v1.ScopeLogs.fromObject(object2.scopeLogs[i2]);
                  }
                }
                if (object2.schemaUrl != null)
                  message.schemaUrl = String(object2.schemaUrl);
                return message;
              };
              ResourceLogs.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults)
                  object2.scopeLogs = [];
                if (options.defaults) {
                  object2.resource = null;
                  object2.schemaUrl = "";
                }
                if (message.resource != null && message.hasOwnProperty("resource"))
                  object2.resource = $root.opentelemetry.proto.resource.v1.Resource.toObject(message.resource, options);
                if (message.scopeLogs && message.scopeLogs.length) {
                  object2.scopeLogs = [];
                  for (var j2 = 0; j2 < message.scopeLogs.length; ++j2)
                    object2.scopeLogs[j2] = $root.opentelemetry.proto.logs.v1.ScopeLogs.toObject(message.scopeLogs[j2], options);
                }
                if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
                  object2.schemaUrl = message.schemaUrl;
                return object2;
              };
              ResourceLogs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              ResourceLogs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.logs.v1.ResourceLogs";
              };
              return ResourceLogs;
            }();
            v1.ScopeLogs = function() {
              function ScopeLogs(properties) {
                this.logRecords = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              ScopeLogs.prototype.scope = null;
              ScopeLogs.prototype.logRecords = $util.emptyArray;
              ScopeLogs.prototype.schemaUrl = null;
              ScopeLogs.create = function create2(properties) {
                return new ScopeLogs(properties);
              };
              ScopeLogs.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.scope != null && Object.hasOwnProperty.call(message, "scope"))
                  $root.opentelemetry.proto.common.v1.InstrumentationScope.encode(message.scope, writer.uint32(
                    /* id 1, wireType 2 =*/
                    10
                  ).fork()).ldelim();
                if (message.logRecords != null && message.logRecords.length)
                  for (var i2 = 0; i2 < message.logRecords.length; ++i2)
                    $root.opentelemetry.proto.logs.v1.LogRecord.encode(message.logRecords[i2], writer.uint32(
                      /* id 2, wireType 2 =*/
                      18
                    ).fork()).ldelim();
                if (message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl"))
                  writer.uint32(
                    /* id 3, wireType 2 =*/
                    26
                  ).string(message.schemaUrl);
                return writer;
              };
              ScopeLogs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              ScopeLogs.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.logs.v1.ScopeLogs();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 1: {
                      message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.decode(reader, reader.uint32());
                      break;
                    }
                    case 2: {
                      if (!(message.logRecords && message.logRecords.length))
                        message.logRecords = [];
                      message.logRecords.push($root.opentelemetry.proto.logs.v1.LogRecord.decode(reader, reader.uint32()));
                      break;
                    }
                    case 3: {
                      message.schemaUrl = reader.string();
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              ScopeLogs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              ScopeLogs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.scope != null && message.hasOwnProperty("scope")) {
                  var error = $root.opentelemetry.proto.common.v1.InstrumentationScope.verify(message.scope);
                  if (error)
                    return "scope." + error;
                }
                if (message.logRecords != null && message.hasOwnProperty("logRecords")) {
                  if (!Array.isArray(message.logRecords))
                    return "logRecords: array expected";
                  for (var i2 = 0; i2 < message.logRecords.length; ++i2) {
                    var error = $root.opentelemetry.proto.logs.v1.LogRecord.verify(message.logRecords[i2]);
                    if (error)
                      return "logRecords." + error;
                  }
                }
                if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl")) {
                  if (!$util.isString(message.schemaUrl))
                    return "schemaUrl: string expected";
                }
                return null;
              };
              ScopeLogs.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.logs.v1.ScopeLogs)
                  return object2;
                var message = new $root.opentelemetry.proto.logs.v1.ScopeLogs();
                if (object2.scope != null) {
                  if (typeof object2.scope !== "object")
                    throw TypeError(".opentelemetry.proto.logs.v1.ScopeLogs.scope: object expected");
                  message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.fromObject(object2.scope);
                }
                if (object2.logRecords) {
                  if (!Array.isArray(object2.logRecords))
                    throw TypeError(".opentelemetry.proto.logs.v1.ScopeLogs.logRecords: array expected");
                  message.logRecords = [];
                  for (var i2 = 0; i2 < object2.logRecords.length; ++i2) {
                    if (typeof object2.logRecords[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.logs.v1.ScopeLogs.logRecords: object expected");
                    message.logRecords[i2] = $root.opentelemetry.proto.logs.v1.LogRecord.fromObject(object2.logRecords[i2]);
                  }
                }
                if (object2.schemaUrl != null)
                  message.schemaUrl = String(object2.schemaUrl);
                return message;
              };
              ScopeLogs.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults)
                  object2.logRecords = [];
                if (options.defaults) {
                  object2.scope = null;
                  object2.schemaUrl = "";
                }
                if (message.scope != null && message.hasOwnProperty("scope"))
                  object2.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.toObject(message.scope, options);
                if (message.logRecords && message.logRecords.length) {
                  object2.logRecords = [];
                  for (var j2 = 0; j2 < message.logRecords.length; ++j2)
                    object2.logRecords[j2] = $root.opentelemetry.proto.logs.v1.LogRecord.toObject(message.logRecords[j2], options);
                }
                if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
                  object2.schemaUrl = message.schemaUrl;
                return object2;
              };
              ScopeLogs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              ScopeLogs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.logs.v1.ScopeLogs";
              };
              return ScopeLogs;
            }();
            v1.SeverityNumber = function() {
              var valuesById = {}, values3 = Object.create(valuesById);
              values3[valuesById[0] = "SEVERITY_NUMBER_UNSPECIFIED"] = 0;
              values3[valuesById[1] = "SEVERITY_NUMBER_TRACE"] = 1;
              values3[valuesById[2] = "SEVERITY_NUMBER_TRACE2"] = 2;
              values3[valuesById[3] = "SEVERITY_NUMBER_TRACE3"] = 3;
              values3[valuesById[4] = "SEVERITY_NUMBER_TRACE4"] = 4;
              values3[valuesById[5] = "SEVERITY_NUMBER_DEBUG"] = 5;
              values3[valuesById[6] = "SEVERITY_NUMBER_DEBUG2"] = 6;
              values3[valuesById[7] = "SEVERITY_NUMBER_DEBUG3"] = 7;
              values3[valuesById[8] = "SEVERITY_NUMBER_DEBUG4"] = 8;
              values3[valuesById[9] = "SEVERITY_NUMBER_INFO"] = 9;
              values3[valuesById[10] = "SEVERITY_NUMBER_INFO2"] = 10;
              values3[valuesById[11] = "SEVERITY_NUMBER_INFO3"] = 11;
              values3[valuesById[12] = "SEVERITY_NUMBER_INFO4"] = 12;
              values3[valuesById[13] = "SEVERITY_NUMBER_WARN"] = 13;
              values3[valuesById[14] = "SEVERITY_NUMBER_WARN2"] = 14;
              values3[valuesById[15] = "SEVERITY_NUMBER_WARN3"] = 15;
              values3[valuesById[16] = "SEVERITY_NUMBER_WARN4"] = 16;
              values3[valuesById[17] = "SEVERITY_NUMBER_ERROR"] = 17;
              values3[valuesById[18] = "SEVERITY_NUMBER_ERROR2"] = 18;
              values3[valuesById[19] = "SEVERITY_NUMBER_ERROR3"] = 19;
              values3[valuesById[20] = "SEVERITY_NUMBER_ERROR4"] = 20;
              values3[valuesById[21] = "SEVERITY_NUMBER_FATAL"] = 21;
              values3[valuesById[22] = "SEVERITY_NUMBER_FATAL2"] = 22;
              values3[valuesById[23] = "SEVERITY_NUMBER_FATAL3"] = 23;
              values3[valuesById[24] = "SEVERITY_NUMBER_FATAL4"] = 24;
              return values3;
            }();
            v1.LogRecordFlags = function() {
              var valuesById = {}, values3 = Object.create(valuesById);
              values3[valuesById[0] = "LOG_RECORD_FLAGS_DO_NOT_USE"] = 0;
              values3[valuesById[255] = "LOG_RECORD_FLAGS_TRACE_FLAGS_MASK"] = 255;
              return values3;
            }();
            v1.LogRecord = function() {
              function LogRecord(properties) {
                this.attributes = [];
                if (properties) {
                  for (var keys4 = Object.keys(properties), i2 = 0; i2 < keys4.length; ++i2)
                    if (properties[keys4[i2]] != null)
                      this[keys4[i2]] = properties[keys4[i2]];
                }
              }
              LogRecord.prototype.timeUnixNano = null;
              LogRecord.prototype.observedTimeUnixNano = null;
              LogRecord.prototype.severityNumber = null;
              LogRecord.prototype.severityText = null;
              LogRecord.prototype.body = null;
              LogRecord.prototype.attributes = $util.emptyArray;
              LogRecord.prototype.droppedAttributesCount = null;
              LogRecord.prototype.flags = null;
              LogRecord.prototype.traceId = null;
              LogRecord.prototype.spanId = null;
              LogRecord.create = function create2(properties) {
                return new LogRecord(properties);
              };
              LogRecord.encode = function encode2(message, writer) {
                if (!writer)
                  writer = $Writer.create();
                if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano"))
                  writer.uint32(
                    /* id 1, wireType 1 =*/
                    9
                  ).fixed64(message.timeUnixNano);
                if (message.severityNumber != null && Object.hasOwnProperty.call(message, "severityNumber"))
                  writer.uint32(
                    /* id 2, wireType 0 =*/
                    16
                  ).int32(message.severityNumber);
                if (message.severityText != null && Object.hasOwnProperty.call(message, "severityText"))
                  writer.uint32(
                    /* id 3, wireType 2 =*/
                    26
                  ).string(message.severityText);
                if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                  $root.opentelemetry.proto.common.v1.AnyValue.encode(message.body, writer.uint32(
                    /* id 5, wireType 2 =*/
                    42
                  ).fork()).ldelim();
                if (message.attributes != null && message.attributes.length)
                  for (var i2 = 0; i2 < message.attributes.length; ++i2)
                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i2], writer.uint32(
                      /* id 6, wireType 2 =*/
                      50
                    ).fork()).ldelim();
                if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, "droppedAttributesCount"))
                  writer.uint32(
                    /* id 7, wireType 0 =*/
                    56
                  ).uint32(message.droppedAttributesCount);
                if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                  writer.uint32(
                    /* id 8, wireType 5 =*/
                    69
                  ).fixed32(message.flags);
                if (message.traceId != null && Object.hasOwnProperty.call(message, "traceId"))
                  writer.uint32(
                    /* id 9, wireType 2 =*/
                    74
                  ).bytes(message.traceId);
                if (message.spanId != null && Object.hasOwnProperty.call(message, "spanId"))
                  writer.uint32(
                    /* id 10, wireType 2 =*/
                    82
                  ).bytes(message.spanId);
                if (message.observedTimeUnixNano != null && Object.hasOwnProperty.call(message, "observedTimeUnixNano"))
                  writer.uint32(
                    /* id 11, wireType 1 =*/
                    89
                  ).fixed64(message.observedTimeUnixNano);
                return writer;
              };
              LogRecord.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };
              LogRecord.decode = function decode2(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                var end4 = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.logs.v1.LogRecord();
                while (reader.pos < end4) {
                  var tag2 = reader.uint32();
                  switch (tag2 >>> 3) {
                    case 1: {
                      message.timeUnixNano = reader.fixed64();
                      break;
                    }
                    case 11: {
                      message.observedTimeUnixNano = reader.fixed64();
                      break;
                    }
                    case 2: {
                      message.severityNumber = reader.int32();
                      break;
                    }
                    case 3: {
                      message.severityText = reader.string();
                      break;
                    }
                    case 5: {
                      message.body = $root.opentelemetry.proto.common.v1.AnyValue.decode(reader, reader.uint32());
                      break;
                    }
                    case 6: {
                      if (!(message.attributes && message.attributes.length))
                        message.attributes = [];
                      message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                      break;
                    }
                    case 7: {
                      message.droppedAttributesCount = reader.uint32();
                      break;
                    }
                    case 8: {
                      message.flags = reader.fixed32();
                      break;
                    }
                    case 9: {
                      message.traceId = reader.bytes();
                      break;
                    }
                    case 10: {
                      message.spanId = reader.bytes();
                      break;
                    }
                    default:
                      reader.skipType(tag2 & 7);
                      break;
                  }
                }
                return message;
              };
              LogRecord.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };
              LogRecord.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano")) {
                  if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
                    return "timeUnixNano: integer|Long expected";
                }
                if (message.observedTimeUnixNano != null && message.hasOwnProperty("observedTimeUnixNano")) {
                  if (!$util.isInteger(message.observedTimeUnixNano) && !(message.observedTimeUnixNano && $util.isInteger(message.observedTimeUnixNano.low) && $util.isInteger(message.observedTimeUnixNano.high)))
                    return "observedTimeUnixNano: integer|Long expected";
                }
                if (message.severityNumber != null && message.hasOwnProperty("severityNumber"))
                  switch (message.severityNumber) {
                    default:
                      return "severityNumber: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                      break;
                  }
                if (message.severityText != null && message.hasOwnProperty("severityText")) {
                  if (!$util.isString(message.severityText))
                    return "severityText: string expected";
                }
                if (message.body != null && message.hasOwnProperty("body")) {
                  var error = $root.opentelemetry.proto.common.v1.AnyValue.verify(message.body);
                  if (error)
                    return "body." + error;
                }
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                  if (!Array.isArray(message.attributes))
                    return "attributes: array expected";
                  for (var i2 = 0; i2 < message.attributes.length; ++i2) {
                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i2]);
                    if (error)
                      return "attributes." + error;
                  }
                }
                if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount")) {
                  if (!$util.isInteger(message.droppedAttributesCount))
                    return "droppedAttributesCount: integer expected";
                }
                if (message.flags != null && message.hasOwnProperty("flags")) {
                  if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
                }
                if (message.traceId != null && message.hasOwnProperty("traceId")) {
                  if (!(message.traceId && typeof message.traceId.length === "number" || $util.isString(message.traceId)))
                    return "traceId: buffer expected";
                }
                if (message.spanId != null && message.hasOwnProperty("spanId")) {
                  if (!(message.spanId && typeof message.spanId.length === "number" || $util.isString(message.spanId)))
                    return "spanId: buffer expected";
                }
                return null;
              };
              LogRecord.fromObject = function fromObject(object2) {
                if (object2 instanceof $root.opentelemetry.proto.logs.v1.LogRecord)
                  return object2;
                var message = new $root.opentelemetry.proto.logs.v1.LogRecord();
                if (object2.timeUnixNano != null) {
                  if ($util.Long)
                    (message.timeUnixNano = $util.Long.fromValue(object2.timeUnixNano)).unsigned = false;
                  else if (typeof object2.timeUnixNano === "string")
                    message.timeUnixNano = parseInt(object2.timeUnixNano, 10);
                  else if (typeof object2.timeUnixNano === "number")
                    message.timeUnixNano = object2.timeUnixNano;
                  else if (typeof object2.timeUnixNano === "object")
                    message.timeUnixNano = new $util.LongBits(object2.timeUnixNano.low >>> 0, object2.timeUnixNano.high >>> 0).toNumber();
                }
                if (object2.observedTimeUnixNano != null) {
                  if ($util.Long)
                    (message.observedTimeUnixNano = $util.Long.fromValue(object2.observedTimeUnixNano)).unsigned = false;
                  else if (typeof object2.observedTimeUnixNano === "string")
                    message.observedTimeUnixNano = parseInt(object2.observedTimeUnixNano, 10);
                  else if (typeof object2.observedTimeUnixNano === "number")
                    message.observedTimeUnixNano = object2.observedTimeUnixNano;
                  else if (typeof object2.observedTimeUnixNano === "object")
                    message.observedTimeUnixNano = new $util.LongBits(object2.observedTimeUnixNano.low >>> 0, object2.observedTimeUnixNano.high >>> 0).toNumber();
                }
                switch (object2.severityNumber) {
                  default:
                    if (typeof object2.severityNumber === "number") {
                      message.severityNumber = object2.severityNumber;
                      break;
                    }
                    break;
                  case "SEVERITY_NUMBER_UNSPECIFIED":
                  case 0:
                    message.severityNumber = 0;
                    break;
                  case "SEVERITY_NUMBER_TRACE":
                  case 1:
                    message.severityNumber = 1;
                    break;
                  case "SEVERITY_NUMBER_TRACE2":
                  case 2:
                    message.severityNumber = 2;
                    break;
                  case "SEVERITY_NUMBER_TRACE3":
                  case 3:
                    message.severityNumber = 3;
                    break;
                  case "SEVERITY_NUMBER_TRACE4":
                  case 4:
                    message.severityNumber = 4;
                    break;
                  case "SEVERITY_NUMBER_DEBUG":
                  case 5:
                    message.severityNumber = 5;
                    break;
                  case "SEVERITY_NUMBER_DEBUG2":
                  case 6:
                    message.severityNumber = 6;
                    break;
                  case "SEVERITY_NUMBER_DEBUG3":
                  case 7:
                    message.severityNumber = 7;
                    break;
                  case "SEVERITY_NUMBER_DEBUG4":
                  case 8:
                    message.severityNumber = 8;
                    break;
                  case "SEVERITY_NUMBER_INFO":
                  case 9:
                    message.severityNumber = 9;
                    break;
                  case "SEVERITY_NUMBER_INFO2":
                  case 10:
                    message.severityNumber = 10;
                    break;
                  case "SEVERITY_NUMBER_INFO3":
                  case 11:
                    message.severityNumber = 11;
                    break;
                  case "SEVERITY_NUMBER_INFO4":
                  case 12:
                    message.severityNumber = 12;
                    break;
                  case "SEVERITY_NUMBER_WARN":
                  case 13:
                    message.severityNumber = 13;
                    break;
                  case "SEVERITY_NUMBER_WARN2":
                  case 14:
                    message.severityNumber = 14;
                    break;
                  case "SEVERITY_NUMBER_WARN3":
                  case 15:
                    message.severityNumber = 15;
                    break;
                  case "SEVERITY_NUMBER_WARN4":
                  case 16:
                    message.severityNumber = 16;
                    break;
                  case "SEVERITY_NUMBER_ERROR":
                  case 17:
                    message.severityNumber = 17;
                    break;
                  case "SEVERITY_NUMBER_ERROR2":
                  case 18:
                    message.severityNumber = 18;
                    break;
                  case "SEVERITY_NUMBER_ERROR3":
                  case 19:
                    message.severityNumber = 19;
                    break;
                  case "SEVERITY_NUMBER_ERROR4":
                  case 20:
                    message.severityNumber = 20;
                    break;
                  case "SEVERITY_NUMBER_FATAL":
                  case 21:
                    message.severityNumber = 21;
                    break;
                  case "SEVERITY_NUMBER_FATAL2":
                  case 22:
                    message.severityNumber = 22;
                    break;
                  case "SEVERITY_NUMBER_FATAL3":
                  case 23:
                    message.severityNumber = 23;
                    break;
                  case "SEVERITY_NUMBER_FATAL4":
                  case 24:
                    message.severityNumber = 24;
                    break;
                }
                if (object2.severityText != null)
                  message.severityText = String(object2.severityText);
                if (object2.body != null) {
                  if (typeof object2.body !== "object")
                    throw TypeError(".opentelemetry.proto.logs.v1.LogRecord.body: object expected");
                  message.body = $root.opentelemetry.proto.common.v1.AnyValue.fromObject(object2.body);
                }
                if (object2.attributes) {
                  if (!Array.isArray(object2.attributes))
                    throw TypeError(".opentelemetry.proto.logs.v1.LogRecord.attributes: array expected");
                  message.attributes = [];
                  for (var i2 = 0; i2 < object2.attributes.length; ++i2) {
                    if (typeof object2.attributes[i2] !== "object")
                      throw TypeError(".opentelemetry.proto.logs.v1.LogRecord.attributes: object expected");
                    message.attributes[i2] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object2.attributes[i2]);
                  }
                }
                if (object2.droppedAttributesCount != null)
                  message.droppedAttributesCount = object2.droppedAttributesCount >>> 0;
                if (object2.flags != null)
                  message.flags = object2.flags >>> 0;
                if (object2.traceId != null) {
                  if (typeof object2.traceId === "string")
                    $util.base64.decode(object2.traceId, message.traceId = $util.newBuffer($util.base64.length(object2.traceId)), 0);
                  else if (object2.traceId.length >= 0)
                    message.traceId = object2.traceId;
                }
                if (object2.spanId != null) {
                  if (typeof object2.spanId === "string")
                    $util.base64.decode(object2.spanId, message.spanId = $util.newBuffer($util.base64.length(object2.spanId)), 0);
                  else if (object2.spanId.length >= 0)
                    message.spanId = object2.spanId;
                }
                return message;
              };
              LogRecord.toObject = function toObject(message, options) {
                if (!options)
                  options = {};
                var object2 = {};
                if (options.arrays || options.defaults)
                  object2.attributes = [];
                if (options.defaults) {
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object2.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object2.timeUnixNano = options.longs === String ? "0" : 0;
                  object2.severityNumber = options.enums === String ? "SEVERITY_NUMBER_UNSPECIFIED" : 0;
                  object2.severityText = "";
                  object2.body = null;
                  object2.droppedAttributesCount = 0;
                  object2.flags = 0;
                  if (options.bytes === String)
                    object2.traceId = "";
                  else {
                    object2.traceId = [];
                    if (options.bytes !== Array)
                      object2.traceId = $util.newBuffer(object2.traceId);
                  }
                  if (options.bytes === String)
                    object2.spanId = "";
                  else {
                    object2.spanId = [];
                    if (options.bytes !== Array)
                      object2.spanId = $util.newBuffer(object2.spanId);
                  }
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object2.observedTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object2.observedTimeUnixNano = options.longs === String ? "0" : 0;
                }
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
                  if (typeof message.timeUnixNano === "number")
                    object2.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;
                  else
                    object2.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;
                if (message.severityNumber != null && message.hasOwnProperty("severityNumber"))
                  object2.severityNumber = options.enums === String ? $root.opentelemetry.proto.logs.v1.SeverityNumber[message.severityNumber] === void 0 ? message.severityNumber : $root.opentelemetry.proto.logs.v1.SeverityNumber[message.severityNumber] : message.severityNumber;
                if (message.severityText != null && message.hasOwnProperty("severityText"))
                  object2.severityText = message.severityText;
                if (message.body != null && message.hasOwnProperty("body"))
                  object2.body = $root.opentelemetry.proto.common.v1.AnyValue.toObject(message.body, options);
                if (message.attributes && message.attributes.length) {
                  object2.attributes = [];
                  for (var j2 = 0; j2 < message.attributes.length; ++j2)
                    object2.attributes[j2] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j2], options);
                }
                if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount"))
                  object2.droppedAttributesCount = message.droppedAttributesCount;
                if (message.flags != null && message.hasOwnProperty("flags"))
                  object2.flags = message.flags;
                if (message.traceId != null && message.hasOwnProperty("traceId"))
                  object2.traceId = options.bytes === String ? $util.base64.encode(message.traceId, 0, message.traceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.traceId) : message.traceId;
                if (message.spanId != null && message.hasOwnProperty("spanId"))
                  object2.spanId = options.bytes === String ? $util.base64.encode(message.spanId, 0, message.spanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spanId) : message.spanId;
                if (message.observedTimeUnixNano != null && message.hasOwnProperty("observedTimeUnixNano"))
                  if (typeof message.observedTimeUnixNano === "number")
                    object2.observedTimeUnixNano = options.longs === String ? String(message.observedTimeUnixNano) : message.observedTimeUnixNano;
                  else
                    object2.observedTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.observedTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.observedTimeUnixNano.low >>> 0, message.observedTimeUnixNano.high >>> 0).toNumber() : message.observedTimeUnixNano;
                return object2;
              };
              LogRecord.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };
              LogRecord.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === void 0) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/opentelemetry.proto.logs.v1.LogRecord";
              };
              return LogRecord;
            }();
            return v1;
          }();
          return logs;
        }();
        return proto;
      }();
      return opentelemetry;
    }();
    module.exports = $root;
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/build/src/serializers.js
var require_serializers = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/build/src/serializers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MetricsSerializer = exports.TraceSerializer = exports.LogsSerializer = void 0;
    var root = require_root();
    var logsResponseType = root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse;
    var logsRequestType = root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest;
    var metricsResponseType = root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse;
    var metricsRequestType = root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest;
    var traceResponseType = root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse;
    var traceRequestType = root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;
    exports.LogsSerializer = {
      serializeRequest: (arg) => {
        return Buffer.from(logsRequestType.encode(arg).finish());
      },
      deserializeResponse: (arg) => {
        return logsResponseType.decode(arg);
      }
    };
    exports.TraceSerializer = {
      serializeRequest: (arg) => {
        return Buffer.from(traceRequestType.encode(arg).finish());
      },
      deserializeResponse: (arg) => {
        return traceResponseType.decode(arg);
      }
    };
    exports.MetricsSerializer = {
      serializeRequest: (arg) => {
        return Buffer.from(metricsRequestType.encode(arg).finish());
      },
      deserializeResponse: (arg) => {
        return metricsResponseType.decode(arg);
      }
    };
  }
});

// node_modules/@opentelemetry/otlp-grpc-exporter-base/build/src/index.js
var require_src13 = __commonJS({
  "node_modules/@opentelemetry/otlp-grpc-exporter-base/build/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LogsSerializer = exports.TraceSerializer = exports.MetricsSerializer = exports.validateAndNormalizeUrl = exports.DEFAULT_COLLECTOR_URL = exports.OTLPGRPCExporterNodeBase = void 0;
    var OTLPGRPCExporterNodeBase_1 = require_OTLPGRPCExporterNodeBase();
    Object.defineProperty(exports, "OTLPGRPCExporterNodeBase", { enumerable: true, get: function() {
      return OTLPGRPCExporterNodeBase_1.OTLPGRPCExporterNodeBase;
    } });
    var util_1 = require_util5();
    Object.defineProperty(exports, "DEFAULT_COLLECTOR_URL", { enumerable: true, get: function() {
      return util_1.DEFAULT_COLLECTOR_URL;
    } });
    Object.defineProperty(exports, "validateAndNormalizeUrl", { enumerable: true, get: function() {
      return util_1.validateAndNormalizeUrl;
    } });
    var serializers_1 = require_serializers();
    Object.defineProperty(exports, "MetricsSerializer", { enumerable: true, get: function() {
      return serializers_1.MetricsSerializer;
    } });
    Object.defineProperty(exports, "TraceSerializer", { enumerable: true, get: function() {
      return serializers_1.TraceSerializer;
    } });
    Object.defineProperty(exports, "LogsSerializer", { enumerable: true, get: function() {
      return serializers_1.LogsSerializer;
    } });
  }
});

// node_modules/@opentelemetry/otlp-transformer/build/src/common/types.js
var require_types6 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/build/src/common/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js
var require_suppress_tracing5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTracingSuppressed = exports.unsuppressTracing = exports.suppressTracing = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var SUPPRESS_TRACING_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
    function suppressTracing(context3) {
      return context3.setValue(SUPPRESS_TRACING_KEY, true);
    }
    exports.suppressTracing = suppressTracing;
    function unsuppressTracing(context3) {
      return context3.deleteValue(SUPPRESS_TRACING_KEY);
    }
    exports.unsuppressTracing = unsuppressTracing;
    function isTracingSuppressed(context3) {
      return context3.getValue(SUPPRESS_TRACING_KEY) === true;
    }
    exports.isTracingSuppressed = isTracingSuppressed;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/baggage/constants.js
var require_constants6 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/baggage/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BAGGAGE_MAX_TOTAL_LENGTH = exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = exports.BAGGAGE_HEADER = exports.BAGGAGE_ITEMS_SEPARATOR = exports.BAGGAGE_PROPERTIES_SEPARATOR = exports.BAGGAGE_KEY_PAIR_SEPARATOR = void 0;
    exports.BAGGAGE_KEY_PAIR_SEPARATOR = "=";
    exports.BAGGAGE_PROPERTIES_SEPARATOR = ";";
    exports.BAGGAGE_ITEMS_SEPARATOR = ",";
    exports.BAGGAGE_HEADER = "baggage";
    exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
    exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
    exports.BAGGAGE_MAX_TOTAL_LENGTH = 8192;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/baggage/utils.js
var require_utils10 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/baggage/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseKeyPairsIntoRecord = exports.parsePairKeyValue = exports.getKeyPairs = exports.serializeKeyPairs = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var constants_1 = require_constants6();
    function serializeKeyPairs(keyPairs) {
      return keyPairs.reduce((hValue, current) => {
        const value = `${hValue}${hValue !== "" ? constants_1.BAGGAGE_ITEMS_SEPARATOR : ""}${current}`;
        return value.length > constants_1.BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
      }, "");
    }
    exports.serializeKeyPairs = serializeKeyPairs;
    function getKeyPairs(baggage) {
      return baggage.getAllEntries().map(([key, value]) => {
        let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;
        if (value.metadata !== void 0) {
          entry += constants_1.BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
        }
        return entry;
      });
    }
    exports.getKeyPairs = getKeyPairs;
    function parsePairKeyValue(entry) {
      const valueProps = entry.split(constants_1.BAGGAGE_PROPERTIES_SEPARATOR);
      if (valueProps.length <= 0)
        return;
      const keyPairPart = valueProps.shift();
      if (!keyPairPart)
        return;
      const separatorIndex = keyPairPart.indexOf(constants_1.BAGGAGE_KEY_PAIR_SEPARATOR);
      if (separatorIndex <= 0)
        return;
      const key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
      const value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
      let metadata;
      if (valueProps.length > 0) {
        metadata = (0, api_1.baggageEntryMetadataFromString)(valueProps.join(constants_1.BAGGAGE_PROPERTIES_SEPARATOR));
      }
      return { key, value, metadata };
    }
    exports.parsePairKeyValue = parsePairKeyValue;
    function parseKeyPairsIntoRecord(value) {
      if (typeof value !== "string" || value.length === 0)
        return {};
      return value.split(constants_1.BAGGAGE_ITEMS_SEPARATOR).map((entry) => {
        return parsePairKeyValue(entry);
      }).filter((keyPair) => keyPair !== void 0 && keyPair.value.length > 0).reduce((headers, keyPair) => {
        headers[keyPair.key] = keyPair.value;
        return headers;
      }, {});
    }
    exports.parseKeyPairsIntoRecord = parseKeyPairsIntoRecord;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js
var require_W3CBaggagePropagator5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.W3CBaggagePropagator = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing5();
    var constants_1 = require_constants6();
    var utils_1 = require_utils10();
    var W3CBaggagePropagator = class {
      inject(context3, carrier, setter) {
        const baggage = api_1.propagation.getBaggage(context3);
        if (!baggage || (0, suppress_tracing_1.isTracingSuppressed)(context3))
          return;
        const keyPairs = (0, utils_1.getKeyPairs)(baggage).filter((pair) => {
          return pair.length <= constants_1.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
        }).slice(0, constants_1.BAGGAGE_MAX_NAME_VALUE_PAIRS);
        const headerValue = (0, utils_1.serializeKeyPairs)(keyPairs);
        if (headerValue.length > 0) {
          setter.set(carrier, constants_1.BAGGAGE_HEADER, headerValue);
        }
      }
      extract(context3, carrier, getter) {
        const headerValue = getter.get(carrier, constants_1.BAGGAGE_HEADER);
        const baggageString = Array.isArray(headerValue) ? headerValue.join(constants_1.BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString)
          return context3;
        const baggage = {};
        if (baggageString.length === 0) {
          return context3;
        }
        const pairs = baggageString.split(constants_1.BAGGAGE_ITEMS_SEPARATOR);
        pairs.forEach((entry) => {
          const keyPair = (0, utils_1.parsePairKeyValue)(entry);
          if (keyPair) {
            const baggageEntry = { value: keyPair.value };
            if (keyPair.metadata) {
              baggageEntry.metadata = keyPair.metadata;
            }
            baggage[keyPair.key] = baggageEntry;
          }
        });
        if (Object.entries(baggage).length === 0) {
          return context3;
        }
        return api_1.propagation.setBaggage(context3, api_1.propagation.createBaggage(baggage));
      }
      fields() {
        return [constants_1.BAGGAGE_HEADER];
      }
    };
    exports.W3CBaggagePropagator = W3CBaggagePropagator;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/common/anchored-clock.js
var require_anchored_clock5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/common/anchored-clock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnchoredClock = void 0;
    var AnchoredClock = class {
      /**
       * Create a new AnchoredClock anchored to the current time returned by systemClock.
       *
       * @param systemClock should be a clock that returns the number of milliseconds since January 1 1970 such as Date
       * @param monotonicClock should be a clock that counts milliseconds monotonically such as window.performance or perf_hooks.performance
       */
      constructor(systemClock, monotonicClock) {
        this._monotonicClock = monotonicClock;
        this._epochMillis = systemClock.now();
        this._performanceMillis = monotonicClock.now();
      }
      /**
       * Returns the current time by adding the number of milliseconds since the
       * AnchoredClock was created to the creation epoch time
       */
      now() {
        const delta = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + delta;
      }
    };
    exports.AnchoredClock = AnchoredClock;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/common/attributes.js
var require_attributes5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/common/attributes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAttributeValue = exports.isAttributeKey = exports.sanitizeAttributes = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    function sanitizeAttributes(attributes) {
      const out = {};
      if (typeof attributes !== "object" || attributes == null) {
        return out;
      }
      for (const [key, val] of Object.entries(attributes)) {
        if (!isAttributeKey(key)) {
          api_1.diag.warn(`Invalid attribute key: ${key}`);
          continue;
        }
        if (!isAttributeValue(val)) {
          api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
          continue;
        }
        if (Array.isArray(val)) {
          out[key] = val.slice();
        } else {
          out[key] = val;
        }
      }
      return out;
    }
    exports.sanitizeAttributes = sanitizeAttributes;
    function isAttributeKey(key) {
      return typeof key === "string" && key.length > 0;
    }
    exports.isAttributeKey = isAttributeKey;
    function isAttributeValue(val) {
      if (val == null) {
        return true;
      }
      if (Array.isArray(val)) {
        return isHomogeneousAttributeValueArray(val);
      }
      return isValidPrimitiveAttributeValue(val);
    }
    exports.isAttributeValue = isAttributeValue;
    function isHomogeneousAttributeValueArray(arr) {
      let type;
      for (const element of arr) {
        if (element == null)
          continue;
        if (!type) {
          if (isValidPrimitiveAttributeValue(element)) {
            type = typeof element;
            continue;
          }
          return false;
        }
        if (typeof element === type) {
          continue;
        }
        return false;
      }
      return true;
    }
    function isValidPrimitiveAttributeValue(val) {
      switch (typeof val) {
        case "number":
        case "boolean":
        case "string":
          return true;
      }
      return false;
    }
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js
var require_logging_error_handler5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loggingErrorHandler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    function loggingErrorHandler() {
      return (ex) => {
        api_1.diag.error(stringifyException(ex));
      };
    }
    exports.loggingErrorHandler = loggingErrorHandler;
    function stringifyException(ex) {
      if (typeof ex === "string") {
        return ex;
      } else {
        return JSON.stringify(flattenException(ex));
      }
    }
    function flattenException(ex) {
      const result4 = {};
      let current = ex;
      while (current !== null) {
        Object.getOwnPropertyNames(current).forEach((propertyName) => {
          if (result4[propertyName])
            return;
          const value = current[propertyName];
          if (value) {
            result4[propertyName] = String(value);
          }
        });
        current = Object.getPrototypeOf(current);
      }
      return result4;
    }
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/common/global-error-handler.js
var require_global_error_handler5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/common/global-error-handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.globalErrorHandler = exports.setGlobalErrorHandler = void 0;
    var logging_error_handler_1 = require_logging_error_handler5();
    var delegateHandler = (0, logging_error_handler_1.loggingErrorHandler)();
    function setGlobalErrorHandler(handler) {
      delegateHandler = handler;
    }
    exports.setGlobalErrorHandler = setGlobalErrorHandler;
    function globalErrorHandler(ex) {
      try {
        delegateHandler(ex);
      } catch (_a12) {
      }
    }
    exports.globalErrorHandler = globalErrorHandler;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/utils/sampling.js
var require_sampling5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/utils/sampling.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TracesSamplerValues = void 0;
    var TracesSamplerValues;
    (function(TracesSamplerValues2) {
      TracesSamplerValues2["AlwaysOff"] = "always_off";
      TracesSamplerValues2["AlwaysOn"] = "always_on";
      TracesSamplerValues2["ParentBasedAlwaysOff"] = "parentbased_always_off";
      TracesSamplerValues2["ParentBasedAlwaysOn"] = "parentbased_always_on";
      TracesSamplerValues2["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
      TracesSamplerValues2["TraceIdRatio"] = "traceidratio";
    })(TracesSamplerValues = exports.TracesSamplerValues || (exports.TracesSamplerValues = {}));
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/utils/environment.js
var require_environment10 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/utils/environment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseEnvironment = exports.DEFAULT_ENVIRONMENT = exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var sampling_1 = require_sampling5();
    var DEFAULT_LIST_SEPARATOR = ",";
    var ENVIRONMENT_BOOLEAN_KEYS = ["OTEL_SDK_DISABLED"];
    function isEnvVarABoolean(key) {
      return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_NUMBERS_KEYS = [
      "OTEL_BSP_EXPORT_TIMEOUT",
      "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BSP_MAX_QUEUE_SIZE",
      "OTEL_BSP_SCHEDULE_DELAY",
      "OTEL_BLRP_EXPORT_TIMEOUT",
      "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BLRP_MAX_QUEUE_SIZE",
      "OTEL_BLRP_SCHEDULE_DELAY",
      "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_LINK_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT",
      "OTEL_EXPORTER_OTLP_TIMEOUT",
      "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
      "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
      "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT",
      "OTEL_EXPORTER_JAEGER_AGENT_PORT"
    ];
    function isEnvVarANumber(key) {
      return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_LISTS_KEYS = [
      "OTEL_NO_PATCH_MODULES",
      "OTEL_PROPAGATORS"
    ];
    function isEnvVarAList(key) {
      return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
    }
    exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
    exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
    exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
    exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
    exports.DEFAULT_ENVIRONMENT = {
      OTEL_SDK_DISABLED: false,
      CONTAINER_NAME: "",
      ECS_CONTAINER_METADATA_URI_V4: "",
      ECS_CONTAINER_METADATA_URI: "",
      HOSTNAME: "",
      KUBERNETES_SERVICE_HOST: "",
      NAMESPACE: "",
      OTEL_BSP_EXPORT_TIMEOUT: 3e4,
      OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BSP_MAX_QUEUE_SIZE: 2048,
      OTEL_BSP_SCHEDULE_DELAY: 5e3,
      OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
      OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
      OTEL_BLRP_SCHEDULE_DELAY: 5e3,
      OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
      OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
      OTEL_EXPORTER_JAEGER_ENDPOINT: "",
      OTEL_EXPORTER_JAEGER_PASSWORD: "",
      OTEL_EXPORTER_JAEGER_USER: "",
      OTEL_EXPORTER_OTLP_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_HEADERS: "",
      OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
      OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
      OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
      OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
      OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
      OTEL_LOG_LEVEL: api_1.DiagLogLevel.INFO,
      OTEL_NO_PATCH_MODULES: [],
      OTEL_PROPAGATORS: ["tracecontext", "baggage"],
      OTEL_RESOURCE_ATTRIBUTES: "",
      OTEL_SERVICE_NAME: "",
      OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
      OTEL_SPAN_LINK_COUNT_LIMIT: 128,
      OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
      OTEL_TRACES_EXPORTER: "",
      OTEL_TRACES_SAMPLER: sampling_1.TracesSamplerValues.ParentBasedAlwaysOn,
      OTEL_TRACES_SAMPLER_ARG: "",
      OTEL_LOGS_EXPORTER: "",
      OTEL_EXPORTER_OTLP_INSECURE: "",
      OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
      OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
      OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
      OTEL_EXPORTER_OTLP_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative"
    };
    function parseBoolean(key, environment5, values3) {
      if (typeof values3[key] === "undefined") {
        return;
      }
      const value = String(values3[key]);
      environment5[key] = value.toLowerCase() === "true";
    }
    function parseNumber(name, environment5, values3, min2 = -Infinity, max2 = Infinity) {
      if (typeof values3[name] !== "undefined") {
        const value = Number(values3[name]);
        if (!isNaN(value)) {
          if (value < min2) {
            environment5[name] = min2;
          } else if (value > max2) {
            environment5[name] = max2;
          } else {
            environment5[name] = value;
          }
        }
      }
    }
    function parseStringList(name, output, input, separator = DEFAULT_LIST_SEPARATOR) {
      const givenValue = input[name];
      if (typeof givenValue === "string") {
        output[name] = givenValue.split(separator).map((v2) => v2.trim());
      }
    }
    var logLevelMap = {
      ALL: api_1.DiagLogLevel.ALL,
      VERBOSE: api_1.DiagLogLevel.VERBOSE,
      DEBUG: api_1.DiagLogLevel.DEBUG,
      INFO: api_1.DiagLogLevel.INFO,
      WARN: api_1.DiagLogLevel.WARN,
      ERROR: api_1.DiagLogLevel.ERROR,
      NONE: api_1.DiagLogLevel.NONE
    };
    function setLogLevelFromEnv(key, environment5, values3) {
      const value = values3[key];
      if (typeof value === "string") {
        const theLevel = logLevelMap[value.toUpperCase()];
        if (theLevel != null) {
          environment5[key] = theLevel;
        }
      }
    }
    function parseEnvironment(values3) {
      const environment5 = {};
      for (const env in exports.DEFAULT_ENVIRONMENT) {
        const key = env;
        switch (key) {
          case "OTEL_LOG_LEVEL":
            setLogLevelFromEnv(key, environment5, values3);
            break;
          default:
            if (isEnvVarABoolean(key)) {
              parseBoolean(key, environment5, values3);
            } else if (isEnvVarANumber(key)) {
              parseNumber(key, environment5, values3);
            } else if (isEnvVarAList(key)) {
              parseStringList(key, environment5, values3);
            } else {
              const value = values3[key];
              if (typeof value !== "undefined" && value !== null) {
                environment5[key] = String(value);
              }
            }
        }
      }
      return environment5;
    }
    exports.parseEnvironment = parseEnvironment;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/platform/node/environment.js
var require_environment11 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/platform/node/environment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnvWithoutDefaults = exports.getEnv = void 0;
    var environment_1 = require_environment10();
    function getEnv() {
      const processEnv = (0, environment_1.parseEnvironment)(process.env);
      return Object.assign({}, environment_1.DEFAULT_ENVIRONMENT, processEnv);
    }
    exports.getEnv = getEnv;
    function getEnvWithoutDefaults() {
      return (0, environment_1.parseEnvironment)(process.env);
    }
    exports.getEnvWithoutDefaults = getEnvWithoutDefaults;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js
var require_globalThis5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._globalThis = void 0;
    exports._globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/common/hex-to-binary.js
var require_hex_to_binary5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/common/hex-to-binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hexToBinary = void 0;
    function intValue(charCode) {
      if (charCode >= 48 && charCode <= 57) {
        return charCode - 48;
      }
      if (charCode >= 97 && charCode <= 102) {
        return charCode - 87;
      }
      return charCode - 55;
    }
    function hexToBinary(hexStr) {
      const buf = new Uint8Array(hexStr.length / 2);
      let offset = 0;
      for (let i2 = 0; i2 < hexStr.length; i2 += 2) {
        const hi = intValue(hexStr.charCodeAt(i2));
        const lo = intValue(hexStr.charCodeAt(i2 + 1));
        buf[offset++] = hi << 4 | lo;
      }
      return buf;
    }
    exports.hexToBinary = hexToBinary;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js
var require_hex_to_base645 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hexToBase64 = void 0;
    var hex_to_binary_1 = require_hex_to_binary5();
    function hexToBase64(hexStr) {
      return Buffer.from((0, hex_to_binary_1.hexToBinary)(hexStr)).toString("base64");
    }
    exports.hexToBase64 = hexToBase64;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js
var require_RandomIdGenerator6 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RandomIdGenerator = void 0;
    var SPAN_ID_BYTES = 8;
    var TRACE_ID_BYTES = 16;
    var RandomIdGenerator = class {
      constructor() {
        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
        this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
      }
    };
    exports.RandomIdGenerator = RandomIdGenerator;
    var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
    function getIdGenerator(bytes) {
      return function generateId() {
        for (let i2 = 0; i2 < bytes / 4; i2++) {
          SHARED_BUFFER.writeUInt32BE(Math.random() * 2 ** 32 >>> 0, i2 * 4);
        }
        for (let i2 = 0; i2 < bytes; i2++) {
          if (SHARED_BUFFER[i2] > 0) {
            break;
          } else if (i2 === bytes - 1) {
            SHARED_BUFFER[bytes - 1] = 1;
          }
        }
        return SHARED_BUFFER.toString("hex", 0, bytes);
      };
    }
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/platform/node/performance.js
var require_performance5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/platform/node/performance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.otperformance = void 0;
    var perf_hooks_1 = __require("perf_hooks");
    exports.otperformance = perf_hooks_1.performance;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/version.js
var require_version5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VERSION = void 0;
    exports.VERSION = "1.24.1";
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/semantic-conventions/build/src/internal/utils.js
var require_utils11 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/semantic-conventions/build/src/internal/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConstMap = void 0;
    // @__NO_SIDE_EFFECTS__
    function createConstMap2(values3) {
      let res = {};
      const len = values3.length;
      for (let lp = 0; lp < len; lp++) {
        const val = values3[lp];
        if (val) {
          res[String(val).toUpperCase().replace(/[-.]/g, "_")] = val;
        }
      }
      return res;
    }
    exports.createConstMap = createConstMap2;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js
var require_SemanticAttributes4 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SEMATTRS_NET_HOST_CARRIER_ICC = exports.SEMATTRS_NET_HOST_CARRIER_MNC = exports.SEMATTRS_NET_HOST_CARRIER_MCC = exports.SEMATTRS_NET_HOST_CARRIER_NAME = exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = exports.SEMATTRS_NET_HOST_NAME = exports.SEMATTRS_NET_HOST_PORT = exports.SEMATTRS_NET_HOST_IP = exports.SEMATTRS_NET_PEER_NAME = exports.SEMATTRS_NET_PEER_PORT = exports.SEMATTRS_NET_PEER_IP = exports.SEMATTRS_NET_TRANSPORT = exports.SEMATTRS_FAAS_INVOKED_REGION = exports.SEMATTRS_FAAS_INVOKED_PROVIDER = exports.SEMATTRS_FAAS_INVOKED_NAME = exports.SEMATTRS_FAAS_COLDSTART = exports.SEMATTRS_FAAS_CRON = exports.SEMATTRS_FAAS_TIME = exports.SEMATTRS_FAAS_DOCUMENT_NAME = exports.SEMATTRS_FAAS_DOCUMENT_TIME = exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = exports.SEMATTRS_FAAS_EXECUTION = exports.SEMATTRS_FAAS_TRIGGER = exports.SEMATTRS_EXCEPTION_ESCAPED = exports.SEMATTRS_EXCEPTION_STACKTRACE = exports.SEMATTRS_EXCEPTION_MESSAGE = exports.SEMATTRS_EXCEPTION_TYPE = exports.SEMATTRS_DB_SQL_TABLE = exports.SEMATTRS_DB_MONGODB_COLLECTION = exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = exports.SEMATTRS_DB_HBASE_NAMESPACE = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = exports.SEMATTRS_DB_CASSANDRA_TABLE = exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = exports.SEMATTRS_DB_OPERATION = exports.SEMATTRS_DB_STATEMENT = exports.SEMATTRS_DB_NAME = exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = exports.SEMATTRS_DB_USER = exports.SEMATTRS_DB_CONNECTION_STRING = exports.SEMATTRS_DB_SYSTEM = exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = void 0;
    exports.SEMATTRS_MESSAGING_DESTINATION_KIND = exports.SEMATTRS_MESSAGING_DESTINATION = exports.SEMATTRS_MESSAGING_SYSTEM = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = exports.SEMATTRS_AWS_DYNAMODB_COUNT = exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_SELECT = exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = exports.SEMATTRS_AWS_DYNAMODB_LIMIT = exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = exports.SEMATTRS_HTTP_CLIENT_IP = exports.SEMATTRS_HTTP_ROUTE = exports.SEMATTRS_HTTP_SERVER_NAME = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = exports.SEMATTRS_HTTP_USER_AGENT = exports.SEMATTRS_HTTP_FLAVOR = exports.SEMATTRS_HTTP_STATUS_CODE = exports.SEMATTRS_HTTP_SCHEME = exports.SEMATTRS_HTTP_HOST = exports.SEMATTRS_HTTP_TARGET = exports.SEMATTRS_HTTP_URL = exports.SEMATTRS_HTTP_METHOD = exports.SEMATTRS_CODE_LINENO = exports.SEMATTRS_CODE_FILEPATH = exports.SEMATTRS_CODE_NAMESPACE = exports.SEMATTRS_CODE_FUNCTION = exports.SEMATTRS_THREAD_NAME = exports.SEMATTRS_THREAD_ID = exports.SEMATTRS_ENDUSER_SCOPE = exports.SEMATTRS_ENDUSER_ROLE = exports.SEMATTRS_ENDUSER_ID = exports.SEMATTRS_PEER_SERVICE = void 0;
    exports.DBSYSTEMVALUES_FILEMAKER = exports.DBSYSTEMVALUES_DERBY = exports.DBSYSTEMVALUES_FIREBIRD = exports.DBSYSTEMVALUES_ADABAS = exports.DBSYSTEMVALUES_CACHE = exports.DBSYSTEMVALUES_EDB = exports.DBSYSTEMVALUES_FIRSTSQL = exports.DBSYSTEMVALUES_INGRES = exports.DBSYSTEMVALUES_HANADB = exports.DBSYSTEMVALUES_MAXDB = exports.DBSYSTEMVALUES_PROGRESS = exports.DBSYSTEMVALUES_HSQLDB = exports.DBSYSTEMVALUES_CLOUDSCAPE = exports.DBSYSTEMVALUES_HIVE = exports.DBSYSTEMVALUES_REDSHIFT = exports.DBSYSTEMVALUES_POSTGRESQL = exports.DBSYSTEMVALUES_DB2 = exports.DBSYSTEMVALUES_ORACLE = exports.DBSYSTEMVALUES_MYSQL = exports.DBSYSTEMVALUES_MSSQL = exports.DBSYSTEMVALUES_OTHER_SQL = exports.SemanticAttributes = exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_ID = exports.SEMATTRS_MESSAGE_TYPE = exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = exports.SEMATTRS_RPC_JSONRPC_VERSION = exports.SEMATTRS_RPC_GRPC_STATUS_CODE = exports.SEMATTRS_RPC_METHOD = exports.SEMATTRS_RPC_SERVICE = exports.SEMATTRS_RPC_SYSTEM = exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = exports.SEMATTRS_MESSAGING_CONSUMER_ID = exports.SEMATTRS_MESSAGING_OPERATION = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = exports.SEMATTRS_MESSAGING_CONVERSATION_ID = exports.SEMATTRS_MESSAGING_MESSAGE_ID = exports.SEMATTRS_MESSAGING_URL = exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = exports.SEMATTRS_MESSAGING_PROTOCOL = exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = void 0;
    exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = exports.FaasDocumentOperationValues = exports.FAASDOCUMENTOPERATIONVALUES_DELETE = exports.FAASDOCUMENTOPERATIONVALUES_EDIT = exports.FAASDOCUMENTOPERATIONVALUES_INSERT = exports.FaasTriggerValues = exports.FAASTRIGGERVALUES_OTHER = exports.FAASTRIGGERVALUES_TIMER = exports.FAASTRIGGERVALUES_PUBSUB = exports.FAASTRIGGERVALUES_HTTP = exports.FAASTRIGGERVALUES_DATASOURCE = exports.DbCassandraConsistencyLevelValues = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = exports.DbSystemValues = exports.DBSYSTEMVALUES_COCKROACHDB = exports.DBSYSTEMVALUES_MEMCACHED = exports.DBSYSTEMVALUES_ELASTICSEARCH = exports.DBSYSTEMVALUES_GEODE = exports.DBSYSTEMVALUES_NEO4J = exports.DBSYSTEMVALUES_DYNAMODB = exports.DBSYSTEMVALUES_COSMOSDB = exports.DBSYSTEMVALUES_COUCHDB = exports.DBSYSTEMVALUES_COUCHBASE = exports.DBSYSTEMVALUES_REDIS = exports.DBSYSTEMVALUES_MONGODB = exports.DBSYSTEMVALUES_HBASE = exports.DBSYSTEMVALUES_CASSANDRA = exports.DBSYSTEMVALUES_COLDFUSION = exports.DBSYSTEMVALUES_H2 = exports.DBSYSTEMVALUES_VERTICA = exports.DBSYSTEMVALUES_TERADATA = exports.DBSYSTEMVALUES_SYBASE = exports.DBSYSTEMVALUES_SQLITE = exports.DBSYSTEMVALUES_POINTBASE = exports.DBSYSTEMVALUES_PERVASIVE = exports.DBSYSTEMVALUES_NETEZZA = exports.DBSYSTEMVALUES_MARIADB = exports.DBSYSTEMVALUES_INTERBASE = exports.DBSYSTEMVALUES_INSTANTDB = exports.DBSYSTEMVALUES_INFORMIX = void 0;
    exports.MESSAGINGOPERATIONVALUES_RECEIVE = exports.MessagingDestinationKindValues = exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = exports.HttpFlavorValues = exports.HTTPFLAVORVALUES_QUIC = exports.HTTPFLAVORVALUES_SPDY = exports.HTTPFLAVORVALUES_HTTP_2_0 = exports.HTTPFLAVORVALUES_HTTP_1_1 = exports.HTTPFLAVORVALUES_HTTP_1_0 = exports.NetHostConnectionSubtypeValues = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = exports.NetHostConnectionTypeValues = exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = exports.NETHOSTCONNECTIONTYPEVALUES_CELL = exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = exports.NetTransportValues = exports.NETTRANSPORTVALUES_OTHER = exports.NETTRANSPORTVALUES_INPROC = exports.NETTRANSPORTVALUES_PIPE = exports.NETTRANSPORTVALUES_UNIX = exports.NETTRANSPORTVALUES_IP = exports.NETTRANSPORTVALUES_IP_UDP = exports.NETTRANSPORTVALUES_IP_TCP = exports.FaasInvokedProviderValues = exports.FAASINVOKEDPROVIDERVALUES_GCP = exports.FAASINVOKEDPROVIDERVALUES_AZURE = exports.FAASINVOKEDPROVIDERVALUES_AWS = void 0;
    exports.MessageTypeValues = exports.MESSAGETYPEVALUES_RECEIVED = exports.MESSAGETYPEVALUES_SENT = exports.RpcGrpcStatusCodeValues = exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = exports.RPCGRPCSTATUSCODEVALUES_ABORTED = exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = exports.RPCGRPCSTATUSCODEVALUES_OK = exports.MessagingOperationValues = exports.MESSAGINGOPERATIONVALUES_PROCESS = void 0;
    var utils_1 = require_utils11();
    var TMP_AWS_LAMBDA_INVOKED_ARN2 = "aws.lambda.invoked_arn";
    var TMP_DB_SYSTEM2 = "db.system";
    var TMP_DB_CONNECTION_STRING2 = "db.connection_string";
    var TMP_DB_USER2 = "db.user";
    var TMP_DB_JDBC_DRIVER_CLASSNAME2 = "db.jdbc.driver_classname";
    var TMP_DB_NAME2 = "db.name";
    var TMP_DB_STATEMENT2 = "db.statement";
    var TMP_DB_OPERATION2 = "db.operation";
    var TMP_DB_MSSQL_INSTANCE_NAME2 = "db.mssql.instance_name";
    var TMP_DB_CASSANDRA_KEYSPACE2 = "db.cassandra.keyspace";
    var TMP_DB_CASSANDRA_PAGE_SIZE2 = "db.cassandra.page_size";
    var TMP_DB_CASSANDRA_CONSISTENCY_LEVEL2 = "db.cassandra.consistency_level";
    var TMP_DB_CASSANDRA_TABLE2 = "db.cassandra.table";
    var TMP_DB_CASSANDRA_IDEMPOTENCE2 = "db.cassandra.idempotence";
    var TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT2 = "db.cassandra.speculative_execution_count";
    var TMP_DB_CASSANDRA_COORDINATOR_ID2 = "db.cassandra.coordinator.id";
    var TMP_DB_CASSANDRA_COORDINATOR_DC2 = "db.cassandra.coordinator.dc";
    var TMP_DB_HBASE_NAMESPACE2 = "db.hbase.namespace";
    var TMP_DB_REDIS_DATABASE_INDEX2 = "db.redis.database_index";
    var TMP_DB_MONGODB_COLLECTION2 = "db.mongodb.collection";
    var TMP_DB_SQL_TABLE2 = "db.sql.table";
    var TMP_EXCEPTION_TYPE2 = "exception.type";
    var TMP_EXCEPTION_MESSAGE2 = "exception.message";
    var TMP_EXCEPTION_STACKTRACE2 = "exception.stacktrace";
    var TMP_EXCEPTION_ESCAPED2 = "exception.escaped";
    var TMP_FAAS_TRIGGER2 = "faas.trigger";
    var TMP_FAAS_EXECUTION2 = "faas.execution";
    var TMP_FAAS_DOCUMENT_COLLECTION2 = "faas.document.collection";
    var TMP_FAAS_DOCUMENT_OPERATION2 = "faas.document.operation";
    var TMP_FAAS_DOCUMENT_TIME2 = "faas.document.time";
    var TMP_FAAS_DOCUMENT_NAME2 = "faas.document.name";
    var TMP_FAAS_TIME2 = "faas.time";
    var TMP_FAAS_CRON2 = "faas.cron";
    var TMP_FAAS_COLDSTART2 = "faas.coldstart";
    var TMP_FAAS_INVOKED_NAME2 = "faas.invoked_name";
    var TMP_FAAS_INVOKED_PROVIDER2 = "faas.invoked_provider";
    var TMP_FAAS_INVOKED_REGION2 = "faas.invoked_region";
    var TMP_NET_TRANSPORT2 = "net.transport";
    var TMP_NET_PEER_IP2 = "net.peer.ip";
    var TMP_NET_PEER_PORT2 = "net.peer.port";
    var TMP_NET_PEER_NAME2 = "net.peer.name";
    var TMP_NET_HOST_IP2 = "net.host.ip";
    var TMP_NET_HOST_PORT2 = "net.host.port";
    var TMP_NET_HOST_NAME2 = "net.host.name";
    var TMP_NET_HOST_CONNECTION_TYPE2 = "net.host.connection.type";
    var TMP_NET_HOST_CONNECTION_SUBTYPE2 = "net.host.connection.subtype";
    var TMP_NET_HOST_CARRIER_NAME2 = "net.host.carrier.name";
    var TMP_NET_HOST_CARRIER_MCC2 = "net.host.carrier.mcc";
    var TMP_NET_HOST_CARRIER_MNC2 = "net.host.carrier.mnc";
    var TMP_NET_HOST_CARRIER_ICC2 = "net.host.carrier.icc";
    var TMP_PEER_SERVICE2 = "peer.service";
    var TMP_ENDUSER_ID2 = "enduser.id";
    var TMP_ENDUSER_ROLE2 = "enduser.role";
    var TMP_ENDUSER_SCOPE2 = "enduser.scope";
    var TMP_THREAD_ID2 = "thread.id";
    var TMP_THREAD_NAME2 = "thread.name";
    var TMP_CODE_FUNCTION2 = "code.function";
    var TMP_CODE_NAMESPACE2 = "code.namespace";
    var TMP_CODE_FILEPATH2 = "code.filepath";
    var TMP_CODE_LINENO2 = "code.lineno";
    var TMP_HTTP_METHOD2 = "http.method";
    var TMP_HTTP_URL2 = "http.url";
    var TMP_HTTP_TARGET2 = "http.target";
    var TMP_HTTP_HOST2 = "http.host";
    var TMP_HTTP_SCHEME2 = "http.scheme";
    var TMP_HTTP_STATUS_CODE2 = "http.status_code";
    var TMP_HTTP_FLAVOR2 = "http.flavor";
    var TMP_HTTP_USER_AGENT2 = "http.user_agent";
    var TMP_HTTP_REQUEST_CONTENT_LENGTH2 = "http.request_content_length";
    var TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED2 = "http.request_content_length_uncompressed";
    var TMP_HTTP_RESPONSE_CONTENT_LENGTH2 = "http.response_content_length";
    var TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2 = "http.response_content_length_uncompressed";
    var TMP_HTTP_SERVER_NAME2 = "http.server_name";
    var TMP_HTTP_ROUTE2 = "http.route";
    var TMP_HTTP_CLIENT_IP2 = "http.client_ip";
    var TMP_AWS_DYNAMODB_TABLE_NAMES2 = "aws.dynamodb.table_names";
    var TMP_AWS_DYNAMODB_CONSUMED_CAPACITY2 = "aws.dynamodb.consumed_capacity";
    var TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS2 = "aws.dynamodb.item_collection_metrics";
    var TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY2 = "aws.dynamodb.provisioned_read_capacity";
    var TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY2 = "aws.dynamodb.provisioned_write_capacity";
    var TMP_AWS_DYNAMODB_CONSISTENT_READ2 = "aws.dynamodb.consistent_read";
    var TMP_AWS_DYNAMODB_PROJECTION2 = "aws.dynamodb.projection";
    var TMP_AWS_DYNAMODB_LIMIT2 = "aws.dynamodb.limit";
    var TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET2 = "aws.dynamodb.attributes_to_get";
    var TMP_AWS_DYNAMODB_INDEX_NAME2 = "aws.dynamodb.index_name";
    var TMP_AWS_DYNAMODB_SELECT2 = "aws.dynamodb.select";
    var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES2 = "aws.dynamodb.global_secondary_indexes";
    var TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES2 = "aws.dynamodb.local_secondary_indexes";
    var TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE2 = "aws.dynamodb.exclusive_start_table";
    var TMP_AWS_DYNAMODB_TABLE_COUNT2 = "aws.dynamodb.table_count";
    var TMP_AWS_DYNAMODB_SCAN_FORWARD2 = "aws.dynamodb.scan_forward";
    var TMP_AWS_DYNAMODB_SEGMENT2 = "aws.dynamodb.segment";
    var TMP_AWS_DYNAMODB_TOTAL_SEGMENTS2 = "aws.dynamodb.total_segments";
    var TMP_AWS_DYNAMODB_COUNT2 = "aws.dynamodb.count";
    var TMP_AWS_DYNAMODB_SCANNED_COUNT2 = "aws.dynamodb.scanned_count";
    var TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS2 = "aws.dynamodb.attribute_definitions";
    var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES2 = "aws.dynamodb.global_secondary_index_updates";
    var TMP_MESSAGING_SYSTEM2 = "messaging.system";
    var TMP_MESSAGING_DESTINATION2 = "messaging.destination";
    var TMP_MESSAGING_DESTINATION_KIND2 = "messaging.destination_kind";
    var TMP_MESSAGING_TEMP_DESTINATION2 = "messaging.temp_destination";
    var TMP_MESSAGING_PROTOCOL2 = "messaging.protocol";
    var TMP_MESSAGING_PROTOCOL_VERSION2 = "messaging.protocol_version";
    var TMP_MESSAGING_URL2 = "messaging.url";
    var TMP_MESSAGING_MESSAGE_ID2 = "messaging.message_id";
    var TMP_MESSAGING_CONVERSATION_ID2 = "messaging.conversation_id";
    var TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES2 = "messaging.message_payload_size_bytes";
    var TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES2 = "messaging.message_payload_compressed_size_bytes";
    var TMP_MESSAGING_OPERATION2 = "messaging.operation";
    var TMP_MESSAGING_CONSUMER_ID2 = "messaging.consumer_id";
    var TMP_MESSAGING_RABBITMQ_ROUTING_KEY2 = "messaging.rabbitmq.routing_key";
    var TMP_MESSAGING_KAFKA_MESSAGE_KEY2 = "messaging.kafka.message_key";
    var TMP_MESSAGING_KAFKA_CONSUMER_GROUP2 = "messaging.kafka.consumer_group";
    var TMP_MESSAGING_KAFKA_CLIENT_ID2 = "messaging.kafka.client_id";
    var TMP_MESSAGING_KAFKA_PARTITION2 = "messaging.kafka.partition";
    var TMP_MESSAGING_KAFKA_TOMBSTONE2 = "messaging.kafka.tombstone";
    var TMP_RPC_SYSTEM2 = "rpc.system";
    var TMP_RPC_SERVICE2 = "rpc.service";
    var TMP_RPC_METHOD2 = "rpc.method";
    var TMP_RPC_GRPC_STATUS_CODE2 = "rpc.grpc.status_code";
    var TMP_RPC_JSONRPC_VERSION2 = "rpc.jsonrpc.version";
    var TMP_RPC_JSONRPC_REQUEST_ID2 = "rpc.jsonrpc.request_id";
    var TMP_RPC_JSONRPC_ERROR_CODE2 = "rpc.jsonrpc.error_code";
    var TMP_RPC_JSONRPC_ERROR_MESSAGE2 = "rpc.jsonrpc.error_message";
    var TMP_MESSAGE_TYPE2 = "message.type";
    var TMP_MESSAGE_ID2 = "message.id";
    var TMP_MESSAGE_COMPRESSED_SIZE2 = "message.compressed_size";
    var TMP_MESSAGE_UNCOMPRESSED_SIZE2 = "message.uncompressed_size";
    exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = TMP_AWS_LAMBDA_INVOKED_ARN2;
    exports.SEMATTRS_DB_SYSTEM = TMP_DB_SYSTEM2;
    exports.SEMATTRS_DB_CONNECTION_STRING = TMP_DB_CONNECTION_STRING2;
    exports.SEMATTRS_DB_USER = TMP_DB_USER2;
    exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = TMP_DB_JDBC_DRIVER_CLASSNAME2;
    exports.SEMATTRS_DB_NAME = TMP_DB_NAME2;
    exports.SEMATTRS_DB_STATEMENT = TMP_DB_STATEMENT2;
    exports.SEMATTRS_DB_OPERATION = TMP_DB_OPERATION2;
    exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = TMP_DB_MSSQL_INSTANCE_NAME2;
    exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = TMP_DB_CASSANDRA_KEYSPACE2;
    exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = TMP_DB_CASSANDRA_PAGE_SIZE2;
    exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL2;
    exports.SEMATTRS_DB_CASSANDRA_TABLE = TMP_DB_CASSANDRA_TABLE2;
    exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = TMP_DB_CASSANDRA_IDEMPOTENCE2;
    exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT2;
    exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = TMP_DB_CASSANDRA_COORDINATOR_ID2;
    exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = TMP_DB_CASSANDRA_COORDINATOR_DC2;
    exports.SEMATTRS_DB_HBASE_NAMESPACE = TMP_DB_HBASE_NAMESPACE2;
    exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = TMP_DB_REDIS_DATABASE_INDEX2;
    exports.SEMATTRS_DB_MONGODB_COLLECTION = TMP_DB_MONGODB_COLLECTION2;
    exports.SEMATTRS_DB_SQL_TABLE = TMP_DB_SQL_TABLE2;
    exports.SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE2;
    exports.SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE2;
    exports.SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE2;
    exports.SEMATTRS_EXCEPTION_ESCAPED = TMP_EXCEPTION_ESCAPED2;
    exports.SEMATTRS_FAAS_TRIGGER = TMP_FAAS_TRIGGER2;
    exports.SEMATTRS_FAAS_EXECUTION = TMP_FAAS_EXECUTION2;
    exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = TMP_FAAS_DOCUMENT_COLLECTION2;
    exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = TMP_FAAS_DOCUMENT_OPERATION2;
    exports.SEMATTRS_FAAS_DOCUMENT_TIME = TMP_FAAS_DOCUMENT_TIME2;
    exports.SEMATTRS_FAAS_DOCUMENT_NAME = TMP_FAAS_DOCUMENT_NAME2;
    exports.SEMATTRS_FAAS_TIME = TMP_FAAS_TIME2;
    exports.SEMATTRS_FAAS_CRON = TMP_FAAS_CRON2;
    exports.SEMATTRS_FAAS_COLDSTART = TMP_FAAS_COLDSTART2;
    exports.SEMATTRS_FAAS_INVOKED_NAME = TMP_FAAS_INVOKED_NAME2;
    exports.SEMATTRS_FAAS_INVOKED_PROVIDER = TMP_FAAS_INVOKED_PROVIDER2;
    exports.SEMATTRS_FAAS_INVOKED_REGION = TMP_FAAS_INVOKED_REGION2;
    exports.SEMATTRS_NET_TRANSPORT = TMP_NET_TRANSPORT2;
    exports.SEMATTRS_NET_PEER_IP = TMP_NET_PEER_IP2;
    exports.SEMATTRS_NET_PEER_PORT = TMP_NET_PEER_PORT2;
    exports.SEMATTRS_NET_PEER_NAME = TMP_NET_PEER_NAME2;
    exports.SEMATTRS_NET_HOST_IP = TMP_NET_HOST_IP2;
    exports.SEMATTRS_NET_HOST_PORT = TMP_NET_HOST_PORT2;
    exports.SEMATTRS_NET_HOST_NAME = TMP_NET_HOST_NAME2;
    exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = TMP_NET_HOST_CONNECTION_TYPE2;
    exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = TMP_NET_HOST_CONNECTION_SUBTYPE2;
    exports.SEMATTRS_NET_HOST_CARRIER_NAME = TMP_NET_HOST_CARRIER_NAME2;
    exports.SEMATTRS_NET_HOST_CARRIER_MCC = TMP_NET_HOST_CARRIER_MCC2;
    exports.SEMATTRS_NET_HOST_CARRIER_MNC = TMP_NET_HOST_CARRIER_MNC2;
    exports.SEMATTRS_NET_HOST_CARRIER_ICC = TMP_NET_HOST_CARRIER_ICC2;
    exports.SEMATTRS_PEER_SERVICE = TMP_PEER_SERVICE2;
    exports.SEMATTRS_ENDUSER_ID = TMP_ENDUSER_ID2;
    exports.SEMATTRS_ENDUSER_ROLE = TMP_ENDUSER_ROLE2;
    exports.SEMATTRS_ENDUSER_SCOPE = TMP_ENDUSER_SCOPE2;
    exports.SEMATTRS_THREAD_ID = TMP_THREAD_ID2;
    exports.SEMATTRS_THREAD_NAME = TMP_THREAD_NAME2;
    exports.SEMATTRS_CODE_FUNCTION = TMP_CODE_FUNCTION2;
    exports.SEMATTRS_CODE_NAMESPACE = TMP_CODE_NAMESPACE2;
    exports.SEMATTRS_CODE_FILEPATH = TMP_CODE_FILEPATH2;
    exports.SEMATTRS_CODE_LINENO = TMP_CODE_LINENO2;
    exports.SEMATTRS_HTTP_METHOD = TMP_HTTP_METHOD2;
    exports.SEMATTRS_HTTP_URL = TMP_HTTP_URL2;
    exports.SEMATTRS_HTTP_TARGET = TMP_HTTP_TARGET2;
    exports.SEMATTRS_HTTP_HOST = TMP_HTTP_HOST2;
    exports.SEMATTRS_HTTP_SCHEME = TMP_HTTP_SCHEME2;
    exports.SEMATTRS_HTTP_STATUS_CODE = TMP_HTTP_STATUS_CODE2;
    exports.SEMATTRS_HTTP_FLAVOR = TMP_HTTP_FLAVOR2;
    exports.SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT2;
    exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = TMP_HTTP_REQUEST_CONTENT_LENGTH2;
    exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED2;
    exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = TMP_HTTP_RESPONSE_CONTENT_LENGTH2;
    exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2;
    exports.SEMATTRS_HTTP_SERVER_NAME = TMP_HTTP_SERVER_NAME2;
    exports.SEMATTRS_HTTP_ROUTE = TMP_HTTP_ROUTE2;
    exports.SEMATTRS_HTTP_CLIENT_IP = TMP_HTTP_CLIENT_IP2;
    exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = TMP_AWS_DYNAMODB_TABLE_NAMES2;
    exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY2;
    exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS2;
    exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY2;
    exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY2;
    exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = TMP_AWS_DYNAMODB_CONSISTENT_READ2;
    exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = TMP_AWS_DYNAMODB_PROJECTION2;
    exports.SEMATTRS_AWS_DYNAMODB_LIMIT = TMP_AWS_DYNAMODB_LIMIT2;
    exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET2;
    exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = TMP_AWS_DYNAMODB_INDEX_NAME2;
    exports.SEMATTRS_AWS_DYNAMODB_SELECT = TMP_AWS_DYNAMODB_SELECT2;
    exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES2;
    exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES2;
    exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE2;
    exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = TMP_AWS_DYNAMODB_TABLE_COUNT2;
    exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = TMP_AWS_DYNAMODB_SCAN_FORWARD2;
    exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = TMP_AWS_DYNAMODB_SEGMENT2;
    exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS2;
    exports.SEMATTRS_AWS_DYNAMODB_COUNT = TMP_AWS_DYNAMODB_COUNT2;
    exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = TMP_AWS_DYNAMODB_SCANNED_COUNT2;
    exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS2;
    exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES2;
    exports.SEMATTRS_MESSAGING_SYSTEM = TMP_MESSAGING_SYSTEM2;
    exports.SEMATTRS_MESSAGING_DESTINATION = TMP_MESSAGING_DESTINATION2;
    exports.SEMATTRS_MESSAGING_DESTINATION_KIND = TMP_MESSAGING_DESTINATION_KIND2;
    exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = TMP_MESSAGING_TEMP_DESTINATION2;
    exports.SEMATTRS_MESSAGING_PROTOCOL = TMP_MESSAGING_PROTOCOL2;
    exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = TMP_MESSAGING_PROTOCOL_VERSION2;
    exports.SEMATTRS_MESSAGING_URL = TMP_MESSAGING_URL2;
    exports.SEMATTRS_MESSAGING_MESSAGE_ID = TMP_MESSAGING_MESSAGE_ID2;
    exports.SEMATTRS_MESSAGING_CONVERSATION_ID = TMP_MESSAGING_CONVERSATION_ID2;
    exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES2;
    exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES2;
    exports.SEMATTRS_MESSAGING_OPERATION = TMP_MESSAGING_OPERATION2;
    exports.SEMATTRS_MESSAGING_CONSUMER_ID = TMP_MESSAGING_CONSUMER_ID2;
    exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = TMP_MESSAGING_RABBITMQ_ROUTING_KEY2;
    exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = TMP_MESSAGING_KAFKA_MESSAGE_KEY2;
    exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = TMP_MESSAGING_KAFKA_CONSUMER_GROUP2;
    exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = TMP_MESSAGING_KAFKA_CLIENT_ID2;
    exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = TMP_MESSAGING_KAFKA_PARTITION2;
    exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = TMP_MESSAGING_KAFKA_TOMBSTONE2;
    exports.SEMATTRS_RPC_SYSTEM = TMP_RPC_SYSTEM2;
    exports.SEMATTRS_RPC_SERVICE = TMP_RPC_SERVICE2;
    exports.SEMATTRS_RPC_METHOD = TMP_RPC_METHOD2;
    exports.SEMATTRS_RPC_GRPC_STATUS_CODE = TMP_RPC_GRPC_STATUS_CODE2;
    exports.SEMATTRS_RPC_JSONRPC_VERSION = TMP_RPC_JSONRPC_VERSION2;
    exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = TMP_RPC_JSONRPC_REQUEST_ID2;
    exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = TMP_RPC_JSONRPC_ERROR_CODE2;
    exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = TMP_RPC_JSONRPC_ERROR_MESSAGE2;
    exports.SEMATTRS_MESSAGE_TYPE = TMP_MESSAGE_TYPE2;
    exports.SEMATTRS_MESSAGE_ID = TMP_MESSAGE_ID2;
    exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = TMP_MESSAGE_COMPRESSED_SIZE2;
    exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = TMP_MESSAGE_UNCOMPRESSED_SIZE2;
    exports.SemanticAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_AWS_LAMBDA_INVOKED_ARN2,
      TMP_DB_SYSTEM2,
      TMP_DB_CONNECTION_STRING2,
      TMP_DB_USER2,
      TMP_DB_JDBC_DRIVER_CLASSNAME2,
      TMP_DB_NAME2,
      TMP_DB_STATEMENT2,
      TMP_DB_OPERATION2,
      TMP_DB_MSSQL_INSTANCE_NAME2,
      TMP_DB_CASSANDRA_KEYSPACE2,
      TMP_DB_CASSANDRA_PAGE_SIZE2,
      TMP_DB_CASSANDRA_CONSISTENCY_LEVEL2,
      TMP_DB_CASSANDRA_TABLE2,
      TMP_DB_CASSANDRA_IDEMPOTENCE2,
      TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT2,
      TMP_DB_CASSANDRA_COORDINATOR_ID2,
      TMP_DB_CASSANDRA_COORDINATOR_DC2,
      TMP_DB_HBASE_NAMESPACE2,
      TMP_DB_REDIS_DATABASE_INDEX2,
      TMP_DB_MONGODB_COLLECTION2,
      TMP_DB_SQL_TABLE2,
      TMP_EXCEPTION_TYPE2,
      TMP_EXCEPTION_MESSAGE2,
      TMP_EXCEPTION_STACKTRACE2,
      TMP_EXCEPTION_ESCAPED2,
      TMP_FAAS_TRIGGER2,
      TMP_FAAS_EXECUTION2,
      TMP_FAAS_DOCUMENT_COLLECTION2,
      TMP_FAAS_DOCUMENT_OPERATION2,
      TMP_FAAS_DOCUMENT_TIME2,
      TMP_FAAS_DOCUMENT_NAME2,
      TMP_FAAS_TIME2,
      TMP_FAAS_CRON2,
      TMP_FAAS_COLDSTART2,
      TMP_FAAS_INVOKED_NAME2,
      TMP_FAAS_INVOKED_PROVIDER2,
      TMP_FAAS_INVOKED_REGION2,
      TMP_NET_TRANSPORT2,
      TMP_NET_PEER_IP2,
      TMP_NET_PEER_PORT2,
      TMP_NET_PEER_NAME2,
      TMP_NET_HOST_IP2,
      TMP_NET_HOST_PORT2,
      TMP_NET_HOST_NAME2,
      TMP_NET_HOST_CONNECTION_TYPE2,
      TMP_NET_HOST_CONNECTION_SUBTYPE2,
      TMP_NET_HOST_CARRIER_NAME2,
      TMP_NET_HOST_CARRIER_MCC2,
      TMP_NET_HOST_CARRIER_MNC2,
      TMP_NET_HOST_CARRIER_ICC2,
      TMP_PEER_SERVICE2,
      TMP_ENDUSER_ID2,
      TMP_ENDUSER_ROLE2,
      TMP_ENDUSER_SCOPE2,
      TMP_THREAD_ID2,
      TMP_THREAD_NAME2,
      TMP_CODE_FUNCTION2,
      TMP_CODE_NAMESPACE2,
      TMP_CODE_FILEPATH2,
      TMP_CODE_LINENO2,
      TMP_HTTP_METHOD2,
      TMP_HTTP_URL2,
      TMP_HTTP_TARGET2,
      TMP_HTTP_HOST2,
      TMP_HTTP_SCHEME2,
      TMP_HTTP_STATUS_CODE2,
      TMP_HTTP_FLAVOR2,
      TMP_HTTP_USER_AGENT2,
      TMP_HTTP_REQUEST_CONTENT_LENGTH2,
      TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED2,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH2,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2,
      TMP_HTTP_SERVER_NAME2,
      TMP_HTTP_ROUTE2,
      TMP_HTTP_CLIENT_IP2,
      TMP_AWS_DYNAMODB_TABLE_NAMES2,
      TMP_AWS_DYNAMODB_CONSUMED_CAPACITY2,
      TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS2,
      TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY2,
      TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY2,
      TMP_AWS_DYNAMODB_CONSISTENT_READ2,
      TMP_AWS_DYNAMODB_PROJECTION2,
      TMP_AWS_DYNAMODB_LIMIT2,
      TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET2,
      TMP_AWS_DYNAMODB_INDEX_NAME2,
      TMP_AWS_DYNAMODB_SELECT2,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES2,
      TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES2,
      TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE2,
      TMP_AWS_DYNAMODB_TABLE_COUNT2,
      TMP_AWS_DYNAMODB_SCAN_FORWARD2,
      TMP_AWS_DYNAMODB_SEGMENT2,
      TMP_AWS_DYNAMODB_TOTAL_SEGMENTS2,
      TMP_AWS_DYNAMODB_COUNT2,
      TMP_AWS_DYNAMODB_SCANNED_COUNT2,
      TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS2,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES2,
      TMP_MESSAGING_SYSTEM2,
      TMP_MESSAGING_DESTINATION2,
      TMP_MESSAGING_DESTINATION_KIND2,
      TMP_MESSAGING_TEMP_DESTINATION2,
      TMP_MESSAGING_PROTOCOL2,
      TMP_MESSAGING_PROTOCOL_VERSION2,
      TMP_MESSAGING_URL2,
      TMP_MESSAGING_MESSAGE_ID2,
      TMP_MESSAGING_CONVERSATION_ID2,
      TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES2,
      TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES2,
      TMP_MESSAGING_OPERATION2,
      TMP_MESSAGING_CONSUMER_ID2,
      TMP_MESSAGING_RABBITMQ_ROUTING_KEY2,
      TMP_MESSAGING_KAFKA_MESSAGE_KEY2,
      TMP_MESSAGING_KAFKA_CONSUMER_GROUP2,
      TMP_MESSAGING_KAFKA_CLIENT_ID2,
      TMP_MESSAGING_KAFKA_PARTITION2,
      TMP_MESSAGING_KAFKA_TOMBSTONE2,
      TMP_RPC_SYSTEM2,
      TMP_RPC_SERVICE2,
      TMP_RPC_METHOD2,
      TMP_RPC_GRPC_STATUS_CODE2,
      TMP_RPC_JSONRPC_VERSION2,
      TMP_RPC_JSONRPC_REQUEST_ID2,
      TMP_RPC_JSONRPC_ERROR_CODE2,
      TMP_RPC_JSONRPC_ERROR_MESSAGE2,
      TMP_MESSAGE_TYPE2,
      TMP_MESSAGE_ID2,
      TMP_MESSAGE_COMPRESSED_SIZE2,
      TMP_MESSAGE_UNCOMPRESSED_SIZE2
    ]);
    var TMP_DBSYSTEMVALUES_OTHER_SQL2 = "other_sql";
    var TMP_DBSYSTEMVALUES_MSSQL2 = "mssql";
    var TMP_DBSYSTEMVALUES_MYSQL2 = "mysql";
    var TMP_DBSYSTEMVALUES_ORACLE2 = "oracle";
    var TMP_DBSYSTEMVALUES_DB22 = "db2";
    var TMP_DBSYSTEMVALUES_POSTGRESQL2 = "postgresql";
    var TMP_DBSYSTEMVALUES_REDSHIFT2 = "redshift";
    var TMP_DBSYSTEMVALUES_HIVE2 = "hive";
    var TMP_DBSYSTEMVALUES_CLOUDSCAPE2 = "cloudscape";
    var TMP_DBSYSTEMVALUES_HSQLDB2 = "hsqldb";
    var TMP_DBSYSTEMVALUES_PROGRESS2 = "progress";
    var TMP_DBSYSTEMVALUES_MAXDB2 = "maxdb";
    var TMP_DBSYSTEMVALUES_HANADB2 = "hanadb";
    var TMP_DBSYSTEMVALUES_INGRES2 = "ingres";
    var TMP_DBSYSTEMVALUES_FIRSTSQL2 = "firstsql";
    var TMP_DBSYSTEMVALUES_EDB2 = "edb";
    var TMP_DBSYSTEMVALUES_CACHE2 = "cache";
    var TMP_DBSYSTEMVALUES_ADABAS2 = "adabas";
    var TMP_DBSYSTEMVALUES_FIREBIRD2 = "firebird";
    var TMP_DBSYSTEMVALUES_DERBY2 = "derby";
    var TMP_DBSYSTEMVALUES_FILEMAKER2 = "filemaker";
    var TMP_DBSYSTEMVALUES_INFORMIX2 = "informix";
    var TMP_DBSYSTEMVALUES_INSTANTDB2 = "instantdb";
    var TMP_DBSYSTEMVALUES_INTERBASE2 = "interbase";
    var TMP_DBSYSTEMVALUES_MARIADB2 = "mariadb";
    var TMP_DBSYSTEMVALUES_NETEZZA2 = "netezza";
    var TMP_DBSYSTEMVALUES_PERVASIVE2 = "pervasive";
    var TMP_DBSYSTEMVALUES_POINTBASE2 = "pointbase";
    var TMP_DBSYSTEMVALUES_SQLITE2 = "sqlite";
    var TMP_DBSYSTEMVALUES_SYBASE2 = "sybase";
    var TMP_DBSYSTEMVALUES_TERADATA2 = "teradata";
    var TMP_DBSYSTEMVALUES_VERTICA2 = "vertica";
    var TMP_DBSYSTEMVALUES_H22 = "h2";
    var TMP_DBSYSTEMVALUES_COLDFUSION2 = "coldfusion";
    var TMP_DBSYSTEMVALUES_CASSANDRA2 = "cassandra";
    var TMP_DBSYSTEMVALUES_HBASE2 = "hbase";
    var TMP_DBSYSTEMVALUES_MONGODB2 = "mongodb";
    var TMP_DBSYSTEMVALUES_REDIS2 = "redis";
    var TMP_DBSYSTEMVALUES_COUCHBASE2 = "couchbase";
    var TMP_DBSYSTEMVALUES_COUCHDB2 = "couchdb";
    var TMP_DBSYSTEMVALUES_COSMOSDB2 = "cosmosdb";
    var TMP_DBSYSTEMVALUES_DYNAMODB2 = "dynamodb";
    var TMP_DBSYSTEMVALUES_NEO4J2 = "neo4j";
    var TMP_DBSYSTEMVALUES_GEODE2 = "geode";
    var TMP_DBSYSTEMVALUES_ELASTICSEARCH2 = "elasticsearch";
    var TMP_DBSYSTEMVALUES_MEMCACHED2 = "memcached";
    var TMP_DBSYSTEMVALUES_COCKROACHDB2 = "cockroachdb";
    exports.DBSYSTEMVALUES_OTHER_SQL = TMP_DBSYSTEMVALUES_OTHER_SQL2;
    exports.DBSYSTEMVALUES_MSSQL = TMP_DBSYSTEMVALUES_MSSQL2;
    exports.DBSYSTEMVALUES_MYSQL = TMP_DBSYSTEMVALUES_MYSQL2;
    exports.DBSYSTEMVALUES_ORACLE = TMP_DBSYSTEMVALUES_ORACLE2;
    exports.DBSYSTEMVALUES_DB2 = TMP_DBSYSTEMVALUES_DB22;
    exports.DBSYSTEMVALUES_POSTGRESQL = TMP_DBSYSTEMVALUES_POSTGRESQL2;
    exports.DBSYSTEMVALUES_REDSHIFT = TMP_DBSYSTEMVALUES_REDSHIFT2;
    exports.DBSYSTEMVALUES_HIVE = TMP_DBSYSTEMVALUES_HIVE2;
    exports.DBSYSTEMVALUES_CLOUDSCAPE = TMP_DBSYSTEMVALUES_CLOUDSCAPE2;
    exports.DBSYSTEMVALUES_HSQLDB = TMP_DBSYSTEMVALUES_HSQLDB2;
    exports.DBSYSTEMVALUES_PROGRESS = TMP_DBSYSTEMVALUES_PROGRESS2;
    exports.DBSYSTEMVALUES_MAXDB = TMP_DBSYSTEMVALUES_MAXDB2;
    exports.DBSYSTEMVALUES_HANADB = TMP_DBSYSTEMVALUES_HANADB2;
    exports.DBSYSTEMVALUES_INGRES = TMP_DBSYSTEMVALUES_INGRES2;
    exports.DBSYSTEMVALUES_FIRSTSQL = TMP_DBSYSTEMVALUES_FIRSTSQL2;
    exports.DBSYSTEMVALUES_EDB = TMP_DBSYSTEMVALUES_EDB2;
    exports.DBSYSTEMVALUES_CACHE = TMP_DBSYSTEMVALUES_CACHE2;
    exports.DBSYSTEMVALUES_ADABAS = TMP_DBSYSTEMVALUES_ADABAS2;
    exports.DBSYSTEMVALUES_FIREBIRD = TMP_DBSYSTEMVALUES_FIREBIRD2;
    exports.DBSYSTEMVALUES_DERBY = TMP_DBSYSTEMVALUES_DERBY2;
    exports.DBSYSTEMVALUES_FILEMAKER = TMP_DBSYSTEMVALUES_FILEMAKER2;
    exports.DBSYSTEMVALUES_INFORMIX = TMP_DBSYSTEMVALUES_INFORMIX2;
    exports.DBSYSTEMVALUES_INSTANTDB = TMP_DBSYSTEMVALUES_INSTANTDB2;
    exports.DBSYSTEMVALUES_INTERBASE = TMP_DBSYSTEMVALUES_INTERBASE2;
    exports.DBSYSTEMVALUES_MARIADB = TMP_DBSYSTEMVALUES_MARIADB2;
    exports.DBSYSTEMVALUES_NETEZZA = TMP_DBSYSTEMVALUES_NETEZZA2;
    exports.DBSYSTEMVALUES_PERVASIVE = TMP_DBSYSTEMVALUES_PERVASIVE2;
    exports.DBSYSTEMVALUES_POINTBASE = TMP_DBSYSTEMVALUES_POINTBASE2;
    exports.DBSYSTEMVALUES_SQLITE = TMP_DBSYSTEMVALUES_SQLITE2;
    exports.DBSYSTEMVALUES_SYBASE = TMP_DBSYSTEMVALUES_SYBASE2;
    exports.DBSYSTEMVALUES_TERADATA = TMP_DBSYSTEMVALUES_TERADATA2;
    exports.DBSYSTEMVALUES_VERTICA = TMP_DBSYSTEMVALUES_VERTICA2;
    exports.DBSYSTEMVALUES_H2 = TMP_DBSYSTEMVALUES_H22;
    exports.DBSYSTEMVALUES_COLDFUSION = TMP_DBSYSTEMVALUES_COLDFUSION2;
    exports.DBSYSTEMVALUES_CASSANDRA = TMP_DBSYSTEMVALUES_CASSANDRA2;
    exports.DBSYSTEMVALUES_HBASE = TMP_DBSYSTEMVALUES_HBASE2;
    exports.DBSYSTEMVALUES_MONGODB = TMP_DBSYSTEMVALUES_MONGODB2;
    exports.DBSYSTEMVALUES_REDIS = TMP_DBSYSTEMVALUES_REDIS2;
    exports.DBSYSTEMVALUES_COUCHBASE = TMP_DBSYSTEMVALUES_COUCHBASE2;
    exports.DBSYSTEMVALUES_COUCHDB = TMP_DBSYSTEMVALUES_COUCHDB2;
    exports.DBSYSTEMVALUES_COSMOSDB = TMP_DBSYSTEMVALUES_COSMOSDB2;
    exports.DBSYSTEMVALUES_DYNAMODB = TMP_DBSYSTEMVALUES_DYNAMODB2;
    exports.DBSYSTEMVALUES_NEO4J = TMP_DBSYSTEMVALUES_NEO4J2;
    exports.DBSYSTEMVALUES_GEODE = TMP_DBSYSTEMVALUES_GEODE2;
    exports.DBSYSTEMVALUES_ELASTICSEARCH = TMP_DBSYSTEMVALUES_ELASTICSEARCH2;
    exports.DBSYSTEMVALUES_MEMCACHED = TMP_DBSYSTEMVALUES_MEMCACHED2;
    exports.DBSYSTEMVALUES_COCKROACHDB = TMP_DBSYSTEMVALUES_COCKROACHDB2;
    exports.DbSystemValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_DBSYSTEMVALUES_OTHER_SQL2,
      TMP_DBSYSTEMVALUES_MSSQL2,
      TMP_DBSYSTEMVALUES_MYSQL2,
      TMP_DBSYSTEMVALUES_ORACLE2,
      TMP_DBSYSTEMVALUES_DB22,
      TMP_DBSYSTEMVALUES_POSTGRESQL2,
      TMP_DBSYSTEMVALUES_REDSHIFT2,
      TMP_DBSYSTEMVALUES_HIVE2,
      TMP_DBSYSTEMVALUES_CLOUDSCAPE2,
      TMP_DBSYSTEMVALUES_HSQLDB2,
      TMP_DBSYSTEMVALUES_PROGRESS2,
      TMP_DBSYSTEMVALUES_MAXDB2,
      TMP_DBSYSTEMVALUES_HANADB2,
      TMP_DBSYSTEMVALUES_INGRES2,
      TMP_DBSYSTEMVALUES_FIRSTSQL2,
      TMP_DBSYSTEMVALUES_EDB2,
      TMP_DBSYSTEMVALUES_CACHE2,
      TMP_DBSYSTEMVALUES_ADABAS2,
      TMP_DBSYSTEMVALUES_FIREBIRD2,
      TMP_DBSYSTEMVALUES_DERBY2,
      TMP_DBSYSTEMVALUES_FILEMAKER2,
      TMP_DBSYSTEMVALUES_INFORMIX2,
      TMP_DBSYSTEMVALUES_INSTANTDB2,
      TMP_DBSYSTEMVALUES_INTERBASE2,
      TMP_DBSYSTEMVALUES_MARIADB2,
      TMP_DBSYSTEMVALUES_NETEZZA2,
      TMP_DBSYSTEMVALUES_PERVASIVE2,
      TMP_DBSYSTEMVALUES_POINTBASE2,
      TMP_DBSYSTEMVALUES_SQLITE2,
      TMP_DBSYSTEMVALUES_SYBASE2,
      TMP_DBSYSTEMVALUES_TERADATA2,
      TMP_DBSYSTEMVALUES_VERTICA2,
      TMP_DBSYSTEMVALUES_H22,
      TMP_DBSYSTEMVALUES_COLDFUSION2,
      TMP_DBSYSTEMVALUES_CASSANDRA2,
      TMP_DBSYSTEMVALUES_HBASE2,
      TMP_DBSYSTEMVALUES_MONGODB2,
      TMP_DBSYSTEMVALUES_REDIS2,
      TMP_DBSYSTEMVALUES_COUCHBASE2,
      TMP_DBSYSTEMVALUES_COUCHDB2,
      TMP_DBSYSTEMVALUES_COSMOSDB2,
      TMP_DBSYSTEMVALUES_DYNAMODB2,
      TMP_DBSYSTEMVALUES_NEO4J2,
      TMP_DBSYSTEMVALUES_GEODE2,
      TMP_DBSYSTEMVALUES_ELASTICSEARCH2,
      TMP_DBSYSTEMVALUES_MEMCACHED2,
      TMP_DBSYSTEMVALUES_COCKROACHDB2
    ]);
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL2 = "all";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM2 = "each_quorum";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM2 = "quorum";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM2 = "local_quorum";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE2 = "one";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO2 = "two";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE2 = "three";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE2 = "local_one";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY2 = "any";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL2 = "serial";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL2 = "local_serial";
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL2;
    exports.DbCassandraConsistencyLevelValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL2
    ]);
    var TMP_FAASTRIGGERVALUES_DATASOURCE2 = "datasource";
    var TMP_FAASTRIGGERVALUES_HTTP2 = "http";
    var TMP_FAASTRIGGERVALUES_PUBSUB2 = "pubsub";
    var TMP_FAASTRIGGERVALUES_TIMER2 = "timer";
    var TMP_FAASTRIGGERVALUES_OTHER2 = "other";
    exports.FAASTRIGGERVALUES_DATASOURCE = TMP_FAASTRIGGERVALUES_DATASOURCE2;
    exports.FAASTRIGGERVALUES_HTTP = TMP_FAASTRIGGERVALUES_HTTP2;
    exports.FAASTRIGGERVALUES_PUBSUB = TMP_FAASTRIGGERVALUES_PUBSUB2;
    exports.FAASTRIGGERVALUES_TIMER = TMP_FAASTRIGGERVALUES_TIMER2;
    exports.FAASTRIGGERVALUES_OTHER = TMP_FAASTRIGGERVALUES_OTHER2;
    exports.FaasTriggerValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_FAASTRIGGERVALUES_DATASOURCE2,
      TMP_FAASTRIGGERVALUES_HTTP2,
      TMP_FAASTRIGGERVALUES_PUBSUB2,
      TMP_FAASTRIGGERVALUES_TIMER2,
      TMP_FAASTRIGGERVALUES_OTHER2
    ]);
    var TMP_FAASDOCUMENTOPERATIONVALUES_INSERT2 = "insert";
    var TMP_FAASDOCUMENTOPERATIONVALUES_EDIT2 = "edit";
    var TMP_FAASDOCUMENTOPERATIONVALUES_DELETE2 = "delete";
    exports.FAASDOCUMENTOPERATIONVALUES_INSERT = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT2;
    exports.FAASDOCUMENTOPERATIONVALUES_EDIT = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT2;
    exports.FAASDOCUMENTOPERATIONVALUES_DELETE = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE2;
    exports.FaasDocumentOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_FAASDOCUMENTOPERATIONVALUES_INSERT2,
      TMP_FAASDOCUMENTOPERATIONVALUES_EDIT2,
      TMP_FAASDOCUMENTOPERATIONVALUES_DELETE2
    ]);
    var TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD2 = "alibaba_cloud";
    var TMP_FAASINVOKEDPROVIDERVALUES_AWS2 = "aws";
    var TMP_FAASINVOKEDPROVIDERVALUES_AZURE2 = "azure";
    var TMP_FAASINVOKEDPROVIDERVALUES_GCP2 = "gcp";
    exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD2;
    exports.FAASINVOKEDPROVIDERVALUES_AWS = TMP_FAASINVOKEDPROVIDERVALUES_AWS2;
    exports.FAASINVOKEDPROVIDERVALUES_AZURE = TMP_FAASINVOKEDPROVIDERVALUES_AZURE2;
    exports.FAASINVOKEDPROVIDERVALUES_GCP = TMP_FAASINVOKEDPROVIDERVALUES_GCP2;
    exports.FaasInvokedProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD2,
      TMP_FAASINVOKEDPROVIDERVALUES_AWS2,
      TMP_FAASINVOKEDPROVIDERVALUES_AZURE2,
      TMP_FAASINVOKEDPROVIDERVALUES_GCP2
    ]);
    var TMP_NETTRANSPORTVALUES_IP_TCP2 = "ip_tcp";
    var TMP_NETTRANSPORTVALUES_IP_UDP2 = "ip_udp";
    var TMP_NETTRANSPORTVALUES_IP2 = "ip";
    var TMP_NETTRANSPORTVALUES_UNIX2 = "unix";
    var TMP_NETTRANSPORTVALUES_PIPE2 = "pipe";
    var TMP_NETTRANSPORTVALUES_INPROC2 = "inproc";
    var TMP_NETTRANSPORTVALUES_OTHER2 = "other";
    exports.NETTRANSPORTVALUES_IP_TCP = TMP_NETTRANSPORTVALUES_IP_TCP2;
    exports.NETTRANSPORTVALUES_IP_UDP = TMP_NETTRANSPORTVALUES_IP_UDP2;
    exports.NETTRANSPORTVALUES_IP = TMP_NETTRANSPORTVALUES_IP2;
    exports.NETTRANSPORTVALUES_UNIX = TMP_NETTRANSPORTVALUES_UNIX2;
    exports.NETTRANSPORTVALUES_PIPE = TMP_NETTRANSPORTVALUES_PIPE2;
    exports.NETTRANSPORTVALUES_INPROC = TMP_NETTRANSPORTVALUES_INPROC2;
    exports.NETTRANSPORTVALUES_OTHER = TMP_NETTRANSPORTVALUES_OTHER2;
    exports.NetTransportValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_NETTRANSPORTVALUES_IP_TCP2,
      TMP_NETTRANSPORTVALUES_IP_UDP2,
      TMP_NETTRANSPORTVALUES_IP2,
      TMP_NETTRANSPORTVALUES_UNIX2,
      TMP_NETTRANSPORTVALUES_PIPE2,
      TMP_NETTRANSPORTVALUES_INPROC2,
      TMP_NETTRANSPORTVALUES_OTHER2
    ]);
    var TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI2 = "wifi";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED2 = "wired";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_CELL2 = "cell";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE2 = "unavailable";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN2 = "unknown";
    exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI2;
    exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED2;
    exports.NETHOSTCONNECTIONTYPEVALUES_CELL = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL2;
    exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE2;
    exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN2;
    exports.NetHostConnectionTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI2,
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED2,
      TMP_NETHOSTCONNECTIONTYPEVALUES_CELL2,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE2,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN2
    ]);
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS2 = "gprs";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE2 = "edge";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS2 = "umts";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2 = "cdma";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_02 = "evdo_0";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A2 = "evdo_a";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT2 = "cdma2000_1xrtt";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA2 = "hsdpa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA2 = "hsupa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA2 = "hspa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN2 = "iden";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B2 = "evdo_b";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE2 = "lte";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD2 = "ehrpd";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP2 = "hspap";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM2 = "gsm";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA2 = "td_scdma";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN2 = "iwlan";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR2 = "nr";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA2 = "nrnsa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA2 = "lte_ca";
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_02;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA2;
    exports.NetHostConnectionSubtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_02,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA2
    ]);
    var TMP_HTTPFLAVORVALUES_HTTP_1_02 = "1.0";
    var TMP_HTTPFLAVORVALUES_HTTP_1_12 = "1.1";
    var TMP_HTTPFLAVORVALUES_HTTP_2_02 = "2.0";
    var TMP_HTTPFLAVORVALUES_SPDY2 = "SPDY";
    var TMP_HTTPFLAVORVALUES_QUIC2 = "QUIC";
    exports.HTTPFLAVORVALUES_HTTP_1_0 = TMP_HTTPFLAVORVALUES_HTTP_1_02;
    exports.HTTPFLAVORVALUES_HTTP_1_1 = TMP_HTTPFLAVORVALUES_HTTP_1_12;
    exports.HTTPFLAVORVALUES_HTTP_2_0 = TMP_HTTPFLAVORVALUES_HTTP_2_02;
    exports.HTTPFLAVORVALUES_SPDY = TMP_HTTPFLAVORVALUES_SPDY2;
    exports.HTTPFLAVORVALUES_QUIC = TMP_HTTPFLAVORVALUES_QUIC2;
    exports.HttpFlavorValues = {
      HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_02,
      HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_12,
      HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_02,
      SPDY: TMP_HTTPFLAVORVALUES_SPDY2,
      QUIC: TMP_HTTPFLAVORVALUES_QUIC2
    };
    var TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE2 = "queue";
    var TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC2 = "topic";
    exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE2;
    exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC2;
    exports.MessagingDestinationKindValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE2,
      TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC2
    ]);
    var TMP_MESSAGINGOPERATIONVALUES_RECEIVE2 = "receive";
    var TMP_MESSAGINGOPERATIONVALUES_PROCESS2 = "process";
    exports.MESSAGINGOPERATIONVALUES_RECEIVE = TMP_MESSAGINGOPERATIONVALUES_RECEIVE2;
    exports.MESSAGINGOPERATIONVALUES_PROCESS = TMP_MESSAGINGOPERATIONVALUES_PROCESS2;
    exports.MessagingOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_MESSAGINGOPERATIONVALUES_RECEIVE2,
      TMP_MESSAGINGOPERATIONVALUES_PROCESS2
    ]);
    var TMP_RPCGRPCSTATUSCODEVALUES_OK2 = 0;
    var TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED2 = 1;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN2 = 2;
    var TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT2 = 3;
    var TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED2 = 4;
    var TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND2 = 5;
    var TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS2 = 6;
    var TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED2 = 7;
    var TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED2 = 8;
    var TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION2 = 9;
    var TMP_RPCGRPCSTATUSCODEVALUES_ABORTED2 = 10;
    var TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE2 = 11;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED2 = 12;
    var TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL2 = 13;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE2 = 14;
    var TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS2 = 15;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED2 = 16;
    exports.RPCGRPCSTATUSCODEVALUES_OK = TMP_RPCGRPCSTATUSCODEVALUES_OK2;
    exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED2;
    exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN2;
    exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT2;
    exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED2;
    exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND2;
    exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS2;
    exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED2;
    exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED2;
    exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION2;
    exports.RPCGRPCSTATUSCODEVALUES_ABORTED = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED2;
    exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE2;
    exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED2;
    exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL2;
    exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE2;
    exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS2;
    exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED2;
    exports.RpcGrpcStatusCodeValues = {
      OK: TMP_RPCGRPCSTATUSCODEVALUES_OK2,
      CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED2,
      UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN2,
      INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT2,
      DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED2,
      NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND2,
      ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS2,
      PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED2,
      RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED2,
      FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION2,
      ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED2,
      OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE2,
      UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED2,
      INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL2,
      UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE2,
      DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS2,
      UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED2
    };
    var TMP_MESSAGETYPEVALUES_SENT2 = "SENT";
    var TMP_MESSAGETYPEVALUES_RECEIVED2 = "RECEIVED";
    exports.MESSAGETYPEVALUES_SENT = TMP_MESSAGETYPEVALUES_SENT2;
    exports.MESSAGETYPEVALUES_RECEIVED = TMP_MESSAGETYPEVALUES_RECEIVED2;
    exports.MessageTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_MESSAGETYPEVALUES_SENT2,
      TMP_MESSAGETYPEVALUES_RECEIVED2
    ]);
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js
var require_trace4 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_SemanticAttributes4(), exports);
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js
var require_SemanticResourceAttributes4 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SEMRESATTRS_K8S_STATEFULSET_NAME = exports.SEMRESATTRS_K8S_STATEFULSET_UID = exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = exports.SEMRESATTRS_K8S_REPLICASET_NAME = exports.SEMRESATTRS_K8S_REPLICASET_UID = exports.SEMRESATTRS_K8S_CONTAINER_NAME = exports.SEMRESATTRS_K8S_POD_NAME = exports.SEMRESATTRS_K8S_POD_UID = exports.SEMRESATTRS_K8S_NAMESPACE_NAME = exports.SEMRESATTRS_K8S_NODE_UID = exports.SEMRESATTRS_K8S_NODE_NAME = exports.SEMRESATTRS_K8S_CLUSTER_NAME = exports.SEMRESATTRS_HOST_IMAGE_VERSION = exports.SEMRESATTRS_HOST_IMAGE_ID = exports.SEMRESATTRS_HOST_IMAGE_NAME = exports.SEMRESATTRS_HOST_ARCH = exports.SEMRESATTRS_HOST_TYPE = exports.SEMRESATTRS_HOST_NAME = exports.SEMRESATTRS_HOST_ID = exports.SEMRESATTRS_FAAS_MAX_MEMORY = exports.SEMRESATTRS_FAAS_INSTANCE = exports.SEMRESATTRS_FAAS_VERSION = exports.SEMRESATTRS_FAAS_ID = exports.SEMRESATTRS_FAAS_NAME = exports.SEMRESATTRS_DEVICE_MODEL_NAME = exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = exports.SEMRESATTRS_DEVICE_ID = exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = exports.SEMRESATTRS_CONTAINER_RUNTIME = exports.SEMRESATTRS_CONTAINER_ID = exports.SEMRESATTRS_CONTAINER_NAME = exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = exports.SEMRESATTRS_AWS_ECS_TASK_ARN = exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = exports.SEMRESATTRS_CLOUD_PLATFORM = exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = exports.SEMRESATTRS_CLOUD_REGION = exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = exports.SEMRESATTRS_CLOUD_PROVIDER = void 0;
    exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = exports.CLOUDPLATFORMVALUES_AZURE_AKS = exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = exports.CLOUDPLATFORMVALUES_AZURE_VM = exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = exports.CLOUDPLATFORMVALUES_AWS_EKS = exports.CLOUDPLATFORMVALUES_AWS_ECS = exports.CLOUDPLATFORMVALUES_AWS_EC2 = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = exports.CloudProviderValues = exports.CLOUDPROVIDERVALUES_GCP = exports.CLOUDPROVIDERVALUES_AZURE = exports.CLOUDPROVIDERVALUES_AWS = exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = exports.SemanticResourceAttributes = exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = exports.SEMRESATTRS_WEBENGINE_VERSION = exports.SEMRESATTRS_WEBENGINE_NAME = exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = exports.SEMRESATTRS_TELEMETRY_SDK_NAME = exports.SEMRESATTRS_SERVICE_VERSION = exports.SEMRESATTRS_SERVICE_INSTANCE_ID = exports.SEMRESATTRS_SERVICE_NAMESPACE = exports.SEMRESATTRS_SERVICE_NAME = exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = exports.SEMRESATTRS_PROCESS_OWNER = exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = exports.SEMRESATTRS_PROCESS_COMMAND_LINE = exports.SEMRESATTRS_PROCESS_COMMAND = exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = exports.SEMRESATTRS_PROCESS_PID = exports.SEMRESATTRS_OS_VERSION = exports.SEMRESATTRS_OS_NAME = exports.SEMRESATTRS_OS_DESCRIPTION = exports.SEMRESATTRS_OS_TYPE = exports.SEMRESATTRS_K8S_CRONJOB_NAME = exports.SEMRESATTRS_K8S_CRONJOB_UID = exports.SEMRESATTRS_K8S_JOB_NAME = exports.SEMRESATTRS_K8S_JOB_UID = exports.SEMRESATTRS_K8S_DAEMONSET_NAME = exports.SEMRESATTRS_K8S_DAEMONSET_UID = void 0;
    exports.TelemetrySdkLanguageValues = exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = exports.TELEMETRYSDKLANGUAGEVALUES_PHP = exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = exports.TELEMETRYSDKLANGUAGEVALUES_GO = exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = exports.TELEMETRYSDKLANGUAGEVALUES_CPP = exports.OsTypeValues = exports.OSTYPEVALUES_Z_OS = exports.OSTYPEVALUES_SOLARIS = exports.OSTYPEVALUES_AIX = exports.OSTYPEVALUES_HPUX = exports.OSTYPEVALUES_DRAGONFLYBSD = exports.OSTYPEVALUES_OPENBSD = exports.OSTYPEVALUES_NETBSD = exports.OSTYPEVALUES_FREEBSD = exports.OSTYPEVALUES_DARWIN = exports.OSTYPEVALUES_LINUX = exports.OSTYPEVALUES_WINDOWS = exports.HostArchValues = exports.HOSTARCHVALUES_X86 = exports.HOSTARCHVALUES_PPC64 = exports.HOSTARCHVALUES_PPC32 = exports.HOSTARCHVALUES_IA64 = exports.HOSTARCHVALUES_ARM64 = exports.HOSTARCHVALUES_ARM32 = exports.HOSTARCHVALUES_AMD64 = exports.AwsEcsLaunchtypeValues = exports.AWSECSLAUNCHTYPEVALUES_FARGATE = exports.AWSECSLAUNCHTYPEVALUES_EC2 = exports.CloudPlatformValues = exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = void 0;
    var utils_1 = require_utils11();
    var TMP_CLOUD_PROVIDER2 = "cloud.provider";
    var TMP_CLOUD_ACCOUNT_ID2 = "cloud.account.id";
    var TMP_CLOUD_REGION2 = "cloud.region";
    var TMP_CLOUD_AVAILABILITY_ZONE2 = "cloud.availability_zone";
    var TMP_CLOUD_PLATFORM2 = "cloud.platform";
    var TMP_AWS_ECS_CONTAINER_ARN2 = "aws.ecs.container.arn";
    var TMP_AWS_ECS_CLUSTER_ARN2 = "aws.ecs.cluster.arn";
    var TMP_AWS_ECS_LAUNCHTYPE2 = "aws.ecs.launchtype";
    var TMP_AWS_ECS_TASK_ARN2 = "aws.ecs.task.arn";
    var TMP_AWS_ECS_TASK_FAMILY2 = "aws.ecs.task.family";
    var TMP_AWS_ECS_TASK_REVISION2 = "aws.ecs.task.revision";
    var TMP_AWS_EKS_CLUSTER_ARN2 = "aws.eks.cluster.arn";
    var TMP_AWS_LOG_GROUP_NAMES2 = "aws.log.group.names";
    var TMP_AWS_LOG_GROUP_ARNS2 = "aws.log.group.arns";
    var TMP_AWS_LOG_STREAM_NAMES2 = "aws.log.stream.names";
    var TMP_AWS_LOG_STREAM_ARNS2 = "aws.log.stream.arns";
    var TMP_CONTAINER_NAME2 = "container.name";
    var TMP_CONTAINER_ID2 = "container.id";
    var TMP_CONTAINER_RUNTIME2 = "container.runtime";
    var TMP_CONTAINER_IMAGE_NAME2 = "container.image.name";
    var TMP_CONTAINER_IMAGE_TAG2 = "container.image.tag";
    var TMP_DEPLOYMENT_ENVIRONMENT2 = "deployment.environment";
    var TMP_DEVICE_ID2 = "device.id";
    var TMP_DEVICE_MODEL_IDENTIFIER2 = "device.model.identifier";
    var TMP_DEVICE_MODEL_NAME2 = "device.model.name";
    var TMP_FAAS_NAME2 = "faas.name";
    var TMP_FAAS_ID2 = "faas.id";
    var TMP_FAAS_VERSION2 = "faas.version";
    var TMP_FAAS_INSTANCE2 = "faas.instance";
    var TMP_FAAS_MAX_MEMORY2 = "faas.max_memory";
    var TMP_HOST_ID2 = "host.id";
    var TMP_HOST_NAME2 = "host.name";
    var TMP_HOST_TYPE2 = "host.type";
    var TMP_HOST_ARCH2 = "host.arch";
    var TMP_HOST_IMAGE_NAME2 = "host.image.name";
    var TMP_HOST_IMAGE_ID2 = "host.image.id";
    var TMP_HOST_IMAGE_VERSION2 = "host.image.version";
    var TMP_K8S_CLUSTER_NAME2 = "k8s.cluster.name";
    var TMP_K8S_NODE_NAME2 = "k8s.node.name";
    var TMP_K8S_NODE_UID2 = "k8s.node.uid";
    var TMP_K8S_NAMESPACE_NAME2 = "k8s.namespace.name";
    var TMP_K8S_POD_UID2 = "k8s.pod.uid";
    var TMP_K8S_POD_NAME2 = "k8s.pod.name";
    var TMP_K8S_CONTAINER_NAME2 = "k8s.container.name";
    var TMP_K8S_REPLICASET_UID2 = "k8s.replicaset.uid";
    var TMP_K8S_REPLICASET_NAME2 = "k8s.replicaset.name";
    var TMP_K8S_DEPLOYMENT_UID2 = "k8s.deployment.uid";
    var TMP_K8S_DEPLOYMENT_NAME2 = "k8s.deployment.name";
    var TMP_K8S_STATEFULSET_UID2 = "k8s.statefulset.uid";
    var TMP_K8S_STATEFULSET_NAME2 = "k8s.statefulset.name";
    var TMP_K8S_DAEMONSET_UID2 = "k8s.daemonset.uid";
    var TMP_K8S_DAEMONSET_NAME2 = "k8s.daemonset.name";
    var TMP_K8S_JOB_UID2 = "k8s.job.uid";
    var TMP_K8S_JOB_NAME2 = "k8s.job.name";
    var TMP_K8S_CRONJOB_UID2 = "k8s.cronjob.uid";
    var TMP_K8S_CRONJOB_NAME2 = "k8s.cronjob.name";
    var TMP_OS_TYPE2 = "os.type";
    var TMP_OS_DESCRIPTION2 = "os.description";
    var TMP_OS_NAME2 = "os.name";
    var TMP_OS_VERSION2 = "os.version";
    var TMP_PROCESS_PID2 = "process.pid";
    var TMP_PROCESS_EXECUTABLE_NAME2 = "process.executable.name";
    var TMP_PROCESS_EXECUTABLE_PATH2 = "process.executable.path";
    var TMP_PROCESS_COMMAND2 = "process.command";
    var TMP_PROCESS_COMMAND_LINE2 = "process.command_line";
    var TMP_PROCESS_COMMAND_ARGS2 = "process.command_args";
    var TMP_PROCESS_OWNER2 = "process.owner";
    var TMP_PROCESS_RUNTIME_NAME2 = "process.runtime.name";
    var TMP_PROCESS_RUNTIME_VERSION2 = "process.runtime.version";
    var TMP_PROCESS_RUNTIME_DESCRIPTION2 = "process.runtime.description";
    var TMP_SERVICE_NAME2 = "service.name";
    var TMP_SERVICE_NAMESPACE2 = "service.namespace";
    var TMP_SERVICE_INSTANCE_ID2 = "service.instance.id";
    var TMP_SERVICE_VERSION2 = "service.version";
    var TMP_TELEMETRY_SDK_NAME2 = "telemetry.sdk.name";
    var TMP_TELEMETRY_SDK_LANGUAGE2 = "telemetry.sdk.language";
    var TMP_TELEMETRY_SDK_VERSION2 = "telemetry.sdk.version";
    var TMP_TELEMETRY_AUTO_VERSION2 = "telemetry.auto.version";
    var TMP_WEBENGINE_NAME2 = "webengine.name";
    var TMP_WEBENGINE_VERSION2 = "webengine.version";
    var TMP_WEBENGINE_DESCRIPTION2 = "webengine.description";
    exports.SEMRESATTRS_CLOUD_PROVIDER = TMP_CLOUD_PROVIDER2;
    exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = TMP_CLOUD_ACCOUNT_ID2;
    exports.SEMRESATTRS_CLOUD_REGION = TMP_CLOUD_REGION2;
    exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = TMP_CLOUD_AVAILABILITY_ZONE2;
    exports.SEMRESATTRS_CLOUD_PLATFORM = TMP_CLOUD_PLATFORM2;
    exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = TMP_AWS_ECS_CONTAINER_ARN2;
    exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = TMP_AWS_ECS_CLUSTER_ARN2;
    exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = TMP_AWS_ECS_LAUNCHTYPE2;
    exports.SEMRESATTRS_AWS_ECS_TASK_ARN = TMP_AWS_ECS_TASK_ARN2;
    exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = TMP_AWS_ECS_TASK_FAMILY2;
    exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = TMP_AWS_ECS_TASK_REVISION2;
    exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = TMP_AWS_EKS_CLUSTER_ARN2;
    exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = TMP_AWS_LOG_GROUP_NAMES2;
    exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = TMP_AWS_LOG_GROUP_ARNS2;
    exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = TMP_AWS_LOG_STREAM_NAMES2;
    exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = TMP_AWS_LOG_STREAM_ARNS2;
    exports.SEMRESATTRS_CONTAINER_NAME = TMP_CONTAINER_NAME2;
    exports.SEMRESATTRS_CONTAINER_ID = TMP_CONTAINER_ID2;
    exports.SEMRESATTRS_CONTAINER_RUNTIME = TMP_CONTAINER_RUNTIME2;
    exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = TMP_CONTAINER_IMAGE_NAME2;
    exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = TMP_CONTAINER_IMAGE_TAG2;
    exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = TMP_DEPLOYMENT_ENVIRONMENT2;
    exports.SEMRESATTRS_DEVICE_ID = TMP_DEVICE_ID2;
    exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = TMP_DEVICE_MODEL_IDENTIFIER2;
    exports.SEMRESATTRS_DEVICE_MODEL_NAME = TMP_DEVICE_MODEL_NAME2;
    exports.SEMRESATTRS_FAAS_NAME = TMP_FAAS_NAME2;
    exports.SEMRESATTRS_FAAS_ID = TMP_FAAS_ID2;
    exports.SEMRESATTRS_FAAS_VERSION = TMP_FAAS_VERSION2;
    exports.SEMRESATTRS_FAAS_INSTANCE = TMP_FAAS_INSTANCE2;
    exports.SEMRESATTRS_FAAS_MAX_MEMORY = TMP_FAAS_MAX_MEMORY2;
    exports.SEMRESATTRS_HOST_ID = TMP_HOST_ID2;
    exports.SEMRESATTRS_HOST_NAME = TMP_HOST_NAME2;
    exports.SEMRESATTRS_HOST_TYPE = TMP_HOST_TYPE2;
    exports.SEMRESATTRS_HOST_ARCH = TMP_HOST_ARCH2;
    exports.SEMRESATTRS_HOST_IMAGE_NAME = TMP_HOST_IMAGE_NAME2;
    exports.SEMRESATTRS_HOST_IMAGE_ID = TMP_HOST_IMAGE_ID2;
    exports.SEMRESATTRS_HOST_IMAGE_VERSION = TMP_HOST_IMAGE_VERSION2;
    exports.SEMRESATTRS_K8S_CLUSTER_NAME = TMP_K8S_CLUSTER_NAME2;
    exports.SEMRESATTRS_K8S_NODE_NAME = TMP_K8S_NODE_NAME2;
    exports.SEMRESATTRS_K8S_NODE_UID = TMP_K8S_NODE_UID2;
    exports.SEMRESATTRS_K8S_NAMESPACE_NAME = TMP_K8S_NAMESPACE_NAME2;
    exports.SEMRESATTRS_K8S_POD_UID = TMP_K8S_POD_UID2;
    exports.SEMRESATTRS_K8S_POD_NAME = TMP_K8S_POD_NAME2;
    exports.SEMRESATTRS_K8S_CONTAINER_NAME = TMP_K8S_CONTAINER_NAME2;
    exports.SEMRESATTRS_K8S_REPLICASET_UID = TMP_K8S_REPLICASET_UID2;
    exports.SEMRESATTRS_K8S_REPLICASET_NAME = TMP_K8S_REPLICASET_NAME2;
    exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = TMP_K8S_DEPLOYMENT_UID2;
    exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = TMP_K8S_DEPLOYMENT_NAME2;
    exports.SEMRESATTRS_K8S_STATEFULSET_UID = TMP_K8S_STATEFULSET_UID2;
    exports.SEMRESATTRS_K8S_STATEFULSET_NAME = TMP_K8S_STATEFULSET_NAME2;
    exports.SEMRESATTRS_K8S_DAEMONSET_UID = TMP_K8S_DAEMONSET_UID2;
    exports.SEMRESATTRS_K8S_DAEMONSET_NAME = TMP_K8S_DAEMONSET_NAME2;
    exports.SEMRESATTRS_K8S_JOB_UID = TMP_K8S_JOB_UID2;
    exports.SEMRESATTRS_K8S_JOB_NAME = TMP_K8S_JOB_NAME2;
    exports.SEMRESATTRS_K8S_CRONJOB_UID = TMP_K8S_CRONJOB_UID2;
    exports.SEMRESATTRS_K8S_CRONJOB_NAME = TMP_K8S_CRONJOB_NAME2;
    exports.SEMRESATTRS_OS_TYPE = TMP_OS_TYPE2;
    exports.SEMRESATTRS_OS_DESCRIPTION = TMP_OS_DESCRIPTION2;
    exports.SEMRESATTRS_OS_NAME = TMP_OS_NAME2;
    exports.SEMRESATTRS_OS_VERSION = TMP_OS_VERSION2;
    exports.SEMRESATTRS_PROCESS_PID = TMP_PROCESS_PID2;
    exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = TMP_PROCESS_EXECUTABLE_NAME2;
    exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = TMP_PROCESS_EXECUTABLE_PATH2;
    exports.SEMRESATTRS_PROCESS_COMMAND = TMP_PROCESS_COMMAND2;
    exports.SEMRESATTRS_PROCESS_COMMAND_LINE = TMP_PROCESS_COMMAND_LINE2;
    exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = TMP_PROCESS_COMMAND_ARGS2;
    exports.SEMRESATTRS_PROCESS_OWNER = TMP_PROCESS_OWNER2;
    exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME2;
    exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = TMP_PROCESS_RUNTIME_VERSION2;
    exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = TMP_PROCESS_RUNTIME_DESCRIPTION2;
    exports.SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME2;
    exports.SEMRESATTRS_SERVICE_NAMESPACE = TMP_SERVICE_NAMESPACE2;
    exports.SEMRESATTRS_SERVICE_INSTANCE_ID = TMP_SERVICE_INSTANCE_ID2;
    exports.SEMRESATTRS_SERVICE_VERSION = TMP_SERVICE_VERSION2;
    exports.SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME2;
    exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE2;
    exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION2;
    exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = TMP_TELEMETRY_AUTO_VERSION2;
    exports.SEMRESATTRS_WEBENGINE_NAME = TMP_WEBENGINE_NAME2;
    exports.SEMRESATTRS_WEBENGINE_VERSION = TMP_WEBENGINE_VERSION2;
    exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = TMP_WEBENGINE_DESCRIPTION2;
    exports.SemanticResourceAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_CLOUD_PROVIDER2,
      TMP_CLOUD_ACCOUNT_ID2,
      TMP_CLOUD_REGION2,
      TMP_CLOUD_AVAILABILITY_ZONE2,
      TMP_CLOUD_PLATFORM2,
      TMP_AWS_ECS_CONTAINER_ARN2,
      TMP_AWS_ECS_CLUSTER_ARN2,
      TMP_AWS_ECS_LAUNCHTYPE2,
      TMP_AWS_ECS_TASK_ARN2,
      TMP_AWS_ECS_TASK_FAMILY2,
      TMP_AWS_ECS_TASK_REVISION2,
      TMP_AWS_EKS_CLUSTER_ARN2,
      TMP_AWS_LOG_GROUP_NAMES2,
      TMP_AWS_LOG_GROUP_ARNS2,
      TMP_AWS_LOG_STREAM_NAMES2,
      TMP_AWS_LOG_STREAM_ARNS2,
      TMP_CONTAINER_NAME2,
      TMP_CONTAINER_ID2,
      TMP_CONTAINER_RUNTIME2,
      TMP_CONTAINER_IMAGE_NAME2,
      TMP_CONTAINER_IMAGE_TAG2,
      TMP_DEPLOYMENT_ENVIRONMENT2,
      TMP_DEVICE_ID2,
      TMP_DEVICE_MODEL_IDENTIFIER2,
      TMP_DEVICE_MODEL_NAME2,
      TMP_FAAS_NAME2,
      TMP_FAAS_ID2,
      TMP_FAAS_VERSION2,
      TMP_FAAS_INSTANCE2,
      TMP_FAAS_MAX_MEMORY2,
      TMP_HOST_ID2,
      TMP_HOST_NAME2,
      TMP_HOST_TYPE2,
      TMP_HOST_ARCH2,
      TMP_HOST_IMAGE_NAME2,
      TMP_HOST_IMAGE_ID2,
      TMP_HOST_IMAGE_VERSION2,
      TMP_K8S_CLUSTER_NAME2,
      TMP_K8S_NODE_NAME2,
      TMP_K8S_NODE_UID2,
      TMP_K8S_NAMESPACE_NAME2,
      TMP_K8S_POD_UID2,
      TMP_K8S_POD_NAME2,
      TMP_K8S_CONTAINER_NAME2,
      TMP_K8S_REPLICASET_UID2,
      TMP_K8S_REPLICASET_NAME2,
      TMP_K8S_DEPLOYMENT_UID2,
      TMP_K8S_DEPLOYMENT_NAME2,
      TMP_K8S_STATEFULSET_UID2,
      TMP_K8S_STATEFULSET_NAME2,
      TMP_K8S_DAEMONSET_UID2,
      TMP_K8S_DAEMONSET_NAME2,
      TMP_K8S_JOB_UID2,
      TMP_K8S_JOB_NAME2,
      TMP_K8S_CRONJOB_UID2,
      TMP_K8S_CRONJOB_NAME2,
      TMP_OS_TYPE2,
      TMP_OS_DESCRIPTION2,
      TMP_OS_NAME2,
      TMP_OS_VERSION2,
      TMP_PROCESS_PID2,
      TMP_PROCESS_EXECUTABLE_NAME2,
      TMP_PROCESS_EXECUTABLE_PATH2,
      TMP_PROCESS_COMMAND2,
      TMP_PROCESS_COMMAND_LINE2,
      TMP_PROCESS_COMMAND_ARGS2,
      TMP_PROCESS_OWNER2,
      TMP_PROCESS_RUNTIME_NAME2,
      TMP_PROCESS_RUNTIME_VERSION2,
      TMP_PROCESS_RUNTIME_DESCRIPTION2,
      TMP_SERVICE_NAME2,
      TMP_SERVICE_NAMESPACE2,
      TMP_SERVICE_INSTANCE_ID2,
      TMP_SERVICE_VERSION2,
      TMP_TELEMETRY_SDK_NAME2,
      TMP_TELEMETRY_SDK_LANGUAGE2,
      TMP_TELEMETRY_SDK_VERSION2,
      TMP_TELEMETRY_AUTO_VERSION2,
      TMP_WEBENGINE_NAME2,
      TMP_WEBENGINE_VERSION2,
      TMP_WEBENGINE_DESCRIPTION2
    ]);
    var TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD2 = "alibaba_cloud";
    var TMP_CLOUDPROVIDERVALUES_AWS2 = "aws";
    var TMP_CLOUDPROVIDERVALUES_AZURE2 = "azure";
    var TMP_CLOUDPROVIDERVALUES_GCP2 = "gcp";
    exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD2;
    exports.CLOUDPROVIDERVALUES_AWS = TMP_CLOUDPROVIDERVALUES_AWS2;
    exports.CLOUDPROVIDERVALUES_AZURE = TMP_CLOUDPROVIDERVALUES_AZURE2;
    exports.CLOUDPROVIDERVALUES_GCP = TMP_CLOUDPROVIDERVALUES_GCP2;
    exports.CloudProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD2,
      TMP_CLOUDPROVIDERVALUES_AWS2,
      TMP_CLOUDPROVIDERVALUES_AZURE2,
      TMP_CLOUDPROVIDERVALUES_GCP2
    ]);
    var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS2 = "alibaba_cloud_ecs";
    var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC2 = "alibaba_cloud_fc";
    var TMP_CLOUDPLATFORMVALUES_AWS_EC22 = "aws_ec2";
    var TMP_CLOUDPLATFORMVALUES_AWS_ECS2 = "aws_ecs";
    var TMP_CLOUDPLATFORMVALUES_AWS_EKS2 = "aws_eks";
    var TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA2 = "aws_lambda";
    var TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK2 = "aws_elastic_beanstalk";
    var TMP_CLOUDPLATFORMVALUES_AZURE_VM2 = "azure_vm";
    var TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES2 = "azure_container_instances";
    var TMP_CLOUDPLATFORMVALUES_AZURE_AKS2 = "azure_aks";
    var TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS2 = "azure_functions";
    var TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE2 = "azure_app_service";
    var TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE2 = "gcp_compute_engine";
    var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN2 = "gcp_cloud_run";
    var TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE2 = "gcp_kubernetes_engine";
    var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS2 = "gcp_cloud_functions";
    var TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE2 = "gcp_app_engine";
    exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS2;
    exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC2;
    exports.CLOUDPLATFORMVALUES_AWS_EC2 = TMP_CLOUDPLATFORMVALUES_AWS_EC22;
    exports.CLOUDPLATFORMVALUES_AWS_ECS = TMP_CLOUDPLATFORMVALUES_AWS_ECS2;
    exports.CLOUDPLATFORMVALUES_AWS_EKS = TMP_CLOUDPLATFORMVALUES_AWS_EKS2;
    exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA2;
    exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK2;
    exports.CLOUDPLATFORMVALUES_AZURE_VM = TMP_CLOUDPLATFORMVALUES_AZURE_VM2;
    exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES2;
    exports.CLOUDPLATFORMVALUES_AZURE_AKS = TMP_CLOUDPLATFORMVALUES_AZURE_AKS2;
    exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS2;
    exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE2;
    exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE2;
    exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN2;
    exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE2;
    exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS2;
    exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE2;
    exports.CloudPlatformValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS2,
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC2,
      TMP_CLOUDPLATFORMVALUES_AWS_EC22,
      TMP_CLOUDPLATFORMVALUES_AWS_ECS2,
      TMP_CLOUDPLATFORMVALUES_AWS_EKS2,
      TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA2,
      TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK2,
      TMP_CLOUDPLATFORMVALUES_AZURE_VM2,
      TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES2,
      TMP_CLOUDPLATFORMVALUES_AZURE_AKS2,
      TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS2,
      TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE2,
      TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE2,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN2,
      TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE2,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS2,
      TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE2
    ]);
    var TMP_AWSECSLAUNCHTYPEVALUES_EC22 = "ec2";
    var TMP_AWSECSLAUNCHTYPEVALUES_FARGATE2 = "fargate";
    exports.AWSECSLAUNCHTYPEVALUES_EC2 = TMP_AWSECSLAUNCHTYPEVALUES_EC22;
    exports.AWSECSLAUNCHTYPEVALUES_FARGATE = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE2;
    exports.AwsEcsLaunchtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_AWSECSLAUNCHTYPEVALUES_EC22,
      TMP_AWSECSLAUNCHTYPEVALUES_FARGATE2
    ]);
    var TMP_HOSTARCHVALUES_AMD642 = "amd64";
    var TMP_HOSTARCHVALUES_ARM322 = "arm32";
    var TMP_HOSTARCHVALUES_ARM642 = "arm64";
    var TMP_HOSTARCHVALUES_IA642 = "ia64";
    var TMP_HOSTARCHVALUES_PPC322 = "ppc32";
    var TMP_HOSTARCHVALUES_PPC642 = "ppc64";
    var TMP_HOSTARCHVALUES_X862 = "x86";
    exports.HOSTARCHVALUES_AMD64 = TMP_HOSTARCHVALUES_AMD642;
    exports.HOSTARCHVALUES_ARM32 = TMP_HOSTARCHVALUES_ARM322;
    exports.HOSTARCHVALUES_ARM64 = TMP_HOSTARCHVALUES_ARM642;
    exports.HOSTARCHVALUES_IA64 = TMP_HOSTARCHVALUES_IA642;
    exports.HOSTARCHVALUES_PPC32 = TMP_HOSTARCHVALUES_PPC322;
    exports.HOSTARCHVALUES_PPC64 = TMP_HOSTARCHVALUES_PPC642;
    exports.HOSTARCHVALUES_X86 = TMP_HOSTARCHVALUES_X862;
    exports.HostArchValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_HOSTARCHVALUES_AMD642,
      TMP_HOSTARCHVALUES_ARM322,
      TMP_HOSTARCHVALUES_ARM642,
      TMP_HOSTARCHVALUES_IA642,
      TMP_HOSTARCHVALUES_PPC322,
      TMP_HOSTARCHVALUES_PPC642,
      TMP_HOSTARCHVALUES_X862
    ]);
    var TMP_OSTYPEVALUES_WINDOWS2 = "windows";
    var TMP_OSTYPEVALUES_LINUX2 = "linux";
    var TMP_OSTYPEVALUES_DARWIN2 = "darwin";
    var TMP_OSTYPEVALUES_FREEBSD2 = "freebsd";
    var TMP_OSTYPEVALUES_NETBSD2 = "netbsd";
    var TMP_OSTYPEVALUES_OPENBSD2 = "openbsd";
    var TMP_OSTYPEVALUES_DRAGONFLYBSD2 = "dragonflybsd";
    var TMP_OSTYPEVALUES_HPUX2 = "hpux";
    var TMP_OSTYPEVALUES_AIX2 = "aix";
    var TMP_OSTYPEVALUES_SOLARIS2 = "solaris";
    var TMP_OSTYPEVALUES_Z_OS2 = "z_os";
    exports.OSTYPEVALUES_WINDOWS = TMP_OSTYPEVALUES_WINDOWS2;
    exports.OSTYPEVALUES_LINUX = TMP_OSTYPEVALUES_LINUX2;
    exports.OSTYPEVALUES_DARWIN = TMP_OSTYPEVALUES_DARWIN2;
    exports.OSTYPEVALUES_FREEBSD = TMP_OSTYPEVALUES_FREEBSD2;
    exports.OSTYPEVALUES_NETBSD = TMP_OSTYPEVALUES_NETBSD2;
    exports.OSTYPEVALUES_OPENBSD = TMP_OSTYPEVALUES_OPENBSD2;
    exports.OSTYPEVALUES_DRAGONFLYBSD = TMP_OSTYPEVALUES_DRAGONFLYBSD2;
    exports.OSTYPEVALUES_HPUX = TMP_OSTYPEVALUES_HPUX2;
    exports.OSTYPEVALUES_AIX = TMP_OSTYPEVALUES_AIX2;
    exports.OSTYPEVALUES_SOLARIS = TMP_OSTYPEVALUES_SOLARIS2;
    exports.OSTYPEVALUES_Z_OS = TMP_OSTYPEVALUES_Z_OS2;
    exports.OsTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_OSTYPEVALUES_WINDOWS2,
      TMP_OSTYPEVALUES_LINUX2,
      TMP_OSTYPEVALUES_DARWIN2,
      TMP_OSTYPEVALUES_FREEBSD2,
      TMP_OSTYPEVALUES_NETBSD2,
      TMP_OSTYPEVALUES_OPENBSD2,
      TMP_OSTYPEVALUES_DRAGONFLYBSD2,
      TMP_OSTYPEVALUES_HPUX2,
      TMP_OSTYPEVALUES_AIX2,
      TMP_OSTYPEVALUES_SOLARIS2,
      TMP_OSTYPEVALUES_Z_OS2
    ]);
    var TMP_TELEMETRYSDKLANGUAGEVALUES_CPP2 = "cpp";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET2 = "dotnet";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG2 = "erlang";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_GO2 = "go";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA2 = "java";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS2 = "nodejs";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_PHP2 = "php";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON2 = "python";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY2 = "ruby";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS2 = "webjs";
    exports.TELEMETRYSDKLANGUAGEVALUES_CPP = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP2;
    exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET2;
    exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG2;
    exports.TELEMETRYSDKLANGUAGEVALUES_GO = TMP_TELEMETRYSDKLANGUAGEVALUES_GO2;
    exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA2;
    exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS2;
    exports.TELEMETRYSDKLANGUAGEVALUES_PHP = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP2;
    exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON2;
    exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY2;
    exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS2;
    exports.TelemetrySdkLanguageValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_TELEMETRYSDKLANGUAGEVALUES_CPP2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_GO2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PHP2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS2
    ]);
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js
var require_resource4 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_SemanticResourceAttributes4(), exports);
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/semantic-conventions/build/src/index.js
var require_src14 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/semantic-conventions/build/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_trace4(), exports);
    __exportStar(require_resource4(), exports);
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js
var require_sdk_info5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDK_INFO = void 0;
    var version_1 = require_version5();
    var semantic_conventions_1 = require_src14();
    exports.SDK_INFO = {
      [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_NAME]: "opentelemetry",
      [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_NAME]: "node",
      [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE]: semantic_conventions_1.TelemetrySdkLanguageValues.NODEJS,
      [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_VERSION]: version_1.VERSION
    };
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js
var require_timer_util5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unrefTimer = void 0;
    function unrefTimer(timer) {
      timer.unref();
    }
    exports.unrefTimer = unrefTimer;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/platform/node/index.js
var require_node9 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/platform/node/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnv = exports.getEnvWithoutDefaults = void 0;
    var environment_1 = require_environment11();
    Object.defineProperty(exports, "getEnvWithoutDefaults", { enumerable: true, get: function() {
      return environment_1.getEnvWithoutDefaults;
    } });
    Object.defineProperty(exports, "getEnv", { enumerable: true, get: function() {
      return environment_1.getEnv;
    } });
    __exportStar(require_globalThis5(), exports);
    __exportStar(require_hex_to_base645(), exports);
    __exportStar(require_RandomIdGenerator6(), exports);
    __exportStar(require_performance5(), exports);
    __exportStar(require_sdk_info5(), exports);
    __exportStar(require_timer_util5(), exports);
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/platform/index.js
var require_platform9 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/platform/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_node9(), exports);
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/common/time.js
var require_time5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/common/time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addHrTimes = exports.isTimeInput = exports.isTimeInputHrTime = exports.hrTimeToMicroseconds = exports.hrTimeToMilliseconds = exports.hrTimeToNanoseconds = exports.hrTimeToTimeStamp = exports.hrTimeDuration = exports.timeInputToHrTime = exports.hrTime = exports.getTimeOrigin = exports.millisToHrTime = void 0;
    var platform_1 = require_platform9();
    var NANOSECOND_DIGITS = 9;
    var NANOSECOND_DIGITS_IN_MILLIS = 6;
    var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
    var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
    function millisToHrTime(epochMillis) {
      const epochSeconds = epochMillis / 1e3;
      const seconds = Math.trunc(epochSeconds);
      const nanos = Math.round(epochMillis % 1e3 * MILLISECONDS_TO_NANOSECONDS);
      return [seconds, nanos];
    }
    exports.millisToHrTime = millisToHrTime;
    function getTimeOrigin() {
      let timeOrigin = platform_1.otperformance.timeOrigin;
      if (typeof timeOrigin !== "number") {
        const perf = platform_1.otperformance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
      }
      return timeOrigin;
    }
    exports.getTimeOrigin = getTimeOrigin;
    function hrTime(performanceNow) {
      const timeOrigin = millisToHrTime(getTimeOrigin());
      const now = millisToHrTime(typeof performanceNow === "number" ? performanceNow : platform_1.otperformance.now());
      return addHrTimes(timeOrigin, now);
    }
    exports.hrTime = hrTime;
    function timeInputToHrTime(time) {
      if (isTimeInputHrTime(time)) {
        return time;
      } else if (typeof time === "number") {
        if (time < getTimeOrigin()) {
          return hrTime(time);
        } else {
          return millisToHrTime(time);
        }
      } else if (time instanceof Date) {
        return millisToHrTime(time.getTime());
      } else {
        throw TypeError("Invalid input type");
      }
    }
    exports.timeInputToHrTime = timeInputToHrTime;
    function hrTimeDuration(startTime, endTime) {
      let seconds = endTime[0] - startTime[0];
      let nanos = endTime[1] - startTime[1];
      if (nanos < 0) {
        seconds -= 1;
        nanos += SECOND_TO_NANOSECONDS;
      }
      return [seconds, nanos];
    }
    exports.hrTimeDuration = hrTimeDuration;
    function hrTimeToTimeStamp(time) {
      const precision = NANOSECOND_DIGITS;
      const tmp = `${"0".repeat(precision)}${time[1]}Z`;
      const nanoString = tmp.substr(tmp.length - precision - 1);
      const date = new Date(time[0] * 1e3).toISOString();
      return date.replace("000Z", nanoString);
    }
    exports.hrTimeToTimeStamp = hrTimeToTimeStamp;
    function hrTimeToNanoseconds(time) {
      return time[0] * SECOND_TO_NANOSECONDS + time[1];
    }
    exports.hrTimeToNanoseconds = hrTimeToNanoseconds;
    function hrTimeToMilliseconds(time) {
      return time[0] * 1e3 + time[1] / 1e6;
    }
    exports.hrTimeToMilliseconds = hrTimeToMilliseconds;
    function hrTimeToMicroseconds(time) {
      return time[0] * 1e6 + time[1] / 1e3;
    }
    exports.hrTimeToMicroseconds = hrTimeToMicroseconds;
    function isTimeInputHrTime(value) {
      return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
    }
    exports.isTimeInputHrTime = isTimeInputHrTime;
    function isTimeInput(value) {
      return isTimeInputHrTime(value) || typeof value === "number" || value instanceof Date;
    }
    exports.isTimeInput = isTimeInput;
    function addHrTimes(time1, time2) {
      const out = [time1[0] + time2[0], time1[1] + time2[1]];
      if (out[1] >= SECOND_TO_NANOSECONDS) {
        out[1] -= SECOND_TO_NANOSECONDS;
        out[0] += 1;
      }
      return out;
    }
    exports.addHrTimes = addHrTimes;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/common/types.js
var require_types7 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/common/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/ExportResult.js
var require_ExportResult5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/ExportResult.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExportResultCode = void 0;
    var ExportResultCode;
    (function(ExportResultCode2) {
      ExportResultCode2[ExportResultCode2["SUCCESS"] = 0] = "SUCCESS";
      ExportResultCode2[ExportResultCode2["FAILED"] = 1] = "FAILED";
    })(ExportResultCode = exports.ExportResultCode || (exports.ExportResultCode = {}));
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/propagation/composite.js
var require_composite5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/propagation/composite.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompositePropagator = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var CompositePropagator = class {
      /**
       * Construct a composite propagator from a list of propagators.
       *
       * @param [config] Configuration object for composite propagator
       */
      constructor(config = {}) {
        var _a12;
        this._propagators = (_a12 = config.propagators) !== null && _a12 !== void 0 ? _a12 : [];
        this._fields = Array.from(new Set(this._propagators.map((p2) => typeof p2.fields === "function" ? p2.fields() : []).reduce((x2, y2) => x2.concat(y2), [])));
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same carrier key, the propagator later in the list
       * will "win".
       *
       * @param context Context to inject
       * @param carrier Carrier into which context will be injected
       */
      inject(context3, carrier, setter) {
        for (const propagator of this._propagators) {
          try {
            propagator.inject(context3, carrier, setter);
          } catch (err) {
            api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
          }
        }
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same context key, the propagator later in the list
       * will "win".
       *
       * @param context Context to add values to
       * @param carrier Carrier from which to extract context
       */
      extract(context3, carrier, getter) {
        return this._propagators.reduce((ctx, propagator) => {
          try {
            return propagator.extract(ctx, carrier, getter);
          } catch (err) {
            api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
          }
          return ctx;
        }, context3);
      }
      fields() {
        return this._fields.slice();
      }
    };
    exports.CompositePropagator = CompositePropagator;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/internal/validators.js
var require_validators5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/internal/validators.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateValue = exports.validateKey = void 0;
    var VALID_KEY_CHAR_RANGE2 = "[_0-9a-z-*/]";
    var VALID_KEY2 = `[a-z]${VALID_KEY_CHAR_RANGE2}{0,255}`;
    var VALID_VENDOR_KEY2 = `[a-z0-9]${VALID_KEY_CHAR_RANGE2}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE2}{0,13}`;
    var VALID_KEY_REGEX2 = new RegExp(`^(?:${VALID_KEY2}|${VALID_VENDOR_KEY2})$`);
    var VALID_VALUE_BASE_REGEX2 = /^[ -~]{0,255}[!-~]$/;
    var INVALID_VALUE_COMMA_EQUAL_REGEX2 = /,|=/;
    function validateKey2(key) {
      return VALID_KEY_REGEX2.test(key);
    }
    exports.validateKey = validateKey2;
    function validateValue2(value) {
      return VALID_VALUE_BASE_REGEX2.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX2.test(value);
    }
    exports.validateValue = validateValue2;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/trace/TraceState.js
var require_TraceState5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/trace/TraceState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TraceState = void 0;
    var validators_1 = require_validators5();
    var MAX_TRACE_STATE_ITEMS2 = 32;
    var MAX_TRACE_STATE_LEN2 = 512;
    var LIST_MEMBERS_SEPARATOR2 = ",";
    var LIST_MEMBER_KEY_VALUE_SPLITTER2 = "=";
    var TraceState = class _TraceState {
      constructor(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      set(key, value) {
        const traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      }
      unset(key) {
        const traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      }
      get(key) {
        return this._internalState.get(key);
      }
      serialize() {
        return this._keys().reduce((agg, key) => {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER2 + this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR2);
      }
      _parse(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN2)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR2).reverse().reduce((agg, part) => {
          const listMember = part.trim();
          const i2 = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER2);
          if (i2 !== -1) {
            const key = listMember.slice(0, i2);
            const value = listMember.slice(i2 + 1, part.length);
            if ((0, validators_1.validateKey)(key) && (0, validators_1.validateValue)(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS2) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS2));
        }
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        const traceState = new _TraceState();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      }
    };
    exports.TraceState = TraceState;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js
var require_W3CTraceContextPropagator5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.W3CTraceContextPropagator = exports.parseTraceParent = exports.TRACE_STATE_HEADER = exports.TRACE_PARENT_HEADER = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing5();
    var TraceState_1 = require_TraceState5();
    exports.TRACE_PARENT_HEADER = "traceparent";
    exports.TRACE_STATE_HEADER = "tracestate";
    var VERSION2 = "00";
    var VERSION_PART = "(?!ff)[\\da-f]{2}";
    var TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}";
    var PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}";
    var FLAGS_PART = "[\\da-f]{2}";
    var TRACE_PARENT_REGEX = new RegExp(`^\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\s?$`);
    function parseTraceParent(traceParent) {
      const match4 = TRACE_PARENT_REGEX.exec(traceParent);
      if (!match4)
        return null;
      if (match4[1] === "00" && match4[5])
        return null;
      return {
        traceId: match4[2],
        spanId: match4[3],
        traceFlags: parseInt(match4[4], 16)
      };
    }
    exports.parseTraceParent = parseTraceParent;
    var W3CTraceContextPropagator = class {
      inject(context3, carrier, setter) {
        const spanContext = api_1.trace.getSpanContext(context3);
        if (!spanContext || (0, suppress_tracing_1.isTracingSuppressed)(context3) || !(0, api_1.isSpanContextValid)(spanContext))
          return;
        const traceParent = `${VERSION2}-${spanContext.traceId}-${spanContext.spanId}-0${Number(spanContext.traceFlags || api_1.TraceFlags.NONE).toString(16)}`;
        setter.set(carrier, exports.TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) {
          setter.set(carrier, exports.TRACE_STATE_HEADER, spanContext.traceState.serialize());
        }
      }
      extract(context3, carrier, getter) {
        const traceParentHeader = getter.get(carrier, exports.TRACE_PARENT_HEADER);
        if (!traceParentHeader)
          return context3;
        const traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
        if (typeof traceParent !== "string")
          return context3;
        const spanContext = parseTraceParent(traceParent);
        if (!spanContext)
          return context3;
        spanContext.isRemote = true;
        const traceStateHeader = getter.get(carrier, exports.TRACE_STATE_HEADER);
        if (traceStateHeader) {
          const state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
          spanContext.traceState = new TraceState_1.TraceState(typeof state === "string" ? state : void 0);
        }
        return api_1.trace.setSpanContext(context3, spanContext);
      }
      fields() {
        return [exports.TRACE_PARENT_HEADER, exports.TRACE_STATE_HEADER];
      }
    };
    exports.W3CTraceContextPropagator = W3CTraceContextPropagator;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/trace/IdGenerator.js
var require_IdGenerator4 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/trace/IdGenerator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js
var require_rpc_metadata5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRPCMetadata = exports.deleteRPCMetadata = exports.setRPCMetadata = exports.RPCType = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var RPC_METADATA_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key RPC_METADATA");
    var RPCType;
    (function(RPCType2) {
      RPCType2["HTTP"] = "http";
    })(RPCType = exports.RPCType || (exports.RPCType = {}));
    function setRPCMetadata(context3, meta) {
      return context3.setValue(RPC_METADATA_KEY, meta);
    }
    exports.setRPCMetadata = setRPCMetadata;
    function deleteRPCMetadata(context3) {
      return context3.deleteValue(RPC_METADATA_KEY);
    }
    exports.deleteRPCMetadata = deleteRPCMetadata;
    function getRPCMetadata(context3) {
      return context3.getValue(RPC_METADATA_KEY);
    }
    exports.getRPCMetadata = getRPCMetadata;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js
var require_AlwaysOffSampler6 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AlwaysOffSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var AlwaysOffSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return "AlwaysOffSampler";
      }
    };
    exports.AlwaysOffSampler = AlwaysOffSampler;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js
var require_AlwaysOnSampler6 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AlwaysOnSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var AlwaysOnSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.RECORD_AND_SAMPLED
        };
      }
      toString() {
        return "AlwaysOnSampler";
      }
    };
    exports.AlwaysOnSampler = AlwaysOnSampler;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js
var require_ParentBasedSampler6 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParentBasedSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var global_error_handler_1 = require_global_error_handler5();
    var AlwaysOffSampler_1 = require_AlwaysOffSampler6();
    var AlwaysOnSampler_1 = require_AlwaysOnSampler6();
    var ParentBasedSampler = class {
      constructor(config) {
        var _a12, _b5, _c4, _d4;
        this._root = config.root;
        if (!this._root) {
          (0, global_error_handler_1.globalErrorHandler)(new Error("ParentBasedSampler must have a root sampler configured"));
          this._root = new AlwaysOnSampler_1.AlwaysOnSampler();
        }
        this._remoteParentSampled = (_a12 = config.remoteParentSampled) !== null && _a12 !== void 0 ? _a12 : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._remoteParentNotSampled = (_b5 = config.remoteParentNotSampled) !== null && _b5 !== void 0 ? _b5 : new AlwaysOffSampler_1.AlwaysOffSampler();
        this._localParentSampled = (_c4 = config.localParentSampled) !== null && _c4 !== void 0 ? _c4 : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._localParentNotSampled = (_d4 = config.localParentNotSampled) !== null && _d4 !== void 0 ? _d4 : new AlwaysOffSampler_1.AlwaysOffSampler();
      }
      shouldSample(context3, traceId, spanName, spanKind, attributes, links) {
        const parentContext = api_1.trace.getSpanContext(context3);
        if (!parentContext || !(0, api_1.isSpanContextValid)(parentContext)) {
          return this._root.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
          if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
            return this._remoteParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
          }
          return this._remoteParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
          return this._localParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
      }
      toString() {
        return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
      }
    };
    exports.ParentBasedSampler = ParentBasedSampler;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js
var require_TraceIdRatioBasedSampler6 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TraceIdRatioBasedSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var TraceIdRatioBasedSampler = class {
      constructor(_ratio = 0) {
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 4294967295);
      }
      shouldSample(context3, traceId) {
        return {
          decision: (0, api_1.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? api_1.SamplingDecision.RECORD_AND_SAMPLED : api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return `TraceIdRatioBased{${this._ratio}}`;
      }
      _normalize(ratio) {
        if (typeof ratio !== "number" || isNaN(ratio))
          return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
      }
      _accumulate(traceId) {
        let accumulation = 0;
        for (let i2 = 0; i2 < traceId.length / 8; i2++) {
          const pos = i2 * 8;
          const part = parseInt(traceId.slice(pos, pos + 8), 16);
          accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
      }
    };
    exports.TraceIdRatioBasedSampler = TraceIdRatioBasedSampler;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js
var require_lodash_merge5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isPlainObject = void 0;
    var objectTag = "[object Object]";
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    var objectCtorString = funcToString.call(Object);
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    var nativeObjectToString = objectProto.toString;
    function overArg(func2, transform) {
      return function(arg) {
        return func2(transform(arg));
      };
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
        return false;
      }
      const proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      const Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
    }
    exports.isPlainObject = isPlainObject;
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function getRawTag(value) {
      const isOwn = hasOwnProperty2.call(value, symToStringTag), tag2 = value[symToStringTag];
      let unmasked = false;
      try {
        value[symToStringTag] = void 0;
        unmasked = true;
      } catch (e2) {
      }
      const result4 = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag2;
        } else {
          delete value[symToStringTag];
        }
      }
      return result4;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/utils/merge.js
var require_merge5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/utils/merge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = void 0;
    var lodash_merge_1 = require_lodash_merge5();
    var MAX_LEVEL = 20;
    function merge5(...args) {
      let result4 = args.shift();
      const objects = /* @__PURE__ */ new WeakMap();
      while (args.length > 0) {
        result4 = mergeTwoObjects(result4, args.shift(), 0, objects);
      }
      return result4;
    }
    exports.merge = merge5;
    function takeValue(value) {
      if (isArray(value)) {
        return value.slice();
      }
      return value;
    }
    function mergeTwoObjects(one, two, level = 0, objects) {
      let result4;
      if (level > MAX_LEVEL) {
        return void 0;
      }
      level++;
      if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {
        result4 = takeValue(two);
      } else if (isArray(one)) {
        result4 = one.slice();
        if (isArray(two)) {
          for (let i2 = 0, j2 = two.length; i2 < j2; i2++) {
            result4.push(takeValue(two[i2]));
          }
        } else if (isObject(two)) {
          const keys4 = Object.keys(two);
          for (let i2 = 0, j2 = keys4.length; i2 < j2; i2++) {
            const key = keys4[i2];
            result4[key] = takeValue(two[key]);
          }
        }
      } else if (isObject(one)) {
        if (isObject(two)) {
          if (!shouldMerge(one, two)) {
            return two;
          }
          result4 = Object.assign({}, one);
          const keys4 = Object.keys(two);
          for (let i2 = 0, j2 = keys4.length; i2 < j2; i2++) {
            const key = keys4[i2];
            const twoValue = two[key];
            if (isPrimitive(twoValue)) {
              if (typeof twoValue === "undefined") {
                delete result4[key];
              } else {
                result4[key] = twoValue;
              }
            } else {
              const obj1 = result4[key];
              const obj2 = twoValue;
              if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {
                delete result4[key];
              } else {
                if (isObject(obj1) && isObject(obj2)) {
                  const arr1 = objects.get(obj1) || [];
                  const arr2 = objects.get(obj2) || [];
                  arr1.push({ obj: one, key });
                  arr2.push({ obj: two, key });
                  objects.set(obj1, arr1);
                  objects.set(obj2, arr2);
                }
                result4[key] = mergeTwoObjects(result4[key], twoValue, level, objects);
              }
            }
          }
        } else {
          result4 = two;
        }
      }
      return result4;
    }
    function wasObjectReferenced(obj, key, objects) {
      const arr = objects.get(obj[key]) || [];
      for (let i2 = 0, j2 = arr.length; i2 < j2; i2++) {
        const info = arr[i2];
        if (info.key === key && info.obj === obj) {
          return true;
        }
      }
      return false;
    }
    function isArray(value) {
      return Array.isArray(value);
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isObject(value) {
      return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === "object";
    }
    function isPrimitive(value) {
      return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "undefined" || value instanceof Date || value instanceof RegExp || value === null;
    }
    function shouldMerge(one, two) {
      if (!(0, lodash_merge_1.isPlainObject)(one) || !(0, lodash_merge_1.isPlainObject)(two)) {
        return false;
      }
      return true;
    }
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/utils/timeout.js
var require_timeout5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/utils/timeout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callWithTimeout = exports.TimeoutError = void 0;
    var TimeoutError = class _TimeoutError extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, _TimeoutError.prototype);
      }
    };
    exports.TimeoutError = TimeoutError;
    function callWithTimeout(promise2, timeout4) {
      let timeoutHandle;
      const timeoutPromise = new Promise(function timeoutFunction(_resolve, reject3) {
        timeoutHandle = setTimeout(function timeoutHandler() {
          reject3(new TimeoutError("Operation timed out."));
        }, timeout4);
      });
      return Promise.race([promise2, timeoutPromise]).then((result4) => {
        clearTimeout(timeoutHandle);
        return result4;
      }, (reason) => {
        clearTimeout(timeoutHandle);
        throw reason;
      });
    }
    exports.callWithTimeout = callWithTimeout;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/utils/url.js
var require_url5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/utils/url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isUrlIgnored = exports.urlMatches = void 0;
    function urlMatches(url, urlToMatch) {
      if (typeof urlToMatch === "string") {
        return url === urlToMatch;
      } else {
        return !!url.match(urlToMatch);
      }
    }
    exports.urlMatches = urlMatches;
    function isUrlIgnored(url, ignoredUrls) {
      if (!ignoredUrls) {
        return false;
      }
      for (const ignoreUrl of ignoredUrls) {
        if (urlMatches(url, ignoreUrl)) {
          return true;
        }
      }
      return false;
    }
    exports.isUrlIgnored = isUrlIgnored;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/utils/wrap.js
var require_wrap5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/utils/wrap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isWrapped = void 0;
    function isWrapped(func2) {
      return typeof func2 === "function" && typeof func2.__original === "function" && typeof func2.__unwrap === "function" && func2.__wrapped === true;
    }
    exports.isWrapped = isWrapped;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/utils/promise.js
var require_promise5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/utils/promise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Deferred = void 0;
    var Deferred = class {
      constructor() {
        this._promise = new Promise((resolve, reject3) => {
          this._resolve = resolve;
          this._reject = reject3;
        });
      }
      get promise() {
        return this._promise;
      }
      resolve(val) {
        this._resolve(val);
      }
      reject(err) {
        this._reject(err);
      }
    };
    exports.Deferred = Deferred;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/utils/callback.js
var require_callback5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/utils/callback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BindOnceFuture = void 0;
    var promise_1 = require_promise5();
    var BindOnceFuture = class {
      constructor(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new promise_1.Deferred();
      }
      get isCalled() {
        return this._isCalled;
      }
      get promise() {
        return this._deferred.promise;
      }
      call(...args) {
        if (!this._isCalled) {
          this._isCalled = true;
          try {
            Promise.resolve(this._callback.call(this._that, ...args)).then((val) => this._deferred.resolve(val), (err) => this._deferred.reject(err));
          } catch (err) {
            this._deferred.reject(err);
          }
        }
        return this._deferred.promise;
      }
    };
    exports.BindOnceFuture = BindOnceFuture;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/internal/exporter.js
var require_exporter5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/internal/exporter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._export = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing5();
    function _export(exporter, arg) {
      return new Promise((resolve) => {
        api_1.context.with((0, suppress_tracing_1.suppressTracing)(api_1.context.active()), () => {
          exporter.export(arg, (result4) => {
            resolve(result4);
          });
        });
      });
    }
    exports._export = _export;
  }
});

// node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/index.js
var require_src15 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/node_modules/@opentelemetry/core/build/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.internal = exports.baggageUtils = void 0;
    __exportStar(require_W3CBaggagePropagator5(), exports);
    __exportStar(require_anchored_clock5(), exports);
    __exportStar(require_attributes5(), exports);
    __exportStar(require_global_error_handler5(), exports);
    __exportStar(require_logging_error_handler5(), exports);
    __exportStar(require_time5(), exports);
    __exportStar(require_types7(), exports);
    __exportStar(require_hex_to_binary5(), exports);
    __exportStar(require_ExportResult5(), exports);
    exports.baggageUtils = require_utils10();
    __exportStar(require_platform9(), exports);
    __exportStar(require_composite5(), exports);
    __exportStar(require_W3CTraceContextPropagator5(), exports);
    __exportStar(require_IdGenerator4(), exports);
    __exportStar(require_rpc_metadata5(), exports);
    __exportStar(require_AlwaysOffSampler6(), exports);
    __exportStar(require_AlwaysOnSampler6(), exports);
    __exportStar(require_ParentBasedSampler6(), exports);
    __exportStar(require_TraceIdRatioBasedSampler6(), exports);
    __exportStar(require_suppress_tracing5(), exports);
    __exportStar(require_TraceState5(), exports);
    __exportStar(require_environment10(), exports);
    __exportStar(require_merge5(), exports);
    __exportStar(require_sampling5(), exports);
    __exportStar(require_timeout5(), exports);
    __exportStar(require_url5(), exports);
    __exportStar(require_wrap5(), exports);
    __exportStar(require_callback5(), exports);
    __exportStar(require_version5(), exports);
    var exporter_1 = require_exporter5();
    exports.internal = {
      _export: exporter_1._export
    };
  }
});

// node_modules/@opentelemetry/otlp-transformer/build/src/common/index.js
var require_common = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/build/src/common/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getOtlpEncoder = exports.encodeAsString = exports.encodeAsLongBits = exports.toLongBits = exports.hrTimeToNanos = void 0;
    var core_1 = require_src15();
    function hrTimeToNanos(hrTime) {
      const NANOSECONDS = BigInt(1e9);
      return BigInt(hrTime[0]) * NANOSECONDS + BigInt(hrTime[1]);
    }
    exports.hrTimeToNanos = hrTimeToNanos;
    function toLongBits(value) {
      const low = Number(BigInt.asUintN(32, value));
      const high = Number(BigInt.asUintN(32, value >> BigInt(32)));
      return { low, high };
    }
    exports.toLongBits = toLongBits;
    function encodeAsLongBits(hrTime) {
      const nanos = hrTimeToNanos(hrTime);
      return toLongBits(nanos);
    }
    exports.encodeAsLongBits = encodeAsLongBits;
    function encodeAsString(hrTime) {
      const nanos = hrTimeToNanos(hrTime);
      return nanos.toString();
    }
    exports.encodeAsString = encodeAsString;
    var encodeTimestamp = typeof BigInt !== "undefined" ? encodeAsString : core_1.hrTimeToNanoseconds;
    function identity4(value) {
      return value;
    }
    function optionalHexToBinary(str) {
      if (str === void 0)
        return void 0;
      return (0, core_1.hexToBinary)(str);
    }
    var DEFAULT_ENCODER = {
      encodeHrTime: encodeAsLongBits,
      encodeSpanContext: core_1.hexToBinary,
      encodeOptionalSpanContext: optionalHexToBinary
    };
    function getOtlpEncoder(options) {
      var _a12, _b5;
      if (options === void 0) {
        return DEFAULT_ENCODER;
      }
      const useLongBits = (_a12 = options.useLongBits) !== null && _a12 !== void 0 ? _a12 : true;
      const useHex = (_b5 = options.useHex) !== null && _b5 !== void 0 ? _b5 : false;
      return {
        encodeHrTime: useLongBits ? encodeAsLongBits : encodeTimestamp,
        encodeSpanContext: useHex ? identity4 : core_1.hexToBinary,
        encodeOptionalSpanContext: useHex ? identity4 : optionalHexToBinary
      };
    }
    exports.getOtlpEncoder = getOtlpEncoder;
  }
});

// node_modules/@opentelemetry/otlp-transformer/build/src/metrics/types.js
var require_types8 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/build/src/metrics/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/otlp-transformer/build/src/resource/types.js
var require_types9 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/build/src/resource/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/otlp-transformer/build/src/trace/types.js
var require_types10 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/build/src/trace/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ESpanKind = void 0;
    var ESpanKind;
    (function(ESpanKind2) {
      ESpanKind2[ESpanKind2["SPAN_KIND_UNSPECIFIED"] = 0] = "SPAN_KIND_UNSPECIFIED";
      ESpanKind2[ESpanKind2["SPAN_KIND_INTERNAL"] = 1] = "SPAN_KIND_INTERNAL";
      ESpanKind2[ESpanKind2["SPAN_KIND_SERVER"] = 2] = "SPAN_KIND_SERVER";
      ESpanKind2[ESpanKind2["SPAN_KIND_CLIENT"] = 3] = "SPAN_KIND_CLIENT";
      ESpanKind2[ESpanKind2["SPAN_KIND_PRODUCER"] = 4] = "SPAN_KIND_PRODUCER";
      ESpanKind2[ESpanKind2["SPAN_KIND_CONSUMER"] = 5] = "SPAN_KIND_CONSUMER";
    })(ESpanKind = exports.ESpanKind || (exports.ESpanKind = {}));
  }
});

// node_modules/@opentelemetry/otlp-transformer/build/src/logs/types.js
var require_types11 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/build/src/logs/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/otlp-transformer/build/src/common/internal.js
var require_internal = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/build/src/common/internal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toAnyValue = exports.toKeyValue = exports.toAttributes = exports.createInstrumentationScope = void 0;
    function createInstrumentationScope(scope3) {
      return {
        name: scope3.name,
        version: scope3.version
      };
    }
    exports.createInstrumentationScope = createInstrumentationScope;
    function toAttributes(attributes) {
      return Object.keys(attributes).map((key) => toKeyValue(key, attributes[key]));
    }
    exports.toAttributes = toAttributes;
    function toKeyValue(key, value) {
      return {
        key,
        value: toAnyValue(value)
      };
    }
    exports.toKeyValue = toKeyValue;
    function toAnyValue(value) {
      const t2 = typeof value;
      if (t2 === "string")
        return { stringValue: value };
      if (t2 === "number") {
        if (!Number.isInteger(value))
          return { doubleValue: value };
        return { intValue: value };
      }
      if (t2 === "boolean")
        return { boolValue: value };
      if (value instanceof Uint8Array)
        return { bytesValue: value };
      if (Array.isArray(value))
        return { arrayValue: { values: value.map(toAnyValue) } };
      if (t2 === "object" && value != null)
        return {
          kvlistValue: {
            values: Object.entries(value).map(([k2, v2]) => toKeyValue(k2, v2))
          }
        };
      return {};
    }
    exports.toAnyValue = toAnyValue;
  }
});

// node_modules/@opentelemetry/otlp-transformer/build/src/trace/internal.js
var require_internal2 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/build/src/trace/internal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toOtlpSpanEvent = exports.toOtlpLink = exports.sdkSpanToOtlpSpan = void 0;
    var internal_1 = require_internal();
    function sdkSpanToOtlpSpan(span, encoder) {
      var _a12;
      const ctx = span.spanContext();
      const status = span.status;
      return {
        traceId: encoder.encodeSpanContext(ctx.traceId),
        spanId: encoder.encodeSpanContext(ctx.spanId),
        parentSpanId: encoder.encodeOptionalSpanContext(span.parentSpanId),
        traceState: (_a12 = ctx.traceState) === null || _a12 === void 0 ? void 0 : _a12.serialize(),
        name: span.name,
        // Span kind is offset by 1 because the API does not define a value for unset
        kind: span.kind == null ? 0 : span.kind + 1,
        startTimeUnixNano: encoder.encodeHrTime(span.startTime),
        endTimeUnixNano: encoder.encodeHrTime(span.endTime),
        attributes: (0, internal_1.toAttributes)(span.attributes),
        droppedAttributesCount: span.droppedAttributesCount,
        events: span.events.map((event) => toOtlpSpanEvent(event, encoder)),
        droppedEventsCount: span.droppedEventsCount,
        status: {
          // API and proto enums share the same values
          code: status.code,
          message: status.message
        },
        links: span.links.map((link) => toOtlpLink(link, encoder)),
        droppedLinksCount: span.droppedLinksCount
      };
    }
    exports.sdkSpanToOtlpSpan = sdkSpanToOtlpSpan;
    function toOtlpLink(link, encoder) {
      var _a12;
      return {
        attributes: link.attributes ? (0, internal_1.toAttributes)(link.attributes) : [],
        spanId: encoder.encodeSpanContext(link.context.spanId),
        traceId: encoder.encodeSpanContext(link.context.traceId),
        traceState: (_a12 = link.context.traceState) === null || _a12 === void 0 ? void 0 : _a12.serialize(),
        droppedAttributesCount: link.droppedAttributesCount || 0
      };
    }
    exports.toOtlpLink = toOtlpLink;
    function toOtlpSpanEvent(timedEvent, encoder) {
      return {
        attributes: timedEvent.attributes ? (0, internal_1.toAttributes)(timedEvent.attributes) : [],
        name: timedEvent.name,
        timeUnixNano: encoder.encodeHrTime(timedEvent.time),
        droppedAttributesCount: timedEvent.droppedAttributesCount || 0
      };
    }
    exports.toOtlpSpanEvent = toOtlpSpanEvent;
  }
});

// node_modules/@opentelemetry/otlp-transformer/build/src/resource/internal.js
var require_internal3 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/build/src/resource/internal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createResource = void 0;
    var internal_1 = require_internal();
    function createResource(resource) {
      return {
        attributes: (0, internal_1.toAttributes)(resource.attributes),
        droppedAttributesCount: 0
      };
    }
    exports.createResource = createResource;
  }
});

// node_modules/@opentelemetry/otlp-transformer/build/src/trace/index.js
var require_trace5 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/build/src/trace/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createExportTraceServiceRequest = void 0;
    var internal_1 = require_internal2();
    var common_1 = require_common();
    var internal_2 = require_internal();
    var internal_3 = require_internal3();
    function createExportTraceServiceRequest(spans, options) {
      const encoder = (0, common_1.getOtlpEncoder)(options);
      return {
        resourceSpans: spanRecordsToResourceSpans(spans, encoder)
      };
    }
    exports.createExportTraceServiceRequest = createExportTraceServiceRequest;
    function createResourceMap(readableSpans) {
      const resourceMap = /* @__PURE__ */ new Map();
      for (const record2 of readableSpans) {
        let ilmMap = resourceMap.get(record2.resource);
        if (!ilmMap) {
          ilmMap = /* @__PURE__ */ new Map();
          resourceMap.set(record2.resource, ilmMap);
        }
        const instrumentationLibraryKey = `${record2.instrumentationLibrary.name}@${record2.instrumentationLibrary.version || ""}:${record2.instrumentationLibrary.schemaUrl || ""}`;
        let records = ilmMap.get(instrumentationLibraryKey);
        if (!records) {
          records = [];
          ilmMap.set(instrumentationLibraryKey, records);
        }
        records.push(record2);
      }
      return resourceMap;
    }
    function spanRecordsToResourceSpans(readableSpans, encoder) {
      const resourceMap = createResourceMap(readableSpans);
      const out = [];
      const entryIterator = resourceMap.entries();
      let entry = entryIterator.next();
      while (!entry.done) {
        const [resource, ilmMap] = entry.value;
        const scopeResourceSpans = [];
        const ilmIterator = ilmMap.values();
        let ilmEntry = ilmIterator.next();
        while (!ilmEntry.done) {
          const scopeSpans = ilmEntry.value;
          if (scopeSpans.length > 0) {
            const spans = scopeSpans.map((readableSpan) => (0, internal_1.sdkSpanToOtlpSpan)(readableSpan, encoder));
            scopeResourceSpans.push({
              scope: (0, internal_2.createInstrumentationScope)(scopeSpans[0].instrumentationLibrary),
              spans,
              schemaUrl: scopeSpans[0].instrumentationLibrary.schemaUrl
            });
          }
          ilmEntry = ilmIterator.next();
        }
        const transformedSpans = {
          resource: (0, internal_3.createResource)(resource),
          scopeSpans: scopeResourceSpans,
          schemaUrl: void 0
        };
        out.push(transformedSpans);
        entry = entryIterator.next();
      }
      return out;
    }
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/export/AggregationTemporality.js
var require_AggregationTemporality = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/export/AggregationTemporality.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AggregationTemporality = void 0;
    var AggregationTemporality;
    (function(AggregationTemporality2) {
      AggregationTemporality2[AggregationTemporality2["DELTA"] = 0] = "DELTA";
      AggregationTemporality2[AggregationTemporality2["CUMULATIVE"] = 1] = "CUMULATIVE";
    })(AggregationTemporality = exports.AggregationTemporality || (exports.AggregationTemporality = {}));
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/export/MetricData.js
var require_MetricData = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/export/MetricData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataPointType = void 0;
    var DataPointType;
    (function(DataPointType2) {
      DataPointType2[DataPointType2["HISTOGRAM"] = 0] = "HISTOGRAM";
      DataPointType2[DataPointType2["EXPONENTIAL_HISTOGRAM"] = 1] = "EXPONENTIAL_HISTOGRAM";
      DataPointType2[DataPointType2["GAUGE"] = 2] = "GAUGE";
      DataPointType2[DataPointType2["SUM"] = 3] = "SUM";
    })(DataPointType = exports.DataPointType || (exports.DataPointType = {}));
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/utils.js
var require_utils12 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.equalsCaseInsensitive = exports.binarySearchLB = exports.setEquals = exports.FlatMap = exports.isPromiseAllSettledRejectionResult = exports.PromiseAllSettled = exports.callWithTimeout = exports.TimeoutError = exports.instrumentationScopeId = exports.hashAttributes = exports.isNotNullish = void 0;
    function isNotNullish(item) {
      return item !== void 0 && item !== null;
    }
    exports.isNotNullish = isNotNullish;
    function hashAttributes(attributes) {
      let keys4 = Object.keys(attributes);
      if (keys4.length === 0)
        return "";
      keys4 = keys4.sort();
      return JSON.stringify(keys4.map((key) => [key, attributes[key]]));
    }
    exports.hashAttributes = hashAttributes;
    function instrumentationScopeId(instrumentationScope) {
      var _a12, _b5;
      return `${instrumentationScope.name}:${(_a12 = instrumentationScope.version) !== null && _a12 !== void 0 ? _a12 : ""}:${(_b5 = instrumentationScope.schemaUrl) !== null && _b5 !== void 0 ? _b5 : ""}`;
    }
    exports.instrumentationScopeId = instrumentationScopeId;
    var TimeoutError = class _TimeoutError extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, _TimeoutError.prototype);
      }
    };
    exports.TimeoutError = TimeoutError;
    function callWithTimeout(promise2, timeout4) {
      let timeoutHandle;
      const timeoutPromise = new Promise(function timeoutFunction(_resolve, reject3) {
        timeoutHandle = setTimeout(function timeoutHandler() {
          reject3(new TimeoutError("Operation timed out."));
        }, timeout4);
      });
      return Promise.race([promise2, timeoutPromise]).then((result4) => {
        clearTimeout(timeoutHandle);
        return result4;
      }, (reason) => {
        clearTimeout(timeoutHandle);
        throw reason;
      });
    }
    exports.callWithTimeout = callWithTimeout;
    async function PromiseAllSettled(promises) {
      return Promise.all(promises.map(async (p2) => {
        try {
          const ret = await p2;
          return {
            status: "fulfilled",
            value: ret
          };
        } catch (e2) {
          return {
            status: "rejected",
            reason: e2
          };
        }
      }));
    }
    exports.PromiseAllSettled = PromiseAllSettled;
    function isPromiseAllSettledRejectionResult(it2) {
      return it2.status === "rejected";
    }
    exports.isPromiseAllSettledRejectionResult = isPromiseAllSettledRejectionResult;
    function FlatMap3(arr, fn) {
      const result4 = [];
      arr.forEach((it2) => {
        result4.push(...fn(it2));
      });
      return result4;
    }
    exports.FlatMap = FlatMap3;
    function setEquals(lhs, rhs) {
      if (lhs.size !== rhs.size) {
        return false;
      }
      for (const item of lhs) {
        if (!rhs.has(item)) {
          return false;
        }
      }
      return true;
    }
    exports.setEquals = setEquals;
    function binarySearchLB(arr, value) {
      let lo = 0;
      let hi = arr.length - 1;
      while (hi - lo > 1) {
        const mid = Math.trunc((hi + lo) / 2);
        if (arr[mid] <= value) {
          lo = mid;
        } else {
          hi = mid - 1;
        }
      }
      if (arr[hi] <= value) {
        return hi;
      } else if (arr[lo] <= value) {
        return lo;
      }
      return -1;
    }
    exports.binarySearchLB = binarySearchLB;
    function equalsCaseInsensitive(lhs, rhs) {
      return lhs.toLowerCase() === rhs.toLowerCase();
    }
    exports.equalsCaseInsensitive = equalsCaseInsensitive;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/types.js
var require_types12 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AggregatorKind = void 0;
    var AggregatorKind;
    (function(AggregatorKind2) {
      AggregatorKind2[AggregatorKind2["DROP"] = 0] = "DROP";
      AggregatorKind2[AggregatorKind2["SUM"] = 1] = "SUM";
      AggregatorKind2[AggregatorKind2["LAST_VALUE"] = 2] = "LAST_VALUE";
      AggregatorKind2[AggregatorKind2["HISTOGRAM"] = 3] = "HISTOGRAM";
      AggregatorKind2[AggregatorKind2["EXPONENTIAL_HISTOGRAM"] = 4] = "EXPONENTIAL_HISTOGRAM";
    })(AggregatorKind = exports.AggregatorKind || (exports.AggregatorKind = {}));
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Drop.js
var require_Drop = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Drop.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DropAggregator = void 0;
    var types_1 = require_types12();
    var DropAggregator = class {
      constructor() {
        this.kind = types_1.AggregatorKind.DROP;
      }
      createAccumulation() {
        return void 0;
      }
      merge(_previous, _delta) {
        return void 0;
      }
      diff(_previous, _current2) {
        return void 0;
      }
      toMetricData(_descriptor, _aggregationTemporality, _accumulationByAttributes, _endTime) {
        return void 0;
      }
    };
    exports.DropAggregator = DropAggregator;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/InstrumentDescriptor.js
var require_InstrumentDescriptor = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/InstrumentDescriptor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isValidName = exports.isDescriptorCompatibleWith = exports.createInstrumentDescriptorWithView = exports.createInstrumentDescriptor = exports.InstrumentType = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var utils_1 = require_utils12();
    var InstrumentType;
    (function(InstrumentType2) {
      InstrumentType2["COUNTER"] = "COUNTER";
      InstrumentType2["GAUGE"] = "GAUGE";
      InstrumentType2["HISTOGRAM"] = "HISTOGRAM";
      InstrumentType2["UP_DOWN_COUNTER"] = "UP_DOWN_COUNTER";
      InstrumentType2["OBSERVABLE_COUNTER"] = "OBSERVABLE_COUNTER";
      InstrumentType2["OBSERVABLE_GAUGE"] = "OBSERVABLE_GAUGE";
      InstrumentType2["OBSERVABLE_UP_DOWN_COUNTER"] = "OBSERVABLE_UP_DOWN_COUNTER";
    })(InstrumentType = exports.InstrumentType || (exports.InstrumentType = {}));
    function createInstrumentDescriptor(name, type, options) {
      var _a12, _b5, _c4, _d4;
      if (!isValidName(name)) {
        api_1.diag.warn(`Invalid metric name: "${name}". The metric name should be a ASCII string with a length no greater than 255 characters.`);
      }
      return {
        name,
        type,
        description: (_a12 = options === null || options === void 0 ? void 0 : options.description) !== null && _a12 !== void 0 ? _a12 : "",
        unit: (_b5 = options === null || options === void 0 ? void 0 : options.unit) !== null && _b5 !== void 0 ? _b5 : "",
        valueType: (_c4 = options === null || options === void 0 ? void 0 : options.valueType) !== null && _c4 !== void 0 ? _c4 : api_1.ValueType.DOUBLE,
        advice: (_d4 = options === null || options === void 0 ? void 0 : options.advice) !== null && _d4 !== void 0 ? _d4 : {}
      };
    }
    exports.createInstrumentDescriptor = createInstrumentDescriptor;
    function createInstrumentDescriptorWithView(view, instrument) {
      var _a12, _b5;
      return {
        name: (_a12 = view.name) !== null && _a12 !== void 0 ? _a12 : instrument.name,
        description: (_b5 = view.description) !== null && _b5 !== void 0 ? _b5 : instrument.description,
        type: instrument.type,
        unit: instrument.unit,
        valueType: instrument.valueType,
        advice: instrument.advice
      };
    }
    exports.createInstrumentDescriptorWithView = createInstrumentDescriptorWithView;
    function isDescriptorCompatibleWith(descriptor3, otherDescriptor) {
      return (0, utils_1.equalsCaseInsensitive)(descriptor3.name, otherDescriptor.name) && descriptor3.unit === otherDescriptor.unit && descriptor3.type === otherDescriptor.type && descriptor3.valueType === otherDescriptor.valueType;
    }
    exports.isDescriptorCompatibleWith = isDescriptorCompatibleWith;
    var NAME_REGEXP = /^[a-z][a-z0-9_.\-/]{0,254}$/i;
    function isValidName(name) {
      return name.match(NAME_REGEXP) != null;
    }
    exports.isValidName = isValidName;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Histogram.js
var require_Histogram = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Histogram.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HistogramAggregator = exports.HistogramAccumulation = void 0;
    var types_1 = require_types12();
    var MetricData_1 = require_MetricData();
    var InstrumentDescriptor_1 = require_InstrumentDescriptor();
    var utils_1 = require_utils12();
    function createNewEmptyCheckpoint(boundaries) {
      const counts = boundaries.map(() => 0);
      counts.push(0);
      return {
        buckets: {
          boundaries,
          counts
        },
        sum: 0,
        count: 0,
        hasMinMax: false,
        min: Infinity,
        max: -Infinity
      };
    }
    var HistogramAccumulation = class {
      constructor(startTime, _boundaries, _recordMinMax = true, _current2 = createNewEmptyCheckpoint(_boundaries)) {
        this.startTime = startTime;
        this._boundaries = _boundaries;
        this._recordMinMax = _recordMinMax;
        this._current = _current2;
      }
      record(value) {
        if (Number.isNaN(value)) {
          return;
        }
        this._current.count += 1;
        this._current.sum += value;
        if (this._recordMinMax) {
          this._current.min = Math.min(value, this._current.min);
          this._current.max = Math.max(value, this._current.max);
          this._current.hasMinMax = true;
        }
        const idx = (0, utils_1.binarySearchLB)(this._boundaries, value);
        this._current.buckets.counts[idx + 1] += 1;
      }
      setStartTime(startTime) {
        this.startTime = startTime;
      }
      toPointValue() {
        return this._current;
      }
    };
    exports.HistogramAccumulation = HistogramAccumulation;
    var HistogramAggregator = class {
      /**
       * @param _boundaries sorted upper bounds of recorded values.
       * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.
       */
      constructor(_boundaries, _recordMinMax) {
        this._boundaries = _boundaries;
        this._recordMinMax = _recordMinMax;
        this.kind = types_1.AggregatorKind.HISTOGRAM;
      }
      createAccumulation(startTime) {
        return new HistogramAccumulation(startTime, this._boundaries, this._recordMinMax);
      }
      /**
       * Return the result of the merge of two histogram accumulations. As long as one Aggregator
       * instance produces all Accumulations with constant boundaries we don't need to worry about
       * merging accumulations with different boundaries.
       */
      merge(previous, delta) {
        const previousValue = previous.toPointValue();
        const deltaValue = delta.toPointValue();
        const previousCounts = previousValue.buckets.counts;
        const deltaCounts = deltaValue.buckets.counts;
        const mergedCounts = new Array(previousCounts.length);
        for (let idx = 0; idx < previousCounts.length; idx++) {
          mergedCounts[idx] = previousCounts[idx] + deltaCounts[idx];
        }
        let min2 = Infinity;
        let max2 = -Infinity;
        if (this._recordMinMax) {
          if (previousValue.hasMinMax && deltaValue.hasMinMax) {
            min2 = Math.min(previousValue.min, deltaValue.min);
            max2 = Math.max(previousValue.max, deltaValue.max);
          } else if (previousValue.hasMinMax) {
            min2 = previousValue.min;
            max2 = previousValue.max;
          } else if (deltaValue.hasMinMax) {
            min2 = deltaValue.min;
            max2 = deltaValue.max;
          }
        }
        return new HistogramAccumulation(previous.startTime, previousValue.buckets.boundaries, this._recordMinMax, {
          buckets: {
            boundaries: previousValue.buckets.boundaries,
            counts: mergedCounts
          },
          count: previousValue.count + deltaValue.count,
          sum: previousValue.sum + deltaValue.sum,
          hasMinMax: this._recordMinMax && (previousValue.hasMinMax || deltaValue.hasMinMax),
          min: min2,
          max: max2
        });
      }
      /**
       * Returns a new DELTA aggregation by comparing two cumulative measurements.
       */
      diff(previous, current) {
        const previousValue = previous.toPointValue();
        const currentValue = current.toPointValue();
        const previousCounts = previousValue.buckets.counts;
        const currentCounts = currentValue.buckets.counts;
        const diffedCounts = new Array(previousCounts.length);
        for (let idx = 0; idx < previousCounts.length; idx++) {
          diffedCounts[idx] = currentCounts[idx] - previousCounts[idx];
        }
        return new HistogramAccumulation(current.startTime, previousValue.buckets.boundaries, this._recordMinMax, {
          buckets: {
            boundaries: previousValue.buckets.boundaries,
            counts: diffedCounts
          },
          count: currentValue.count - previousValue.count,
          sum: currentValue.sum - previousValue.sum,
          hasMinMax: false,
          min: Infinity,
          max: -Infinity
        });
      }
      toMetricData(descriptor3, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
          descriptor: descriptor3,
          aggregationTemporality,
          dataPointType: MetricData_1.DataPointType.HISTOGRAM,
          dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {
            const pointValue = accumulation.toPointValue();
            const allowsNegativeValues = descriptor3.type === InstrumentDescriptor_1.InstrumentType.GAUGE || descriptor3.type === InstrumentDescriptor_1.InstrumentType.UP_DOWN_COUNTER || descriptor3.type === InstrumentDescriptor_1.InstrumentType.OBSERVABLE_GAUGE || descriptor3.type === InstrumentDescriptor_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;
            return {
              attributes,
              startTime: accumulation.startTime,
              endTime,
              value: {
                min: pointValue.hasMinMax ? pointValue.min : void 0,
                max: pointValue.hasMinMax ? pointValue.max : void 0,
                sum: !allowsNegativeValues ? pointValue.sum : void 0,
                buckets: pointValue.buckets,
                count: pointValue.count
              }
            };
          })
        };
      }
    };
    exports.HistogramAggregator = HistogramAggregator;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/Buckets.js
var require_Buckets = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/Buckets.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Buckets = void 0;
    var Buckets = class _Buckets {
      /**
       * The term index refers to the number of the exponential histogram bucket
       * used to determine its boundaries. The lower boundary of a bucket is
       * determined by base ** index and the upper boundary of a bucket is
       * determined by base ** (index + 1). index values are signed to account
       * for values less than or equal to 1.
       *
       * indexBase is the index of the 0th position in the
       * backing array, i.e., backing[0] is the count
       * in the bucket with index `indexBase`.
       *
       * indexStart is the smallest index value represented
       * in the backing array.
       *
       * indexEnd is the largest index value represented in
       * the backing array.
       */
      constructor(backing = new BucketsBacking(), indexBase = 0, indexStart = 0, indexEnd = 0) {
        this.backing = backing;
        this.indexBase = indexBase;
        this.indexStart = indexStart;
        this.indexEnd = indexEnd;
      }
      /**
       * Offset is the bucket index of the smallest entry in the counts array
       * @returns {number}
       */
      get offset() {
        return this.indexStart;
      }
      /**
       * Buckets is a view into the backing array.
       * @returns {number}
       */
      get length() {
        if (this.backing.length === 0) {
          return 0;
        }
        if (this.indexEnd === this.indexStart && this.at(0) === 0) {
          return 0;
        }
        return this.indexEnd - this.indexStart + 1;
      }
      /**
       * An array of counts, where count[i] carries the count
       * of the bucket at index (offset+i).  count[i] is the count of
       * values greater than base^(offset+i) and less than or equal to
       * base^(offset+i+1).
       * @returns {number} The logical counts based on the backing array
       */
      counts() {
        return Array.from({ length: this.length }, (_2, i2) => this.at(i2));
      }
      /**
       * At returns the count of the bucket at a position in the logical
       * array of counts.
       * @param position
       * @returns {number}
       */
      at(position) {
        const bias = this.indexBase - this.indexStart;
        if (position < bias) {
          position += this.backing.length;
        }
        position -= bias;
        return this.backing.countAt(position);
      }
      /**
       * incrementBucket increments the backing array index by `increment`
       * @param bucketIndex
       * @param increment
       */
      incrementBucket(bucketIndex, increment) {
        this.backing.increment(bucketIndex, increment);
      }
      /**
       * decrementBucket decrements the backing array index by `decrement`
       * if decrement is greater than the current value, it's set to 0.
       * @param bucketIndex
       * @param decrement
       */
      decrementBucket(bucketIndex, decrement) {
        this.backing.decrement(bucketIndex, decrement);
      }
      /**
       * trim removes leading and / or trailing zero buckets (which can occur
       * after diffing two histos) and rotates the backing array so that the
       * smallest non-zero index is in the 0th position of the backing array
       */
      trim() {
        for (let i2 = 0; i2 < this.length; i2++) {
          if (this.at(i2) !== 0) {
            this.indexStart += i2;
            break;
          } else if (i2 === this.length - 1) {
            this.indexStart = this.indexEnd = this.indexBase = 0;
            return;
          }
        }
        for (let i2 = this.length - 1; i2 >= 0; i2--) {
          if (this.at(i2) !== 0) {
            this.indexEnd -= this.length - i2 - 1;
            break;
          }
        }
        this._rotate();
      }
      /**
       * downscale first rotates, then collapses 2**`by`-to-1 buckets.
       * @param by
       */
      downscale(by) {
        this._rotate();
        const size7 = 1 + this.indexEnd - this.indexStart;
        const each = 1 << by;
        let inpos = 0;
        let outpos = 0;
        for (let pos = this.indexStart; pos <= this.indexEnd; ) {
          let mod = pos % each;
          if (mod < 0) {
            mod += each;
          }
          for (let i2 = mod; i2 < each && inpos < size7; i2++) {
            this._relocateBucket(outpos, inpos);
            inpos++;
            pos++;
          }
          outpos++;
        }
        this.indexStart >>= by;
        this.indexEnd >>= by;
        this.indexBase = this.indexStart;
      }
      /**
       * Clone returns a deep copy of Buckets
       * @returns {Buckets}
       */
      clone() {
        return new _Buckets(this.backing.clone(), this.indexBase, this.indexStart, this.indexEnd);
      }
      /**
       * _rotate shifts the backing array contents so that indexStart ==
       * indexBase to simplify the downscale logic.
       */
      _rotate() {
        const bias = this.indexBase - this.indexStart;
        if (bias === 0) {
          return;
        } else if (bias > 0) {
          this.backing.reverse(0, this.backing.length);
          this.backing.reverse(0, bias);
          this.backing.reverse(bias, this.backing.length);
        } else {
          this.backing.reverse(0, this.backing.length);
          this.backing.reverse(0, this.backing.length + bias);
        }
        this.indexBase = this.indexStart;
      }
      /**
       * _relocateBucket adds the count in counts[src] to counts[dest] and
       * resets count[src] to zero.
       */
      _relocateBucket(dest, src) {
        if (dest === src) {
          return;
        }
        this.incrementBucket(dest, this.backing.emptyBucket(src));
      }
    };
    exports.Buckets = Buckets;
    var BucketsBacking = class _BucketsBacking {
      constructor(_counts = [0]) {
        this._counts = _counts;
      }
      /**
       * length returns the physical size of the backing array, which
       * is >= buckets.length()
       */
      get length() {
        return this._counts.length;
      }
      /**
       * countAt returns the count in a specific bucket
       */
      countAt(pos) {
        return this._counts[pos];
      }
      /**
       * growTo grows a backing array and copies old entries
       * into their correct new positions.
       */
      growTo(newSize, oldPositiveLimit, newPositiveLimit) {
        const tmp = new Array(newSize).fill(0);
        tmp.splice(newPositiveLimit, this._counts.length - oldPositiveLimit, ...this._counts.slice(oldPositiveLimit));
        tmp.splice(0, oldPositiveLimit, ...this._counts.slice(0, oldPositiveLimit));
        this._counts = tmp;
      }
      /**
       * reverse the items in the backing array in the range [from, limit).
       */
      reverse(from4, limit) {
        const num = Math.floor((from4 + limit) / 2) - from4;
        for (let i2 = 0; i2 < num; i2++) {
          const tmp = this._counts[from4 + i2];
          this._counts[from4 + i2] = this._counts[limit - i2 - 1];
          this._counts[limit - i2 - 1] = tmp;
        }
      }
      /**
       * emptyBucket empties the count from a bucket, for
       * moving into another.
       */
      emptyBucket(src) {
        const tmp = this._counts[src];
        this._counts[src] = 0;
        return tmp;
      }
      /**
       * increments a bucket by `increment`
       */
      increment(bucketIndex, increment) {
        this._counts[bucketIndex] += increment;
      }
      /**
       * decrements a bucket by `decrement`
       */
      decrement(bucketIndex, decrement) {
        if (this._counts[bucketIndex] >= decrement) {
          this._counts[bucketIndex] -= decrement;
        } else {
          this._counts[bucketIndex] = 0;
        }
      }
      /**
       * clone returns a deep copy of BucketsBacking
       */
      clone() {
        return new _BucketsBacking([...this._counts]);
      }
    };
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/ieee754.js
var require_ieee754 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/ieee754.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSignificand = exports.getNormalBase2 = exports.MIN_VALUE = exports.MAX_NORMAL_EXPONENT = exports.MIN_NORMAL_EXPONENT = exports.SIGNIFICAND_WIDTH = void 0;
    exports.SIGNIFICAND_WIDTH = 52;
    var EXPONENT_MASK = 2146435072;
    var SIGNIFICAND_MASK = 1048575;
    var EXPONENT_BIAS = 1023;
    exports.MIN_NORMAL_EXPONENT = -EXPONENT_BIAS + 1;
    exports.MAX_NORMAL_EXPONENT = EXPONENT_BIAS;
    exports.MIN_VALUE = Math.pow(2, -1022);
    function getNormalBase2(value) {
      const dv = new DataView(new ArrayBuffer(8));
      dv.setFloat64(0, value);
      const hiBits = dv.getUint32(0);
      const expBits = (hiBits & EXPONENT_MASK) >> 20;
      return expBits - EXPONENT_BIAS;
    }
    exports.getNormalBase2 = getNormalBase2;
    function getSignificand(value) {
      const dv = new DataView(new ArrayBuffer(8));
      dv.setFloat64(0, value);
      const hiBits = dv.getUint32(0);
      const loBits = dv.getUint32(4);
      const significandHiBits = (hiBits & SIGNIFICAND_MASK) * Math.pow(2, 32);
      return significandHiBits + loBits;
    }
    exports.getSignificand = getSignificand;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/util.js
var require_util6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nextGreaterSquare = exports.ldexp = void 0;
    function ldexp(frac, exp) {
      if (frac === 0 || frac === Number.POSITIVE_INFINITY || frac === Number.NEGATIVE_INFINITY || Number.isNaN(frac)) {
        return frac;
      }
      return frac * Math.pow(2, exp);
    }
    exports.ldexp = ldexp;
    function nextGreaterSquare(v2) {
      v2--;
      v2 |= v2 >> 1;
      v2 |= v2 >> 2;
      v2 |= v2 >> 4;
      v2 |= v2 >> 8;
      v2 |= v2 >> 16;
      v2++;
      return v2;
    }
    exports.nextGreaterSquare = nextGreaterSquare;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/types.js
var require_types13 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MappingError = void 0;
    var MappingError = class extends Error {
    };
    exports.MappingError = MappingError;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/ExponentMapping.js
var require_ExponentMapping = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/ExponentMapping.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExponentMapping = void 0;
    var ieee754 = require_ieee754();
    var util = require_util6();
    var types_1 = require_types13();
    var ExponentMapping = class {
      constructor(scale) {
        this._shift = -scale;
      }
      /**
       * Maps positive floating point values to indexes corresponding to scale
       * @param value
       * @returns {number} index for provided value at the current scale
       */
      mapToIndex(value) {
        if (value < ieee754.MIN_VALUE) {
          return this._minNormalLowerBoundaryIndex();
        }
        const exp = ieee754.getNormalBase2(value);
        const correction = this._rightShift(ieee754.getSignificand(value) - 1, ieee754.SIGNIFICAND_WIDTH);
        return exp + correction >> this._shift;
      }
      /**
       * Returns the lower bucket boundary for the given index for scale
       *
       * @param index
       * @returns {number}
       */
      lowerBoundary(index) {
        const minIndex = this._minNormalLowerBoundaryIndex();
        if (index < minIndex) {
          throw new types_1.MappingError(`underflow: ${index} is < minimum lower boundary: ${minIndex}`);
        }
        const maxIndex = this._maxNormalLowerBoundaryIndex();
        if (index > maxIndex) {
          throw new types_1.MappingError(`overflow: ${index} is > maximum lower boundary: ${maxIndex}`);
        }
        return util.ldexp(1, index << this._shift);
      }
      /**
       * The scale used by this mapping
       * @returns {number}
       */
      get scale() {
        if (this._shift === 0) {
          return 0;
        }
        return -this._shift;
      }
      _minNormalLowerBoundaryIndex() {
        let index = ieee754.MIN_NORMAL_EXPONENT >> this._shift;
        if (this._shift < 2) {
          index--;
        }
        return index;
      }
      _maxNormalLowerBoundaryIndex() {
        return ieee754.MAX_NORMAL_EXPONENT >> this._shift;
      }
      _rightShift(value, shift) {
        return Math.floor(value * Math.pow(2, -shift));
      }
    };
    exports.ExponentMapping = ExponentMapping;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/LogarithmMapping.js
var require_LogarithmMapping = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/LogarithmMapping.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LogarithmMapping = void 0;
    var ieee754 = require_ieee754();
    var util = require_util6();
    var types_1 = require_types13();
    var LogarithmMapping = class {
      constructor(scale) {
        this._scale = scale;
        this._scaleFactor = util.ldexp(Math.LOG2E, scale);
        this._inverseFactor = util.ldexp(Math.LN2, -scale);
      }
      /**
       * Maps positive floating point values to indexes corresponding to scale
       * @param value
       * @returns {number} index for provided value at the current scale
       */
      mapToIndex(value) {
        if (value <= ieee754.MIN_VALUE) {
          return this._minNormalLowerBoundaryIndex() - 1;
        }
        if (ieee754.getSignificand(value) === 0) {
          const exp = ieee754.getNormalBase2(value);
          return (exp << this._scale) - 1;
        }
        const index = Math.floor(Math.log(value) * this._scaleFactor);
        const maxIndex = this._maxNormalLowerBoundaryIndex();
        if (index >= maxIndex) {
          return maxIndex;
        }
        return index;
      }
      /**
       * Returns the lower bucket boundary for the given index for scale
       *
       * @param index
       * @returns {number}
       */
      lowerBoundary(index) {
        const maxIndex = this._maxNormalLowerBoundaryIndex();
        if (index >= maxIndex) {
          if (index === maxIndex) {
            return 2 * Math.exp((index - (1 << this._scale)) / this._scaleFactor);
          }
          throw new types_1.MappingError(`overflow: ${index} is > maximum lower boundary: ${maxIndex}`);
        }
        const minIndex = this._minNormalLowerBoundaryIndex();
        if (index <= minIndex) {
          if (index === minIndex) {
            return ieee754.MIN_VALUE;
          } else if (index === minIndex - 1) {
            return Math.exp((index + (1 << this._scale)) / this._scaleFactor) / 2;
          }
          throw new types_1.MappingError(`overflow: ${index} is < minimum lower boundary: ${minIndex}`);
        }
        return Math.exp(index * this._inverseFactor);
      }
      /**
       * The scale used by this mapping
       * @returns {number}
       */
      get scale() {
        return this._scale;
      }
      _minNormalLowerBoundaryIndex() {
        return ieee754.MIN_NORMAL_EXPONENT << this._scale;
      }
      _maxNormalLowerBoundaryIndex() {
        return (ieee754.MAX_NORMAL_EXPONENT + 1 << this._scale) - 1;
      }
    };
    exports.LogarithmMapping = LogarithmMapping;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/getMapping.js
var require_getMapping = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/getMapping.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMapping = void 0;
    var ExponentMapping_1 = require_ExponentMapping();
    var LogarithmMapping_1 = require_LogarithmMapping();
    var types_1 = require_types13();
    var MIN_SCALE = -10;
    var MAX_SCALE = 20;
    var PREBUILT_MAPPINGS = Array.from({ length: 31 }, (_2, i2) => {
      if (i2 > 10) {
        return new LogarithmMapping_1.LogarithmMapping(i2 - 10);
      }
      return new ExponentMapping_1.ExponentMapping(i2 - 10);
    });
    function getMapping(scale) {
      if (scale > MAX_SCALE || scale < MIN_SCALE) {
        throw new types_1.MappingError(`expected scale >= ${MIN_SCALE} && <= ${MAX_SCALE}, got: ${scale}`);
      }
      return PREBUILT_MAPPINGS[scale + 10];
    }
    exports.getMapping = getMapping;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/ExponentialHistogram.js
var require_ExponentialHistogram = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/ExponentialHistogram.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExponentialHistogramAggregator = exports.ExponentialHistogramAccumulation = void 0;
    var types_1 = require_types12();
    var MetricData_1 = require_MetricData();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var InstrumentDescriptor_1 = require_InstrumentDescriptor();
    var Buckets_1 = require_Buckets();
    var getMapping_1 = require_getMapping();
    var util_1 = require_util6();
    var HighLow = class _HighLow {
      constructor(low, high) {
        this.low = low;
        this.high = high;
      }
      static combine(h1, h2) {
        return new _HighLow(Math.min(h1.low, h2.low), Math.max(h1.high, h2.high));
      }
    };
    var MAX_SCALE = 20;
    var DEFAULT_MAX_SIZE = 160;
    var MIN_MAX_SIZE = 2;
    var ExponentialHistogramAccumulation = class _ExponentialHistogramAccumulation {
      constructor(startTime = startTime, _maxSize = DEFAULT_MAX_SIZE, _recordMinMax = true, _sum = 0, _count = 0, _zeroCount = 0, _min = Number.POSITIVE_INFINITY, _max = Number.NEGATIVE_INFINITY, _positive = new Buckets_1.Buckets(), _negative = new Buckets_1.Buckets(), _mapping = (0, getMapping_1.getMapping)(MAX_SCALE)) {
        this.startTime = startTime;
        this._maxSize = _maxSize;
        this._recordMinMax = _recordMinMax;
        this._sum = _sum;
        this._count = _count;
        this._zeroCount = _zeroCount;
        this._min = _min;
        this._max = _max;
        this._positive = _positive;
        this._negative = _negative;
        this._mapping = _mapping;
        if (this._maxSize < MIN_MAX_SIZE) {
          api_1.diag.warn(`Exponential Histogram Max Size set to ${this._maxSize},                 changing to the minimum size of: ${MIN_MAX_SIZE}`);
          this._maxSize = MIN_MAX_SIZE;
        }
      }
      /**
       * record updates a histogram with a single count
       * @param {Number} value
       */
      record(value) {
        this.updateByIncrement(value, 1);
      }
      /**
       * Sets the start time for this accumulation
       * @param {HrTime} startTime
       */
      setStartTime(startTime) {
        this.startTime = startTime;
      }
      /**
       * Returns the datapoint representation of this accumulation
       * @param {HrTime} startTime
       */
      toPointValue() {
        return {
          hasMinMax: this._recordMinMax,
          min: this.min,
          max: this.max,
          sum: this.sum,
          positive: {
            offset: this.positive.offset,
            bucketCounts: this.positive.counts()
          },
          negative: {
            offset: this.negative.offset,
            bucketCounts: this.negative.counts()
          },
          count: this.count,
          scale: this.scale,
          zeroCount: this.zeroCount
        };
      }
      /**
       * @returns {Number} The sum of values recorded by this accumulation
       */
      get sum() {
        return this._sum;
      }
      /**
       * @returns {Number} The minimum value recorded by this accumulation
       */
      get min() {
        return this._min;
      }
      /**
       * @returns {Number} The maximum value recorded by this accumulation
       */
      get max() {
        return this._max;
      }
      /**
       * @returns {Number} The count of values recorded by this accumulation
       */
      get count() {
        return this._count;
      }
      /**
       * @returns {Number} The number of 0 values recorded by this accumulation
       */
      get zeroCount() {
        return this._zeroCount;
      }
      /**
       * @returns {Number} The scale used by this accumulation
       */
      get scale() {
        if (this._count === this._zeroCount) {
          return 0;
        }
        return this._mapping.scale;
      }
      /**
       * positive holds the positive values
       * @returns {Buckets}
       */
      get positive() {
        return this._positive;
      }
      /**
       * negative holds the negative values by their absolute value
       * @returns {Buckets}
       */
      get negative() {
        return this._negative;
      }
      /**
       * updateByIncr supports updating a histogram with a non-negative
       * increment.
       * @param value
       * @param increment
       */
      updateByIncrement(value, increment) {
        if (Number.isNaN(value)) {
          return;
        }
        if (value > this._max) {
          this._max = value;
        }
        if (value < this._min) {
          this._min = value;
        }
        this._count += increment;
        if (value === 0) {
          this._zeroCount += increment;
          return;
        }
        this._sum += value * increment;
        if (value > 0) {
          this._updateBuckets(this._positive, value, increment);
        } else {
          this._updateBuckets(this._negative, -value, increment);
        }
      }
      /**
       * merge combines data from previous value into self
       * @param {ExponentialHistogramAccumulation} previous
       */
      merge(previous) {
        if (this._count === 0) {
          this._min = previous.min;
          this._max = previous.max;
        } else if (previous.count !== 0) {
          if (previous.min < this.min) {
            this._min = previous.min;
          }
          if (previous.max > this.max) {
            this._max = previous.max;
          }
        }
        this.startTime = previous.startTime;
        this._sum += previous.sum;
        this._count += previous.count;
        this._zeroCount += previous.zeroCount;
        const minScale = this._minScale(previous);
        this._downscale(this.scale - minScale);
        this._mergeBuckets(this.positive, previous, previous.positive, minScale);
        this._mergeBuckets(this.negative, previous, previous.negative, minScale);
      }
      /**
       * diff subtracts other from self
       * @param {ExponentialHistogramAccumulation} other
       */
      diff(other) {
        this._min = Infinity;
        this._max = -Infinity;
        this._sum -= other.sum;
        this._count -= other.count;
        this._zeroCount -= other.zeroCount;
        const minScale = this._minScale(other);
        this._downscale(this.scale - minScale);
        this._diffBuckets(this.positive, other, other.positive, minScale);
        this._diffBuckets(this.negative, other, other.negative, minScale);
      }
      /**
       * clone returns a deep copy of self
       * @returns {ExponentialHistogramAccumulation}
       */
      clone() {
        return new _ExponentialHistogramAccumulation(this.startTime, this._maxSize, this._recordMinMax, this._sum, this._count, this._zeroCount, this._min, this._max, this.positive.clone(), this.negative.clone(), this._mapping);
      }
      /**
       * _updateBuckets maps the incoming value to a bucket index for the current
       * scale. If the bucket index is outside of the range of the backing array,
       * it will rescale the backing array and update the mapping for the new scale.
       */
      _updateBuckets(buckets2, value, increment) {
        let index = this._mapping.mapToIndex(value);
        let rescalingNeeded = false;
        let high = 0;
        let low = 0;
        if (buckets2.length === 0) {
          buckets2.indexStart = index;
          buckets2.indexEnd = buckets2.indexStart;
          buckets2.indexBase = buckets2.indexStart;
        } else if (index < buckets2.indexStart && buckets2.indexEnd - index >= this._maxSize) {
          rescalingNeeded = true;
          low = index;
          high = buckets2.indexEnd;
        } else if (index > buckets2.indexEnd && index - buckets2.indexStart >= this._maxSize) {
          rescalingNeeded = true;
          low = buckets2.indexStart;
          high = index;
        }
        if (rescalingNeeded) {
          const change = this._changeScale(high, low);
          this._downscale(change);
          index = this._mapping.mapToIndex(value);
        }
        this._incrementIndexBy(buckets2, index, increment);
      }
      /**
       * _incrementIndexBy increments the count of the bucket specified by `index`.
       * If the index is outside of the range [buckets.indexStart, buckets.indexEnd]
       * the boundaries of the backing array will be adjusted and more buckets will
       * be added if needed.
       */
      _incrementIndexBy(buckets2, index, increment) {
        if (increment === 0) {
          return;
        }
        if (buckets2.length === 0) {
          buckets2.indexStart = buckets2.indexEnd = buckets2.indexBase = index;
        }
        if (index < buckets2.indexStart) {
          const span = buckets2.indexEnd - index;
          if (span >= buckets2.backing.length) {
            this._grow(buckets2, span + 1);
          }
          buckets2.indexStart = index;
        } else if (index > buckets2.indexEnd) {
          const span = index - buckets2.indexStart;
          if (span >= buckets2.backing.length) {
            this._grow(buckets2, span + 1);
          }
          buckets2.indexEnd = index;
        }
        let bucketIndex = index - buckets2.indexBase;
        if (bucketIndex < 0) {
          bucketIndex += buckets2.backing.length;
        }
        buckets2.incrementBucket(bucketIndex, increment);
      }
      /**
       * grow resizes the backing array by doubling in size up to maxSize.
       * This extends the array with a bunch of zeros and copies the
       * existing counts to the same position.
       */
      _grow(buckets2, needed) {
        const size7 = buckets2.backing.length;
        const bias = buckets2.indexBase - buckets2.indexStart;
        const oldPositiveLimit = size7 - bias;
        let newSize = (0, util_1.nextGreaterSquare)(needed);
        if (newSize > this._maxSize) {
          newSize = this._maxSize;
        }
        const newPositiveLimit = newSize - bias;
        buckets2.backing.growTo(newSize, oldPositiveLimit, newPositiveLimit);
      }
      /**
       * _changeScale computes how much downscaling is needed by shifting the
       * high and low values until they are separated by no more than size.
       */
      _changeScale(high, low) {
        let change = 0;
        while (high - low >= this._maxSize) {
          high >>= 1;
          low >>= 1;
          change++;
        }
        return change;
      }
      /**
       * _downscale subtracts `change` from the current mapping scale.
       */
      _downscale(change) {
        if (change === 0) {
          return;
        }
        if (change < 0) {
          throw new Error(`impossible change of scale: ${this.scale}`);
        }
        const newScale = this._mapping.scale - change;
        this._positive.downscale(change);
        this._negative.downscale(change);
        this._mapping = (0, getMapping_1.getMapping)(newScale);
      }
      /**
       * _minScale is used by diff and merge to compute an ideal combined scale
       */
      _minScale(other) {
        const minScale = Math.min(this.scale, other.scale);
        const highLowPos = HighLow.combine(this._highLowAtScale(this.positive, this.scale, minScale), this._highLowAtScale(other.positive, other.scale, minScale));
        const highLowNeg = HighLow.combine(this._highLowAtScale(this.negative, this.scale, minScale), this._highLowAtScale(other.negative, other.scale, minScale));
        return Math.min(minScale - this._changeScale(highLowPos.high, highLowPos.low), minScale - this._changeScale(highLowNeg.high, highLowNeg.low));
      }
      /**
       * _highLowAtScale is used by diff and merge to compute an ideal combined scale.
       */
      _highLowAtScale(buckets2, currentScale, newScale) {
        if (buckets2.length === 0) {
          return new HighLow(0, -1);
        }
        const shift = currentScale - newScale;
        return new HighLow(buckets2.indexStart >> shift, buckets2.indexEnd >> shift);
      }
      /**
       * _mergeBuckets translates index values from another histogram and
       * adds the values into the corresponding buckets of this histogram.
       */
      _mergeBuckets(ours, other, theirs, scale) {
        const theirOffset = theirs.offset;
        const theirChange = other.scale - scale;
        for (let i2 = 0; i2 < theirs.length; i2++) {
          this._incrementIndexBy(ours, theirOffset + i2 >> theirChange, theirs.at(i2));
        }
      }
      /**
       * _diffBuckets translates index values from another histogram and
       * subtracts the values in the corresponding buckets of this histogram.
       */
      _diffBuckets(ours, other, theirs, scale) {
        const theirOffset = theirs.offset;
        const theirChange = other.scale - scale;
        for (let i2 = 0; i2 < theirs.length; i2++) {
          const ourIndex = theirOffset + i2 >> theirChange;
          let bucketIndex = ourIndex - ours.indexBase;
          if (bucketIndex < 0) {
            bucketIndex += ours.backing.length;
          }
          ours.decrementBucket(bucketIndex, theirs.at(i2));
        }
        ours.trim();
      }
    };
    exports.ExponentialHistogramAccumulation = ExponentialHistogramAccumulation;
    var ExponentialHistogramAggregator = class {
      /**
       * @param _maxSize Maximum number of buckets for each of the positive
       *    and negative ranges, exclusive of the zero-bucket.
       * @param _recordMinMax If set to true, min and max will be recorded.
       *    Otherwise, min and max will not be recorded.
       */
      constructor(_maxSize, _recordMinMax) {
        this._maxSize = _maxSize;
        this._recordMinMax = _recordMinMax;
        this.kind = types_1.AggregatorKind.EXPONENTIAL_HISTOGRAM;
      }
      createAccumulation(startTime) {
        return new ExponentialHistogramAccumulation(startTime, this._maxSize, this._recordMinMax);
      }
      /**
       * Return the result of the merge of two exponential histogram accumulations.
       */
      merge(previous, delta) {
        const result4 = delta.clone();
        result4.merge(previous);
        return result4;
      }
      /**
       * Returns a new DELTA aggregation by comparing two cumulative measurements.
       */
      diff(previous, current) {
        const result4 = current.clone();
        result4.diff(previous);
        return result4;
      }
      toMetricData(descriptor3, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
          descriptor: descriptor3,
          aggregationTemporality,
          dataPointType: MetricData_1.DataPointType.EXPONENTIAL_HISTOGRAM,
          dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {
            const pointValue = accumulation.toPointValue();
            const allowsNegativeValues = descriptor3.type === InstrumentDescriptor_1.InstrumentType.GAUGE || descriptor3.type === InstrumentDescriptor_1.InstrumentType.UP_DOWN_COUNTER || descriptor3.type === InstrumentDescriptor_1.InstrumentType.OBSERVABLE_GAUGE || descriptor3.type === InstrumentDescriptor_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;
            return {
              attributes,
              startTime: accumulation.startTime,
              endTime,
              value: {
                min: pointValue.hasMinMax ? pointValue.min : void 0,
                max: pointValue.hasMinMax ? pointValue.max : void 0,
                sum: !allowsNegativeValues ? pointValue.sum : void 0,
                positive: {
                  offset: pointValue.positive.offset,
                  bucketCounts: pointValue.positive.bucketCounts
                },
                negative: {
                  offset: pointValue.negative.offset,
                  bucketCounts: pointValue.negative.bucketCounts
                },
                count: pointValue.count,
                scale: pointValue.scale,
                zeroCount: pointValue.zeroCount
              }
            };
          })
        };
      }
    };
    exports.ExponentialHistogramAggregator = ExponentialHistogramAggregator;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js
var require_suppress_tracing6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTracingSuppressed = exports.unsuppressTracing = exports.suppressTracing = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var SUPPRESS_TRACING_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
    function suppressTracing(context3) {
      return context3.setValue(SUPPRESS_TRACING_KEY, true);
    }
    exports.suppressTracing = suppressTracing;
    function unsuppressTracing(context3) {
      return context3.deleteValue(SUPPRESS_TRACING_KEY);
    }
    exports.unsuppressTracing = unsuppressTracing;
    function isTracingSuppressed(context3) {
      return context3.getValue(SUPPRESS_TRACING_KEY) === true;
    }
    exports.isTracingSuppressed = isTracingSuppressed;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/baggage/constants.js
var require_constants7 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/baggage/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BAGGAGE_MAX_TOTAL_LENGTH = exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = exports.BAGGAGE_HEADER = exports.BAGGAGE_ITEMS_SEPARATOR = exports.BAGGAGE_PROPERTIES_SEPARATOR = exports.BAGGAGE_KEY_PAIR_SEPARATOR = void 0;
    exports.BAGGAGE_KEY_PAIR_SEPARATOR = "=";
    exports.BAGGAGE_PROPERTIES_SEPARATOR = ";";
    exports.BAGGAGE_ITEMS_SEPARATOR = ",";
    exports.BAGGAGE_HEADER = "baggage";
    exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
    exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
    exports.BAGGAGE_MAX_TOTAL_LENGTH = 8192;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/baggage/utils.js
var require_utils13 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/baggage/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseKeyPairsIntoRecord = exports.parsePairKeyValue = exports.getKeyPairs = exports.serializeKeyPairs = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var constants_1 = require_constants7();
    function serializeKeyPairs(keyPairs) {
      return keyPairs.reduce((hValue, current) => {
        const value = `${hValue}${hValue !== "" ? constants_1.BAGGAGE_ITEMS_SEPARATOR : ""}${current}`;
        return value.length > constants_1.BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
      }, "");
    }
    exports.serializeKeyPairs = serializeKeyPairs;
    function getKeyPairs(baggage) {
      return baggage.getAllEntries().map(([key, value]) => {
        let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;
        if (value.metadata !== void 0) {
          entry += constants_1.BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
        }
        return entry;
      });
    }
    exports.getKeyPairs = getKeyPairs;
    function parsePairKeyValue(entry) {
      const valueProps = entry.split(constants_1.BAGGAGE_PROPERTIES_SEPARATOR);
      if (valueProps.length <= 0)
        return;
      const keyPairPart = valueProps.shift();
      if (!keyPairPart)
        return;
      const separatorIndex = keyPairPart.indexOf(constants_1.BAGGAGE_KEY_PAIR_SEPARATOR);
      if (separatorIndex <= 0)
        return;
      const key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
      const value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
      let metadata;
      if (valueProps.length > 0) {
        metadata = (0, api_1.baggageEntryMetadataFromString)(valueProps.join(constants_1.BAGGAGE_PROPERTIES_SEPARATOR));
      }
      return { key, value, metadata };
    }
    exports.parsePairKeyValue = parsePairKeyValue;
    function parseKeyPairsIntoRecord(value) {
      if (typeof value !== "string" || value.length === 0)
        return {};
      return value.split(constants_1.BAGGAGE_ITEMS_SEPARATOR).map((entry) => {
        return parsePairKeyValue(entry);
      }).filter((keyPair) => keyPair !== void 0 && keyPair.value.length > 0).reduce((headers, keyPair) => {
        headers[keyPair.key] = keyPair.value;
        return headers;
      }, {});
    }
    exports.parseKeyPairsIntoRecord = parseKeyPairsIntoRecord;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js
var require_W3CBaggagePropagator6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.W3CBaggagePropagator = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing6();
    var constants_1 = require_constants7();
    var utils_1 = require_utils13();
    var W3CBaggagePropagator = class {
      inject(context3, carrier, setter) {
        const baggage = api_1.propagation.getBaggage(context3);
        if (!baggage || (0, suppress_tracing_1.isTracingSuppressed)(context3))
          return;
        const keyPairs = (0, utils_1.getKeyPairs)(baggage).filter((pair) => {
          return pair.length <= constants_1.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
        }).slice(0, constants_1.BAGGAGE_MAX_NAME_VALUE_PAIRS);
        const headerValue = (0, utils_1.serializeKeyPairs)(keyPairs);
        if (headerValue.length > 0) {
          setter.set(carrier, constants_1.BAGGAGE_HEADER, headerValue);
        }
      }
      extract(context3, carrier, getter) {
        const headerValue = getter.get(carrier, constants_1.BAGGAGE_HEADER);
        const baggageString = Array.isArray(headerValue) ? headerValue.join(constants_1.BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString)
          return context3;
        const baggage = {};
        if (baggageString.length === 0) {
          return context3;
        }
        const pairs = baggageString.split(constants_1.BAGGAGE_ITEMS_SEPARATOR);
        pairs.forEach((entry) => {
          const keyPair = (0, utils_1.parsePairKeyValue)(entry);
          if (keyPair) {
            const baggageEntry = { value: keyPair.value };
            if (keyPair.metadata) {
              baggageEntry.metadata = keyPair.metadata;
            }
            baggage[keyPair.key] = baggageEntry;
          }
        });
        if (Object.entries(baggage).length === 0) {
          return context3;
        }
        return api_1.propagation.setBaggage(context3, api_1.propagation.createBaggage(baggage));
      }
      fields() {
        return [constants_1.BAGGAGE_HEADER];
      }
    };
    exports.W3CBaggagePropagator = W3CBaggagePropagator;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/common/anchored-clock.js
var require_anchored_clock6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/common/anchored-clock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnchoredClock = void 0;
    var AnchoredClock = class {
      /**
       * Create a new AnchoredClock anchored to the current time returned by systemClock.
       *
       * @param systemClock should be a clock that returns the number of milliseconds since January 1 1970 such as Date
       * @param monotonicClock should be a clock that counts milliseconds monotonically such as window.performance or perf_hooks.performance
       */
      constructor(systemClock, monotonicClock) {
        this._monotonicClock = monotonicClock;
        this._epochMillis = systemClock.now();
        this._performanceMillis = monotonicClock.now();
      }
      /**
       * Returns the current time by adding the number of milliseconds since the
       * AnchoredClock was created to the creation epoch time
       */
      now() {
        const delta = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + delta;
      }
    };
    exports.AnchoredClock = AnchoredClock;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/common/attributes.js
var require_attributes6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/common/attributes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAttributeValue = exports.isAttributeKey = exports.sanitizeAttributes = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    function sanitizeAttributes(attributes) {
      const out = {};
      if (typeof attributes !== "object" || attributes == null) {
        return out;
      }
      for (const [key, val] of Object.entries(attributes)) {
        if (!isAttributeKey(key)) {
          api_1.diag.warn(`Invalid attribute key: ${key}`);
          continue;
        }
        if (!isAttributeValue(val)) {
          api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
          continue;
        }
        if (Array.isArray(val)) {
          out[key] = val.slice();
        } else {
          out[key] = val;
        }
      }
      return out;
    }
    exports.sanitizeAttributes = sanitizeAttributes;
    function isAttributeKey(key) {
      return typeof key === "string" && key.length > 0;
    }
    exports.isAttributeKey = isAttributeKey;
    function isAttributeValue(val) {
      if (val == null) {
        return true;
      }
      if (Array.isArray(val)) {
        return isHomogeneousAttributeValueArray(val);
      }
      return isValidPrimitiveAttributeValue(val);
    }
    exports.isAttributeValue = isAttributeValue;
    function isHomogeneousAttributeValueArray(arr) {
      let type;
      for (const element of arr) {
        if (element == null)
          continue;
        if (!type) {
          if (isValidPrimitiveAttributeValue(element)) {
            type = typeof element;
            continue;
          }
          return false;
        }
        if (typeof element === type) {
          continue;
        }
        return false;
      }
      return true;
    }
    function isValidPrimitiveAttributeValue(val) {
      switch (typeof val) {
        case "number":
        case "boolean":
        case "string":
          return true;
      }
      return false;
    }
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js
var require_logging_error_handler6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loggingErrorHandler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    function loggingErrorHandler() {
      return (ex) => {
        api_1.diag.error(stringifyException(ex));
      };
    }
    exports.loggingErrorHandler = loggingErrorHandler;
    function stringifyException(ex) {
      if (typeof ex === "string") {
        return ex;
      } else {
        return JSON.stringify(flattenException(ex));
      }
    }
    function flattenException(ex) {
      const result4 = {};
      let current = ex;
      while (current !== null) {
        Object.getOwnPropertyNames(current).forEach((propertyName) => {
          if (result4[propertyName])
            return;
          const value = current[propertyName];
          if (value) {
            result4[propertyName] = String(value);
          }
        });
        current = Object.getPrototypeOf(current);
      }
      return result4;
    }
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/common/global-error-handler.js
var require_global_error_handler6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/common/global-error-handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.globalErrorHandler = exports.setGlobalErrorHandler = void 0;
    var logging_error_handler_1 = require_logging_error_handler6();
    var delegateHandler = (0, logging_error_handler_1.loggingErrorHandler)();
    function setGlobalErrorHandler(handler) {
      delegateHandler = handler;
    }
    exports.setGlobalErrorHandler = setGlobalErrorHandler;
    function globalErrorHandler(ex) {
      try {
        delegateHandler(ex);
      } catch (_a12) {
      }
    }
    exports.globalErrorHandler = globalErrorHandler;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/utils/sampling.js
var require_sampling6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/utils/sampling.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TracesSamplerValues = void 0;
    var TracesSamplerValues;
    (function(TracesSamplerValues2) {
      TracesSamplerValues2["AlwaysOff"] = "always_off";
      TracesSamplerValues2["AlwaysOn"] = "always_on";
      TracesSamplerValues2["ParentBasedAlwaysOff"] = "parentbased_always_off";
      TracesSamplerValues2["ParentBasedAlwaysOn"] = "parentbased_always_on";
      TracesSamplerValues2["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
      TracesSamplerValues2["TraceIdRatio"] = "traceidratio";
    })(TracesSamplerValues = exports.TracesSamplerValues || (exports.TracesSamplerValues = {}));
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/utils/environment.js
var require_environment12 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/utils/environment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseEnvironment = exports.DEFAULT_ENVIRONMENT = exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var sampling_1 = require_sampling6();
    var DEFAULT_LIST_SEPARATOR = ",";
    var ENVIRONMENT_BOOLEAN_KEYS = ["OTEL_SDK_DISABLED"];
    function isEnvVarABoolean(key) {
      return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_NUMBERS_KEYS = [
      "OTEL_BSP_EXPORT_TIMEOUT",
      "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BSP_MAX_QUEUE_SIZE",
      "OTEL_BSP_SCHEDULE_DELAY",
      "OTEL_BLRP_EXPORT_TIMEOUT",
      "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BLRP_MAX_QUEUE_SIZE",
      "OTEL_BLRP_SCHEDULE_DELAY",
      "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_LINK_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT",
      "OTEL_EXPORTER_OTLP_TIMEOUT",
      "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
      "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
      "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT",
      "OTEL_EXPORTER_JAEGER_AGENT_PORT"
    ];
    function isEnvVarANumber(key) {
      return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_LISTS_KEYS = [
      "OTEL_NO_PATCH_MODULES",
      "OTEL_PROPAGATORS"
    ];
    function isEnvVarAList(key) {
      return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
    }
    exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
    exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
    exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
    exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
    exports.DEFAULT_ENVIRONMENT = {
      OTEL_SDK_DISABLED: false,
      CONTAINER_NAME: "",
      ECS_CONTAINER_METADATA_URI_V4: "",
      ECS_CONTAINER_METADATA_URI: "",
      HOSTNAME: "",
      KUBERNETES_SERVICE_HOST: "",
      NAMESPACE: "",
      OTEL_BSP_EXPORT_TIMEOUT: 3e4,
      OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BSP_MAX_QUEUE_SIZE: 2048,
      OTEL_BSP_SCHEDULE_DELAY: 5e3,
      OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
      OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
      OTEL_BLRP_SCHEDULE_DELAY: 5e3,
      OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
      OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
      OTEL_EXPORTER_JAEGER_ENDPOINT: "",
      OTEL_EXPORTER_JAEGER_PASSWORD: "",
      OTEL_EXPORTER_JAEGER_USER: "",
      OTEL_EXPORTER_OTLP_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_HEADERS: "",
      OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
      OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
      OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
      OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
      OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
      OTEL_LOG_LEVEL: api_1.DiagLogLevel.INFO,
      OTEL_NO_PATCH_MODULES: [],
      OTEL_PROPAGATORS: ["tracecontext", "baggage"],
      OTEL_RESOURCE_ATTRIBUTES: "",
      OTEL_SERVICE_NAME: "",
      OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
      OTEL_SPAN_LINK_COUNT_LIMIT: 128,
      OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
      OTEL_TRACES_EXPORTER: "",
      OTEL_TRACES_SAMPLER: sampling_1.TracesSamplerValues.ParentBasedAlwaysOn,
      OTEL_TRACES_SAMPLER_ARG: "",
      OTEL_LOGS_EXPORTER: "",
      OTEL_EXPORTER_OTLP_INSECURE: "",
      OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
      OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
      OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
      OTEL_EXPORTER_OTLP_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative"
    };
    function parseBoolean(key, environment5, values3) {
      if (typeof values3[key] === "undefined") {
        return;
      }
      const value = String(values3[key]);
      environment5[key] = value.toLowerCase() === "true";
    }
    function parseNumber(name, environment5, values3, min2 = -Infinity, max2 = Infinity) {
      if (typeof values3[name] !== "undefined") {
        const value = Number(values3[name]);
        if (!isNaN(value)) {
          if (value < min2) {
            environment5[name] = min2;
          } else if (value > max2) {
            environment5[name] = max2;
          } else {
            environment5[name] = value;
          }
        }
      }
    }
    function parseStringList(name, output, input, separator = DEFAULT_LIST_SEPARATOR) {
      const givenValue = input[name];
      if (typeof givenValue === "string") {
        output[name] = givenValue.split(separator).map((v2) => v2.trim());
      }
    }
    var logLevelMap = {
      ALL: api_1.DiagLogLevel.ALL,
      VERBOSE: api_1.DiagLogLevel.VERBOSE,
      DEBUG: api_1.DiagLogLevel.DEBUG,
      INFO: api_1.DiagLogLevel.INFO,
      WARN: api_1.DiagLogLevel.WARN,
      ERROR: api_1.DiagLogLevel.ERROR,
      NONE: api_1.DiagLogLevel.NONE
    };
    function setLogLevelFromEnv(key, environment5, values3) {
      const value = values3[key];
      if (typeof value === "string") {
        const theLevel = logLevelMap[value.toUpperCase()];
        if (theLevel != null) {
          environment5[key] = theLevel;
        }
      }
    }
    function parseEnvironment(values3) {
      const environment5 = {};
      for (const env in exports.DEFAULT_ENVIRONMENT) {
        const key = env;
        switch (key) {
          case "OTEL_LOG_LEVEL":
            setLogLevelFromEnv(key, environment5, values3);
            break;
          default:
            if (isEnvVarABoolean(key)) {
              parseBoolean(key, environment5, values3);
            } else if (isEnvVarANumber(key)) {
              parseNumber(key, environment5, values3);
            } else if (isEnvVarAList(key)) {
              parseStringList(key, environment5, values3);
            } else {
              const value = values3[key];
              if (typeof value !== "undefined" && value !== null) {
                environment5[key] = String(value);
              }
            }
        }
      }
      return environment5;
    }
    exports.parseEnvironment = parseEnvironment;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/platform/node/environment.js
var require_environment13 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/platform/node/environment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnvWithoutDefaults = exports.getEnv = void 0;
    var environment_1 = require_environment12();
    function getEnv() {
      const processEnv = (0, environment_1.parseEnvironment)(process.env);
      return Object.assign({}, environment_1.DEFAULT_ENVIRONMENT, processEnv);
    }
    exports.getEnv = getEnv;
    function getEnvWithoutDefaults() {
      return (0, environment_1.parseEnvironment)(process.env);
    }
    exports.getEnvWithoutDefaults = getEnvWithoutDefaults;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js
var require_globalThis6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._globalThis = void 0;
    exports._globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/common/hex-to-binary.js
var require_hex_to_binary6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/common/hex-to-binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hexToBinary = void 0;
    function intValue(charCode) {
      if (charCode >= 48 && charCode <= 57) {
        return charCode - 48;
      }
      if (charCode >= 97 && charCode <= 102) {
        return charCode - 87;
      }
      return charCode - 55;
    }
    function hexToBinary(hexStr) {
      const buf = new Uint8Array(hexStr.length / 2);
      let offset = 0;
      for (let i2 = 0; i2 < hexStr.length; i2 += 2) {
        const hi = intValue(hexStr.charCodeAt(i2));
        const lo = intValue(hexStr.charCodeAt(i2 + 1));
        buf[offset++] = hi << 4 | lo;
      }
      return buf;
    }
    exports.hexToBinary = hexToBinary;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js
var require_hex_to_base646 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hexToBase64 = void 0;
    var hex_to_binary_1 = require_hex_to_binary6();
    function hexToBase64(hexStr) {
      return Buffer.from((0, hex_to_binary_1.hexToBinary)(hexStr)).toString("base64");
    }
    exports.hexToBase64 = hexToBase64;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js
var require_RandomIdGenerator7 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RandomIdGenerator = void 0;
    var SPAN_ID_BYTES = 8;
    var TRACE_ID_BYTES = 16;
    var RandomIdGenerator = class {
      constructor() {
        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
        this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
      }
    };
    exports.RandomIdGenerator = RandomIdGenerator;
    var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
    function getIdGenerator(bytes) {
      return function generateId() {
        for (let i2 = 0; i2 < bytes / 4; i2++) {
          SHARED_BUFFER.writeUInt32BE(Math.random() * 2 ** 32 >>> 0, i2 * 4);
        }
        for (let i2 = 0; i2 < bytes; i2++) {
          if (SHARED_BUFFER[i2] > 0) {
            break;
          } else if (i2 === bytes - 1) {
            SHARED_BUFFER[bytes - 1] = 1;
          }
        }
        return SHARED_BUFFER.toString("hex", 0, bytes);
      };
    }
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/platform/node/performance.js
var require_performance6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/platform/node/performance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.otperformance = void 0;
    var perf_hooks_1 = __require("perf_hooks");
    exports.otperformance = perf_hooks_1.performance;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/version.js
var require_version6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VERSION = void 0;
    exports.VERSION = "1.24.1";
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/semantic-conventions/build/src/internal/utils.js
var require_utils14 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/semantic-conventions/build/src/internal/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConstMap = void 0;
    // @__NO_SIDE_EFFECTS__
    function createConstMap2(values3) {
      let res = {};
      const len = values3.length;
      for (let lp = 0; lp < len; lp++) {
        const val = values3[lp];
        if (val) {
          res[String(val).toUpperCase().replace(/[-.]/g, "_")] = val;
        }
      }
      return res;
    }
    exports.createConstMap = createConstMap2;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js
var require_SemanticAttributes5 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SEMATTRS_NET_HOST_CARRIER_ICC = exports.SEMATTRS_NET_HOST_CARRIER_MNC = exports.SEMATTRS_NET_HOST_CARRIER_MCC = exports.SEMATTRS_NET_HOST_CARRIER_NAME = exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = exports.SEMATTRS_NET_HOST_NAME = exports.SEMATTRS_NET_HOST_PORT = exports.SEMATTRS_NET_HOST_IP = exports.SEMATTRS_NET_PEER_NAME = exports.SEMATTRS_NET_PEER_PORT = exports.SEMATTRS_NET_PEER_IP = exports.SEMATTRS_NET_TRANSPORT = exports.SEMATTRS_FAAS_INVOKED_REGION = exports.SEMATTRS_FAAS_INVOKED_PROVIDER = exports.SEMATTRS_FAAS_INVOKED_NAME = exports.SEMATTRS_FAAS_COLDSTART = exports.SEMATTRS_FAAS_CRON = exports.SEMATTRS_FAAS_TIME = exports.SEMATTRS_FAAS_DOCUMENT_NAME = exports.SEMATTRS_FAAS_DOCUMENT_TIME = exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = exports.SEMATTRS_FAAS_EXECUTION = exports.SEMATTRS_FAAS_TRIGGER = exports.SEMATTRS_EXCEPTION_ESCAPED = exports.SEMATTRS_EXCEPTION_STACKTRACE = exports.SEMATTRS_EXCEPTION_MESSAGE = exports.SEMATTRS_EXCEPTION_TYPE = exports.SEMATTRS_DB_SQL_TABLE = exports.SEMATTRS_DB_MONGODB_COLLECTION = exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = exports.SEMATTRS_DB_HBASE_NAMESPACE = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = exports.SEMATTRS_DB_CASSANDRA_TABLE = exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = exports.SEMATTRS_DB_OPERATION = exports.SEMATTRS_DB_STATEMENT = exports.SEMATTRS_DB_NAME = exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = exports.SEMATTRS_DB_USER = exports.SEMATTRS_DB_CONNECTION_STRING = exports.SEMATTRS_DB_SYSTEM = exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = void 0;
    exports.SEMATTRS_MESSAGING_DESTINATION_KIND = exports.SEMATTRS_MESSAGING_DESTINATION = exports.SEMATTRS_MESSAGING_SYSTEM = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = exports.SEMATTRS_AWS_DYNAMODB_COUNT = exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_SELECT = exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = exports.SEMATTRS_AWS_DYNAMODB_LIMIT = exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = exports.SEMATTRS_HTTP_CLIENT_IP = exports.SEMATTRS_HTTP_ROUTE = exports.SEMATTRS_HTTP_SERVER_NAME = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = exports.SEMATTRS_HTTP_USER_AGENT = exports.SEMATTRS_HTTP_FLAVOR = exports.SEMATTRS_HTTP_STATUS_CODE = exports.SEMATTRS_HTTP_SCHEME = exports.SEMATTRS_HTTP_HOST = exports.SEMATTRS_HTTP_TARGET = exports.SEMATTRS_HTTP_URL = exports.SEMATTRS_HTTP_METHOD = exports.SEMATTRS_CODE_LINENO = exports.SEMATTRS_CODE_FILEPATH = exports.SEMATTRS_CODE_NAMESPACE = exports.SEMATTRS_CODE_FUNCTION = exports.SEMATTRS_THREAD_NAME = exports.SEMATTRS_THREAD_ID = exports.SEMATTRS_ENDUSER_SCOPE = exports.SEMATTRS_ENDUSER_ROLE = exports.SEMATTRS_ENDUSER_ID = exports.SEMATTRS_PEER_SERVICE = void 0;
    exports.DBSYSTEMVALUES_FILEMAKER = exports.DBSYSTEMVALUES_DERBY = exports.DBSYSTEMVALUES_FIREBIRD = exports.DBSYSTEMVALUES_ADABAS = exports.DBSYSTEMVALUES_CACHE = exports.DBSYSTEMVALUES_EDB = exports.DBSYSTEMVALUES_FIRSTSQL = exports.DBSYSTEMVALUES_INGRES = exports.DBSYSTEMVALUES_HANADB = exports.DBSYSTEMVALUES_MAXDB = exports.DBSYSTEMVALUES_PROGRESS = exports.DBSYSTEMVALUES_HSQLDB = exports.DBSYSTEMVALUES_CLOUDSCAPE = exports.DBSYSTEMVALUES_HIVE = exports.DBSYSTEMVALUES_REDSHIFT = exports.DBSYSTEMVALUES_POSTGRESQL = exports.DBSYSTEMVALUES_DB2 = exports.DBSYSTEMVALUES_ORACLE = exports.DBSYSTEMVALUES_MYSQL = exports.DBSYSTEMVALUES_MSSQL = exports.DBSYSTEMVALUES_OTHER_SQL = exports.SemanticAttributes = exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_ID = exports.SEMATTRS_MESSAGE_TYPE = exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = exports.SEMATTRS_RPC_JSONRPC_VERSION = exports.SEMATTRS_RPC_GRPC_STATUS_CODE = exports.SEMATTRS_RPC_METHOD = exports.SEMATTRS_RPC_SERVICE = exports.SEMATTRS_RPC_SYSTEM = exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = exports.SEMATTRS_MESSAGING_CONSUMER_ID = exports.SEMATTRS_MESSAGING_OPERATION = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = exports.SEMATTRS_MESSAGING_CONVERSATION_ID = exports.SEMATTRS_MESSAGING_MESSAGE_ID = exports.SEMATTRS_MESSAGING_URL = exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = exports.SEMATTRS_MESSAGING_PROTOCOL = exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = void 0;
    exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = exports.FaasDocumentOperationValues = exports.FAASDOCUMENTOPERATIONVALUES_DELETE = exports.FAASDOCUMENTOPERATIONVALUES_EDIT = exports.FAASDOCUMENTOPERATIONVALUES_INSERT = exports.FaasTriggerValues = exports.FAASTRIGGERVALUES_OTHER = exports.FAASTRIGGERVALUES_TIMER = exports.FAASTRIGGERVALUES_PUBSUB = exports.FAASTRIGGERVALUES_HTTP = exports.FAASTRIGGERVALUES_DATASOURCE = exports.DbCassandraConsistencyLevelValues = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = exports.DbSystemValues = exports.DBSYSTEMVALUES_COCKROACHDB = exports.DBSYSTEMVALUES_MEMCACHED = exports.DBSYSTEMVALUES_ELASTICSEARCH = exports.DBSYSTEMVALUES_GEODE = exports.DBSYSTEMVALUES_NEO4J = exports.DBSYSTEMVALUES_DYNAMODB = exports.DBSYSTEMVALUES_COSMOSDB = exports.DBSYSTEMVALUES_COUCHDB = exports.DBSYSTEMVALUES_COUCHBASE = exports.DBSYSTEMVALUES_REDIS = exports.DBSYSTEMVALUES_MONGODB = exports.DBSYSTEMVALUES_HBASE = exports.DBSYSTEMVALUES_CASSANDRA = exports.DBSYSTEMVALUES_COLDFUSION = exports.DBSYSTEMVALUES_H2 = exports.DBSYSTEMVALUES_VERTICA = exports.DBSYSTEMVALUES_TERADATA = exports.DBSYSTEMVALUES_SYBASE = exports.DBSYSTEMVALUES_SQLITE = exports.DBSYSTEMVALUES_POINTBASE = exports.DBSYSTEMVALUES_PERVASIVE = exports.DBSYSTEMVALUES_NETEZZA = exports.DBSYSTEMVALUES_MARIADB = exports.DBSYSTEMVALUES_INTERBASE = exports.DBSYSTEMVALUES_INSTANTDB = exports.DBSYSTEMVALUES_INFORMIX = void 0;
    exports.MESSAGINGOPERATIONVALUES_RECEIVE = exports.MessagingDestinationKindValues = exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = exports.HttpFlavorValues = exports.HTTPFLAVORVALUES_QUIC = exports.HTTPFLAVORVALUES_SPDY = exports.HTTPFLAVORVALUES_HTTP_2_0 = exports.HTTPFLAVORVALUES_HTTP_1_1 = exports.HTTPFLAVORVALUES_HTTP_1_0 = exports.NetHostConnectionSubtypeValues = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = exports.NetHostConnectionTypeValues = exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = exports.NETHOSTCONNECTIONTYPEVALUES_CELL = exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = exports.NetTransportValues = exports.NETTRANSPORTVALUES_OTHER = exports.NETTRANSPORTVALUES_INPROC = exports.NETTRANSPORTVALUES_PIPE = exports.NETTRANSPORTVALUES_UNIX = exports.NETTRANSPORTVALUES_IP = exports.NETTRANSPORTVALUES_IP_UDP = exports.NETTRANSPORTVALUES_IP_TCP = exports.FaasInvokedProviderValues = exports.FAASINVOKEDPROVIDERVALUES_GCP = exports.FAASINVOKEDPROVIDERVALUES_AZURE = exports.FAASINVOKEDPROVIDERVALUES_AWS = void 0;
    exports.MessageTypeValues = exports.MESSAGETYPEVALUES_RECEIVED = exports.MESSAGETYPEVALUES_SENT = exports.RpcGrpcStatusCodeValues = exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = exports.RPCGRPCSTATUSCODEVALUES_ABORTED = exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = exports.RPCGRPCSTATUSCODEVALUES_OK = exports.MessagingOperationValues = exports.MESSAGINGOPERATIONVALUES_PROCESS = void 0;
    var utils_1 = require_utils14();
    var TMP_AWS_LAMBDA_INVOKED_ARN2 = "aws.lambda.invoked_arn";
    var TMP_DB_SYSTEM2 = "db.system";
    var TMP_DB_CONNECTION_STRING2 = "db.connection_string";
    var TMP_DB_USER2 = "db.user";
    var TMP_DB_JDBC_DRIVER_CLASSNAME2 = "db.jdbc.driver_classname";
    var TMP_DB_NAME2 = "db.name";
    var TMP_DB_STATEMENT2 = "db.statement";
    var TMP_DB_OPERATION2 = "db.operation";
    var TMP_DB_MSSQL_INSTANCE_NAME2 = "db.mssql.instance_name";
    var TMP_DB_CASSANDRA_KEYSPACE2 = "db.cassandra.keyspace";
    var TMP_DB_CASSANDRA_PAGE_SIZE2 = "db.cassandra.page_size";
    var TMP_DB_CASSANDRA_CONSISTENCY_LEVEL2 = "db.cassandra.consistency_level";
    var TMP_DB_CASSANDRA_TABLE2 = "db.cassandra.table";
    var TMP_DB_CASSANDRA_IDEMPOTENCE2 = "db.cassandra.idempotence";
    var TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT2 = "db.cassandra.speculative_execution_count";
    var TMP_DB_CASSANDRA_COORDINATOR_ID2 = "db.cassandra.coordinator.id";
    var TMP_DB_CASSANDRA_COORDINATOR_DC2 = "db.cassandra.coordinator.dc";
    var TMP_DB_HBASE_NAMESPACE2 = "db.hbase.namespace";
    var TMP_DB_REDIS_DATABASE_INDEX2 = "db.redis.database_index";
    var TMP_DB_MONGODB_COLLECTION2 = "db.mongodb.collection";
    var TMP_DB_SQL_TABLE2 = "db.sql.table";
    var TMP_EXCEPTION_TYPE2 = "exception.type";
    var TMP_EXCEPTION_MESSAGE2 = "exception.message";
    var TMP_EXCEPTION_STACKTRACE2 = "exception.stacktrace";
    var TMP_EXCEPTION_ESCAPED2 = "exception.escaped";
    var TMP_FAAS_TRIGGER2 = "faas.trigger";
    var TMP_FAAS_EXECUTION2 = "faas.execution";
    var TMP_FAAS_DOCUMENT_COLLECTION2 = "faas.document.collection";
    var TMP_FAAS_DOCUMENT_OPERATION2 = "faas.document.operation";
    var TMP_FAAS_DOCUMENT_TIME2 = "faas.document.time";
    var TMP_FAAS_DOCUMENT_NAME2 = "faas.document.name";
    var TMP_FAAS_TIME2 = "faas.time";
    var TMP_FAAS_CRON2 = "faas.cron";
    var TMP_FAAS_COLDSTART2 = "faas.coldstart";
    var TMP_FAAS_INVOKED_NAME2 = "faas.invoked_name";
    var TMP_FAAS_INVOKED_PROVIDER2 = "faas.invoked_provider";
    var TMP_FAAS_INVOKED_REGION2 = "faas.invoked_region";
    var TMP_NET_TRANSPORT2 = "net.transport";
    var TMP_NET_PEER_IP2 = "net.peer.ip";
    var TMP_NET_PEER_PORT2 = "net.peer.port";
    var TMP_NET_PEER_NAME2 = "net.peer.name";
    var TMP_NET_HOST_IP2 = "net.host.ip";
    var TMP_NET_HOST_PORT2 = "net.host.port";
    var TMP_NET_HOST_NAME2 = "net.host.name";
    var TMP_NET_HOST_CONNECTION_TYPE2 = "net.host.connection.type";
    var TMP_NET_HOST_CONNECTION_SUBTYPE2 = "net.host.connection.subtype";
    var TMP_NET_HOST_CARRIER_NAME2 = "net.host.carrier.name";
    var TMP_NET_HOST_CARRIER_MCC2 = "net.host.carrier.mcc";
    var TMP_NET_HOST_CARRIER_MNC2 = "net.host.carrier.mnc";
    var TMP_NET_HOST_CARRIER_ICC2 = "net.host.carrier.icc";
    var TMP_PEER_SERVICE2 = "peer.service";
    var TMP_ENDUSER_ID2 = "enduser.id";
    var TMP_ENDUSER_ROLE2 = "enduser.role";
    var TMP_ENDUSER_SCOPE2 = "enduser.scope";
    var TMP_THREAD_ID2 = "thread.id";
    var TMP_THREAD_NAME2 = "thread.name";
    var TMP_CODE_FUNCTION2 = "code.function";
    var TMP_CODE_NAMESPACE2 = "code.namespace";
    var TMP_CODE_FILEPATH2 = "code.filepath";
    var TMP_CODE_LINENO2 = "code.lineno";
    var TMP_HTTP_METHOD2 = "http.method";
    var TMP_HTTP_URL2 = "http.url";
    var TMP_HTTP_TARGET2 = "http.target";
    var TMP_HTTP_HOST2 = "http.host";
    var TMP_HTTP_SCHEME2 = "http.scheme";
    var TMP_HTTP_STATUS_CODE2 = "http.status_code";
    var TMP_HTTP_FLAVOR2 = "http.flavor";
    var TMP_HTTP_USER_AGENT2 = "http.user_agent";
    var TMP_HTTP_REQUEST_CONTENT_LENGTH2 = "http.request_content_length";
    var TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED2 = "http.request_content_length_uncompressed";
    var TMP_HTTP_RESPONSE_CONTENT_LENGTH2 = "http.response_content_length";
    var TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2 = "http.response_content_length_uncompressed";
    var TMP_HTTP_SERVER_NAME2 = "http.server_name";
    var TMP_HTTP_ROUTE2 = "http.route";
    var TMP_HTTP_CLIENT_IP2 = "http.client_ip";
    var TMP_AWS_DYNAMODB_TABLE_NAMES2 = "aws.dynamodb.table_names";
    var TMP_AWS_DYNAMODB_CONSUMED_CAPACITY2 = "aws.dynamodb.consumed_capacity";
    var TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS2 = "aws.dynamodb.item_collection_metrics";
    var TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY2 = "aws.dynamodb.provisioned_read_capacity";
    var TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY2 = "aws.dynamodb.provisioned_write_capacity";
    var TMP_AWS_DYNAMODB_CONSISTENT_READ2 = "aws.dynamodb.consistent_read";
    var TMP_AWS_DYNAMODB_PROJECTION2 = "aws.dynamodb.projection";
    var TMP_AWS_DYNAMODB_LIMIT2 = "aws.dynamodb.limit";
    var TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET2 = "aws.dynamodb.attributes_to_get";
    var TMP_AWS_DYNAMODB_INDEX_NAME2 = "aws.dynamodb.index_name";
    var TMP_AWS_DYNAMODB_SELECT2 = "aws.dynamodb.select";
    var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES2 = "aws.dynamodb.global_secondary_indexes";
    var TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES2 = "aws.dynamodb.local_secondary_indexes";
    var TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE2 = "aws.dynamodb.exclusive_start_table";
    var TMP_AWS_DYNAMODB_TABLE_COUNT2 = "aws.dynamodb.table_count";
    var TMP_AWS_DYNAMODB_SCAN_FORWARD2 = "aws.dynamodb.scan_forward";
    var TMP_AWS_DYNAMODB_SEGMENT2 = "aws.dynamodb.segment";
    var TMP_AWS_DYNAMODB_TOTAL_SEGMENTS2 = "aws.dynamodb.total_segments";
    var TMP_AWS_DYNAMODB_COUNT2 = "aws.dynamodb.count";
    var TMP_AWS_DYNAMODB_SCANNED_COUNT2 = "aws.dynamodb.scanned_count";
    var TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS2 = "aws.dynamodb.attribute_definitions";
    var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES2 = "aws.dynamodb.global_secondary_index_updates";
    var TMP_MESSAGING_SYSTEM2 = "messaging.system";
    var TMP_MESSAGING_DESTINATION2 = "messaging.destination";
    var TMP_MESSAGING_DESTINATION_KIND2 = "messaging.destination_kind";
    var TMP_MESSAGING_TEMP_DESTINATION2 = "messaging.temp_destination";
    var TMP_MESSAGING_PROTOCOL2 = "messaging.protocol";
    var TMP_MESSAGING_PROTOCOL_VERSION2 = "messaging.protocol_version";
    var TMP_MESSAGING_URL2 = "messaging.url";
    var TMP_MESSAGING_MESSAGE_ID2 = "messaging.message_id";
    var TMP_MESSAGING_CONVERSATION_ID2 = "messaging.conversation_id";
    var TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES2 = "messaging.message_payload_size_bytes";
    var TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES2 = "messaging.message_payload_compressed_size_bytes";
    var TMP_MESSAGING_OPERATION2 = "messaging.operation";
    var TMP_MESSAGING_CONSUMER_ID2 = "messaging.consumer_id";
    var TMP_MESSAGING_RABBITMQ_ROUTING_KEY2 = "messaging.rabbitmq.routing_key";
    var TMP_MESSAGING_KAFKA_MESSAGE_KEY2 = "messaging.kafka.message_key";
    var TMP_MESSAGING_KAFKA_CONSUMER_GROUP2 = "messaging.kafka.consumer_group";
    var TMP_MESSAGING_KAFKA_CLIENT_ID2 = "messaging.kafka.client_id";
    var TMP_MESSAGING_KAFKA_PARTITION2 = "messaging.kafka.partition";
    var TMP_MESSAGING_KAFKA_TOMBSTONE2 = "messaging.kafka.tombstone";
    var TMP_RPC_SYSTEM2 = "rpc.system";
    var TMP_RPC_SERVICE2 = "rpc.service";
    var TMP_RPC_METHOD2 = "rpc.method";
    var TMP_RPC_GRPC_STATUS_CODE2 = "rpc.grpc.status_code";
    var TMP_RPC_JSONRPC_VERSION2 = "rpc.jsonrpc.version";
    var TMP_RPC_JSONRPC_REQUEST_ID2 = "rpc.jsonrpc.request_id";
    var TMP_RPC_JSONRPC_ERROR_CODE2 = "rpc.jsonrpc.error_code";
    var TMP_RPC_JSONRPC_ERROR_MESSAGE2 = "rpc.jsonrpc.error_message";
    var TMP_MESSAGE_TYPE2 = "message.type";
    var TMP_MESSAGE_ID2 = "message.id";
    var TMP_MESSAGE_COMPRESSED_SIZE2 = "message.compressed_size";
    var TMP_MESSAGE_UNCOMPRESSED_SIZE2 = "message.uncompressed_size";
    exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = TMP_AWS_LAMBDA_INVOKED_ARN2;
    exports.SEMATTRS_DB_SYSTEM = TMP_DB_SYSTEM2;
    exports.SEMATTRS_DB_CONNECTION_STRING = TMP_DB_CONNECTION_STRING2;
    exports.SEMATTRS_DB_USER = TMP_DB_USER2;
    exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = TMP_DB_JDBC_DRIVER_CLASSNAME2;
    exports.SEMATTRS_DB_NAME = TMP_DB_NAME2;
    exports.SEMATTRS_DB_STATEMENT = TMP_DB_STATEMENT2;
    exports.SEMATTRS_DB_OPERATION = TMP_DB_OPERATION2;
    exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = TMP_DB_MSSQL_INSTANCE_NAME2;
    exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = TMP_DB_CASSANDRA_KEYSPACE2;
    exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = TMP_DB_CASSANDRA_PAGE_SIZE2;
    exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL2;
    exports.SEMATTRS_DB_CASSANDRA_TABLE = TMP_DB_CASSANDRA_TABLE2;
    exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = TMP_DB_CASSANDRA_IDEMPOTENCE2;
    exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT2;
    exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = TMP_DB_CASSANDRA_COORDINATOR_ID2;
    exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = TMP_DB_CASSANDRA_COORDINATOR_DC2;
    exports.SEMATTRS_DB_HBASE_NAMESPACE = TMP_DB_HBASE_NAMESPACE2;
    exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = TMP_DB_REDIS_DATABASE_INDEX2;
    exports.SEMATTRS_DB_MONGODB_COLLECTION = TMP_DB_MONGODB_COLLECTION2;
    exports.SEMATTRS_DB_SQL_TABLE = TMP_DB_SQL_TABLE2;
    exports.SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE2;
    exports.SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE2;
    exports.SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE2;
    exports.SEMATTRS_EXCEPTION_ESCAPED = TMP_EXCEPTION_ESCAPED2;
    exports.SEMATTRS_FAAS_TRIGGER = TMP_FAAS_TRIGGER2;
    exports.SEMATTRS_FAAS_EXECUTION = TMP_FAAS_EXECUTION2;
    exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = TMP_FAAS_DOCUMENT_COLLECTION2;
    exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = TMP_FAAS_DOCUMENT_OPERATION2;
    exports.SEMATTRS_FAAS_DOCUMENT_TIME = TMP_FAAS_DOCUMENT_TIME2;
    exports.SEMATTRS_FAAS_DOCUMENT_NAME = TMP_FAAS_DOCUMENT_NAME2;
    exports.SEMATTRS_FAAS_TIME = TMP_FAAS_TIME2;
    exports.SEMATTRS_FAAS_CRON = TMP_FAAS_CRON2;
    exports.SEMATTRS_FAAS_COLDSTART = TMP_FAAS_COLDSTART2;
    exports.SEMATTRS_FAAS_INVOKED_NAME = TMP_FAAS_INVOKED_NAME2;
    exports.SEMATTRS_FAAS_INVOKED_PROVIDER = TMP_FAAS_INVOKED_PROVIDER2;
    exports.SEMATTRS_FAAS_INVOKED_REGION = TMP_FAAS_INVOKED_REGION2;
    exports.SEMATTRS_NET_TRANSPORT = TMP_NET_TRANSPORT2;
    exports.SEMATTRS_NET_PEER_IP = TMP_NET_PEER_IP2;
    exports.SEMATTRS_NET_PEER_PORT = TMP_NET_PEER_PORT2;
    exports.SEMATTRS_NET_PEER_NAME = TMP_NET_PEER_NAME2;
    exports.SEMATTRS_NET_HOST_IP = TMP_NET_HOST_IP2;
    exports.SEMATTRS_NET_HOST_PORT = TMP_NET_HOST_PORT2;
    exports.SEMATTRS_NET_HOST_NAME = TMP_NET_HOST_NAME2;
    exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = TMP_NET_HOST_CONNECTION_TYPE2;
    exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = TMP_NET_HOST_CONNECTION_SUBTYPE2;
    exports.SEMATTRS_NET_HOST_CARRIER_NAME = TMP_NET_HOST_CARRIER_NAME2;
    exports.SEMATTRS_NET_HOST_CARRIER_MCC = TMP_NET_HOST_CARRIER_MCC2;
    exports.SEMATTRS_NET_HOST_CARRIER_MNC = TMP_NET_HOST_CARRIER_MNC2;
    exports.SEMATTRS_NET_HOST_CARRIER_ICC = TMP_NET_HOST_CARRIER_ICC2;
    exports.SEMATTRS_PEER_SERVICE = TMP_PEER_SERVICE2;
    exports.SEMATTRS_ENDUSER_ID = TMP_ENDUSER_ID2;
    exports.SEMATTRS_ENDUSER_ROLE = TMP_ENDUSER_ROLE2;
    exports.SEMATTRS_ENDUSER_SCOPE = TMP_ENDUSER_SCOPE2;
    exports.SEMATTRS_THREAD_ID = TMP_THREAD_ID2;
    exports.SEMATTRS_THREAD_NAME = TMP_THREAD_NAME2;
    exports.SEMATTRS_CODE_FUNCTION = TMP_CODE_FUNCTION2;
    exports.SEMATTRS_CODE_NAMESPACE = TMP_CODE_NAMESPACE2;
    exports.SEMATTRS_CODE_FILEPATH = TMP_CODE_FILEPATH2;
    exports.SEMATTRS_CODE_LINENO = TMP_CODE_LINENO2;
    exports.SEMATTRS_HTTP_METHOD = TMP_HTTP_METHOD2;
    exports.SEMATTRS_HTTP_URL = TMP_HTTP_URL2;
    exports.SEMATTRS_HTTP_TARGET = TMP_HTTP_TARGET2;
    exports.SEMATTRS_HTTP_HOST = TMP_HTTP_HOST2;
    exports.SEMATTRS_HTTP_SCHEME = TMP_HTTP_SCHEME2;
    exports.SEMATTRS_HTTP_STATUS_CODE = TMP_HTTP_STATUS_CODE2;
    exports.SEMATTRS_HTTP_FLAVOR = TMP_HTTP_FLAVOR2;
    exports.SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT2;
    exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = TMP_HTTP_REQUEST_CONTENT_LENGTH2;
    exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED2;
    exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = TMP_HTTP_RESPONSE_CONTENT_LENGTH2;
    exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2;
    exports.SEMATTRS_HTTP_SERVER_NAME = TMP_HTTP_SERVER_NAME2;
    exports.SEMATTRS_HTTP_ROUTE = TMP_HTTP_ROUTE2;
    exports.SEMATTRS_HTTP_CLIENT_IP = TMP_HTTP_CLIENT_IP2;
    exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = TMP_AWS_DYNAMODB_TABLE_NAMES2;
    exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY2;
    exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS2;
    exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY2;
    exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY2;
    exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = TMP_AWS_DYNAMODB_CONSISTENT_READ2;
    exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = TMP_AWS_DYNAMODB_PROJECTION2;
    exports.SEMATTRS_AWS_DYNAMODB_LIMIT = TMP_AWS_DYNAMODB_LIMIT2;
    exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET2;
    exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = TMP_AWS_DYNAMODB_INDEX_NAME2;
    exports.SEMATTRS_AWS_DYNAMODB_SELECT = TMP_AWS_DYNAMODB_SELECT2;
    exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES2;
    exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES2;
    exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE2;
    exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = TMP_AWS_DYNAMODB_TABLE_COUNT2;
    exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = TMP_AWS_DYNAMODB_SCAN_FORWARD2;
    exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = TMP_AWS_DYNAMODB_SEGMENT2;
    exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS2;
    exports.SEMATTRS_AWS_DYNAMODB_COUNT = TMP_AWS_DYNAMODB_COUNT2;
    exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = TMP_AWS_DYNAMODB_SCANNED_COUNT2;
    exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS2;
    exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES2;
    exports.SEMATTRS_MESSAGING_SYSTEM = TMP_MESSAGING_SYSTEM2;
    exports.SEMATTRS_MESSAGING_DESTINATION = TMP_MESSAGING_DESTINATION2;
    exports.SEMATTRS_MESSAGING_DESTINATION_KIND = TMP_MESSAGING_DESTINATION_KIND2;
    exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = TMP_MESSAGING_TEMP_DESTINATION2;
    exports.SEMATTRS_MESSAGING_PROTOCOL = TMP_MESSAGING_PROTOCOL2;
    exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = TMP_MESSAGING_PROTOCOL_VERSION2;
    exports.SEMATTRS_MESSAGING_URL = TMP_MESSAGING_URL2;
    exports.SEMATTRS_MESSAGING_MESSAGE_ID = TMP_MESSAGING_MESSAGE_ID2;
    exports.SEMATTRS_MESSAGING_CONVERSATION_ID = TMP_MESSAGING_CONVERSATION_ID2;
    exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES2;
    exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES2;
    exports.SEMATTRS_MESSAGING_OPERATION = TMP_MESSAGING_OPERATION2;
    exports.SEMATTRS_MESSAGING_CONSUMER_ID = TMP_MESSAGING_CONSUMER_ID2;
    exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = TMP_MESSAGING_RABBITMQ_ROUTING_KEY2;
    exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = TMP_MESSAGING_KAFKA_MESSAGE_KEY2;
    exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = TMP_MESSAGING_KAFKA_CONSUMER_GROUP2;
    exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = TMP_MESSAGING_KAFKA_CLIENT_ID2;
    exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = TMP_MESSAGING_KAFKA_PARTITION2;
    exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = TMP_MESSAGING_KAFKA_TOMBSTONE2;
    exports.SEMATTRS_RPC_SYSTEM = TMP_RPC_SYSTEM2;
    exports.SEMATTRS_RPC_SERVICE = TMP_RPC_SERVICE2;
    exports.SEMATTRS_RPC_METHOD = TMP_RPC_METHOD2;
    exports.SEMATTRS_RPC_GRPC_STATUS_CODE = TMP_RPC_GRPC_STATUS_CODE2;
    exports.SEMATTRS_RPC_JSONRPC_VERSION = TMP_RPC_JSONRPC_VERSION2;
    exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = TMP_RPC_JSONRPC_REQUEST_ID2;
    exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = TMP_RPC_JSONRPC_ERROR_CODE2;
    exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = TMP_RPC_JSONRPC_ERROR_MESSAGE2;
    exports.SEMATTRS_MESSAGE_TYPE = TMP_MESSAGE_TYPE2;
    exports.SEMATTRS_MESSAGE_ID = TMP_MESSAGE_ID2;
    exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = TMP_MESSAGE_COMPRESSED_SIZE2;
    exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = TMP_MESSAGE_UNCOMPRESSED_SIZE2;
    exports.SemanticAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_AWS_LAMBDA_INVOKED_ARN2,
      TMP_DB_SYSTEM2,
      TMP_DB_CONNECTION_STRING2,
      TMP_DB_USER2,
      TMP_DB_JDBC_DRIVER_CLASSNAME2,
      TMP_DB_NAME2,
      TMP_DB_STATEMENT2,
      TMP_DB_OPERATION2,
      TMP_DB_MSSQL_INSTANCE_NAME2,
      TMP_DB_CASSANDRA_KEYSPACE2,
      TMP_DB_CASSANDRA_PAGE_SIZE2,
      TMP_DB_CASSANDRA_CONSISTENCY_LEVEL2,
      TMP_DB_CASSANDRA_TABLE2,
      TMP_DB_CASSANDRA_IDEMPOTENCE2,
      TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT2,
      TMP_DB_CASSANDRA_COORDINATOR_ID2,
      TMP_DB_CASSANDRA_COORDINATOR_DC2,
      TMP_DB_HBASE_NAMESPACE2,
      TMP_DB_REDIS_DATABASE_INDEX2,
      TMP_DB_MONGODB_COLLECTION2,
      TMP_DB_SQL_TABLE2,
      TMP_EXCEPTION_TYPE2,
      TMP_EXCEPTION_MESSAGE2,
      TMP_EXCEPTION_STACKTRACE2,
      TMP_EXCEPTION_ESCAPED2,
      TMP_FAAS_TRIGGER2,
      TMP_FAAS_EXECUTION2,
      TMP_FAAS_DOCUMENT_COLLECTION2,
      TMP_FAAS_DOCUMENT_OPERATION2,
      TMP_FAAS_DOCUMENT_TIME2,
      TMP_FAAS_DOCUMENT_NAME2,
      TMP_FAAS_TIME2,
      TMP_FAAS_CRON2,
      TMP_FAAS_COLDSTART2,
      TMP_FAAS_INVOKED_NAME2,
      TMP_FAAS_INVOKED_PROVIDER2,
      TMP_FAAS_INVOKED_REGION2,
      TMP_NET_TRANSPORT2,
      TMP_NET_PEER_IP2,
      TMP_NET_PEER_PORT2,
      TMP_NET_PEER_NAME2,
      TMP_NET_HOST_IP2,
      TMP_NET_HOST_PORT2,
      TMP_NET_HOST_NAME2,
      TMP_NET_HOST_CONNECTION_TYPE2,
      TMP_NET_HOST_CONNECTION_SUBTYPE2,
      TMP_NET_HOST_CARRIER_NAME2,
      TMP_NET_HOST_CARRIER_MCC2,
      TMP_NET_HOST_CARRIER_MNC2,
      TMP_NET_HOST_CARRIER_ICC2,
      TMP_PEER_SERVICE2,
      TMP_ENDUSER_ID2,
      TMP_ENDUSER_ROLE2,
      TMP_ENDUSER_SCOPE2,
      TMP_THREAD_ID2,
      TMP_THREAD_NAME2,
      TMP_CODE_FUNCTION2,
      TMP_CODE_NAMESPACE2,
      TMP_CODE_FILEPATH2,
      TMP_CODE_LINENO2,
      TMP_HTTP_METHOD2,
      TMP_HTTP_URL2,
      TMP_HTTP_TARGET2,
      TMP_HTTP_HOST2,
      TMP_HTTP_SCHEME2,
      TMP_HTTP_STATUS_CODE2,
      TMP_HTTP_FLAVOR2,
      TMP_HTTP_USER_AGENT2,
      TMP_HTTP_REQUEST_CONTENT_LENGTH2,
      TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED2,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH2,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED2,
      TMP_HTTP_SERVER_NAME2,
      TMP_HTTP_ROUTE2,
      TMP_HTTP_CLIENT_IP2,
      TMP_AWS_DYNAMODB_TABLE_NAMES2,
      TMP_AWS_DYNAMODB_CONSUMED_CAPACITY2,
      TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS2,
      TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY2,
      TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY2,
      TMP_AWS_DYNAMODB_CONSISTENT_READ2,
      TMP_AWS_DYNAMODB_PROJECTION2,
      TMP_AWS_DYNAMODB_LIMIT2,
      TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET2,
      TMP_AWS_DYNAMODB_INDEX_NAME2,
      TMP_AWS_DYNAMODB_SELECT2,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES2,
      TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES2,
      TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE2,
      TMP_AWS_DYNAMODB_TABLE_COUNT2,
      TMP_AWS_DYNAMODB_SCAN_FORWARD2,
      TMP_AWS_DYNAMODB_SEGMENT2,
      TMP_AWS_DYNAMODB_TOTAL_SEGMENTS2,
      TMP_AWS_DYNAMODB_COUNT2,
      TMP_AWS_DYNAMODB_SCANNED_COUNT2,
      TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS2,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES2,
      TMP_MESSAGING_SYSTEM2,
      TMP_MESSAGING_DESTINATION2,
      TMP_MESSAGING_DESTINATION_KIND2,
      TMP_MESSAGING_TEMP_DESTINATION2,
      TMP_MESSAGING_PROTOCOL2,
      TMP_MESSAGING_PROTOCOL_VERSION2,
      TMP_MESSAGING_URL2,
      TMP_MESSAGING_MESSAGE_ID2,
      TMP_MESSAGING_CONVERSATION_ID2,
      TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES2,
      TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES2,
      TMP_MESSAGING_OPERATION2,
      TMP_MESSAGING_CONSUMER_ID2,
      TMP_MESSAGING_RABBITMQ_ROUTING_KEY2,
      TMP_MESSAGING_KAFKA_MESSAGE_KEY2,
      TMP_MESSAGING_KAFKA_CONSUMER_GROUP2,
      TMP_MESSAGING_KAFKA_CLIENT_ID2,
      TMP_MESSAGING_KAFKA_PARTITION2,
      TMP_MESSAGING_KAFKA_TOMBSTONE2,
      TMP_RPC_SYSTEM2,
      TMP_RPC_SERVICE2,
      TMP_RPC_METHOD2,
      TMP_RPC_GRPC_STATUS_CODE2,
      TMP_RPC_JSONRPC_VERSION2,
      TMP_RPC_JSONRPC_REQUEST_ID2,
      TMP_RPC_JSONRPC_ERROR_CODE2,
      TMP_RPC_JSONRPC_ERROR_MESSAGE2,
      TMP_MESSAGE_TYPE2,
      TMP_MESSAGE_ID2,
      TMP_MESSAGE_COMPRESSED_SIZE2,
      TMP_MESSAGE_UNCOMPRESSED_SIZE2
    ]);
    var TMP_DBSYSTEMVALUES_OTHER_SQL2 = "other_sql";
    var TMP_DBSYSTEMVALUES_MSSQL2 = "mssql";
    var TMP_DBSYSTEMVALUES_MYSQL2 = "mysql";
    var TMP_DBSYSTEMVALUES_ORACLE2 = "oracle";
    var TMP_DBSYSTEMVALUES_DB22 = "db2";
    var TMP_DBSYSTEMVALUES_POSTGRESQL2 = "postgresql";
    var TMP_DBSYSTEMVALUES_REDSHIFT2 = "redshift";
    var TMP_DBSYSTEMVALUES_HIVE2 = "hive";
    var TMP_DBSYSTEMVALUES_CLOUDSCAPE2 = "cloudscape";
    var TMP_DBSYSTEMVALUES_HSQLDB2 = "hsqldb";
    var TMP_DBSYSTEMVALUES_PROGRESS2 = "progress";
    var TMP_DBSYSTEMVALUES_MAXDB2 = "maxdb";
    var TMP_DBSYSTEMVALUES_HANADB2 = "hanadb";
    var TMP_DBSYSTEMVALUES_INGRES2 = "ingres";
    var TMP_DBSYSTEMVALUES_FIRSTSQL2 = "firstsql";
    var TMP_DBSYSTEMVALUES_EDB2 = "edb";
    var TMP_DBSYSTEMVALUES_CACHE2 = "cache";
    var TMP_DBSYSTEMVALUES_ADABAS2 = "adabas";
    var TMP_DBSYSTEMVALUES_FIREBIRD2 = "firebird";
    var TMP_DBSYSTEMVALUES_DERBY2 = "derby";
    var TMP_DBSYSTEMVALUES_FILEMAKER2 = "filemaker";
    var TMP_DBSYSTEMVALUES_INFORMIX2 = "informix";
    var TMP_DBSYSTEMVALUES_INSTANTDB2 = "instantdb";
    var TMP_DBSYSTEMVALUES_INTERBASE2 = "interbase";
    var TMP_DBSYSTEMVALUES_MARIADB2 = "mariadb";
    var TMP_DBSYSTEMVALUES_NETEZZA2 = "netezza";
    var TMP_DBSYSTEMVALUES_PERVASIVE2 = "pervasive";
    var TMP_DBSYSTEMVALUES_POINTBASE2 = "pointbase";
    var TMP_DBSYSTEMVALUES_SQLITE2 = "sqlite";
    var TMP_DBSYSTEMVALUES_SYBASE2 = "sybase";
    var TMP_DBSYSTEMVALUES_TERADATA2 = "teradata";
    var TMP_DBSYSTEMVALUES_VERTICA2 = "vertica";
    var TMP_DBSYSTEMVALUES_H22 = "h2";
    var TMP_DBSYSTEMVALUES_COLDFUSION2 = "coldfusion";
    var TMP_DBSYSTEMVALUES_CASSANDRA2 = "cassandra";
    var TMP_DBSYSTEMVALUES_HBASE2 = "hbase";
    var TMP_DBSYSTEMVALUES_MONGODB2 = "mongodb";
    var TMP_DBSYSTEMVALUES_REDIS2 = "redis";
    var TMP_DBSYSTEMVALUES_COUCHBASE2 = "couchbase";
    var TMP_DBSYSTEMVALUES_COUCHDB2 = "couchdb";
    var TMP_DBSYSTEMVALUES_COSMOSDB2 = "cosmosdb";
    var TMP_DBSYSTEMVALUES_DYNAMODB2 = "dynamodb";
    var TMP_DBSYSTEMVALUES_NEO4J2 = "neo4j";
    var TMP_DBSYSTEMVALUES_GEODE2 = "geode";
    var TMP_DBSYSTEMVALUES_ELASTICSEARCH2 = "elasticsearch";
    var TMP_DBSYSTEMVALUES_MEMCACHED2 = "memcached";
    var TMP_DBSYSTEMVALUES_COCKROACHDB2 = "cockroachdb";
    exports.DBSYSTEMVALUES_OTHER_SQL = TMP_DBSYSTEMVALUES_OTHER_SQL2;
    exports.DBSYSTEMVALUES_MSSQL = TMP_DBSYSTEMVALUES_MSSQL2;
    exports.DBSYSTEMVALUES_MYSQL = TMP_DBSYSTEMVALUES_MYSQL2;
    exports.DBSYSTEMVALUES_ORACLE = TMP_DBSYSTEMVALUES_ORACLE2;
    exports.DBSYSTEMVALUES_DB2 = TMP_DBSYSTEMVALUES_DB22;
    exports.DBSYSTEMVALUES_POSTGRESQL = TMP_DBSYSTEMVALUES_POSTGRESQL2;
    exports.DBSYSTEMVALUES_REDSHIFT = TMP_DBSYSTEMVALUES_REDSHIFT2;
    exports.DBSYSTEMVALUES_HIVE = TMP_DBSYSTEMVALUES_HIVE2;
    exports.DBSYSTEMVALUES_CLOUDSCAPE = TMP_DBSYSTEMVALUES_CLOUDSCAPE2;
    exports.DBSYSTEMVALUES_HSQLDB = TMP_DBSYSTEMVALUES_HSQLDB2;
    exports.DBSYSTEMVALUES_PROGRESS = TMP_DBSYSTEMVALUES_PROGRESS2;
    exports.DBSYSTEMVALUES_MAXDB = TMP_DBSYSTEMVALUES_MAXDB2;
    exports.DBSYSTEMVALUES_HANADB = TMP_DBSYSTEMVALUES_HANADB2;
    exports.DBSYSTEMVALUES_INGRES = TMP_DBSYSTEMVALUES_INGRES2;
    exports.DBSYSTEMVALUES_FIRSTSQL = TMP_DBSYSTEMVALUES_FIRSTSQL2;
    exports.DBSYSTEMVALUES_EDB = TMP_DBSYSTEMVALUES_EDB2;
    exports.DBSYSTEMVALUES_CACHE = TMP_DBSYSTEMVALUES_CACHE2;
    exports.DBSYSTEMVALUES_ADABAS = TMP_DBSYSTEMVALUES_ADABAS2;
    exports.DBSYSTEMVALUES_FIREBIRD = TMP_DBSYSTEMVALUES_FIREBIRD2;
    exports.DBSYSTEMVALUES_DERBY = TMP_DBSYSTEMVALUES_DERBY2;
    exports.DBSYSTEMVALUES_FILEMAKER = TMP_DBSYSTEMVALUES_FILEMAKER2;
    exports.DBSYSTEMVALUES_INFORMIX = TMP_DBSYSTEMVALUES_INFORMIX2;
    exports.DBSYSTEMVALUES_INSTANTDB = TMP_DBSYSTEMVALUES_INSTANTDB2;
    exports.DBSYSTEMVALUES_INTERBASE = TMP_DBSYSTEMVALUES_INTERBASE2;
    exports.DBSYSTEMVALUES_MARIADB = TMP_DBSYSTEMVALUES_MARIADB2;
    exports.DBSYSTEMVALUES_NETEZZA = TMP_DBSYSTEMVALUES_NETEZZA2;
    exports.DBSYSTEMVALUES_PERVASIVE = TMP_DBSYSTEMVALUES_PERVASIVE2;
    exports.DBSYSTEMVALUES_POINTBASE = TMP_DBSYSTEMVALUES_POINTBASE2;
    exports.DBSYSTEMVALUES_SQLITE = TMP_DBSYSTEMVALUES_SQLITE2;
    exports.DBSYSTEMVALUES_SYBASE = TMP_DBSYSTEMVALUES_SYBASE2;
    exports.DBSYSTEMVALUES_TERADATA = TMP_DBSYSTEMVALUES_TERADATA2;
    exports.DBSYSTEMVALUES_VERTICA = TMP_DBSYSTEMVALUES_VERTICA2;
    exports.DBSYSTEMVALUES_H2 = TMP_DBSYSTEMVALUES_H22;
    exports.DBSYSTEMVALUES_COLDFUSION = TMP_DBSYSTEMVALUES_COLDFUSION2;
    exports.DBSYSTEMVALUES_CASSANDRA = TMP_DBSYSTEMVALUES_CASSANDRA2;
    exports.DBSYSTEMVALUES_HBASE = TMP_DBSYSTEMVALUES_HBASE2;
    exports.DBSYSTEMVALUES_MONGODB = TMP_DBSYSTEMVALUES_MONGODB2;
    exports.DBSYSTEMVALUES_REDIS = TMP_DBSYSTEMVALUES_REDIS2;
    exports.DBSYSTEMVALUES_COUCHBASE = TMP_DBSYSTEMVALUES_COUCHBASE2;
    exports.DBSYSTEMVALUES_COUCHDB = TMP_DBSYSTEMVALUES_COUCHDB2;
    exports.DBSYSTEMVALUES_COSMOSDB = TMP_DBSYSTEMVALUES_COSMOSDB2;
    exports.DBSYSTEMVALUES_DYNAMODB = TMP_DBSYSTEMVALUES_DYNAMODB2;
    exports.DBSYSTEMVALUES_NEO4J = TMP_DBSYSTEMVALUES_NEO4J2;
    exports.DBSYSTEMVALUES_GEODE = TMP_DBSYSTEMVALUES_GEODE2;
    exports.DBSYSTEMVALUES_ELASTICSEARCH = TMP_DBSYSTEMVALUES_ELASTICSEARCH2;
    exports.DBSYSTEMVALUES_MEMCACHED = TMP_DBSYSTEMVALUES_MEMCACHED2;
    exports.DBSYSTEMVALUES_COCKROACHDB = TMP_DBSYSTEMVALUES_COCKROACHDB2;
    exports.DbSystemValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_DBSYSTEMVALUES_OTHER_SQL2,
      TMP_DBSYSTEMVALUES_MSSQL2,
      TMP_DBSYSTEMVALUES_MYSQL2,
      TMP_DBSYSTEMVALUES_ORACLE2,
      TMP_DBSYSTEMVALUES_DB22,
      TMP_DBSYSTEMVALUES_POSTGRESQL2,
      TMP_DBSYSTEMVALUES_REDSHIFT2,
      TMP_DBSYSTEMVALUES_HIVE2,
      TMP_DBSYSTEMVALUES_CLOUDSCAPE2,
      TMP_DBSYSTEMVALUES_HSQLDB2,
      TMP_DBSYSTEMVALUES_PROGRESS2,
      TMP_DBSYSTEMVALUES_MAXDB2,
      TMP_DBSYSTEMVALUES_HANADB2,
      TMP_DBSYSTEMVALUES_INGRES2,
      TMP_DBSYSTEMVALUES_FIRSTSQL2,
      TMP_DBSYSTEMVALUES_EDB2,
      TMP_DBSYSTEMVALUES_CACHE2,
      TMP_DBSYSTEMVALUES_ADABAS2,
      TMP_DBSYSTEMVALUES_FIREBIRD2,
      TMP_DBSYSTEMVALUES_DERBY2,
      TMP_DBSYSTEMVALUES_FILEMAKER2,
      TMP_DBSYSTEMVALUES_INFORMIX2,
      TMP_DBSYSTEMVALUES_INSTANTDB2,
      TMP_DBSYSTEMVALUES_INTERBASE2,
      TMP_DBSYSTEMVALUES_MARIADB2,
      TMP_DBSYSTEMVALUES_NETEZZA2,
      TMP_DBSYSTEMVALUES_PERVASIVE2,
      TMP_DBSYSTEMVALUES_POINTBASE2,
      TMP_DBSYSTEMVALUES_SQLITE2,
      TMP_DBSYSTEMVALUES_SYBASE2,
      TMP_DBSYSTEMVALUES_TERADATA2,
      TMP_DBSYSTEMVALUES_VERTICA2,
      TMP_DBSYSTEMVALUES_H22,
      TMP_DBSYSTEMVALUES_COLDFUSION2,
      TMP_DBSYSTEMVALUES_CASSANDRA2,
      TMP_DBSYSTEMVALUES_HBASE2,
      TMP_DBSYSTEMVALUES_MONGODB2,
      TMP_DBSYSTEMVALUES_REDIS2,
      TMP_DBSYSTEMVALUES_COUCHBASE2,
      TMP_DBSYSTEMVALUES_COUCHDB2,
      TMP_DBSYSTEMVALUES_COSMOSDB2,
      TMP_DBSYSTEMVALUES_DYNAMODB2,
      TMP_DBSYSTEMVALUES_NEO4J2,
      TMP_DBSYSTEMVALUES_GEODE2,
      TMP_DBSYSTEMVALUES_ELASTICSEARCH2,
      TMP_DBSYSTEMVALUES_MEMCACHED2,
      TMP_DBSYSTEMVALUES_COCKROACHDB2
    ]);
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL2 = "all";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM2 = "each_quorum";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM2 = "quorum";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM2 = "local_quorum";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE2 = "one";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO2 = "two";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE2 = "three";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE2 = "local_one";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY2 = "any";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL2 = "serial";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL2 = "local_serial";
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL2;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL2;
    exports.DbCassandraConsistencyLevelValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL2,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL2
    ]);
    var TMP_FAASTRIGGERVALUES_DATASOURCE2 = "datasource";
    var TMP_FAASTRIGGERVALUES_HTTP2 = "http";
    var TMP_FAASTRIGGERVALUES_PUBSUB2 = "pubsub";
    var TMP_FAASTRIGGERVALUES_TIMER2 = "timer";
    var TMP_FAASTRIGGERVALUES_OTHER2 = "other";
    exports.FAASTRIGGERVALUES_DATASOURCE = TMP_FAASTRIGGERVALUES_DATASOURCE2;
    exports.FAASTRIGGERVALUES_HTTP = TMP_FAASTRIGGERVALUES_HTTP2;
    exports.FAASTRIGGERVALUES_PUBSUB = TMP_FAASTRIGGERVALUES_PUBSUB2;
    exports.FAASTRIGGERVALUES_TIMER = TMP_FAASTRIGGERVALUES_TIMER2;
    exports.FAASTRIGGERVALUES_OTHER = TMP_FAASTRIGGERVALUES_OTHER2;
    exports.FaasTriggerValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_FAASTRIGGERVALUES_DATASOURCE2,
      TMP_FAASTRIGGERVALUES_HTTP2,
      TMP_FAASTRIGGERVALUES_PUBSUB2,
      TMP_FAASTRIGGERVALUES_TIMER2,
      TMP_FAASTRIGGERVALUES_OTHER2
    ]);
    var TMP_FAASDOCUMENTOPERATIONVALUES_INSERT2 = "insert";
    var TMP_FAASDOCUMENTOPERATIONVALUES_EDIT2 = "edit";
    var TMP_FAASDOCUMENTOPERATIONVALUES_DELETE2 = "delete";
    exports.FAASDOCUMENTOPERATIONVALUES_INSERT = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT2;
    exports.FAASDOCUMENTOPERATIONVALUES_EDIT = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT2;
    exports.FAASDOCUMENTOPERATIONVALUES_DELETE = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE2;
    exports.FaasDocumentOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_FAASDOCUMENTOPERATIONVALUES_INSERT2,
      TMP_FAASDOCUMENTOPERATIONVALUES_EDIT2,
      TMP_FAASDOCUMENTOPERATIONVALUES_DELETE2
    ]);
    var TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD2 = "alibaba_cloud";
    var TMP_FAASINVOKEDPROVIDERVALUES_AWS2 = "aws";
    var TMP_FAASINVOKEDPROVIDERVALUES_AZURE2 = "azure";
    var TMP_FAASINVOKEDPROVIDERVALUES_GCP2 = "gcp";
    exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD2;
    exports.FAASINVOKEDPROVIDERVALUES_AWS = TMP_FAASINVOKEDPROVIDERVALUES_AWS2;
    exports.FAASINVOKEDPROVIDERVALUES_AZURE = TMP_FAASINVOKEDPROVIDERVALUES_AZURE2;
    exports.FAASINVOKEDPROVIDERVALUES_GCP = TMP_FAASINVOKEDPROVIDERVALUES_GCP2;
    exports.FaasInvokedProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD2,
      TMP_FAASINVOKEDPROVIDERVALUES_AWS2,
      TMP_FAASINVOKEDPROVIDERVALUES_AZURE2,
      TMP_FAASINVOKEDPROVIDERVALUES_GCP2
    ]);
    var TMP_NETTRANSPORTVALUES_IP_TCP2 = "ip_tcp";
    var TMP_NETTRANSPORTVALUES_IP_UDP2 = "ip_udp";
    var TMP_NETTRANSPORTVALUES_IP2 = "ip";
    var TMP_NETTRANSPORTVALUES_UNIX2 = "unix";
    var TMP_NETTRANSPORTVALUES_PIPE2 = "pipe";
    var TMP_NETTRANSPORTVALUES_INPROC2 = "inproc";
    var TMP_NETTRANSPORTVALUES_OTHER2 = "other";
    exports.NETTRANSPORTVALUES_IP_TCP = TMP_NETTRANSPORTVALUES_IP_TCP2;
    exports.NETTRANSPORTVALUES_IP_UDP = TMP_NETTRANSPORTVALUES_IP_UDP2;
    exports.NETTRANSPORTVALUES_IP = TMP_NETTRANSPORTVALUES_IP2;
    exports.NETTRANSPORTVALUES_UNIX = TMP_NETTRANSPORTVALUES_UNIX2;
    exports.NETTRANSPORTVALUES_PIPE = TMP_NETTRANSPORTVALUES_PIPE2;
    exports.NETTRANSPORTVALUES_INPROC = TMP_NETTRANSPORTVALUES_INPROC2;
    exports.NETTRANSPORTVALUES_OTHER = TMP_NETTRANSPORTVALUES_OTHER2;
    exports.NetTransportValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_NETTRANSPORTVALUES_IP_TCP2,
      TMP_NETTRANSPORTVALUES_IP_UDP2,
      TMP_NETTRANSPORTVALUES_IP2,
      TMP_NETTRANSPORTVALUES_UNIX2,
      TMP_NETTRANSPORTVALUES_PIPE2,
      TMP_NETTRANSPORTVALUES_INPROC2,
      TMP_NETTRANSPORTVALUES_OTHER2
    ]);
    var TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI2 = "wifi";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED2 = "wired";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_CELL2 = "cell";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE2 = "unavailable";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN2 = "unknown";
    exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI2;
    exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED2;
    exports.NETHOSTCONNECTIONTYPEVALUES_CELL = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL2;
    exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE2;
    exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN2;
    exports.NetHostConnectionTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI2,
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED2,
      TMP_NETHOSTCONNECTIONTYPEVALUES_CELL2,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE2,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN2
    ]);
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS2 = "gprs";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE2 = "edge";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS2 = "umts";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2 = "cdma";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_02 = "evdo_0";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A2 = "evdo_a";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT2 = "cdma2000_1xrtt";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA2 = "hsdpa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA2 = "hsupa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA2 = "hspa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN2 = "iden";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B2 = "evdo_b";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE2 = "lte";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD2 = "ehrpd";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP2 = "hspap";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM2 = "gsm";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA2 = "td_scdma";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN2 = "iwlan";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR2 = "nr";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA2 = "nrnsa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA2 = "lte_ca";
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_02;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA2;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA2;
    exports.NetHostConnectionSubtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_02,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA2,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA2
    ]);
    var TMP_HTTPFLAVORVALUES_HTTP_1_02 = "1.0";
    var TMP_HTTPFLAVORVALUES_HTTP_1_12 = "1.1";
    var TMP_HTTPFLAVORVALUES_HTTP_2_02 = "2.0";
    var TMP_HTTPFLAVORVALUES_SPDY2 = "SPDY";
    var TMP_HTTPFLAVORVALUES_QUIC2 = "QUIC";
    exports.HTTPFLAVORVALUES_HTTP_1_0 = TMP_HTTPFLAVORVALUES_HTTP_1_02;
    exports.HTTPFLAVORVALUES_HTTP_1_1 = TMP_HTTPFLAVORVALUES_HTTP_1_12;
    exports.HTTPFLAVORVALUES_HTTP_2_0 = TMP_HTTPFLAVORVALUES_HTTP_2_02;
    exports.HTTPFLAVORVALUES_SPDY = TMP_HTTPFLAVORVALUES_SPDY2;
    exports.HTTPFLAVORVALUES_QUIC = TMP_HTTPFLAVORVALUES_QUIC2;
    exports.HttpFlavorValues = {
      HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_02,
      HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_12,
      HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_02,
      SPDY: TMP_HTTPFLAVORVALUES_SPDY2,
      QUIC: TMP_HTTPFLAVORVALUES_QUIC2
    };
    var TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE2 = "queue";
    var TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC2 = "topic";
    exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE2;
    exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC2;
    exports.MessagingDestinationKindValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE2,
      TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC2
    ]);
    var TMP_MESSAGINGOPERATIONVALUES_RECEIVE2 = "receive";
    var TMP_MESSAGINGOPERATIONVALUES_PROCESS2 = "process";
    exports.MESSAGINGOPERATIONVALUES_RECEIVE = TMP_MESSAGINGOPERATIONVALUES_RECEIVE2;
    exports.MESSAGINGOPERATIONVALUES_PROCESS = TMP_MESSAGINGOPERATIONVALUES_PROCESS2;
    exports.MessagingOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_MESSAGINGOPERATIONVALUES_RECEIVE2,
      TMP_MESSAGINGOPERATIONVALUES_PROCESS2
    ]);
    var TMP_RPCGRPCSTATUSCODEVALUES_OK2 = 0;
    var TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED2 = 1;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN2 = 2;
    var TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT2 = 3;
    var TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED2 = 4;
    var TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND2 = 5;
    var TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS2 = 6;
    var TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED2 = 7;
    var TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED2 = 8;
    var TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION2 = 9;
    var TMP_RPCGRPCSTATUSCODEVALUES_ABORTED2 = 10;
    var TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE2 = 11;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED2 = 12;
    var TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL2 = 13;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE2 = 14;
    var TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS2 = 15;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED2 = 16;
    exports.RPCGRPCSTATUSCODEVALUES_OK = TMP_RPCGRPCSTATUSCODEVALUES_OK2;
    exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED2;
    exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN2;
    exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT2;
    exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED2;
    exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND2;
    exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS2;
    exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED2;
    exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED2;
    exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION2;
    exports.RPCGRPCSTATUSCODEVALUES_ABORTED = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED2;
    exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE2;
    exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED2;
    exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL2;
    exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE2;
    exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS2;
    exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED2;
    exports.RpcGrpcStatusCodeValues = {
      OK: TMP_RPCGRPCSTATUSCODEVALUES_OK2,
      CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED2,
      UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN2,
      INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT2,
      DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED2,
      NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND2,
      ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS2,
      PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED2,
      RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED2,
      FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION2,
      ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED2,
      OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE2,
      UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED2,
      INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL2,
      UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE2,
      DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS2,
      UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED2
    };
    var TMP_MESSAGETYPEVALUES_SENT2 = "SENT";
    var TMP_MESSAGETYPEVALUES_RECEIVED2 = "RECEIVED";
    exports.MESSAGETYPEVALUES_SENT = TMP_MESSAGETYPEVALUES_SENT2;
    exports.MESSAGETYPEVALUES_RECEIVED = TMP_MESSAGETYPEVALUES_RECEIVED2;
    exports.MessageTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_MESSAGETYPEVALUES_SENT2,
      TMP_MESSAGETYPEVALUES_RECEIVED2
    ]);
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js
var require_trace6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_SemanticAttributes5(), exports);
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js
var require_SemanticResourceAttributes5 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SEMRESATTRS_K8S_STATEFULSET_NAME = exports.SEMRESATTRS_K8S_STATEFULSET_UID = exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = exports.SEMRESATTRS_K8S_REPLICASET_NAME = exports.SEMRESATTRS_K8S_REPLICASET_UID = exports.SEMRESATTRS_K8S_CONTAINER_NAME = exports.SEMRESATTRS_K8S_POD_NAME = exports.SEMRESATTRS_K8S_POD_UID = exports.SEMRESATTRS_K8S_NAMESPACE_NAME = exports.SEMRESATTRS_K8S_NODE_UID = exports.SEMRESATTRS_K8S_NODE_NAME = exports.SEMRESATTRS_K8S_CLUSTER_NAME = exports.SEMRESATTRS_HOST_IMAGE_VERSION = exports.SEMRESATTRS_HOST_IMAGE_ID = exports.SEMRESATTRS_HOST_IMAGE_NAME = exports.SEMRESATTRS_HOST_ARCH = exports.SEMRESATTRS_HOST_TYPE = exports.SEMRESATTRS_HOST_NAME = exports.SEMRESATTRS_HOST_ID = exports.SEMRESATTRS_FAAS_MAX_MEMORY = exports.SEMRESATTRS_FAAS_INSTANCE = exports.SEMRESATTRS_FAAS_VERSION = exports.SEMRESATTRS_FAAS_ID = exports.SEMRESATTRS_FAAS_NAME = exports.SEMRESATTRS_DEVICE_MODEL_NAME = exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = exports.SEMRESATTRS_DEVICE_ID = exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = exports.SEMRESATTRS_CONTAINER_RUNTIME = exports.SEMRESATTRS_CONTAINER_ID = exports.SEMRESATTRS_CONTAINER_NAME = exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = exports.SEMRESATTRS_AWS_ECS_TASK_ARN = exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = exports.SEMRESATTRS_CLOUD_PLATFORM = exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = exports.SEMRESATTRS_CLOUD_REGION = exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = exports.SEMRESATTRS_CLOUD_PROVIDER = void 0;
    exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = exports.CLOUDPLATFORMVALUES_AZURE_AKS = exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = exports.CLOUDPLATFORMVALUES_AZURE_VM = exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = exports.CLOUDPLATFORMVALUES_AWS_EKS = exports.CLOUDPLATFORMVALUES_AWS_ECS = exports.CLOUDPLATFORMVALUES_AWS_EC2 = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = exports.CloudProviderValues = exports.CLOUDPROVIDERVALUES_GCP = exports.CLOUDPROVIDERVALUES_AZURE = exports.CLOUDPROVIDERVALUES_AWS = exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = exports.SemanticResourceAttributes = exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = exports.SEMRESATTRS_WEBENGINE_VERSION = exports.SEMRESATTRS_WEBENGINE_NAME = exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = exports.SEMRESATTRS_TELEMETRY_SDK_NAME = exports.SEMRESATTRS_SERVICE_VERSION = exports.SEMRESATTRS_SERVICE_INSTANCE_ID = exports.SEMRESATTRS_SERVICE_NAMESPACE = exports.SEMRESATTRS_SERVICE_NAME = exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = exports.SEMRESATTRS_PROCESS_OWNER = exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = exports.SEMRESATTRS_PROCESS_COMMAND_LINE = exports.SEMRESATTRS_PROCESS_COMMAND = exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = exports.SEMRESATTRS_PROCESS_PID = exports.SEMRESATTRS_OS_VERSION = exports.SEMRESATTRS_OS_NAME = exports.SEMRESATTRS_OS_DESCRIPTION = exports.SEMRESATTRS_OS_TYPE = exports.SEMRESATTRS_K8S_CRONJOB_NAME = exports.SEMRESATTRS_K8S_CRONJOB_UID = exports.SEMRESATTRS_K8S_JOB_NAME = exports.SEMRESATTRS_K8S_JOB_UID = exports.SEMRESATTRS_K8S_DAEMONSET_NAME = exports.SEMRESATTRS_K8S_DAEMONSET_UID = void 0;
    exports.TelemetrySdkLanguageValues = exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = exports.TELEMETRYSDKLANGUAGEVALUES_PHP = exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = exports.TELEMETRYSDKLANGUAGEVALUES_GO = exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = exports.TELEMETRYSDKLANGUAGEVALUES_CPP = exports.OsTypeValues = exports.OSTYPEVALUES_Z_OS = exports.OSTYPEVALUES_SOLARIS = exports.OSTYPEVALUES_AIX = exports.OSTYPEVALUES_HPUX = exports.OSTYPEVALUES_DRAGONFLYBSD = exports.OSTYPEVALUES_OPENBSD = exports.OSTYPEVALUES_NETBSD = exports.OSTYPEVALUES_FREEBSD = exports.OSTYPEVALUES_DARWIN = exports.OSTYPEVALUES_LINUX = exports.OSTYPEVALUES_WINDOWS = exports.HostArchValues = exports.HOSTARCHVALUES_X86 = exports.HOSTARCHVALUES_PPC64 = exports.HOSTARCHVALUES_PPC32 = exports.HOSTARCHVALUES_IA64 = exports.HOSTARCHVALUES_ARM64 = exports.HOSTARCHVALUES_ARM32 = exports.HOSTARCHVALUES_AMD64 = exports.AwsEcsLaunchtypeValues = exports.AWSECSLAUNCHTYPEVALUES_FARGATE = exports.AWSECSLAUNCHTYPEVALUES_EC2 = exports.CloudPlatformValues = exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = void 0;
    var utils_1 = require_utils14();
    var TMP_CLOUD_PROVIDER2 = "cloud.provider";
    var TMP_CLOUD_ACCOUNT_ID2 = "cloud.account.id";
    var TMP_CLOUD_REGION2 = "cloud.region";
    var TMP_CLOUD_AVAILABILITY_ZONE2 = "cloud.availability_zone";
    var TMP_CLOUD_PLATFORM2 = "cloud.platform";
    var TMP_AWS_ECS_CONTAINER_ARN2 = "aws.ecs.container.arn";
    var TMP_AWS_ECS_CLUSTER_ARN2 = "aws.ecs.cluster.arn";
    var TMP_AWS_ECS_LAUNCHTYPE2 = "aws.ecs.launchtype";
    var TMP_AWS_ECS_TASK_ARN2 = "aws.ecs.task.arn";
    var TMP_AWS_ECS_TASK_FAMILY2 = "aws.ecs.task.family";
    var TMP_AWS_ECS_TASK_REVISION2 = "aws.ecs.task.revision";
    var TMP_AWS_EKS_CLUSTER_ARN2 = "aws.eks.cluster.arn";
    var TMP_AWS_LOG_GROUP_NAMES2 = "aws.log.group.names";
    var TMP_AWS_LOG_GROUP_ARNS2 = "aws.log.group.arns";
    var TMP_AWS_LOG_STREAM_NAMES2 = "aws.log.stream.names";
    var TMP_AWS_LOG_STREAM_ARNS2 = "aws.log.stream.arns";
    var TMP_CONTAINER_NAME2 = "container.name";
    var TMP_CONTAINER_ID2 = "container.id";
    var TMP_CONTAINER_RUNTIME2 = "container.runtime";
    var TMP_CONTAINER_IMAGE_NAME2 = "container.image.name";
    var TMP_CONTAINER_IMAGE_TAG2 = "container.image.tag";
    var TMP_DEPLOYMENT_ENVIRONMENT2 = "deployment.environment";
    var TMP_DEVICE_ID2 = "device.id";
    var TMP_DEVICE_MODEL_IDENTIFIER2 = "device.model.identifier";
    var TMP_DEVICE_MODEL_NAME2 = "device.model.name";
    var TMP_FAAS_NAME2 = "faas.name";
    var TMP_FAAS_ID2 = "faas.id";
    var TMP_FAAS_VERSION2 = "faas.version";
    var TMP_FAAS_INSTANCE2 = "faas.instance";
    var TMP_FAAS_MAX_MEMORY2 = "faas.max_memory";
    var TMP_HOST_ID2 = "host.id";
    var TMP_HOST_NAME2 = "host.name";
    var TMP_HOST_TYPE2 = "host.type";
    var TMP_HOST_ARCH2 = "host.arch";
    var TMP_HOST_IMAGE_NAME2 = "host.image.name";
    var TMP_HOST_IMAGE_ID2 = "host.image.id";
    var TMP_HOST_IMAGE_VERSION2 = "host.image.version";
    var TMP_K8S_CLUSTER_NAME2 = "k8s.cluster.name";
    var TMP_K8S_NODE_NAME2 = "k8s.node.name";
    var TMP_K8S_NODE_UID2 = "k8s.node.uid";
    var TMP_K8S_NAMESPACE_NAME2 = "k8s.namespace.name";
    var TMP_K8S_POD_UID2 = "k8s.pod.uid";
    var TMP_K8S_POD_NAME2 = "k8s.pod.name";
    var TMP_K8S_CONTAINER_NAME2 = "k8s.container.name";
    var TMP_K8S_REPLICASET_UID2 = "k8s.replicaset.uid";
    var TMP_K8S_REPLICASET_NAME2 = "k8s.replicaset.name";
    var TMP_K8S_DEPLOYMENT_UID2 = "k8s.deployment.uid";
    var TMP_K8S_DEPLOYMENT_NAME2 = "k8s.deployment.name";
    var TMP_K8S_STATEFULSET_UID2 = "k8s.statefulset.uid";
    var TMP_K8S_STATEFULSET_NAME2 = "k8s.statefulset.name";
    var TMP_K8S_DAEMONSET_UID2 = "k8s.daemonset.uid";
    var TMP_K8S_DAEMONSET_NAME2 = "k8s.daemonset.name";
    var TMP_K8S_JOB_UID2 = "k8s.job.uid";
    var TMP_K8S_JOB_NAME2 = "k8s.job.name";
    var TMP_K8S_CRONJOB_UID2 = "k8s.cronjob.uid";
    var TMP_K8S_CRONJOB_NAME2 = "k8s.cronjob.name";
    var TMP_OS_TYPE2 = "os.type";
    var TMP_OS_DESCRIPTION2 = "os.description";
    var TMP_OS_NAME2 = "os.name";
    var TMP_OS_VERSION2 = "os.version";
    var TMP_PROCESS_PID2 = "process.pid";
    var TMP_PROCESS_EXECUTABLE_NAME2 = "process.executable.name";
    var TMP_PROCESS_EXECUTABLE_PATH2 = "process.executable.path";
    var TMP_PROCESS_COMMAND2 = "process.command";
    var TMP_PROCESS_COMMAND_LINE2 = "process.command_line";
    var TMP_PROCESS_COMMAND_ARGS2 = "process.command_args";
    var TMP_PROCESS_OWNER2 = "process.owner";
    var TMP_PROCESS_RUNTIME_NAME2 = "process.runtime.name";
    var TMP_PROCESS_RUNTIME_VERSION2 = "process.runtime.version";
    var TMP_PROCESS_RUNTIME_DESCRIPTION2 = "process.runtime.description";
    var TMP_SERVICE_NAME2 = "service.name";
    var TMP_SERVICE_NAMESPACE2 = "service.namespace";
    var TMP_SERVICE_INSTANCE_ID2 = "service.instance.id";
    var TMP_SERVICE_VERSION2 = "service.version";
    var TMP_TELEMETRY_SDK_NAME2 = "telemetry.sdk.name";
    var TMP_TELEMETRY_SDK_LANGUAGE2 = "telemetry.sdk.language";
    var TMP_TELEMETRY_SDK_VERSION2 = "telemetry.sdk.version";
    var TMP_TELEMETRY_AUTO_VERSION2 = "telemetry.auto.version";
    var TMP_WEBENGINE_NAME2 = "webengine.name";
    var TMP_WEBENGINE_VERSION2 = "webengine.version";
    var TMP_WEBENGINE_DESCRIPTION2 = "webengine.description";
    exports.SEMRESATTRS_CLOUD_PROVIDER = TMP_CLOUD_PROVIDER2;
    exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = TMP_CLOUD_ACCOUNT_ID2;
    exports.SEMRESATTRS_CLOUD_REGION = TMP_CLOUD_REGION2;
    exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = TMP_CLOUD_AVAILABILITY_ZONE2;
    exports.SEMRESATTRS_CLOUD_PLATFORM = TMP_CLOUD_PLATFORM2;
    exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = TMP_AWS_ECS_CONTAINER_ARN2;
    exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = TMP_AWS_ECS_CLUSTER_ARN2;
    exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = TMP_AWS_ECS_LAUNCHTYPE2;
    exports.SEMRESATTRS_AWS_ECS_TASK_ARN = TMP_AWS_ECS_TASK_ARN2;
    exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = TMP_AWS_ECS_TASK_FAMILY2;
    exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = TMP_AWS_ECS_TASK_REVISION2;
    exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = TMP_AWS_EKS_CLUSTER_ARN2;
    exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = TMP_AWS_LOG_GROUP_NAMES2;
    exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = TMP_AWS_LOG_GROUP_ARNS2;
    exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = TMP_AWS_LOG_STREAM_NAMES2;
    exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = TMP_AWS_LOG_STREAM_ARNS2;
    exports.SEMRESATTRS_CONTAINER_NAME = TMP_CONTAINER_NAME2;
    exports.SEMRESATTRS_CONTAINER_ID = TMP_CONTAINER_ID2;
    exports.SEMRESATTRS_CONTAINER_RUNTIME = TMP_CONTAINER_RUNTIME2;
    exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = TMP_CONTAINER_IMAGE_NAME2;
    exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = TMP_CONTAINER_IMAGE_TAG2;
    exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = TMP_DEPLOYMENT_ENVIRONMENT2;
    exports.SEMRESATTRS_DEVICE_ID = TMP_DEVICE_ID2;
    exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = TMP_DEVICE_MODEL_IDENTIFIER2;
    exports.SEMRESATTRS_DEVICE_MODEL_NAME = TMP_DEVICE_MODEL_NAME2;
    exports.SEMRESATTRS_FAAS_NAME = TMP_FAAS_NAME2;
    exports.SEMRESATTRS_FAAS_ID = TMP_FAAS_ID2;
    exports.SEMRESATTRS_FAAS_VERSION = TMP_FAAS_VERSION2;
    exports.SEMRESATTRS_FAAS_INSTANCE = TMP_FAAS_INSTANCE2;
    exports.SEMRESATTRS_FAAS_MAX_MEMORY = TMP_FAAS_MAX_MEMORY2;
    exports.SEMRESATTRS_HOST_ID = TMP_HOST_ID2;
    exports.SEMRESATTRS_HOST_NAME = TMP_HOST_NAME2;
    exports.SEMRESATTRS_HOST_TYPE = TMP_HOST_TYPE2;
    exports.SEMRESATTRS_HOST_ARCH = TMP_HOST_ARCH2;
    exports.SEMRESATTRS_HOST_IMAGE_NAME = TMP_HOST_IMAGE_NAME2;
    exports.SEMRESATTRS_HOST_IMAGE_ID = TMP_HOST_IMAGE_ID2;
    exports.SEMRESATTRS_HOST_IMAGE_VERSION = TMP_HOST_IMAGE_VERSION2;
    exports.SEMRESATTRS_K8S_CLUSTER_NAME = TMP_K8S_CLUSTER_NAME2;
    exports.SEMRESATTRS_K8S_NODE_NAME = TMP_K8S_NODE_NAME2;
    exports.SEMRESATTRS_K8S_NODE_UID = TMP_K8S_NODE_UID2;
    exports.SEMRESATTRS_K8S_NAMESPACE_NAME = TMP_K8S_NAMESPACE_NAME2;
    exports.SEMRESATTRS_K8S_POD_UID = TMP_K8S_POD_UID2;
    exports.SEMRESATTRS_K8S_POD_NAME = TMP_K8S_POD_NAME2;
    exports.SEMRESATTRS_K8S_CONTAINER_NAME = TMP_K8S_CONTAINER_NAME2;
    exports.SEMRESATTRS_K8S_REPLICASET_UID = TMP_K8S_REPLICASET_UID2;
    exports.SEMRESATTRS_K8S_REPLICASET_NAME = TMP_K8S_REPLICASET_NAME2;
    exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = TMP_K8S_DEPLOYMENT_UID2;
    exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = TMP_K8S_DEPLOYMENT_NAME2;
    exports.SEMRESATTRS_K8S_STATEFULSET_UID = TMP_K8S_STATEFULSET_UID2;
    exports.SEMRESATTRS_K8S_STATEFULSET_NAME = TMP_K8S_STATEFULSET_NAME2;
    exports.SEMRESATTRS_K8S_DAEMONSET_UID = TMP_K8S_DAEMONSET_UID2;
    exports.SEMRESATTRS_K8S_DAEMONSET_NAME = TMP_K8S_DAEMONSET_NAME2;
    exports.SEMRESATTRS_K8S_JOB_UID = TMP_K8S_JOB_UID2;
    exports.SEMRESATTRS_K8S_JOB_NAME = TMP_K8S_JOB_NAME2;
    exports.SEMRESATTRS_K8S_CRONJOB_UID = TMP_K8S_CRONJOB_UID2;
    exports.SEMRESATTRS_K8S_CRONJOB_NAME = TMP_K8S_CRONJOB_NAME2;
    exports.SEMRESATTRS_OS_TYPE = TMP_OS_TYPE2;
    exports.SEMRESATTRS_OS_DESCRIPTION = TMP_OS_DESCRIPTION2;
    exports.SEMRESATTRS_OS_NAME = TMP_OS_NAME2;
    exports.SEMRESATTRS_OS_VERSION = TMP_OS_VERSION2;
    exports.SEMRESATTRS_PROCESS_PID = TMP_PROCESS_PID2;
    exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = TMP_PROCESS_EXECUTABLE_NAME2;
    exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = TMP_PROCESS_EXECUTABLE_PATH2;
    exports.SEMRESATTRS_PROCESS_COMMAND = TMP_PROCESS_COMMAND2;
    exports.SEMRESATTRS_PROCESS_COMMAND_LINE = TMP_PROCESS_COMMAND_LINE2;
    exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = TMP_PROCESS_COMMAND_ARGS2;
    exports.SEMRESATTRS_PROCESS_OWNER = TMP_PROCESS_OWNER2;
    exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME2;
    exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = TMP_PROCESS_RUNTIME_VERSION2;
    exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = TMP_PROCESS_RUNTIME_DESCRIPTION2;
    exports.SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME2;
    exports.SEMRESATTRS_SERVICE_NAMESPACE = TMP_SERVICE_NAMESPACE2;
    exports.SEMRESATTRS_SERVICE_INSTANCE_ID = TMP_SERVICE_INSTANCE_ID2;
    exports.SEMRESATTRS_SERVICE_VERSION = TMP_SERVICE_VERSION2;
    exports.SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME2;
    exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE2;
    exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION2;
    exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = TMP_TELEMETRY_AUTO_VERSION2;
    exports.SEMRESATTRS_WEBENGINE_NAME = TMP_WEBENGINE_NAME2;
    exports.SEMRESATTRS_WEBENGINE_VERSION = TMP_WEBENGINE_VERSION2;
    exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = TMP_WEBENGINE_DESCRIPTION2;
    exports.SemanticResourceAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_CLOUD_PROVIDER2,
      TMP_CLOUD_ACCOUNT_ID2,
      TMP_CLOUD_REGION2,
      TMP_CLOUD_AVAILABILITY_ZONE2,
      TMP_CLOUD_PLATFORM2,
      TMP_AWS_ECS_CONTAINER_ARN2,
      TMP_AWS_ECS_CLUSTER_ARN2,
      TMP_AWS_ECS_LAUNCHTYPE2,
      TMP_AWS_ECS_TASK_ARN2,
      TMP_AWS_ECS_TASK_FAMILY2,
      TMP_AWS_ECS_TASK_REVISION2,
      TMP_AWS_EKS_CLUSTER_ARN2,
      TMP_AWS_LOG_GROUP_NAMES2,
      TMP_AWS_LOG_GROUP_ARNS2,
      TMP_AWS_LOG_STREAM_NAMES2,
      TMP_AWS_LOG_STREAM_ARNS2,
      TMP_CONTAINER_NAME2,
      TMP_CONTAINER_ID2,
      TMP_CONTAINER_RUNTIME2,
      TMP_CONTAINER_IMAGE_NAME2,
      TMP_CONTAINER_IMAGE_TAG2,
      TMP_DEPLOYMENT_ENVIRONMENT2,
      TMP_DEVICE_ID2,
      TMP_DEVICE_MODEL_IDENTIFIER2,
      TMP_DEVICE_MODEL_NAME2,
      TMP_FAAS_NAME2,
      TMP_FAAS_ID2,
      TMP_FAAS_VERSION2,
      TMP_FAAS_INSTANCE2,
      TMP_FAAS_MAX_MEMORY2,
      TMP_HOST_ID2,
      TMP_HOST_NAME2,
      TMP_HOST_TYPE2,
      TMP_HOST_ARCH2,
      TMP_HOST_IMAGE_NAME2,
      TMP_HOST_IMAGE_ID2,
      TMP_HOST_IMAGE_VERSION2,
      TMP_K8S_CLUSTER_NAME2,
      TMP_K8S_NODE_NAME2,
      TMP_K8S_NODE_UID2,
      TMP_K8S_NAMESPACE_NAME2,
      TMP_K8S_POD_UID2,
      TMP_K8S_POD_NAME2,
      TMP_K8S_CONTAINER_NAME2,
      TMP_K8S_REPLICASET_UID2,
      TMP_K8S_REPLICASET_NAME2,
      TMP_K8S_DEPLOYMENT_UID2,
      TMP_K8S_DEPLOYMENT_NAME2,
      TMP_K8S_STATEFULSET_UID2,
      TMP_K8S_STATEFULSET_NAME2,
      TMP_K8S_DAEMONSET_UID2,
      TMP_K8S_DAEMONSET_NAME2,
      TMP_K8S_JOB_UID2,
      TMP_K8S_JOB_NAME2,
      TMP_K8S_CRONJOB_UID2,
      TMP_K8S_CRONJOB_NAME2,
      TMP_OS_TYPE2,
      TMP_OS_DESCRIPTION2,
      TMP_OS_NAME2,
      TMP_OS_VERSION2,
      TMP_PROCESS_PID2,
      TMP_PROCESS_EXECUTABLE_NAME2,
      TMP_PROCESS_EXECUTABLE_PATH2,
      TMP_PROCESS_COMMAND2,
      TMP_PROCESS_COMMAND_LINE2,
      TMP_PROCESS_COMMAND_ARGS2,
      TMP_PROCESS_OWNER2,
      TMP_PROCESS_RUNTIME_NAME2,
      TMP_PROCESS_RUNTIME_VERSION2,
      TMP_PROCESS_RUNTIME_DESCRIPTION2,
      TMP_SERVICE_NAME2,
      TMP_SERVICE_NAMESPACE2,
      TMP_SERVICE_INSTANCE_ID2,
      TMP_SERVICE_VERSION2,
      TMP_TELEMETRY_SDK_NAME2,
      TMP_TELEMETRY_SDK_LANGUAGE2,
      TMP_TELEMETRY_SDK_VERSION2,
      TMP_TELEMETRY_AUTO_VERSION2,
      TMP_WEBENGINE_NAME2,
      TMP_WEBENGINE_VERSION2,
      TMP_WEBENGINE_DESCRIPTION2
    ]);
    var TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD2 = "alibaba_cloud";
    var TMP_CLOUDPROVIDERVALUES_AWS2 = "aws";
    var TMP_CLOUDPROVIDERVALUES_AZURE2 = "azure";
    var TMP_CLOUDPROVIDERVALUES_GCP2 = "gcp";
    exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD2;
    exports.CLOUDPROVIDERVALUES_AWS = TMP_CLOUDPROVIDERVALUES_AWS2;
    exports.CLOUDPROVIDERVALUES_AZURE = TMP_CLOUDPROVIDERVALUES_AZURE2;
    exports.CLOUDPROVIDERVALUES_GCP = TMP_CLOUDPROVIDERVALUES_GCP2;
    exports.CloudProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD2,
      TMP_CLOUDPROVIDERVALUES_AWS2,
      TMP_CLOUDPROVIDERVALUES_AZURE2,
      TMP_CLOUDPROVIDERVALUES_GCP2
    ]);
    var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS2 = "alibaba_cloud_ecs";
    var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC2 = "alibaba_cloud_fc";
    var TMP_CLOUDPLATFORMVALUES_AWS_EC22 = "aws_ec2";
    var TMP_CLOUDPLATFORMVALUES_AWS_ECS2 = "aws_ecs";
    var TMP_CLOUDPLATFORMVALUES_AWS_EKS2 = "aws_eks";
    var TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA2 = "aws_lambda";
    var TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK2 = "aws_elastic_beanstalk";
    var TMP_CLOUDPLATFORMVALUES_AZURE_VM2 = "azure_vm";
    var TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES2 = "azure_container_instances";
    var TMP_CLOUDPLATFORMVALUES_AZURE_AKS2 = "azure_aks";
    var TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS2 = "azure_functions";
    var TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE2 = "azure_app_service";
    var TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE2 = "gcp_compute_engine";
    var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN2 = "gcp_cloud_run";
    var TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE2 = "gcp_kubernetes_engine";
    var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS2 = "gcp_cloud_functions";
    var TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE2 = "gcp_app_engine";
    exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS2;
    exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC2;
    exports.CLOUDPLATFORMVALUES_AWS_EC2 = TMP_CLOUDPLATFORMVALUES_AWS_EC22;
    exports.CLOUDPLATFORMVALUES_AWS_ECS = TMP_CLOUDPLATFORMVALUES_AWS_ECS2;
    exports.CLOUDPLATFORMVALUES_AWS_EKS = TMP_CLOUDPLATFORMVALUES_AWS_EKS2;
    exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA2;
    exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK2;
    exports.CLOUDPLATFORMVALUES_AZURE_VM = TMP_CLOUDPLATFORMVALUES_AZURE_VM2;
    exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES2;
    exports.CLOUDPLATFORMVALUES_AZURE_AKS = TMP_CLOUDPLATFORMVALUES_AZURE_AKS2;
    exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS2;
    exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE2;
    exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE2;
    exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN2;
    exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE2;
    exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS2;
    exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE2;
    exports.CloudPlatformValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS2,
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC2,
      TMP_CLOUDPLATFORMVALUES_AWS_EC22,
      TMP_CLOUDPLATFORMVALUES_AWS_ECS2,
      TMP_CLOUDPLATFORMVALUES_AWS_EKS2,
      TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA2,
      TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK2,
      TMP_CLOUDPLATFORMVALUES_AZURE_VM2,
      TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES2,
      TMP_CLOUDPLATFORMVALUES_AZURE_AKS2,
      TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS2,
      TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE2,
      TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE2,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN2,
      TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE2,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS2,
      TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE2
    ]);
    var TMP_AWSECSLAUNCHTYPEVALUES_EC22 = "ec2";
    var TMP_AWSECSLAUNCHTYPEVALUES_FARGATE2 = "fargate";
    exports.AWSECSLAUNCHTYPEVALUES_EC2 = TMP_AWSECSLAUNCHTYPEVALUES_EC22;
    exports.AWSECSLAUNCHTYPEVALUES_FARGATE = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE2;
    exports.AwsEcsLaunchtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_AWSECSLAUNCHTYPEVALUES_EC22,
      TMP_AWSECSLAUNCHTYPEVALUES_FARGATE2
    ]);
    var TMP_HOSTARCHVALUES_AMD642 = "amd64";
    var TMP_HOSTARCHVALUES_ARM322 = "arm32";
    var TMP_HOSTARCHVALUES_ARM642 = "arm64";
    var TMP_HOSTARCHVALUES_IA642 = "ia64";
    var TMP_HOSTARCHVALUES_PPC322 = "ppc32";
    var TMP_HOSTARCHVALUES_PPC642 = "ppc64";
    var TMP_HOSTARCHVALUES_X862 = "x86";
    exports.HOSTARCHVALUES_AMD64 = TMP_HOSTARCHVALUES_AMD642;
    exports.HOSTARCHVALUES_ARM32 = TMP_HOSTARCHVALUES_ARM322;
    exports.HOSTARCHVALUES_ARM64 = TMP_HOSTARCHVALUES_ARM642;
    exports.HOSTARCHVALUES_IA64 = TMP_HOSTARCHVALUES_IA642;
    exports.HOSTARCHVALUES_PPC32 = TMP_HOSTARCHVALUES_PPC322;
    exports.HOSTARCHVALUES_PPC64 = TMP_HOSTARCHVALUES_PPC642;
    exports.HOSTARCHVALUES_X86 = TMP_HOSTARCHVALUES_X862;
    exports.HostArchValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_HOSTARCHVALUES_AMD642,
      TMP_HOSTARCHVALUES_ARM322,
      TMP_HOSTARCHVALUES_ARM642,
      TMP_HOSTARCHVALUES_IA642,
      TMP_HOSTARCHVALUES_PPC322,
      TMP_HOSTARCHVALUES_PPC642,
      TMP_HOSTARCHVALUES_X862
    ]);
    var TMP_OSTYPEVALUES_WINDOWS2 = "windows";
    var TMP_OSTYPEVALUES_LINUX2 = "linux";
    var TMP_OSTYPEVALUES_DARWIN2 = "darwin";
    var TMP_OSTYPEVALUES_FREEBSD2 = "freebsd";
    var TMP_OSTYPEVALUES_NETBSD2 = "netbsd";
    var TMP_OSTYPEVALUES_OPENBSD2 = "openbsd";
    var TMP_OSTYPEVALUES_DRAGONFLYBSD2 = "dragonflybsd";
    var TMP_OSTYPEVALUES_HPUX2 = "hpux";
    var TMP_OSTYPEVALUES_AIX2 = "aix";
    var TMP_OSTYPEVALUES_SOLARIS2 = "solaris";
    var TMP_OSTYPEVALUES_Z_OS2 = "z_os";
    exports.OSTYPEVALUES_WINDOWS = TMP_OSTYPEVALUES_WINDOWS2;
    exports.OSTYPEVALUES_LINUX = TMP_OSTYPEVALUES_LINUX2;
    exports.OSTYPEVALUES_DARWIN = TMP_OSTYPEVALUES_DARWIN2;
    exports.OSTYPEVALUES_FREEBSD = TMP_OSTYPEVALUES_FREEBSD2;
    exports.OSTYPEVALUES_NETBSD = TMP_OSTYPEVALUES_NETBSD2;
    exports.OSTYPEVALUES_OPENBSD = TMP_OSTYPEVALUES_OPENBSD2;
    exports.OSTYPEVALUES_DRAGONFLYBSD = TMP_OSTYPEVALUES_DRAGONFLYBSD2;
    exports.OSTYPEVALUES_HPUX = TMP_OSTYPEVALUES_HPUX2;
    exports.OSTYPEVALUES_AIX = TMP_OSTYPEVALUES_AIX2;
    exports.OSTYPEVALUES_SOLARIS = TMP_OSTYPEVALUES_SOLARIS2;
    exports.OSTYPEVALUES_Z_OS = TMP_OSTYPEVALUES_Z_OS2;
    exports.OsTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_OSTYPEVALUES_WINDOWS2,
      TMP_OSTYPEVALUES_LINUX2,
      TMP_OSTYPEVALUES_DARWIN2,
      TMP_OSTYPEVALUES_FREEBSD2,
      TMP_OSTYPEVALUES_NETBSD2,
      TMP_OSTYPEVALUES_OPENBSD2,
      TMP_OSTYPEVALUES_DRAGONFLYBSD2,
      TMP_OSTYPEVALUES_HPUX2,
      TMP_OSTYPEVALUES_AIX2,
      TMP_OSTYPEVALUES_SOLARIS2,
      TMP_OSTYPEVALUES_Z_OS2
    ]);
    var TMP_TELEMETRYSDKLANGUAGEVALUES_CPP2 = "cpp";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET2 = "dotnet";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG2 = "erlang";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_GO2 = "go";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA2 = "java";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS2 = "nodejs";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_PHP2 = "php";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON2 = "python";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY2 = "ruby";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS2 = "webjs";
    exports.TELEMETRYSDKLANGUAGEVALUES_CPP = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP2;
    exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET2;
    exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG2;
    exports.TELEMETRYSDKLANGUAGEVALUES_GO = TMP_TELEMETRYSDKLANGUAGEVALUES_GO2;
    exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA2;
    exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS2;
    exports.TELEMETRYSDKLANGUAGEVALUES_PHP = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP2;
    exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON2;
    exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY2;
    exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS2;
    exports.TelemetrySdkLanguageValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_TELEMETRYSDKLANGUAGEVALUES_CPP2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_GO2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PHP2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY2,
      TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS2
    ]);
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js
var require_resource5 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_SemanticResourceAttributes5(), exports);
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/semantic-conventions/build/src/index.js
var require_src16 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/semantic-conventions/build/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_trace6(), exports);
    __exportStar(require_resource5(), exports);
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js
var require_sdk_info6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDK_INFO = void 0;
    var version_1 = require_version6();
    var semantic_conventions_1 = require_src16();
    exports.SDK_INFO = {
      [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_NAME]: "opentelemetry",
      [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_NAME]: "node",
      [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE]: semantic_conventions_1.TelemetrySdkLanguageValues.NODEJS,
      [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_VERSION]: version_1.VERSION
    };
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js
var require_timer_util6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unrefTimer = void 0;
    function unrefTimer(timer) {
      timer.unref();
    }
    exports.unrefTimer = unrefTimer;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/platform/node/index.js
var require_node10 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/platform/node/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnv = exports.getEnvWithoutDefaults = void 0;
    var environment_1 = require_environment13();
    Object.defineProperty(exports, "getEnvWithoutDefaults", { enumerable: true, get: function() {
      return environment_1.getEnvWithoutDefaults;
    } });
    Object.defineProperty(exports, "getEnv", { enumerable: true, get: function() {
      return environment_1.getEnv;
    } });
    __exportStar(require_globalThis6(), exports);
    __exportStar(require_hex_to_base646(), exports);
    __exportStar(require_RandomIdGenerator7(), exports);
    __exportStar(require_performance6(), exports);
    __exportStar(require_sdk_info6(), exports);
    __exportStar(require_timer_util6(), exports);
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/platform/index.js
var require_platform10 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/platform/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_node10(), exports);
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/common/time.js
var require_time6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/common/time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addHrTimes = exports.isTimeInput = exports.isTimeInputHrTime = exports.hrTimeToMicroseconds = exports.hrTimeToMilliseconds = exports.hrTimeToNanoseconds = exports.hrTimeToTimeStamp = exports.hrTimeDuration = exports.timeInputToHrTime = exports.hrTime = exports.getTimeOrigin = exports.millisToHrTime = void 0;
    var platform_1 = require_platform10();
    var NANOSECOND_DIGITS = 9;
    var NANOSECOND_DIGITS_IN_MILLIS = 6;
    var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
    var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
    function millisToHrTime(epochMillis) {
      const epochSeconds = epochMillis / 1e3;
      const seconds = Math.trunc(epochSeconds);
      const nanos = Math.round(epochMillis % 1e3 * MILLISECONDS_TO_NANOSECONDS);
      return [seconds, nanos];
    }
    exports.millisToHrTime = millisToHrTime;
    function getTimeOrigin() {
      let timeOrigin = platform_1.otperformance.timeOrigin;
      if (typeof timeOrigin !== "number") {
        const perf = platform_1.otperformance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
      }
      return timeOrigin;
    }
    exports.getTimeOrigin = getTimeOrigin;
    function hrTime(performanceNow) {
      const timeOrigin = millisToHrTime(getTimeOrigin());
      const now = millisToHrTime(typeof performanceNow === "number" ? performanceNow : platform_1.otperformance.now());
      return addHrTimes(timeOrigin, now);
    }
    exports.hrTime = hrTime;
    function timeInputToHrTime(time) {
      if (isTimeInputHrTime(time)) {
        return time;
      } else if (typeof time === "number") {
        if (time < getTimeOrigin()) {
          return hrTime(time);
        } else {
          return millisToHrTime(time);
        }
      } else if (time instanceof Date) {
        return millisToHrTime(time.getTime());
      } else {
        throw TypeError("Invalid input type");
      }
    }
    exports.timeInputToHrTime = timeInputToHrTime;
    function hrTimeDuration(startTime, endTime) {
      let seconds = endTime[0] - startTime[0];
      let nanos = endTime[1] - startTime[1];
      if (nanos < 0) {
        seconds -= 1;
        nanos += SECOND_TO_NANOSECONDS;
      }
      return [seconds, nanos];
    }
    exports.hrTimeDuration = hrTimeDuration;
    function hrTimeToTimeStamp(time) {
      const precision = NANOSECOND_DIGITS;
      const tmp = `${"0".repeat(precision)}${time[1]}Z`;
      const nanoString = tmp.substr(tmp.length - precision - 1);
      const date = new Date(time[0] * 1e3).toISOString();
      return date.replace("000Z", nanoString);
    }
    exports.hrTimeToTimeStamp = hrTimeToTimeStamp;
    function hrTimeToNanoseconds(time) {
      return time[0] * SECOND_TO_NANOSECONDS + time[1];
    }
    exports.hrTimeToNanoseconds = hrTimeToNanoseconds;
    function hrTimeToMilliseconds(time) {
      return time[0] * 1e3 + time[1] / 1e6;
    }
    exports.hrTimeToMilliseconds = hrTimeToMilliseconds;
    function hrTimeToMicroseconds(time) {
      return time[0] * 1e6 + time[1] / 1e3;
    }
    exports.hrTimeToMicroseconds = hrTimeToMicroseconds;
    function isTimeInputHrTime(value) {
      return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
    }
    exports.isTimeInputHrTime = isTimeInputHrTime;
    function isTimeInput(value) {
      return isTimeInputHrTime(value) || typeof value === "number" || value instanceof Date;
    }
    exports.isTimeInput = isTimeInput;
    function addHrTimes(time1, time2) {
      const out = [time1[0] + time2[0], time1[1] + time2[1]];
      if (out[1] >= SECOND_TO_NANOSECONDS) {
        out[1] -= SECOND_TO_NANOSECONDS;
        out[0] += 1;
      }
      return out;
    }
    exports.addHrTimes = addHrTimes;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/common/types.js
var require_types14 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/common/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/ExportResult.js
var require_ExportResult6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/ExportResult.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExportResultCode = void 0;
    var ExportResultCode;
    (function(ExportResultCode2) {
      ExportResultCode2[ExportResultCode2["SUCCESS"] = 0] = "SUCCESS";
      ExportResultCode2[ExportResultCode2["FAILED"] = 1] = "FAILED";
    })(ExportResultCode = exports.ExportResultCode || (exports.ExportResultCode = {}));
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/propagation/composite.js
var require_composite6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/propagation/composite.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompositePropagator = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var CompositePropagator = class {
      /**
       * Construct a composite propagator from a list of propagators.
       *
       * @param [config] Configuration object for composite propagator
       */
      constructor(config = {}) {
        var _a12;
        this._propagators = (_a12 = config.propagators) !== null && _a12 !== void 0 ? _a12 : [];
        this._fields = Array.from(new Set(this._propagators.map((p2) => typeof p2.fields === "function" ? p2.fields() : []).reduce((x2, y2) => x2.concat(y2), [])));
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same carrier key, the propagator later in the list
       * will "win".
       *
       * @param context Context to inject
       * @param carrier Carrier into which context will be injected
       */
      inject(context3, carrier, setter) {
        for (const propagator of this._propagators) {
          try {
            propagator.inject(context3, carrier, setter);
          } catch (err) {
            api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
          }
        }
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same context key, the propagator later in the list
       * will "win".
       *
       * @param context Context to add values to
       * @param carrier Carrier from which to extract context
       */
      extract(context3, carrier, getter) {
        return this._propagators.reduce((ctx, propagator) => {
          try {
            return propagator.extract(ctx, carrier, getter);
          } catch (err) {
            api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
          }
          return ctx;
        }, context3);
      }
      fields() {
        return this._fields.slice();
      }
    };
    exports.CompositePropagator = CompositePropagator;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/internal/validators.js
var require_validators6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/internal/validators.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateValue = exports.validateKey = void 0;
    var VALID_KEY_CHAR_RANGE2 = "[_0-9a-z-*/]";
    var VALID_KEY2 = `[a-z]${VALID_KEY_CHAR_RANGE2}{0,255}`;
    var VALID_VENDOR_KEY2 = `[a-z0-9]${VALID_KEY_CHAR_RANGE2}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE2}{0,13}`;
    var VALID_KEY_REGEX2 = new RegExp(`^(?:${VALID_KEY2}|${VALID_VENDOR_KEY2})$`);
    var VALID_VALUE_BASE_REGEX2 = /^[ -~]{0,255}[!-~]$/;
    var INVALID_VALUE_COMMA_EQUAL_REGEX2 = /,|=/;
    function validateKey2(key) {
      return VALID_KEY_REGEX2.test(key);
    }
    exports.validateKey = validateKey2;
    function validateValue2(value) {
      return VALID_VALUE_BASE_REGEX2.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX2.test(value);
    }
    exports.validateValue = validateValue2;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/trace/TraceState.js
var require_TraceState6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/trace/TraceState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TraceState = void 0;
    var validators_1 = require_validators6();
    var MAX_TRACE_STATE_ITEMS2 = 32;
    var MAX_TRACE_STATE_LEN2 = 512;
    var LIST_MEMBERS_SEPARATOR2 = ",";
    var LIST_MEMBER_KEY_VALUE_SPLITTER2 = "=";
    var TraceState = class _TraceState {
      constructor(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      set(key, value) {
        const traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      }
      unset(key) {
        const traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      }
      get(key) {
        return this._internalState.get(key);
      }
      serialize() {
        return this._keys().reduce((agg, key) => {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER2 + this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR2);
      }
      _parse(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN2)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR2).reverse().reduce((agg, part) => {
          const listMember = part.trim();
          const i2 = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER2);
          if (i2 !== -1) {
            const key = listMember.slice(0, i2);
            const value = listMember.slice(i2 + 1, part.length);
            if ((0, validators_1.validateKey)(key) && (0, validators_1.validateValue)(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS2) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS2));
        }
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        const traceState = new _TraceState();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      }
    };
    exports.TraceState = TraceState;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js
var require_W3CTraceContextPropagator6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.W3CTraceContextPropagator = exports.parseTraceParent = exports.TRACE_STATE_HEADER = exports.TRACE_PARENT_HEADER = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing6();
    var TraceState_1 = require_TraceState6();
    exports.TRACE_PARENT_HEADER = "traceparent";
    exports.TRACE_STATE_HEADER = "tracestate";
    var VERSION2 = "00";
    var VERSION_PART = "(?!ff)[\\da-f]{2}";
    var TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}";
    var PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}";
    var FLAGS_PART = "[\\da-f]{2}";
    var TRACE_PARENT_REGEX = new RegExp(`^\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\s?$`);
    function parseTraceParent(traceParent) {
      const match4 = TRACE_PARENT_REGEX.exec(traceParent);
      if (!match4)
        return null;
      if (match4[1] === "00" && match4[5])
        return null;
      return {
        traceId: match4[2],
        spanId: match4[3],
        traceFlags: parseInt(match4[4], 16)
      };
    }
    exports.parseTraceParent = parseTraceParent;
    var W3CTraceContextPropagator = class {
      inject(context3, carrier, setter) {
        const spanContext = api_1.trace.getSpanContext(context3);
        if (!spanContext || (0, suppress_tracing_1.isTracingSuppressed)(context3) || !(0, api_1.isSpanContextValid)(spanContext))
          return;
        const traceParent = `${VERSION2}-${spanContext.traceId}-${spanContext.spanId}-0${Number(spanContext.traceFlags || api_1.TraceFlags.NONE).toString(16)}`;
        setter.set(carrier, exports.TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) {
          setter.set(carrier, exports.TRACE_STATE_HEADER, spanContext.traceState.serialize());
        }
      }
      extract(context3, carrier, getter) {
        const traceParentHeader = getter.get(carrier, exports.TRACE_PARENT_HEADER);
        if (!traceParentHeader)
          return context3;
        const traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
        if (typeof traceParent !== "string")
          return context3;
        const spanContext = parseTraceParent(traceParent);
        if (!spanContext)
          return context3;
        spanContext.isRemote = true;
        const traceStateHeader = getter.get(carrier, exports.TRACE_STATE_HEADER);
        if (traceStateHeader) {
          const state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
          spanContext.traceState = new TraceState_1.TraceState(typeof state === "string" ? state : void 0);
        }
        return api_1.trace.setSpanContext(context3, spanContext);
      }
      fields() {
        return [exports.TRACE_PARENT_HEADER, exports.TRACE_STATE_HEADER];
      }
    };
    exports.W3CTraceContextPropagator = W3CTraceContextPropagator;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/trace/IdGenerator.js
var require_IdGenerator5 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/trace/IdGenerator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js
var require_rpc_metadata6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRPCMetadata = exports.deleteRPCMetadata = exports.setRPCMetadata = exports.RPCType = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var RPC_METADATA_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key RPC_METADATA");
    var RPCType;
    (function(RPCType2) {
      RPCType2["HTTP"] = "http";
    })(RPCType = exports.RPCType || (exports.RPCType = {}));
    function setRPCMetadata(context3, meta) {
      return context3.setValue(RPC_METADATA_KEY, meta);
    }
    exports.setRPCMetadata = setRPCMetadata;
    function deleteRPCMetadata(context3) {
      return context3.deleteValue(RPC_METADATA_KEY);
    }
    exports.deleteRPCMetadata = deleteRPCMetadata;
    function getRPCMetadata(context3) {
      return context3.getValue(RPC_METADATA_KEY);
    }
    exports.getRPCMetadata = getRPCMetadata;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js
var require_AlwaysOffSampler7 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AlwaysOffSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var AlwaysOffSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return "AlwaysOffSampler";
      }
    };
    exports.AlwaysOffSampler = AlwaysOffSampler;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js
var require_AlwaysOnSampler7 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AlwaysOnSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var AlwaysOnSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.RECORD_AND_SAMPLED
        };
      }
      toString() {
        return "AlwaysOnSampler";
      }
    };
    exports.AlwaysOnSampler = AlwaysOnSampler;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js
var require_ParentBasedSampler7 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParentBasedSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var global_error_handler_1 = require_global_error_handler6();
    var AlwaysOffSampler_1 = require_AlwaysOffSampler7();
    var AlwaysOnSampler_1 = require_AlwaysOnSampler7();
    var ParentBasedSampler = class {
      constructor(config) {
        var _a12, _b5, _c4, _d4;
        this._root = config.root;
        if (!this._root) {
          (0, global_error_handler_1.globalErrorHandler)(new Error("ParentBasedSampler must have a root sampler configured"));
          this._root = new AlwaysOnSampler_1.AlwaysOnSampler();
        }
        this._remoteParentSampled = (_a12 = config.remoteParentSampled) !== null && _a12 !== void 0 ? _a12 : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._remoteParentNotSampled = (_b5 = config.remoteParentNotSampled) !== null && _b5 !== void 0 ? _b5 : new AlwaysOffSampler_1.AlwaysOffSampler();
        this._localParentSampled = (_c4 = config.localParentSampled) !== null && _c4 !== void 0 ? _c4 : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._localParentNotSampled = (_d4 = config.localParentNotSampled) !== null && _d4 !== void 0 ? _d4 : new AlwaysOffSampler_1.AlwaysOffSampler();
      }
      shouldSample(context3, traceId, spanName, spanKind, attributes, links) {
        const parentContext = api_1.trace.getSpanContext(context3);
        if (!parentContext || !(0, api_1.isSpanContextValid)(parentContext)) {
          return this._root.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
          if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
            return this._remoteParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
          }
          return this._remoteParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
          return this._localParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
      }
      toString() {
        return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
      }
    };
    exports.ParentBasedSampler = ParentBasedSampler;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js
var require_TraceIdRatioBasedSampler7 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TraceIdRatioBasedSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var TraceIdRatioBasedSampler = class {
      constructor(_ratio = 0) {
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 4294967295);
      }
      shouldSample(context3, traceId) {
        return {
          decision: (0, api_1.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? api_1.SamplingDecision.RECORD_AND_SAMPLED : api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return `TraceIdRatioBased{${this._ratio}}`;
      }
      _normalize(ratio) {
        if (typeof ratio !== "number" || isNaN(ratio))
          return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
      }
      _accumulate(traceId) {
        let accumulation = 0;
        for (let i2 = 0; i2 < traceId.length / 8; i2++) {
          const pos = i2 * 8;
          const part = parseInt(traceId.slice(pos, pos + 8), 16);
          accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
      }
    };
    exports.TraceIdRatioBasedSampler = TraceIdRatioBasedSampler;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js
var require_lodash_merge6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isPlainObject = void 0;
    var objectTag = "[object Object]";
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    var objectCtorString = funcToString.call(Object);
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    var nativeObjectToString = objectProto.toString;
    function overArg(func2, transform) {
      return function(arg) {
        return func2(transform(arg));
      };
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
        return false;
      }
      const proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      const Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
    }
    exports.isPlainObject = isPlainObject;
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function getRawTag(value) {
      const isOwn = hasOwnProperty2.call(value, symToStringTag), tag2 = value[symToStringTag];
      let unmasked = false;
      try {
        value[symToStringTag] = void 0;
        unmasked = true;
      } catch (e2) {
      }
      const result4 = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag2;
        } else {
          delete value[symToStringTag];
        }
      }
      return result4;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/utils/merge.js
var require_merge6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/utils/merge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = void 0;
    var lodash_merge_1 = require_lodash_merge6();
    var MAX_LEVEL = 20;
    function merge5(...args) {
      let result4 = args.shift();
      const objects = /* @__PURE__ */ new WeakMap();
      while (args.length > 0) {
        result4 = mergeTwoObjects(result4, args.shift(), 0, objects);
      }
      return result4;
    }
    exports.merge = merge5;
    function takeValue(value) {
      if (isArray(value)) {
        return value.slice();
      }
      return value;
    }
    function mergeTwoObjects(one, two, level = 0, objects) {
      let result4;
      if (level > MAX_LEVEL) {
        return void 0;
      }
      level++;
      if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {
        result4 = takeValue(two);
      } else if (isArray(one)) {
        result4 = one.slice();
        if (isArray(two)) {
          for (let i2 = 0, j2 = two.length; i2 < j2; i2++) {
            result4.push(takeValue(two[i2]));
          }
        } else if (isObject(two)) {
          const keys4 = Object.keys(two);
          for (let i2 = 0, j2 = keys4.length; i2 < j2; i2++) {
            const key = keys4[i2];
            result4[key] = takeValue(two[key]);
          }
        }
      } else if (isObject(one)) {
        if (isObject(two)) {
          if (!shouldMerge(one, two)) {
            return two;
          }
          result4 = Object.assign({}, one);
          const keys4 = Object.keys(two);
          for (let i2 = 0, j2 = keys4.length; i2 < j2; i2++) {
            const key = keys4[i2];
            const twoValue = two[key];
            if (isPrimitive(twoValue)) {
              if (typeof twoValue === "undefined") {
                delete result4[key];
              } else {
                result4[key] = twoValue;
              }
            } else {
              const obj1 = result4[key];
              const obj2 = twoValue;
              if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {
                delete result4[key];
              } else {
                if (isObject(obj1) && isObject(obj2)) {
                  const arr1 = objects.get(obj1) || [];
                  const arr2 = objects.get(obj2) || [];
                  arr1.push({ obj: one, key });
                  arr2.push({ obj: two, key });
                  objects.set(obj1, arr1);
                  objects.set(obj2, arr2);
                }
                result4[key] = mergeTwoObjects(result4[key], twoValue, level, objects);
              }
            }
          }
        } else {
          result4 = two;
        }
      }
      return result4;
    }
    function wasObjectReferenced(obj, key, objects) {
      const arr = objects.get(obj[key]) || [];
      for (let i2 = 0, j2 = arr.length; i2 < j2; i2++) {
        const info = arr[i2];
        if (info.key === key && info.obj === obj) {
          return true;
        }
      }
      return false;
    }
    function isArray(value) {
      return Array.isArray(value);
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isObject(value) {
      return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === "object";
    }
    function isPrimitive(value) {
      return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "undefined" || value instanceof Date || value instanceof RegExp || value === null;
    }
    function shouldMerge(one, two) {
      if (!(0, lodash_merge_1.isPlainObject)(one) || !(0, lodash_merge_1.isPlainObject)(two)) {
        return false;
      }
      return true;
    }
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/utils/timeout.js
var require_timeout6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/utils/timeout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callWithTimeout = exports.TimeoutError = void 0;
    var TimeoutError = class _TimeoutError extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, _TimeoutError.prototype);
      }
    };
    exports.TimeoutError = TimeoutError;
    function callWithTimeout(promise2, timeout4) {
      let timeoutHandle;
      const timeoutPromise = new Promise(function timeoutFunction(_resolve, reject3) {
        timeoutHandle = setTimeout(function timeoutHandler() {
          reject3(new TimeoutError("Operation timed out."));
        }, timeout4);
      });
      return Promise.race([promise2, timeoutPromise]).then((result4) => {
        clearTimeout(timeoutHandle);
        return result4;
      }, (reason) => {
        clearTimeout(timeoutHandle);
        throw reason;
      });
    }
    exports.callWithTimeout = callWithTimeout;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/utils/url.js
var require_url6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/utils/url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isUrlIgnored = exports.urlMatches = void 0;
    function urlMatches(url, urlToMatch) {
      if (typeof urlToMatch === "string") {
        return url === urlToMatch;
      } else {
        return !!url.match(urlToMatch);
      }
    }
    exports.urlMatches = urlMatches;
    function isUrlIgnored(url, ignoredUrls) {
      if (!ignoredUrls) {
        return false;
      }
      for (const ignoreUrl of ignoredUrls) {
        if (urlMatches(url, ignoreUrl)) {
          return true;
        }
      }
      return false;
    }
    exports.isUrlIgnored = isUrlIgnored;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/utils/wrap.js
var require_wrap6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/utils/wrap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isWrapped = void 0;
    function isWrapped(func2) {
      return typeof func2 === "function" && typeof func2.__original === "function" && typeof func2.__unwrap === "function" && func2.__wrapped === true;
    }
    exports.isWrapped = isWrapped;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/utils/promise.js
var require_promise6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/utils/promise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Deferred = void 0;
    var Deferred = class {
      constructor() {
        this._promise = new Promise((resolve, reject3) => {
          this._resolve = resolve;
          this._reject = reject3;
        });
      }
      get promise() {
        return this._promise;
      }
      resolve(val) {
        this._resolve(val);
      }
      reject(err) {
        this._reject(err);
      }
    };
    exports.Deferred = Deferred;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/utils/callback.js
var require_callback6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/utils/callback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BindOnceFuture = void 0;
    var promise_1 = require_promise6();
    var BindOnceFuture = class {
      constructor(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new promise_1.Deferred();
      }
      get isCalled() {
        return this._isCalled;
      }
      get promise() {
        return this._deferred.promise;
      }
      call(...args) {
        if (!this._isCalled) {
          this._isCalled = true;
          try {
            Promise.resolve(this._callback.call(this._that, ...args)).then((val) => this._deferred.resolve(val), (err) => this._deferred.reject(err));
          } catch (err) {
            this._deferred.reject(err);
          }
        }
        return this._deferred.promise;
      }
    };
    exports.BindOnceFuture = BindOnceFuture;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/internal/exporter.js
var require_exporter6 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/internal/exporter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._export = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing6();
    function _export(exporter, arg) {
      return new Promise((resolve) => {
        api_1.context.with((0, suppress_tracing_1.suppressTracing)(api_1.context.active()), () => {
          exporter.export(arg, (result4) => {
            resolve(result4);
          });
        });
      });
    }
    exports._export = _export;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/index.js
var require_src17 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/core/build/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.internal = exports.baggageUtils = void 0;
    __exportStar(require_W3CBaggagePropagator6(), exports);
    __exportStar(require_anchored_clock6(), exports);
    __exportStar(require_attributes6(), exports);
    __exportStar(require_global_error_handler6(), exports);
    __exportStar(require_logging_error_handler6(), exports);
    __exportStar(require_time6(), exports);
    __exportStar(require_types14(), exports);
    __exportStar(require_hex_to_binary6(), exports);
    __exportStar(require_ExportResult6(), exports);
    exports.baggageUtils = require_utils13();
    __exportStar(require_platform10(), exports);
    __exportStar(require_composite6(), exports);
    __exportStar(require_W3CTraceContextPropagator6(), exports);
    __exportStar(require_IdGenerator5(), exports);
    __exportStar(require_rpc_metadata6(), exports);
    __exportStar(require_AlwaysOffSampler7(), exports);
    __exportStar(require_AlwaysOnSampler7(), exports);
    __exportStar(require_ParentBasedSampler7(), exports);
    __exportStar(require_TraceIdRatioBasedSampler7(), exports);
    __exportStar(require_suppress_tracing6(), exports);
    __exportStar(require_TraceState6(), exports);
    __exportStar(require_environment12(), exports);
    __exportStar(require_merge6(), exports);
    __exportStar(require_sampling6(), exports);
    __exportStar(require_timeout6(), exports);
    __exportStar(require_url6(), exports);
    __exportStar(require_wrap6(), exports);
    __exportStar(require_callback6(), exports);
    __exportStar(require_version6(), exports);
    var exporter_1 = require_exporter6();
    exports.internal = {
      _export: exporter_1._export
    };
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/LastValue.js
var require_LastValue = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/LastValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LastValueAggregator = exports.LastValueAccumulation = void 0;
    var types_1 = require_types12();
    var core_1 = require_src17();
    var MetricData_1 = require_MetricData();
    var LastValueAccumulation = class {
      constructor(startTime, _current2 = 0, sampleTime = [0, 0]) {
        this.startTime = startTime;
        this._current = _current2;
        this.sampleTime = sampleTime;
      }
      record(value) {
        this._current = value;
        this.sampleTime = (0, core_1.millisToHrTime)(Date.now());
      }
      setStartTime(startTime) {
        this.startTime = startTime;
      }
      toPointValue() {
        return this._current;
      }
    };
    exports.LastValueAccumulation = LastValueAccumulation;
    var LastValueAggregator = class {
      constructor() {
        this.kind = types_1.AggregatorKind.LAST_VALUE;
      }
      createAccumulation(startTime) {
        return new LastValueAccumulation(startTime);
      }
      /**
       * Returns the result of the merge of the given accumulations.
       *
       * Return the newly captured (delta) accumulation for LastValueAggregator.
       */
      merge(previous, delta) {
        const latestAccumulation = (0, core_1.hrTimeToMicroseconds)(delta.sampleTime) >= (0, core_1.hrTimeToMicroseconds)(previous.sampleTime) ? delta : previous;
        return new LastValueAccumulation(previous.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);
      }
      /**
       * Returns a new DELTA aggregation by comparing two cumulative measurements.
       *
       * A delta aggregation is not meaningful to LastValueAggregator, just return
       * the newly captured (delta) accumulation for LastValueAggregator.
       */
      diff(previous, current) {
        const latestAccumulation = (0, core_1.hrTimeToMicroseconds)(current.sampleTime) >= (0, core_1.hrTimeToMicroseconds)(previous.sampleTime) ? current : previous;
        return new LastValueAccumulation(current.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);
      }
      toMetricData(descriptor3, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
          descriptor: descriptor3,
          aggregationTemporality,
          dataPointType: MetricData_1.DataPointType.GAUGE,
          dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {
            return {
              attributes,
              startTime: accumulation.startTime,
              endTime,
              value: accumulation.toPointValue()
            };
          })
        };
      }
    };
    exports.LastValueAggregator = LastValueAggregator;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Sum.js
var require_Sum = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Sum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SumAggregator = exports.SumAccumulation = void 0;
    var types_1 = require_types12();
    var MetricData_1 = require_MetricData();
    var SumAccumulation = class {
      constructor(startTime, monotonic, _current2 = 0, reset = false) {
        this.startTime = startTime;
        this.monotonic = monotonic;
        this._current = _current2;
        this.reset = reset;
      }
      record(value) {
        if (this.monotonic && value < 0) {
          return;
        }
        this._current += value;
      }
      setStartTime(startTime) {
        this.startTime = startTime;
      }
      toPointValue() {
        return this._current;
      }
    };
    exports.SumAccumulation = SumAccumulation;
    var SumAggregator = class {
      constructor(monotonic) {
        this.monotonic = monotonic;
        this.kind = types_1.AggregatorKind.SUM;
      }
      createAccumulation(startTime) {
        return new SumAccumulation(startTime, this.monotonic);
      }
      /**
       * Returns the result of the merge of the given accumulations.
       */
      merge(previous, delta) {
        const prevPv = previous.toPointValue();
        const deltaPv = delta.toPointValue();
        if (delta.reset) {
          return new SumAccumulation(delta.startTime, this.monotonic, deltaPv, delta.reset);
        }
        return new SumAccumulation(previous.startTime, this.monotonic, prevPv + deltaPv);
      }
      /**
       * Returns a new DELTA aggregation by comparing two cumulative measurements.
       */
      diff(previous, current) {
        const prevPv = previous.toPointValue();
        const currPv = current.toPointValue();
        if (this.monotonic && prevPv > currPv) {
          return new SumAccumulation(current.startTime, this.monotonic, currPv, true);
        }
        return new SumAccumulation(current.startTime, this.monotonic, currPv - prevPv);
      }
      toMetricData(descriptor3, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
          descriptor: descriptor3,
          aggregationTemporality,
          dataPointType: MetricData_1.DataPointType.SUM,
          dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {
            return {
              attributes,
              startTime: accumulation.startTime,
              endTime,
              value: accumulation.toPointValue()
            };
          }),
          isMonotonic: this.monotonic
        };
      }
    };
    exports.SumAggregator = SumAggregator;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/index.js
var require_aggregator = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_Drop(), exports);
    __exportStar(require_Histogram(), exports);
    __exportStar(require_ExponentialHistogram(), exports);
    __exportStar(require_LastValue(), exports);
    __exportStar(require_Sum(), exports);
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/Aggregation.js
var require_Aggregation = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/view/Aggregation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultAggregation = exports.ExponentialHistogramAggregation = exports.ExplicitBucketHistogramAggregation = exports.HistogramAggregation = exports.LastValueAggregation = exports.SumAggregation = exports.DropAggregation = exports.Aggregation = void 0;
    var api = (init_esm(), __toCommonJS(esm_exports));
    var aggregator_1 = require_aggregator();
    var InstrumentDescriptor_1 = require_InstrumentDescriptor();
    var Aggregation = class {
      static Drop() {
        return DROP_AGGREGATION;
      }
      static Sum() {
        return SUM_AGGREGATION;
      }
      static LastValue() {
        return LAST_VALUE_AGGREGATION;
      }
      static Histogram() {
        return HISTOGRAM_AGGREGATION;
      }
      static ExponentialHistogram() {
        return EXPONENTIAL_HISTOGRAM_AGGREGATION;
      }
      static Default() {
        return DEFAULT_AGGREGATION;
      }
    };
    exports.Aggregation = Aggregation;
    var DropAggregation = class _DropAggregation extends Aggregation {
      createAggregator(_instrument) {
        return _DropAggregation.DEFAULT_INSTANCE;
      }
    };
    exports.DropAggregation = DropAggregation;
    DropAggregation.DEFAULT_INSTANCE = new aggregator_1.DropAggregator();
    var SumAggregation = class _SumAggregation extends Aggregation {
      createAggregator(instrument) {
        switch (instrument.type) {
          case InstrumentDescriptor_1.InstrumentType.COUNTER:
          case InstrumentDescriptor_1.InstrumentType.OBSERVABLE_COUNTER:
          case InstrumentDescriptor_1.InstrumentType.HISTOGRAM: {
            return _SumAggregation.MONOTONIC_INSTANCE;
          }
          default: {
            return _SumAggregation.NON_MONOTONIC_INSTANCE;
          }
        }
      }
    };
    exports.SumAggregation = SumAggregation;
    SumAggregation.MONOTONIC_INSTANCE = new aggregator_1.SumAggregator(true);
    SumAggregation.NON_MONOTONIC_INSTANCE = new aggregator_1.SumAggregator(false);
    var LastValueAggregation = class _LastValueAggregation extends Aggregation {
      createAggregator(_instrument) {
        return _LastValueAggregation.DEFAULT_INSTANCE;
      }
    };
    exports.LastValueAggregation = LastValueAggregation;
    LastValueAggregation.DEFAULT_INSTANCE = new aggregator_1.LastValueAggregator();
    var HistogramAggregation = class _HistogramAggregation extends Aggregation {
      createAggregator(_instrument) {
        return _HistogramAggregation.DEFAULT_INSTANCE;
      }
    };
    exports.HistogramAggregation = HistogramAggregation;
    HistogramAggregation.DEFAULT_INSTANCE = new aggregator_1.HistogramAggregator([0, 5, 10, 25, 50, 75, 100, 250, 500, 750, 1e3, 2500, 5e3, 7500, 1e4], true);
    var ExplicitBucketHistogramAggregation = class extends Aggregation {
      /**
       * @param boundaries the bucket boundaries of the histogram aggregation
       * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.
       */
      constructor(boundaries, _recordMinMax = true) {
        super();
        this._recordMinMax = _recordMinMax;
        if (boundaries == null) {
          throw new Error("ExplicitBucketHistogramAggregation should be created with explicit boundaries, if a single bucket histogram is required, please pass an empty array");
        }
        boundaries = boundaries.concat();
        boundaries = boundaries.sort((a2, b2) => a2 - b2);
        const minusInfinityIndex = boundaries.lastIndexOf(-Infinity);
        let infinityIndex = boundaries.indexOf(Infinity);
        if (infinityIndex === -1) {
          infinityIndex = void 0;
        }
        this._boundaries = boundaries.slice(minusInfinityIndex + 1, infinityIndex);
      }
      createAggregator(_instrument) {
        return new aggregator_1.HistogramAggregator(this._boundaries, this._recordMinMax);
      }
    };
    exports.ExplicitBucketHistogramAggregation = ExplicitBucketHistogramAggregation;
    var ExponentialHistogramAggregation = class extends Aggregation {
      constructor(_maxSize = 160, _recordMinMax = true) {
        super();
        this._maxSize = _maxSize;
        this._recordMinMax = _recordMinMax;
      }
      createAggregator(_instrument) {
        return new aggregator_1.ExponentialHistogramAggregator(this._maxSize, this._recordMinMax);
      }
    };
    exports.ExponentialHistogramAggregation = ExponentialHistogramAggregation;
    var DefaultAggregation = class extends Aggregation {
      _resolve(instrument) {
        switch (instrument.type) {
          case InstrumentDescriptor_1.InstrumentType.COUNTER:
          case InstrumentDescriptor_1.InstrumentType.UP_DOWN_COUNTER:
          case InstrumentDescriptor_1.InstrumentType.OBSERVABLE_COUNTER:
          case InstrumentDescriptor_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER: {
            return SUM_AGGREGATION;
          }
          case InstrumentDescriptor_1.InstrumentType.GAUGE:
          case InstrumentDescriptor_1.InstrumentType.OBSERVABLE_GAUGE: {
            return LAST_VALUE_AGGREGATION;
          }
          case InstrumentDescriptor_1.InstrumentType.HISTOGRAM: {
            if (instrument.advice.explicitBucketBoundaries) {
              return new ExplicitBucketHistogramAggregation(instrument.advice.explicitBucketBoundaries);
            }
            return HISTOGRAM_AGGREGATION;
          }
        }
        api.diag.warn(`Unable to recognize instrument type: ${instrument.type}`);
        return DROP_AGGREGATION;
      }
      createAggregator(instrument) {
        return this._resolve(instrument).createAggregator(instrument);
      }
    };
    exports.DefaultAggregation = DefaultAggregation;
    var DROP_AGGREGATION = new DropAggregation();
    var SUM_AGGREGATION = new SumAggregation();
    var LAST_VALUE_AGGREGATION = new LastValueAggregation();
    var HISTOGRAM_AGGREGATION = new HistogramAggregation();
    var EXPONENTIAL_HISTOGRAM_AGGREGATION = new ExponentialHistogramAggregation();
    var DEFAULT_AGGREGATION = new DefaultAggregation();
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/export/AggregationSelector.js
var require_AggregationSelector = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/export/AggregationSelector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR = exports.DEFAULT_AGGREGATION_SELECTOR = void 0;
    var Aggregation_1 = require_Aggregation();
    var AggregationTemporality_1 = require_AggregationTemporality();
    var DEFAULT_AGGREGATION_SELECTOR = (_instrumentType) => Aggregation_1.Aggregation.Default();
    exports.DEFAULT_AGGREGATION_SELECTOR = DEFAULT_AGGREGATION_SELECTOR;
    var DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR = (_instrumentType) => AggregationTemporality_1.AggregationTemporality.CUMULATIVE;
    exports.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR = DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/export/MetricReader.js
var require_MetricReader = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/export/MetricReader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MetricReader = void 0;
    var api = (init_esm(), __toCommonJS(esm_exports));
    var utils_1 = require_utils12();
    var AggregationSelector_1 = require_AggregationSelector();
    var MetricReader = class {
      constructor(options) {
        var _a12, _b5, _c4;
        this._shutdown = false;
        this._aggregationSelector = (_a12 = options === null || options === void 0 ? void 0 : options.aggregationSelector) !== null && _a12 !== void 0 ? _a12 : AggregationSelector_1.DEFAULT_AGGREGATION_SELECTOR;
        this._aggregationTemporalitySelector = (_b5 = options === null || options === void 0 ? void 0 : options.aggregationTemporalitySelector) !== null && _b5 !== void 0 ? _b5 : AggregationSelector_1.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;
        this._metricProducers = (_c4 = options === null || options === void 0 ? void 0 : options.metricProducers) !== null && _c4 !== void 0 ? _c4 : [];
      }
      /**
       * Set the {@link MetricProducer} used by this instance. **This should only be called by the
       * SDK and should be considered internal.**
       *
       * To add additional {@link MetricProducer}s to a {@link MetricReader}, pass them to the
       * constructor as {@link MetricReaderOptions.metricProducers}.
       *
       * @internal
       * @param metricProducer
       */
      setMetricProducer(metricProducer) {
        if (this._sdkMetricProducer) {
          throw new Error("MetricReader can not be bound to a MeterProvider again.");
        }
        this._sdkMetricProducer = metricProducer;
        this.onInitialized();
      }
      /**
       * Select the {@link Aggregation} for the given {@link InstrumentType} for this
       * reader.
       */
      selectAggregation(instrumentType) {
        return this._aggregationSelector(instrumentType);
      }
      /**
       * Select the {@link AggregationTemporality} for the given
       * {@link InstrumentType} for this reader.
       */
      selectAggregationTemporality(instrumentType) {
        return this._aggregationTemporalitySelector(instrumentType);
      }
      /**
       * Handle once the SDK has initialized this {@link MetricReader}
       * Overriding this method is optional.
       */
      onInitialized() {
      }
      /**
       * Collect all metrics from the associated {@link MetricProducer}
       */
      async collect(options) {
        if (this._sdkMetricProducer === void 0) {
          throw new Error("MetricReader is not bound to a MetricProducer");
        }
        if (this._shutdown) {
          throw new Error("MetricReader is shutdown");
        }
        const [sdkCollectionResults, ...additionalCollectionResults] = await Promise.all([
          this._sdkMetricProducer.collect({
            timeoutMillis: options === null || options === void 0 ? void 0 : options.timeoutMillis
          }),
          ...this._metricProducers.map((producer) => producer.collect({
            timeoutMillis: options === null || options === void 0 ? void 0 : options.timeoutMillis
          }))
        ]);
        const errors = sdkCollectionResults.errors.concat((0, utils_1.FlatMap)(additionalCollectionResults, (result4) => result4.errors));
        const resource = sdkCollectionResults.resourceMetrics.resource;
        const scopeMetrics = sdkCollectionResults.resourceMetrics.scopeMetrics.concat((0, utils_1.FlatMap)(additionalCollectionResults, (result4) => result4.resourceMetrics.scopeMetrics));
        return {
          resourceMetrics: {
            resource,
            scopeMetrics
          },
          errors
        };
      }
      /**
       * Shuts down the metric reader, the promise will reject after the optional timeout or resolve after completion.
       *
       * <p> NOTE: this operation will continue even after the promise rejects due to a timeout.
       * @param options options with timeout.
       */
      async shutdown(options) {
        if (this._shutdown) {
          api.diag.error("Cannot call shutdown twice.");
          return;
        }
        if ((options === null || options === void 0 ? void 0 : options.timeoutMillis) == null) {
          await this.onShutdown();
        } else {
          await (0, utils_1.callWithTimeout)(this.onShutdown(), options.timeoutMillis);
        }
        this._shutdown = true;
      }
      /**
       * Flushes metrics read by this reader, the promise will reject after the optional timeout or resolve after completion.
       *
       * <p> NOTE: this operation will continue even after the promise rejects due to a timeout.
       * @param options options with timeout.
       */
      async forceFlush(options) {
        if (this._shutdown) {
          api.diag.warn("Cannot forceFlush on already shutdown MetricReader.");
          return;
        }
        if ((options === null || options === void 0 ? void 0 : options.timeoutMillis) == null) {
          await this.onForceFlush();
          return;
        }
        await (0, utils_1.callWithTimeout)(this.onForceFlush(), options.timeoutMillis);
      }
    };
    exports.MetricReader = MetricReader;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/export/PeriodicExportingMetricReader.js
var require_PeriodicExportingMetricReader = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/export/PeriodicExportingMetricReader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PeriodicExportingMetricReader = void 0;
    var api = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src17();
    var MetricReader_1 = require_MetricReader();
    var utils_1 = require_utils12();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var PeriodicExportingMetricReader = class extends MetricReader_1.MetricReader {
      constructor(options) {
        var _a12, _b5, _c4, _d4;
        super({
          aggregationSelector: (_a12 = options.exporter.selectAggregation) === null || _a12 === void 0 ? void 0 : _a12.bind(options.exporter),
          aggregationTemporalitySelector: (_b5 = options.exporter.selectAggregationTemporality) === null || _b5 === void 0 ? void 0 : _b5.bind(options.exporter),
          metricProducers: options.metricProducers
        });
        if (options.exportIntervalMillis !== void 0 && options.exportIntervalMillis <= 0) {
          throw Error("exportIntervalMillis must be greater than 0");
        }
        if (options.exportTimeoutMillis !== void 0 && options.exportTimeoutMillis <= 0) {
          throw Error("exportTimeoutMillis must be greater than 0");
        }
        if (options.exportTimeoutMillis !== void 0 && options.exportIntervalMillis !== void 0 && options.exportIntervalMillis < options.exportTimeoutMillis) {
          throw Error("exportIntervalMillis must be greater than or equal to exportTimeoutMillis");
        }
        this._exportInterval = (_c4 = options.exportIntervalMillis) !== null && _c4 !== void 0 ? _c4 : 6e4;
        this._exportTimeout = (_d4 = options.exportTimeoutMillis) !== null && _d4 !== void 0 ? _d4 : 3e4;
        this._exporter = options.exporter;
      }
      async _runOnce() {
        try {
          await (0, utils_1.callWithTimeout)(this._doRun(), this._exportTimeout);
        } catch (err) {
          if (err instanceof utils_1.TimeoutError) {
            api.diag.error("Export took longer than %s milliseconds and timed out.", this._exportTimeout);
            return;
          }
          (0, core_1.globalErrorHandler)(err);
        }
      }
      async _doRun() {
        var _a12, _b5;
        const { resourceMetrics, errors } = await this.collect({
          timeoutMillis: this._exportTimeout
        });
        if (errors.length > 0) {
          api.diag.error("PeriodicExportingMetricReader: metrics collection errors", ...errors);
        }
        const doExport = async () => {
          const result4 = await core_1.internal._export(this._exporter, resourceMetrics);
          if (result4.code !== core_1.ExportResultCode.SUCCESS) {
            throw new Error(`PeriodicExportingMetricReader: metrics export failed (error ${result4.error})`);
          }
        };
        if (resourceMetrics.resource.asyncAttributesPending) {
          (_b5 = (_a12 = resourceMetrics.resource).waitForAsyncAttributes) === null || _b5 === void 0 ? void 0 : _b5.call(_a12).then(doExport, (err) => api_1.diag.debug("Error while resolving async portion of resource: ", err));
        } else {
          await doExport();
        }
      }
      onInitialized() {
        this._interval = setInterval(() => {
          void this._runOnce();
        }, this._exportInterval);
        (0, core_1.unrefTimer)(this._interval);
      }
      async onForceFlush() {
        await this._runOnce();
        await this._exporter.forceFlush();
      }
      async onShutdown() {
        if (this._interval) {
          clearInterval(this._interval);
        }
        await this._exporter.shutdown();
      }
    };
    exports.PeriodicExportingMetricReader = PeriodicExportingMetricReader;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/export/InMemoryMetricExporter.js
var require_InMemoryMetricExporter = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/export/InMemoryMetricExporter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InMemoryMetricExporter = void 0;
    var core_1 = require_src17();
    var InMemoryMetricExporter = class {
      constructor(aggregationTemporality) {
        this._shutdown = false;
        this._metrics = [];
        this._aggregationTemporality = aggregationTemporality;
      }
      /**
       * @inheritedDoc
       */
      export(metrics2, resultCallback) {
        if (this._shutdown) {
          setTimeout(() => resultCallback({ code: core_1.ExportResultCode.FAILED }), 0);
          return;
        }
        this._metrics.push(metrics2);
        setTimeout(() => resultCallback({ code: core_1.ExportResultCode.SUCCESS }), 0);
      }
      /**
       * Returns all the collected resource metrics
       * @returns ResourceMetrics[]
       */
      getMetrics() {
        return this._metrics;
      }
      forceFlush() {
        return Promise.resolve();
      }
      reset() {
        this._metrics = [];
      }
      selectAggregationTemporality(_instrumentType) {
        return this._aggregationTemporality;
      }
      shutdown() {
        this._shutdown = true;
        return Promise.resolve();
      }
    };
    exports.InMemoryMetricExporter = InMemoryMetricExporter;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/export/ConsoleMetricExporter.js
var require_ConsoleMetricExporter = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/export/ConsoleMetricExporter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConsoleMetricExporter = void 0;
    var core_1 = require_src17();
    var AggregationSelector_1 = require_AggregationSelector();
    var ConsoleMetricExporter = class _ConsoleMetricExporter {
      constructor(options) {
        var _a12;
        this._shutdown = false;
        this._temporalitySelector = (_a12 = options === null || options === void 0 ? void 0 : options.temporalitySelector) !== null && _a12 !== void 0 ? _a12 : AggregationSelector_1.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;
      }
      export(metrics2, resultCallback) {
        if (this._shutdown) {
          setImmediate(resultCallback, { code: core_1.ExportResultCode.FAILED });
          return;
        }
        return _ConsoleMetricExporter._sendMetrics(metrics2, resultCallback);
      }
      forceFlush() {
        return Promise.resolve();
      }
      selectAggregationTemporality(_instrumentType) {
        return this._temporalitySelector(_instrumentType);
      }
      shutdown() {
        this._shutdown = true;
        return Promise.resolve();
      }
      static _sendMetrics(metrics2, done7) {
        for (const scopeMetrics of metrics2.scopeMetrics) {
          for (const metric of scopeMetrics.metrics) {
            console.dir({
              descriptor: metric.descriptor,
              dataPointType: metric.dataPointType,
              dataPoints: metric.dataPoints
            }, { depth: null });
          }
        }
        done7({ code: core_1.ExportResultCode.SUCCESS });
      }
    };
    exports.ConsoleMetricExporter = ConsoleMetricExporter;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/platform/node/default-service-name.js
var require_default_service_name2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/platform/node/default-service-name.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultServiceName = void 0;
    function defaultServiceName() {
      return `unknown_service:${process.argv0}`;
    }
    exports.defaultServiceName = defaultServiceName;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/platform/node/index.js
var require_node11 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/platform/node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultServiceName = void 0;
    var default_service_name_1 = require_default_service_name2();
    Object.defineProperty(exports, "defaultServiceName", { enumerable: true, get: function() {
      return default_service_name_1.defaultServiceName;
    } });
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/platform/index.js
var require_platform11 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/platform/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultServiceName = void 0;
    var node_1 = require_node11();
    Object.defineProperty(exports, "defaultServiceName", { enumerable: true, get: function() {
      return node_1.defaultServiceName;
    } });
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/Resource.js
var require_Resource2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/Resource.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Resource = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var semantic_conventions_1 = require_src16();
    var core_1 = require_src17();
    var platform_1 = require_platform11();
    var Resource = class _Resource {
      constructor(attributes, asyncAttributesPromise) {
        var _a12;
        this._attributes = attributes;
        this.asyncAttributesPending = asyncAttributesPromise != null;
        this._syncAttributes = (_a12 = this._attributes) !== null && _a12 !== void 0 ? _a12 : {};
        this._asyncAttributesPromise = asyncAttributesPromise === null || asyncAttributesPromise === void 0 ? void 0 : asyncAttributesPromise.then((asyncAttributes) => {
          this._attributes = Object.assign({}, this._attributes, asyncAttributes);
          this.asyncAttributesPending = false;
          return asyncAttributes;
        }, (err) => {
          api_1.diag.debug("a resource's async attributes promise rejected: %s", err);
          this.asyncAttributesPending = false;
          return {};
        });
      }
      /**
       * Returns an empty Resource
       */
      static empty() {
        return _Resource.EMPTY;
      }
      /**
       * Returns a Resource that identifies the SDK in use.
       */
      static default() {
        return new _Resource({
          [semantic_conventions_1.SEMRESATTRS_SERVICE_NAME]: (0, platform_1.defaultServiceName)(),
          [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE]: core_1.SDK_INFO[semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE],
          [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_NAME]: core_1.SDK_INFO[semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_NAME],
          [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_VERSION]: core_1.SDK_INFO[semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_VERSION]
        });
      }
      get attributes() {
        var _a12;
        if (this.asyncAttributesPending) {
          api_1.diag.error("Accessing resource attributes before async attributes settled");
        }
        return (_a12 = this._attributes) !== null && _a12 !== void 0 ? _a12 : {};
      }
      /**
       * Returns a promise that will never be rejected. Resolves when all async attributes have finished being added to
       * this Resource's attributes. This is useful in exporters to block until resource detection
       * has finished.
       */
      async waitForAsyncAttributes() {
        if (this.asyncAttributesPending) {
          await this._asyncAttributesPromise;
        }
      }
      /**
       * Returns a new, merged {@link Resource} by merging the current Resource
       * with the other Resource. In case of a collision, other Resource takes
       * precedence.
       *
       * @param other the Resource that will be merged with this.
       * @returns the newly merged Resource.
       */
      merge(other) {
        var _a12;
        if (!other)
          return this;
        const mergedSyncAttributes = Object.assign(Object.assign({}, this._syncAttributes), (_a12 = other._syncAttributes) !== null && _a12 !== void 0 ? _a12 : other.attributes);
        if (!this._asyncAttributesPromise && !other._asyncAttributesPromise) {
          return new _Resource(mergedSyncAttributes);
        }
        const mergedAttributesPromise = Promise.all([
          this._asyncAttributesPromise,
          other._asyncAttributesPromise
        ]).then(([thisAsyncAttributes, otherAsyncAttributes]) => {
          var _a13;
          return Object.assign(Object.assign(Object.assign(Object.assign({}, this._syncAttributes), thisAsyncAttributes), (_a13 = other._syncAttributes) !== null && _a13 !== void 0 ? _a13 : other.attributes), otherAsyncAttributes);
        });
        return new _Resource(mergedSyncAttributes, mergedAttributesPromise);
      }
    };
    exports.Resource = Resource;
    Resource.EMPTY = new Resource({});
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/utils.js
var require_utils15 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalizeType = exports.normalizeArch = void 0;
    var normalizeArch = (nodeArchString) => {
      switch (nodeArchString) {
        case "arm":
          return "arm32";
        case "ppc":
          return "ppc32";
        case "x64":
          return "amd64";
        default:
          return nodeArchString;
      }
    };
    exports.normalizeArch = normalizeArch;
    var normalizeType = (nodePlatform) => {
      switch (nodePlatform) {
        case "sunos":
          return "solaris";
        case "win32":
          return "windows";
        default:
          return nodePlatform;
      }
    };
    exports.normalizeType = normalizeType;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/execAsync.js
var require_execAsync2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/execAsync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.execAsync = void 0;
    var child_process = __require("child_process");
    var util = __require("util");
    exports.execAsync = util.promisify(child_process.exec);
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-darwin.js
var require_getMachineId_darwin2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-darwin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMachineId = void 0;
    var execAsync_1 = require_execAsync2();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      try {
        const result4 = await (0, execAsync_1.execAsync)('ioreg -rd1 -c "IOPlatformExpertDevice"');
        const idLine = result4.stdout.split("\n").find((line) => line.includes("IOPlatformUUID"));
        if (!idLine) {
          return "";
        }
        const parts = idLine.split('" = "');
        if (parts.length === 2) {
          return parts[1].slice(0, -1);
        }
      } catch (e2) {
        api_1.diag.debug(`error reading machine id: ${e2}`);
      }
      return "";
    }
    exports.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-linux.js
var require_getMachineId_linux2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-linux.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMachineId = void 0;
    var fs_1 = __require("fs");
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      const paths = ["/etc/machine-id", "/var/lib/dbus/machine-id"];
      for (const path9 of paths) {
        try {
          const result4 = await fs_1.promises.readFile(path9, { encoding: "utf8" });
          return result4.trim();
        } catch (e2) {
          api_1.diag.debug(`error reading machine id: ${e2}`);
        }
      }
      return "";
    }
    exports.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-bsd.js
var require_getMachineId_bsd2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-bsd.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMachineId = void 0;
    var fs_1 = __require("fs");
    var execAsync_1 = require_execAsync2();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      try {
        const result4 = await fs_1.promises.readFile("/etc/hostid", { encoding: "utf8" });
        return result4.trim();
      } catch (e2) {
        api_1.diag.debug(`error reading machine id: ${e2}`);
      }
      try {
        const result4 = await (0, execAsync_1.execAsync)("kenv -q smbios.system.uuid");
        return result4.stdout.trim();
      } catch (e2) {
        api_1.diag.debug(`error reading machine id: ${e2}`);
      }
      return "";
    }
    exports.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-win.js
var require_getMachineId_win2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-win.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMachineId = void 0;
    var process2 = __require("process");
    var execAsync_1 = require_execAsync2();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      const args = "QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid";
      let command = "%windir%\\System32\\REG.exe";
      if (process2.arch === "ia32" && "PROCESSOR_ARCHITEW6432" in process2.env) {
        command = "%windir%\\sysnative\\cmd.exe /c " + command;
      }
      try {
        const result4 = await (0, execAsync_1.execAsync)(`${command} ${args}`);
        const parts = result4.stdout.split("REG_SZ");
        if (parts.length === 2) {
          return parts[1].trim();
        }
      } catch (e2) {
        api_1.diag.debug(`error reading machine id: ${e2}`);
      }
      return "";
    }
    exports.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-unsupported.js
var require_getMachineId_unsupported2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-unsupported.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMachineId = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      api_1.diag.debug("could not read machine-id: unsupported platform");
      return "";
    }
    exports.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId.js
var require_getMachineId2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMachineId = void 0;
    var process2 = __require("process");
    var getMachineId;
    exports.getMachineId = getMachineId;
    switch (process2.platform) {
      case "darwin":
        exports.getMachineId = getMachineId = require_getMachineId_darwin2().getMachineId;
        break;
      case "linux":
        exports.getMachineId = getMachineId = require_getMachineId_linux2().getMachineId;
        break;
      case "freebsd":
        exports.getMachineId = getMachineId = require_getMachineId_bsd2().getMachineId;
        break;
      case "win32":
        exports.getMachineId = getMachineId = require_getMachineId_win2().getMachineId;
        break;
      default:
        exports.getMachineId = getMachineId = require_getMachineId_unsupported2().getMachineId;
    }
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/HostDetectorSync.js
var require_HostDetectorSync2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/HostDetectorSync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hostDetectorSync = void 0;
    var semantic_conventions_1 = require_src16();
    var Resource_1 = require_Resource2();
    var os_1 = __require("os");
    var utils_1 = require_utils15();
    var getMachineId_1 = require_getMachineId2();
    var HostDetectorSync = class {
      detect(_config) {
        const attributes = {
          [semantic_conventions_1.SemanticResourceAttributes.HOST_NAME]: (0, os_1.hostname)(),
          [semantic_conventions_1.SemanticResourceAttributes.HOST_ARCH]: (0, utils_1.normalizeArch)((0, os_1.arch)())
        };
        return new Resource_1.Resource(attributes, this._getAsyncAttributes());
      }
      _getAsyncAttributes() {
        return (0, getMachineId_1.getMachineId)().then((machineId) => {
          const attributes = {};
          if (machineId) {
            attributes[semantic_conventions_1.SemanticResourceAttributes.HOST_ID] = machineId;
          }
          return attributes;
        });
      }
    };
    exports.hostDetectorSync = new HostDetectorSync();
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/HostDetector.js
var require_HostDetector2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/HostDetector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hostDetector = void 0;
    var HostDetectorSync_1 = require_HostDetectorSync2();
    var HostDetector = class {
      detect(_config) {
        return Promise.resolve(HostDetectorSync_1.hostDetectorSync.detect(_config));
      }
    };
    exports.hostDetector = new HostDetector();
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/OSDetectorSync.js
var require_OSDetectorSync2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/OSDetectorSync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.osDetectorSync = void 0;
    var semantic_conventions_1 = require_src16();
    var Resource_1 = require_Resource2();
    var os_1 = __require("os");
    var utils_1 = require_utils15();
    var OSDetectorSync = class {
      detect(_config) {
        const attributes = {
          [semantic_conventions_1.SemanticResourceAttributes.OS_TYPE]: (0, utils_1.normalizeType)((0, os_1.platform)()),
          [semantic_conventions_1.SemanticResourceAttributes.OS_VERSION]: (0, os_1.release)()
        };
        return new Resource_1.Resource(attributes);
      }
    };
    exports.osDetectorSync = new OSDetectorSync();
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/OSDetector.js
var require_OSDetector2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/OSDetector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.osDetector = void 0;
    var OSDetectorSync_1 = require_OSDetectorSync2();
    var OSDetector = class {
      detect(_config) {
        return Promise.resolve(OSDetectorSync_1.osDetectorSync.detect(_config));
      }
    };
    exports.osDetector = new OSDetector();
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ProcessDetectorSync.js
var require_ProcessDetectorSync2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ProcessDetectorSync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.processDetectorSync = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var semantic_conventions_1 = require_src16();
    var Resource_1 = require_Resource2();
    var os3 = __require("os");
    var ProcessDetectorSync = class {
      detect(_config) {
        const attributes = {
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_PID]: process.pid,
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_EXECUTABLE_NAME]: process.title,
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_EXECUTABLE_PATH]: process.execPath,
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_COMMAND_ARGS]: [
            process.argv[0],
            ...process.execArgv,
            ...process.argv.slice(1)
          ],
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_VERSION]: process.versions.node,
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_NAME]: "nodejs",
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION]: "Node.js"
        };
        if (process.argv.length > 1) {
          attributes[semantic_conventions_1.SemanticResourceAttributes.PROCESS_COMMAND] = process.argv[1];
        }
        try {
          const userInfo = os3.userInfo();
          attributes[semantic_conventions_1.SemanticResourceAttributes.PROCESS_OWNER] = userInfo.username;
        } catch (e2) {
          api_1.diag.debug(`error obtaining process owner: ${e2}`);
        }
        return new Resource_1.Resource(attributes);
      }
    };
    exports.processDetectorSync = new ProcessDetectorSync();
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ProcessDetector.js
var require_ProcessDetector2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ProcessDetector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.processDetector = void 0;
    var ProcessDetectorSync_1 = require_ProcessDetectorSync2();
    var ProcessDetector = class {
      detect(config) {
        return Promise.resolve(ProcessDetectorSync_1.processDetectorSync.detect(config));
      }
    };
    exports.processDetector = new ProcessDetector();
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ServiceInstanceIdDetectorSync.js
var require_ServiceInstanceIdDetectorSync2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ServiceInstanceIdDetectorSync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serviceInstanceIdDetectorSync = void 0;
    var semantic_conventions_1 = require_src16();
    var Resource_1 = require_Resource2();
    var crypto_1 = __require("crypto");
    var ServiceInstanceIdDetectorSync = class {
      detect(_config) {
        const attributes = {
          [semantic_conventions_1.SEMRESATTRS_SERVICE_INSTANCE_ID]: (0, crypto_1.randomUUID)()
        };
        return new Resource_1.Resource(attributes);
      }
    };
    exports.serviceInstanceIdDetectorSync = new ServiceInstanceIdDetectorSync();
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/index.js
var require_node12 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serviceInstanceIdDetectorSync = exports.processDetectorSync = exports.processDetector = exports.osDetectorSync = exports.osDetector = exports.hostDetectorSync = exports.hostDetector = void 0;
    var HostDetector_1 = require_HostDetector2();
    Object.defineProperty(exports, "hostDetector", { enumerable: true, get: function() {
      return HostDetector_1.hostDetector;
    } });
    var HostDetectorSync_1 = require_HostDetectorSync2();
    Object.defineProperty(exports, "hostDetectorSync", { enumerable: true, get: function() {
      return HostDetectorSync_1.hostDetectorSync;
    } });
    var OSDetector_1 = require_OSDetector2();
    Object.defineProperty(exports, "osDetector", { enumerable: true, get: function() {
      return OSDetector_1.osDetector;
    } });
    var OSDetectorSync_1 = require_OSDetectorSync2();
    Object.defineProperty(exports, "osDetectorSync", { enumerable: true, get: function() {
      return OSDetectorSync_1.osDetectorSync;
    } });
    var ProcessDetector_1 = require_ProcessDetector2();
    Object.defineProperty(exports, "processDetector", { enumerable: true, get: function() {
      return ProcessDetector_1.processDetector;
    } });
    var ProcessDetectorSync_1 = require_ProcessDetectorSync2();
    Object.defineProperty(exports, "processDetectorSync", { enumerable: true, get: function() {
      return ProcessDetectorSync_1.processDetectorSync;
    } });
    var ServiceInstanceIdDetectorSync_1 = require_ServiceInstanceIdDetectorSync2();
    Object.defineProperty(exports, "serviceInstanceIdDetectorSync", { enumerable: true, get: function() {
      return ServiceInstanceIdDetectorSync_1.serviceInstanceIdDetectorSync;
    } });
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/index.js
var require_platform12 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/platform/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serviceInstanceIdDetectorSync = exports.processDetectorSync = exports.processDetector = exports.osDetectorSync = exports.osDetector = exports.hostDetectorSync = exports.hostDetector = void 0;
    var node_1 = require_node12();
    Object.defineProperty(exports, "hostDetector", { enumerable: true, get: function() {
      return node_1.hostDetector;
    } });
    Object.defineProperty(exports, "hostDetectorSync", { enumerable: true, get: function() {
      return node_1.hostDetectorSync;
    } });
    Object.defineProperty(exports, "osDetector", { enumerable: true, get: function() {
      return node_1.osDetector;
    } });
    Object.defineProperty(exports, "osDetectorSync", { enumerable: true, get: function() {
      return node_1.osDetectorSync;
    } });
    Object.defineProperty(exports, "processDetector", { enumerable: true, get: function() {
      return node_1.processDetector;
    } });
    Object.defineProperty(exports, "processDetectorSync", { enumerable: true, get: function() {
      return node_1.processDetectorSync;
    } });
    Object.defineProperty(exports, "serviceInstanceIdDetectorSync", { enumerable: true, get: function() {
      return node_1.serviceInstanceIdDetectorSync;
    } });
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetectorSync.js
var require_BrowserDetectorSync2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetectorSync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.browserDetectorSync = void 0;
    var semantic_conventions_1 = require_src16();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var Resource_1 = require_Resource2();
    var BrowserDetectorSync = class {
      detect(config) {
        var _a12, _b5, _c4;
        const isBrowser = typeof navigator !== "undefined" && ((_b5 = (_a12 = global.process) === null || _a12 === void 0 ? void 0 : _a12.versions) === null || _b5 === void 0 ? void 0 : _b5.node) === void 0 && // Node.js v21 adds `navigator`
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore don't have Bun types
        ((_c4 = global.Bun) === null || _c4 === void 0 ? void 0 : _c4.version) === void 0;
        if (!isBrowser) {
          return Resource_1.Resource.empty();
        }
        const browserResource = {
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_NAME]: "browser",
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION]: "Web Browser",
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_VERSION]: navigator.userAgent
        };
        return this._getResourceAttributes(browserResource, config);
      }
      /**
       * Validates process resource attribute map from process variables
       *
       * @param browserResource The un-sanitized resource attributes from process as key/value pairs.
       * @param config: Config
       * @returns The sanitized resource attributes.
       */
      _getResourceAttributes(browserResource, _config) {
        if (browserResource[semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] === "") {
          api_1.diag.debug("BrowserDetector failed: Unable to find required browser resources. ");
          return Resource_1.Resource.empty();
        } else {
          return new Resource_1.Resource(Object.assign({}, browserResource));
        }
      }
    };
    exports.browserDetectorSync = new BrowserDetectorSync();
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetector.js
var require_BrowserDetector2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.browserDetector = void 0;
    var BrowserDetectorSync_1 = require_BrowserDetectorSync2();
    var BrowserDetector = class {
      detect(config) {
        return Promise.resolve(BrowserDetectorSync_1.browserDetectorSync.detect(config));
      }
    };
    exports.browserDetector = new BrowserDetector();
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/EnvDetectorSync.js
var require_EnvDetectorSync2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/EnvDetectorSync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.envDetectorSync = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src17();
    var semantic_conventions_1 = require_src16();
    var Resource_1 = require_Resource2();
    var EnvDetectorSync = class {
      constructor() {
        this._MAX_LENGTH = 255;
        this._COMMA_SEPARATOR = ",";
        this._LABEL_KEY_VALUE_SPLITTER = "=";
        this._ERROR_MESSAGE_INVALID_CHARS = "should be a ASCII string with a length greater than 0 and not exceed " + this._MAX_LENGTH + " characters.";
        this._ERROR_MESSAGE_INVALID_VALUE = "should be a ASCII string with a length not exceed " + this._MAX_LENGTH + " characters.";
      }
      /**
       * Returns a {@link Resource} populated with attributes from the
       * OTEL_RESOURCE_ATTRIBUTES environment variable. Note this is an async
       * function to conform to the Detector interface.
       *
       * @param config The resource detection config
       */
      detect(_config) {
        const attributes = {};
        const env = (0, core_1.getEnv)();
        const rawAttributes = env.OTEL_RESOURCE_ATTRIBUTES;
        const serviceName = env.OTEL_SERVICE_NAME;
        if (rawAttributes) {
          try {
            const parsedAttributes = this._parseResourceAttributes(rawAttributes);
            Object.assign(attributes, parsedAttributes);
          } catch (e2) {
            api_1.diag.debug(`EnvDetector failed: ${e2.message}`);
          }
        }
        if (serviceName) {
          attributes[semantic_conventions_1.SEMRESATTRS_SERVICE_NAME] = serviceName;
        }
        return new Resource_1.Resource(attributes);
      }
      /**
       * Creates an attribute map from the OTEL_RESOURCE_ATTRIBUTES environment
       * variable.
       *
       * OTEL_RESOURCE_ATTRIBUTES: A comma-separated list of attributes describing
       * the source in more detail, e.g. key1=val1,key2=val2. Domain names and
       * paths are accepted as attribute keys. Values may be quoted or unquoted in
       * general. If a value contains whitespace, =, or " characters, it must
       * always be quoted.
       *
       * @param rawEnvAttributes The resource attributes as a comma-separated list
       * of key/value pairs.
       * @returns The sanitized resource attributes.
       */
      _parseResourceAttributes(rawEnvAttributes) {
        if (!rawEnvAttributes)
          return {};
        const attributes = {};
        const rawAttributes = rawEnvAttributes.split(this._COMMA_SEPARATOR, -1);
        for (const rawAttribute of rawAttributes) {
          const keyValuePair = rawAttribute.split(this._LABEL_KEY_VALUE_SPLITTER, -1);
          if (keyValuePair.length !== 2) {
            continue;
          }
          let [key, value] = keyValuePair;
          key = key.trim();
          value = value.trim().split(/^"|"$/).join("");
          if (!this._isValidAndNotEmpty(key)) {
            throw new Error(`Attribute key ${this._ERROR_MESSAGE_INVALID_CHARS}`);
          }
          if (!this._isValid(value)) {
            throw new Error(`Attribute value ${this._ERROR_MESSAGE_INVALID_VALUE}`);
          }
          attributes[key] = decodeURIComponent(value);
        }
        return attributes;
      }
      /**
       * Determines whether the given String is a valid printable ASCII string with
       * a length not exceed _MAX_LENGTH characters.
       *
       * @param str The String to be validated.
       * @returns Whether the String is valid.
       */
      _isValid(name) {
        return name.length <= this._MAX_LENGTH && this._isBaggageOctetString(name);
      }
      // https://www.w3.org/TR/baggage/#definition
      _isBaggageOctetString(str) {
        for (let i2 = 0; i2 < str.length; i2++) {
          const ch = str.charCodeAt(i2);
          if (ch < 33 || ch === 44 || ch === 59 || ch === 92 || ch > 126) {
            return false;
          }
        }
        return true;
      }
      /**
       * Determines whether the given String is a valid printable ASCII string with
       * a length greater than 0 and not exceed _MAX_LENGTH characters.
       *
       * @param str The String to be validated.
       * @returns Whether the String is valid and not empty.
       */
      _isValidAndNotEmpty(str) {
        return str.length > 0 && this._isValid(str);
      }
    };
    exports.envDetectorSync = new EnvDetectorSync();
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/EnvDetector.js
var require_EnvDetector2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/EnvDetector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.envDetector = void 0;
    var EnvDetectorSync_1 = require_EnvDetectorSync2();
    var EnvDetector = class {
      /**
       * Returns a {@link Resource} populated with attributes from the
       * OTEL_RESOURCE_ATTRIBUTES environment variable. Note this is an async
       * function to conform to the Detector interface.
       *
       * @param config The resource detection config
       */
      detect(config) {
        return Promise.resolve(EnvDetectorSync_1.envDetectorSync.detect(config));
      }
    };
    exports.envDetector = new EnvDetector();
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/index.js
var require_detectors2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detectors/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.envDetectorSync = exports.browserDetectorSync = exports.envDetector = exports.browserDetector = exports.serviceInstanceIdDetectorSync = exports.processDetectorSync = exports.processDetector = exports.osDetectorSync = exports.osDetector = exports.hostDetectorSync = exports.hostDetector = void 0;
    var platform_1 = require_platform12();
    Object.defineProperty(exports, "hostDetector", { enumerable: true, get: function() {
      return platform_1.hostDetector;
    } });
    Object.defineProperty(exports, "hostDetectorSync", { enumerable: true, get: function() {
      return platform_1.hostDetectorSync;
    } });
    Object.defineProperty(exports, "osDetector", { enumerable: true, get: function() {
      return platform_1.osDetector;
    } });
    Object.defineProperty(exports, "osDetectorSync", { enumerable: true, get: function() {
      return platform_1.osDetectorSync;
    } });
    Object.defineProperty(exports, "processDetector", { enumerable: true, get: function() {
      return platform_1.processDetector;
    } });
    Object.defineProperty(exports, "processDetectorSync", { enumerable: true, get: function() {
      return platform_1.processDetectorSync;
    } });
    Object.defineProperty(exports, "serviceInstanceIdDetectorSync", { enumerable: true, get: function() {
      return platform_1.serviceInstanceIdDetectorSync;
    } });
    var BrowserDetector_1 = require_BrowserDetector2();
    Object.defineProperty(exports, "browserDetector", { enumerable: true, get: function() {
      return BrowserDetector_1.browserDetector;
    } });
    var EnvDetector_1 = require_EnvDetector2();
    Object.defineProperty(exports, "envDetector", { enumerable: true, get: function() {
      return EnvDetector_1.envDetector;
    } });
    var BrowserDetectorSync_1 = require_BrowserDetectorSync2();
    Object.defineProperty(exports, "browserDetectorSync", { enumerable: true, get: function() {
      return BrowserDetectorSync_1.browserDetectorSync;
    } });
    var EnvDetectorSync_1 = require_EnvDetectorSync2();
    Object.defineProperty(exports, "envDetectorSync", { enumerable: true, get: function() {
      return EnvDetectorSync_1.envDetectorSync;
    } });
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/utils.js
var require_utils16 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isPromiseLike = void 0;
    var isPromiseLike = (val) => {
      return val !== null && typeof val === "object" && typeof val.then === "function";
    };
    exports.isPromiseLike = isPromiseLike;
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detect-resources.js
var require_detect_resources2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/detect-resources.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.detectResourcesSync = exports.detectResources = void 0;
    var Resource_1 = require_Resource2();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var utils_1 = require_utils16();
    var detectResources = async (config = {}) => {
      const resources = await Promise.all((config.detectors || []).map(async (d2) => {
        try {
          const resource = await d2.detect(config);
          api_1.diag.debug(`${d2.constructor.name} found resource.`, resource);
          return resource;
        } catch (e2) {
          api_1.diag.debug(`${d2.constructor.name} failed: ${e2.message}`);
          return Resource_1.Resource.empty();
        }
      }));
      logResources(resources);
      return resources.reduce((acc, resource) => acc.merge(resource), Resource_1.Resource.empty());
    };
    exports.detectResources = detectResources;
    var detectResourcesSync = (config = {}) => {
      var _a12;
      const resources = ((_a12 = config.detectors) !== null && _a12 !== void 0 ? _a12 : []).map((d2) => {
        try {
          const resourceOrPromise = d2.detect(config);
          let resource;
          if ((0, utils_1.isPromiseLike)(resourceOrPromise)) {
            const createPromise = async () => {
              const resolvedResource = await resourceOrPromise;
              return resolvedResource.attributes;
            };
            resource = new Resource_1.Resource({}, createPromise());
          } else {
            resource = resourceOrPromise;
          }
          if (resource.waitForAsyncAttributes) {
            void resource.waitForAsyncAttributes().then(() => api_1.diag.debug(`${d2.constructor.name} found resource.`, resource));
          } else {
            api_1.diag.debug(`${d2.constructor.name} found resource.`, resource);
          }
          return resource;
        } catch (e2) {
          api_1.diag.error(`${d2.constructor.name} failed: ${e2.message}`);
          return Resource_1.Resource.empty();
        }
      });
      const mergedResources = resources.reduce((acc, resource) => acc.merge(resource), Resource_1.Resource.empty());
      if (mergedResources.waitForAsyncAttributes) {
        void mergedResources.waitForAsyncAttributes().then(() => {
          logResources(resources);
        });
      }
      return mergedResources;
    };
    exports.detectResourcesSync = detectResourcesSync;
    var logResources = (resources) => {
      resources.forEach((resource) => {
        if (Object.keys(resource.attributes).length > 0) {
          const resourceDebugString = JSON.stringify(resource.attributes, null, 4);
          api_1.diag.verbose(resourceDebugString);
        }
      });
    };
  }
});

// node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/index.js
var require_src18 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/node_modules/@opentelemetry/resources/build/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.detectResources = exports.detectResourcesSync = exports.serviceInstanceIdDetectorSync = exports.processDetectorSync = exports.processDetector = exports.osDetectorSync = exports.osDetector = exports.hostDetectorSync = exports.hostDetector = exports.envDetectorSync = exports.envDetector = exports.browserDetectorSync = exports.browserDetector = exports.defaultServiceName = exports.Resource = void 0;
    var Resource_1 = require_Resource2();
    Object.defineProperty(exports, "Resource", { enumerable: true, get: function() {
      return Resource_1.Resource;
    } });
    var platform_1 = require_platform11();
    Object.defineProperty(exports, "defaultServiceName", { enumerable: true, get: function() {
      return platform_1.defaultServiceName;
    } });
    var detectors_1 = require_detectors2();
    Object.defineProperty(exports, "browserDetector", { enumerable: true, get: function() {
      return detectors_1.browserDetector;
    } });
    Object.defineProperty(exports, "browserDetectorSync", { enumerable: true, get: function() {
      return detectors_1.browserDetectorSync;
    } });
    Object.defineProperty(exports, "envDetector", { enumerable: true, get: function() {
      return detectors_1.envDetector;
    } });
    Object.defineProperty(exports, "envDetectorSync", { enumerable: true, get: function() {
      return detectors_1.envDetectorSync;
    } });
    Object.defineProperty(exports, "hostDetector", { enumerable: true, get: function() {
      return detectors_1.hostDetector;
    } });
    Object.defineProperty(exports, "hostDetectorSync", { enumerable: true, get: function() {
      return detectors_1.hostDetectorSync;
    } });
    Object.defineProperty(exports, "osDetector", { enumerable: true, get: function() {
      return detectors_1.osDetector;
    } });
    Object.defineProperty(exports, "osDetectorSync", { enumerable: true, get: function() {
      return detectors_1.osDetectorSync;
    } });
    Object.defineProperty(exports, "processDetector", { enumerable: true, get: function() {
      return detectors_1.processDetector;
    } });
    Object.defineProperty(exports, "processDetectorSync", { enumerable: true, get: function() {
      return detectors_1.processDetectorSync;
    } });
    Object.defineProperty(exports, "serviceInstanceIdDetectorSync", { enumerable: true, get: function() {
      return detectors_1.serviceInstanceIdDetectorSync;
    } });
    var detect_resources_1 = require_detect_resources2();
    Object.defineProperty(exports, "detectResourcesSync", { enumerable: true, get: function() {
      return detect_resources_1.detectResourcesSync;
    } });
    Object.defineProperty(exports, "detectResources", { enumerable: true, get: function() {
      return detect_resources_1.detectResources;
    } });
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/ViewRegistry.js
var require_ViewRegistry = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/view/ViewRegistry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ViewRegistry = void 0;
    var ViewRegistry = class {
      constructor() {
        this._registeredViews = [];
      }
      addView(view) {
        this._registeredViews.push(view);
      }
      findViews(instrument, meter) {
        const views = this._registeredViews.filter((registeredView) => {
          return this._matchInstrument(registeredView.instrumentSelector, instrument) && this._matchMeter(registeredView.meterSelector, meter);
        });
        return views;
      }
      _matchInstrument(selector, instrument) {
        return (selector.getType() === void 0 || instrument.type === selector.getType()) && selector.getNameFilter().match(instrument.name) && selector.getUnitFilter().match(instrument.unit);
      }
      _matchMeter(selector, meter) {
        return selector.getNameFilter().match(meter.name) && (meter.version === void 0 || selector.getVersionFilter().match(meter.version)) && (meter.schemaUrl === void 0 || selector.getSchemaUrlFilter().match(meter.schemaUrl));
      }
    };
    exports.ViewRegistry = ViewRegistry;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/Instruments.js
var require_Instruments = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/Instruments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isObservableInstrument = exports.ObservableUpDownCounterInstrument = exports.ObservableGaugeInstrument = exports.ObservableCounterInstrument = exports.ObservableInstrument = exports.HistogramInstrument = exports.GaugeInstrument = exports.CounterInstrument = exports.UpDownCounterInstrument = exports.SyncInstrument = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src17();
    var SyncInstrument = class {
      constructor(_writableMetricStorage, _descriptor) {
        this._writableMetricStorage = _writableMetricStorage;
        this._descriptor = _descriptor;
      }
      _record(value, attributes = {}, context3 = api_1.context.active()) {
        if (typeof value !== "number") {
          api_1.diag.warn(`non-number value provided to metric ${this._descriptor.name}: ${value}`);
          return;
        }
        if (this._descriptor.valueType === api_1.ValueType.INT && !Number.isInteger(value)) {
          api_1.diag.warn(`INT value type cannot accept a floating-point value for ${this._descriptor.name}, ignoring the fractional digits.`);
          value = Math.trunc(value);
          if (!Number.isInteger(value)) {
            return;
          }
        }
        this._writableMetricStorage.record(value, attributes, context3, (0, core_1.millisToHrTime)(Date.now()));
      }
    };
    exports.SyncInstrument = SyncInstrument;
    var UpDownCounterInstrument = class extends SyncInstrument {
      /**
       * Increment value of counter by the input. Inputs may be negative.
       */
      add(value, attributes, ctx) {
        this._record(value, attributes, ctx);
      }
    };
    exports.UpDownCounterInstrument = UpDownCounterInstrument;
    var CounterInstrument = class extends SyncInstrument {
      /**
       * Increment value of counter by the input. Inputs may not be negative.
       */
      add(value, attributes, ctx) {
        if (value < 0) {
          api_1.diag.warn(`negative value provided to counter ${this._descriptor.name}: ${value}`);
          return;
        }
        this._record(value, attributes, ctx);
      }
    };
    exports.CounterInstrument = CounterInstrument;
    var GaugeInstrument = class extends SyncInstrument {
      /**
       * Records a measurement.
       */
      record(value, attributes, ctx) {
        this._record(value, attributes, ctx);
      }
    };
    exports.GaugeInstrument = GaugeInstrument;
    var HistogramInstrument = class extends SyncInstrument {
      /**
       * Records a measurement. Value of the measurement must not be negative.
       */
      record(value, attributes, ctx) {
        if (value < 0) {
          api_1.diag.warn(`negative value provided to histogram ${this._descriptor.name}: ${value}`);
          return;
        }
        this._record(value, attributes, ctx);
      }
    };
    exports.HistogramInstrument = HistogramInstrument;
    var ObservableInstrument = class {
      constructor(descriptor3, metricStorages, _observableRegistry) {
        this._observableRegistry = _observableRegistry;
        this._descriptor = descriptor3;
        this._metricStorages = metricStorages;
      }
      /**
       * @see {Observable.addCallback}
       */
      addCallback(callback) {
        this._observableRegistry.addCallback(callback, this);
      }
      /**
       * @see {Observable.removeCallback}
       */
      removeCallback(callback) {
        this._observableRegistry.removeCallback(callback, this);
      }
    };
    exports.ObservableInstrument = ObservableInstrument;
    var ObservableCounterInstrument = class extends ObservableInstrument {
    };
    exports.ObservableCounterInstrument = ObservableCounterInstrument;
    var ObservableGaugeInstrument = class extends ObservableInstrument {
    };
    exports.ObservableGaugeInstrument = ObservableGaugeInstrument;
    var ObservableUpDownCounterInstrument = class extends ObservableInstrument {
    };
    exports.ObservableUpDownCounterInstrument = ObservableUpDownCounterInstrument;
    function isObservableInstrument(it2) {
      return it2 instanceof ObservableInstrument;
    }
    exports.isObservableInstrument = isObservableInstrument;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/Meter.js
var require_Meter = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/Meter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Meter = void 0;
    var InstrumentDescriptor_1 = require_InstrumentDescriptor();
    var Instruments_1 = require_Instruments();
    var Meter = class {
      constructor(_meterSharedState) {
        this._meterSharedState = _meterSharedState;
      }
      /**
       * Create a {@link Gauge} instrument.
       * @experimental
       */
      createGauge(name, options) {
        const descriptor3 = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.GAUGE, options);
        const storage = this._meterSharedState.registerMetricStorage(descriptor3);
        return new Instruments_1.GaugeInstrument(storage, descriptor3);
      }
      /**
       * Create a {@link Histogram} instrument.
       */
      createHistogram(name, options) {
        const descriptor3 = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.HISTOGRAM, options);
        const storage = this._meterSharedState.registerMetricStorage(descriptor3);
        return new Instruments_1.HistogramInstrument(storage, descriptor3);
      }
      /**
       * Create a {@link Counter} instrument.
       */
      createCounter(name, options) {
        const descriptor3 = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.COUNTER, options);
        const storage = this._meterSharedState.registerMetricStorage(descriptor3);
        return new Instruments_1.CounterInstrument(storage, descriptor3);
      }
      /**
       * Create a {@link UpDownCounter} instrument.
       */
      createUpDownCounter(name, options) {
        const descriptor3 = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.UP_DOWN_COUNTER, options);
        const storage = this._meterSharedState.registerMetricStorage(descriptor3);
        return new Instruments_1.UpDownCounterInstrument(storage, descriptor3);
      }
      /**
       * Create a {@link ObservableGauge} instrument.
       */
      createObservableGauge(name, options) {
        const descriptor3 = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.OBSERVABLE_GAUGE, options);
        const storages = this._meterSharedState.registerAsyncMetricStorage(descriptor3);
        return new Instruments_1.ObservableGaugeInstrument(descriptor3, storages, this._meterSharedState.observableRegistry);
      }
      /**
       * Create a {@link ObservableCounter} instrument.
       */
      createObservableCounter(name, options) {
        const descriptor3 = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.OBSERVABLE_COUNTER, options);
        const storages = this._meterSharedState.registerAsyncMetricStorage(descriptor3);
        return new Instruments_1.ObservableCounterInstrument(descriptor3, storages, this._meterSharedState.observableRegistry);
      }
      /**
       * Create a {@link ObservableUpDownCounter} instrument.
       */
      createObservableUpDownCounter(name, options) {
        const descriptor3 = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER, options);
        const storages = this._meterSharedState.registerAsyncMetricStorage(descriptor3);
        return new Instruments_1.ObservableUpDownCounterInstrument(descriptor3, storages, this._meterSharedState.observableRegistry);
      }
      /**
       * @see {@link Meter.addBatchObservableCallback}
       */
      addBatchObservableCallback(callback, observables) {
        this._meterSharedState.observableRegistry.addBatchCallback(callback, observables);
      }
      /**
       * @see {@link Meter.removeBatchObservableCallback}
       */
      removeBatchObservableCallback(callback, observables) {
        this._meterSharedState.observableRegistry.removeBatchCallback(callback, observables);
      }
    };
    exports.Meter = Meter;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricStorage.js
var require_MetricStorage = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MetricStorage = void 0;
    var InstrumentDescriptor_1 = require_InstrumentDescriptor();
    var MetricStorage = class {
      constructor(_instrumentDescriptor) {
        this._instrumentDescriptor = _instrumentDescriptor;
      }
      getInstrumentDescriptor() {
        return this._instrumentDescriptor;
      }
      updateDescription(description) {
        this._instrumentDescriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(this._instrumentDescriptor.name, this._instrumentDescriptor.type, {
          description,
          valueType: this._instrumentDescriptor.valueType,
          unit: this._instrumentDescriptor.unit,
          advice: this._instrumentDescriptor.advice
        });
      }
    };
    exports.MetricStorage = MetricStorage;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/HashMap.js
var require_HashMap = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/state/HashMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AttributeHashMap = exports.HashMap = void 0;
    var utils_1 = require_utils12();
    var HashMap3 = class {
      constructor(_hash2) {
        this._hash = _hash2;
        this._valueMap = /* @__PURE__ */ new Map();
        this._keyMap = /* @__PURE__ */ new Map();
      }
      get(key, hashCode2) {
        hashCode2 !== null && hashCode2 !== void 0 ? hashCode2 : hashCode2 = this._hash(key);
        return this._valueMap.get(hashCode2);
      }
      getOrDefault(key, defaultFactory) {
        const hash2 = this._hash(key);
        if (this._valueMap.has(hash2)) {
          return this._valueMap.get(hash2);
        }
        const val = defaultFactory();
        if (!this._keyMap.has(hash2)) {
          this._keyMap.set(hash2, key);
        }
        this._valueMap.set(hash2, val);
        return val;
      }
      set(key, value, hashCode2) {
        hashCode2 !== null && hashCode2 !== void 0 ? hashCode2 : hashCode2 = this._hash(key);
        if (!this._keyMap.has(hashCode2)) {
          this._keyMap.set(hashCode2, key);
        }
        this._valueMap.set(hashCode2, value);
      }
      has(key, hashCode2) {
        hashCode2 !== null && hashCode2 !== void 0 ? hashCode2 : hashCode2 = this._hash(key);
        return this._valueMap.has(hashCode2);
      }
      *keys() {
        const keyIterator = this._keyMap.entries();
        let next2 = keyIterator.next();
        while (next2.done !== true) {
          yield [next2.value[1], next2.value[0]];
          next2 = keyIterator.next();
        }
      }
      *entries() {
        const valueIterator = this._valueMap.entries();
        let next2 = valueIterator.next();
        while (next2.done !== true) {
          yield [this._keyMap.get(next2.value[0]), next2.value[1], next2.value[0]];
          next2 = valueIterator.next();
        }
      }
      get size() {
        return this._valueMap.size;
      }
    };
    exports.HashMap = HashMap3;
    var AttributeHashMap = class extends HashMap3 {
      constructor() {
        super(utils_1.hashAttributes);
      }
    };
    exports.AttributeHashMap = AttributeHashMap;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/DeltaMetricProcessor.js
var require_DeltaMetricProcessor = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/state/DeltaMetricProcessor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeltaMetricProcessor = void 0;
    var HashMap_1 = require_HashMap();
    var DeltaMetricProcessor = class {
      constructor(_aggregator) {
        this._aggregator = _aggregator;
        this._activeCollectionStorage = new HashMap_1.AttributeHashMap();
        this._cumulativeMemoStorage = new HashMap_1.AttributeHashMap();
      }
      record(value, attributes, _context, collectionTime) {
        const accumulation = this._activeCollectionStorage.getOrDefault(attributes, () => this._aggregator.createAccumulation(collectionTime));
        accumulation === null || accumulation === void 0 ? void 0 : accumulation.record(value);
      }
      batchCumulate(measurements, collectionTime) {
        Array.from(measurements.entries()).forEach(([attributes, value, hashCode2]) => {
          const accumulation = this._aggregator.createAccumulation(collectionTime);
          accumulation === null || accumulation === void 0 ? void 0 : accumulation.record(value);
          let delta = accumulation;
          if (this._cumulativeMemoStorage.has(attributes, hashCode2)) {
            const previous = this._cumulativeMemoStorage.get(attributes, hashCode2);
            delta = this._aggregator.diff(previous, accumulation);
          }
          if (this._activeCollectionStorage.has(attributes, hashCode2)) {
            const active = this._activeCollectionStorage.get(attributes, hashCode2);
            delta = this._aggregator.merge(active, delta);
          }
          this._cumulativeMemoStorage.set(attributes, accumulation, hashCode2);
          this._activeCollectionStorage.set(attributes, delta, hashCode2);
        });
      }
      /**
       * Returns a collection of delta metrics. Start time is the when first
       * time event collected.
       */
      collect() {
        const unreportedDelta = this._activeCollectionStorage;
        this._activeCollectionStorage = new HashMap_1.AttributeHashMap();
        return unreportedDelta;
      }
    };
    exports.DeltaMetricProcessor = DeltaMetricProcessor;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/TemporalMetricProcessor.js
var require_TemporalMetricProcessor = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/state/TemporalMetricProcessor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TemporalMetricProcessor = void 0;
    var AggregationTemporality_1 = require_AggregationTemporality();
    var HashMap_1 = require_HashMap();
    var TemporalMetricProcessor = class _TemporalMetricProcessor {
      constructor(_aggregator, collectorHandles) {
        this._aggregator = _aggregator;
        this._unreportedAccumulations = /* @__PURE__ */ new Map();
        this._reportHistory = /* @__PURE__ */ new Map();
        collectorHandles.forEach((handle) => {
          this._unreportedAccumulations.set(handle, []);
        });
      }
      /**
       * Builds the {@link MetricData} streams to report against a specific MetricCollector.
       * @param collector The information of the MetricCollector.
       * @param collectors The registered collectors.
       * @param instrumentDescriptor The instrumentation descriptor that these metrics generated with.
       * @param currentAccumulations The current accumulation of metric data from instruments.
       * @param collectionTime The current collection timestamp.
       * @returns The {@link MetricData} points or `null`.
       */
      buildMetrics(collector, instrumentDescriptor, currentAccumulations, collectionTime) {
        this._stashAccumulations(currentAccumulations);
        const unreportedAccumulations = this._getMergedUnreportedAccumulations(collector);
        let result4 = unreportedAccumulations;
        let aggregationTemporality;
        if (this._reportHistory.has(collector)) {
          const last4 = this._reportHistory.get(collector);
          const lastCollectionTime = last4.collectionTime;
          aggregationTemporality = last4.aggregationTemporality;
          if (aggregationTemporality === AggregationTemporality_1.AggregationTemporality.CUMULATIVE) {
            result4 = _TemporalMetricProcessor.merge(last4.accumulations, unreportedAccumulations, this._aggregator);
          } else {
            result4 = _TemporalMetricProcessor.calibrateStartTime(last4.accumulations, unreportedAccumulations, lastCollectionTime);
          }
        } else {
          aggregationTemporality = collector.selectAggregationTemporality(instrumentDescriptor.type);
        }
        this._reportHistory.set(collector, {
          accumulations: result4,
          collectionTime,
          aggregationTemporality
        });
        const accumulationRecords = AttributesMapToAccumulationRecords(result4);
        if (accumulationRecords.length === 0) {
          return void 0;
        }
        return this._aggregator.toMetricData(
          instrumentDescriptor,
          aggregationTemporality,
          accumulationRecords,
          /* endTime */
          collectionTime
        );
      }
      _stashAccumulations(currentAccumulation) {
        const registeredCollectors = this._unreportedAccumulations.keys();
        for (const collector of registeredCollectors) {
          let stash = this._unreportedAccumulations.get(collector);
          if (stash === void 0) {
            stash = [];
            this._unreportedAccumulations.set(collector, stash);
          }
          stash.push(currentAccumulation);
        }
      }
      _getMergedUnreportedAccumulations(collector) {
        let result4 = new HashMap_1.AttributeHashMap();
        const unreportedList = this._unreportedAccumulations.get(collector);
        this._unreportedAccumulations.set(collector, []);
        if (unreportedList === void 0) {
          return result4;
        }
        for (const it2 of unreportedList) {
          result4 = _TemporalMetricProcessor.merge(result4, it2, this._aggregator);
        }
        return result4;
      }
      static merge(last4, current, aggregator) {
        const result4 = last4;
        const iterator = current.entries();
        let next2 = iterator.next();
        while (next2.done !== true) {
          const [key, record2, hash2] = next2.value;
          if (last4.has(key, hash2)) {
            const lastAccumulation = last4.get(key, hash2);
            const accumulation = aggregator.merge(lastAccumulation, record2);
            result4.set(key, accumulation, hash2);
          } else {
            result4.set(key, record2, hash2);
          }
          next2 = iterator.next();
        }
        return result4;
      }
      /**
       * Calibrate the reported metric streams' startTime to lastCollectionTime. Leaves
       * the new stream to be the initial observation time unchanged.
       */
      static calibrateStartTime(last4, current, lastCollectionTime) {
        for (const [key, hash2] of last4.keys()) {
          const currentAccumulation = current.get(key, hash2);
          currentAccumulation === null || currentAccumulation === void 0 ? void 0 : currentAccumulation.setStartTime(lastCollectionTime);
        }
        return current;
      }
    };
    exports.TemporalMetricProcessor = TemporalMetricProcessor;
    function AttributesMapToAccumulationRecords(map15) {
      return Array.from(map15.entries());
    }
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/AsyncMetricStorage.js
var require_AsyncMetricStorage = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/state/AsyncMetricStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncMetricStorage = void 0;
    var MetricStorage_1 = require_MetricStorage();
    var DeltaMetricProcessor_1 = require_DeltaMetricProcessor();
    var TemporalMetricProcessor_1 = require_TemporalMetricProcessor();
    var HashMap_1 = require_HashMap();
    var AsyncMetricStorage = class extends MetricStorage_1.MetricStorage {
      constructor(_instrumentDescriptor, aggregator, _attributesProcessor, collectorHandles) {
        super(_instrumentDescriptor);
        this._attributesProcessor = _attributesProcessor;
        this._deltaMetricStorage = new DeltaMetricProcessor_1.DeltaMetricProcessor(aggregator);
        this._temporalMetricStorage = new TemporalMetricProcessor_1.TemporalMetricProcessor(aggregator, collectorHandles);
      }
      record(measurements, observationTime) {
        const processed = new HashMap_1.AttributeHashMap();
        Array.from(measurements.entries()).forEach(([attributes, value]) => {
          processed.set(this._attributesProcessor.process(attributes), value);
        });
        this._deltaMetricStorage.batchCumulate(processed, observationTime);
      }
      /**
       * Collects the metrics from this storage. The ObservableCallback is invoked
       * during the collection.
       *
       * Note: This is a stateful operation and may reset any interval-related
       * state for the MetricCollector.
       */
      collect(collector, collectionTime) {
        const accumulations = this._deltaMetricStorage.collect();
        return this._temporalMetricStorage.buildMetrics(collector, this._instrumentDescriptor, accumulations, collectionTime);
      }
    };
    exports.AsyncMetricStorage = AsyncMetricStorage;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/RegistrationConflicts.js
var require_RegistrationConflicts = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/view/RegistrationConflicts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getConflictResolutionRecipe = exports.getDescriptionResolutionRecipe = exports.getTypeConflictResolutionRecipe = exports.getUnitConflictResolutionRecipe = exports.getValueTypeConflictResolutionRecipe = exports.getIncompatibilityDetails = void 0;
    function getIncompatibilityDetails(existing, otherDescriptor) {
      let incompatibility = "";
      if (existing.unit !== otherDescriptor.unit) {
        incompatibility += `	- Unit '${existing.unit}' does not match '${otherDescriptor.unit}'
`;
      }
      if (existing.type !== otherDescriptor.type) {
        incompatibility += `	- Type '${existing.type}' does not match '${otherDescriptor.type}'
`;
      }
      if (existing.valueType !== otherDescriptor.valueType) {
        incompatibility += `	- Value Type '${existing.valueType}' does not match '${otherDescriptor.valueType}'
`;
      }
      if (existing.description !== otherDescriptor.description) {
        incompatibility += `	- Description '${existing.description}' does not match '${otherDescriptor.description}'
`;
      }
      return incompatibility;
    }
    exports.getIncompatibilityDetails = getIncompatibilityDetails;
    function getValueTypeConflictResolutionRecipe(existing, otherDescriptor) {
      return `	- use valueType '${existing.valueType}' on instrument creation or use an instrument name other than '${otherDescriptor.name}'`;
    }
    exports.getValueTypeConflictResolutionRecipe = getValueTypeConflictResolutionRecipe;
    function getUnitConflictResolutionRecipe(existing, otherDescriptor) {
      return `	- use unit '${existing.unit}' on instrument creation or use an instrument name other than '${otherDescriptor.name}'`;
    }
    exports.getUnitConflictResolutionRecipe = getUnitConflictResolutionRecipe;
    function getTypeConflictResolutionRecipe(existing, otherDescriptor) {
      const selector = {
        name: otherDescriptor.name,
        type: otherDescriptor.type,
        unit: otherDescriptor.unit
      };
      const selectorString = JSON.stringify(selector);
      return `	- create a new view with a name other than '${existing.name}' and InstrumentSelector '${selectorString}'`;
    }
    exports.getTypeConflictResolutionRecipe = getTypeConflictResolutionRecipe;
    function getDescriptionResolutionRecipe(existing, otherDescriptor) {
      const selector = {
        name: otherDescriptor.name,
        type: otherDescriptor.type,
        unit: otherDescriptor.unit
      };
      const selectorString = JSON.stringify(selector);
      return `	- create a new view with a name other than '${existing.name}' and InstrumentSelector '${selectorString}'
    	- OR - create a new view with the name ${existing.name} and description '${existing.description}' and InstrumentSelector ${selectorString}
    	- OR - create a new view with the name ${otherDescriptor.name} and description '${existing.description}' and InstrumentSelector ${selectorString}`;
    }
    exports.getDescriptionResolutionRecipe = getDescriptionResolutionRecipe;
    function getConflictResolutionRecipe(existing, otherDescriptor) {
      if (existing.valueType !== otherDescriptor.valueType) {
        return getValueTypeConflictResolutionRecipe(existing, otherDescriptor);
      }
      if (existing.unit !== otherDescriptor.unit) {
        return getUnitConflictResolutionRecipe(existing, otherDescriptor);
      }
      if (existing.type !== otherDescriptor.type) {
        return getTypeConflictResolutionRecipe(existing, otherDescriptor);
      }
      if (existing.description !== otherDescriptor.description) {
        return getDescriptionResolutionRecipe(existing, otherDescriptor);
      }
      return "";
    }
    exports.getConflictResolutionRecipe = getConflictResolutionRecipe;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricStorageRegistry.js
var require_MetricStorageRegistry = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricStorageRegistry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MetricStorageRegistry = void 0;
    var InstrumentDescriptor_1 = require_InstrumentDescriptor();
    var api = (init_esm(), __toCommonJS(esm_exports));
    var RegistrationConflicts_1 = require_RegistrationConflicts();
    var MetricStorageRegistry = class _MetricStorageRegistry {
      constructor() {
        this._sharedRegistry = /* @__PURE__ */ new Map();
        this._perCollectorRegistry = /* @__PURE__ */ new Map();
      }
      static create() {
        return new _MetricStorageRegistry();
      }
      getStorages(collector) {
        let storages = [];
        for (const metricStorages of this._sharedRegistry.values()) {
          storages = storages.concat(metricStorages);
        }
        const perCollectorStorages = this._perCollectorRegistry.get(collector);
        if (perCollectorStorages != null) {
          for (const metricStorages of perCollectorStorages.values()) {
            storages = storages.concat(metricStorages);
          }
        }
        return storages;
      }
      register(storage) {
        this._registerStorage(storage, this._sharedRegistry);
      }
      registerForCollector(collector, storage) {
        let storageMap = this._perCollectorRegistry.get(collector);
        if (storageMap == null) {
          storageMap = /* @__PURE__ */ new Map();
          this._perCollectorRegistry.set(collector, storageMap);
        }
        this._registerStorage(storage, storageMap);
      }
      findOrUpdateCompatibleStorage(expectedDescriptor) {
        const storages = this._sharedRegistry.get(expectedDescriptor.name);
        if (storages === void 0) {
          return null;
        }
        return this._findOrUpdateCompatibleStorage(expectedDescriptor, storages);
      }
      findOrUpdateCompatibleCollectorStorage(collector, expectedDescriptor) {
        const storageMap = this._perCollectorRegistry.get(collector);
        if (storageMap === void 0) {
          return null;
        }
        const storages = storageMap.get(expectedDescriptor.name);
        if (storages === void 0) {
          return null;
        }
        return this._findOrUpdateCompatibleStorage(expectedDescriptor, storages);
      }
      _registerStorage(storage, storageMap) {
        const descriptor3 = storage.getInstrumentDescriptor();
        const storages = storageMap.get(descriptor3.name);
        if (storages === void 0) {
          storageMap.set(descriptor3.name, [storage]);
          return;
        }
        storages.push(storage);
      }
      _findOrUpdateCompatibleStorage(expectedDescriptor, existingStorages) {
        let compatibleStorage = null;
        for (const existingStorage of existingStorages) {
          const existingDescriptor = existingStorage.getInstrumentDescriptor();
          if ((0, InstrumentDescriptor_1.isDescriptorCompatibleWith)(existingDescriptor, expectedDescriptor)) {
            if (existingDescriptor.description !== expectedDescriptor.description) {
              if (expectedDescriptor.description.length > existingDescriptor.description.length) {
                existingStorage.updateDescription(expectedDescriptor.description);
              }
              api.diag.warn("A view or instrument with the name ", expectedDescriptor.name, " has already been registered, but has a different description and is incompatible with another registered view.\n", "Details:\n", (0, RegistrationConflicts_1.getIncompatibilityDetails)(existingDescriptor, expectedDescriptor), "The longer description will be used.\nTo resolve the conflict:", (0, RegistrationConflicts_1.getConflictResolutionRecipe)(existingDescriptor, expectedDescriptor));
            }
            compatibleStorage = existingStorage;
          } else {
            api.diag.warn("A view or instrument with the name ", expectedDescriptor.name, " has already been registered and is incompatible with another registered view.\n", "Details:\n", (0, RegistrationConflicts_1.getIncompatibilityDetails)(existingDescriptor, expectedDescriptor), "To resolve the conflict:\n", (0, RegistrationConflicts_1.getConflictResolutionRecipe)(existingDescriptor, expectedDescriptor));
          }
        }
        return compatibleStorage;
      }
    };
    exports.MetricStorageRegistry = MetricStorageRegistry;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/MultiWritableMetricStorage.js
var require_MultiWritableMetricStorage = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/state/MultiWritableMetricStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultiMetricStorage = void 0;
    var MultiMetricStorage = class {
      constructor(_backingStorages) {
        this._backingStorages = _backingStorages;
      }
      record(value, attributes, context3, recordTime) {
        this._backingStorages.forEach((it2) => {
          it2.record(value, attributes, context3, recordTime);
        });
      }
    };
    exports.MultiMetricStorage = MultiMetricStorage;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/ObservableResult.js
var require_ObservableResult = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/ObservableResult.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BatchObservableResultImpl = exports.ObservableResultImpl = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var HashMap_1 = require_HashMap();
    var Instruments_1 = require_Instruments();
    var ObservableResultImpl = class {
      constructor(_instrumentName, _valueType) {
        this._instrumentName = _instrumentName;
        this._valueType = _valueType;
        this._buffer = new HashMap_1.AttributeHashMap();
      }
      /**
       * Observe a measurement of the value associated with the given attributes.
       */
      observe(value, attributes = {}) {
        if (typeof value !== "number") {
          api_1.diag.warn(`non-number value provided to metric ${this._instrumentName}: ${value}`);
          return;
        }
        if (this._valueType === api_1.ValueType.INT && !Number.isInteger(value)) {
          api_1.diag.warn(`INT value type cannot accept a floating-point value for ${this._instrumentName}, ignoring the fractional digits.`);
          value = Math.trunc(value);
          if (!Number.isInteger(value)) {
            return;
          }
        }
        this._buffer.set(attributes, value);
      }
    };
    exports.ObservableResultImpl = ObservableResultImpl;
    var BatchObservableResultImpl = class {
      constructor() {
        this._buffer = /* @__PURE__ */ new Map();
      }
      /**
       * Observe a measurement of the value associated with the given attributes.
       */
      observe(metric, value, attributes = {}) {
        if (!(0, Instruments_1.isObservableInstrument)(metric)) {
          return;
        }
        let map15 = this._buffer.get(metric);
        if (map15 == null) {
          map15 = new HashMap_1.AttributeHashMap();
          this._buffer.set(metric, map15);
        }
        if (typeof value !== "number") {
          api_1.diag.warn(`non-number value provided to metric ${metric._descriptor.name}: ${value}`);
          return;
        }
        if (metric._descriptor.valueType === api_1.ValueType.INT && !Number.isInteger(value)) {
          api_1.diag.warn(`INT value type cannot accept a floating-point value for ${metric._descriptor.name}, ignoring the fractional digits.`);
          value = Math.trunc(value);
          if (!Number.isInteger(value)) {
            return;
          }
        }
        map15.set(attributes, value);
      }
    };
    exports.BatchObservableResultImpl = BatchObservableResultImpl;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/ObservableRegistry.js
var require_ObservableRegistry = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/state/ObservableRegistry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ObservableRegistry = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var Instruments_1 = require_Instruments();
    var ObservableResult_1 = require_ObservableResult();
    var utils_1 = require_utils12();
    var ObservableRegistry = class {
      constructor() {
        this._callbacks = [];
        this._batchCallbacks = [];
      }
      addCallback(callback, instrument) {
        const idx = this._findCallback(callback, instrument);
        if (idx >= 0) {
          return;
        }
        this._callbacks.push({ callback, instrument });
      }
      removeCallback(callback, instrument) {
        const idx = this._findCallback(callback, instrument);
        if (idx < 0) {
          return;
        }
        this._callbacks.splice(idx, 1);
      }
      addBatchCallback(callback, instruments) {
        const observableInstruments = new Set(instruments.filter(Instruments_1.isObservableInstrument));
        if (observableInstruments.size === 0) {
          api_1.diag.error("BatchObservableCallback is not associated with valid instruments", instruments);
          return;
        }
        const idx = this._findBatchCallback(callback, observableInstruments);
        if (idx >= 0) {
          return;
        }
        this._batchCallbacks.push({ callback, instruments: observableInstruments });
      }
      removeBatchCallback(callback, instruments) {
        const observableInstruments = new Set(instruments.filter(Instruments_1.isObservableInstrument));
        const idx = this._findBatchCallback(callback, observableInstruments);
        if (idx < 0) {
          return;
        }
        this._batchCallbacks.splice(idx, 1);
      }
      /**
       * @returns a promise of rejected reasons for invoking callbacks.
       */
      async observe(collectionTime, timeoutMillis) {
        const callbackFutures = this._observeCallbacks(collectionTime, timeoutMillis);
        const batchCallbackFutures = this._observeBatchCallbacks(collectionTime, timeoutMillis);
        const results = await (0, utils_1.PromiseAllSettled)([
          ...callbackFutures,
          ...batchCallbackFutures
        ]);
        const rejections = results.filter(utils_1.isPromiseAllSettledRejectionResult).map((it2) => it2.reason);
        return rejections;
      }
      _observeCallbacks(observationTime, timeoutMillis) {
        return this._callbacks.map(async ({ callback, instrument }) => {
          const observableResult = new ObservableResult_1.ObservableResultImpl(instrument._descriptor.name, instrument._descriptor.valueType);
          let callPromise = Promise.resolve(callback(observableResult));
          if (timeoutMillis != null) {
            callPromise = (0, utils_1.callWithTimeout)(callPromise, timeoutMillis);
          }
          await callPromise;
          instrument._metricStorages.forEach((metricStorage) => {
            metricStorage.record(observableResult._buffer, observationTime);
          });
        });
      }
      _observeBatchCallbacks(observationTime, timeoutMillis) {
        return this._batchCallbacks.map(async ({ callback, instruments }) => {
          const observableResult = new ObservableResult_1.BatchObservableResultImpl();
          let callPromise = Promise.resolve(callback(observableResult));
          if (timeoutMillis != null) {
            callPromise = (0, utils_1.callWithTimeout)(callPromise, timeoutMillis);
          }
          await callPromise;
          instruments.forEach((instrument) => {
            const buffer2 = observableResult._buffer.get(instrument);
            if (buffer2 == null) {
              return;
            }
            instrument._metricStorages.forEach((metricStorage) => {
              metricStorage.record(buffer2, observationTime);
            });
          });
        });
      }
      _findCallback(callback, instrument) {
        return this._callbacks.findIndex((record2) => {
          return record2.callback === callback && record2.instrument === instrument;
        });
      }
      _findBatchCallback(callback, instruments) {
        return this._batchCallbacks.findIndex((record2) => {
          return record2.callback === callback && (0, utils_1.setEquals)(record2.instruments, instruments);
        });
      }
    };
    exports.ObservableRegistry = ObservableRegistry;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/SyncMetricStorage.js
var require_SyncMetricStorage = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/state/SyncMetricStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SyncMetricStorage = void 0;
    var MetricStorage_1 = require_MetricStorage();
    var DeltaMetricProcessor_1 = require_DeltaMetricProcessor();
    var TemporalMetricProcessor_1 = require_TemporalMetricProcessor();
    var SyncMetricStorage = class extends MetricStorage_1.MetricStorage {
      constructor(instrumentDescriptor, aggregator, _attributesProcessor, collectorHandles) {
        super(instrumentDescriptor);
        this._attributesProcessor = _attributesProcessor;
        this._deltaMetricStorage = new DeltaMetricProcessor_1.DeltaMetricProcessor(aggregator);
        this._temporalMetricStorage = new TemporalMetricProcessor_1.TemporalMetricProcessor(aggregator, collectorHandles);
      }
      record(value, attributes, context3, recordTime) {
        attributes = this._attributesProcessor.process(attributes, context3);
        this._deltaMetricStorage.record(value, attributes, context3, recordTime);
      }
      /**
       * Collects the metrics from this storage.
       *
       * Note: This is a stateful operation and may reset any interval-related
       * state for the MetricCollector.
       */
      collect(collector, collectionTime) {
        const accumulations = this._deltaMetricStorage.collect();
        return this._temporalMetricStorage.buildMetrics(collector, this._instrumentDescriptor, accumulations, collectionTime);
      }
    };
    exports.SyncMetricStorage = SyncMetricStorage;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/AttributesProcessor.js
var require_AttributesProcessor = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/view/AttributesProcessor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FilteringAttributesProcessor = exports.NoopAttributesProcessor = exports.AttributesProcessor = void 0;
    var AttributesProcessor = class {
      static Noop() {
        return NOOP;
      }
    };
    exports.AttributesProcessor = AttributesProcessor;
    var NoopAttributesProcessor = class extends AttributesProcessor {
      process(incoming, _context) {
        return incoming;
      }
    };
    exports.NoopAttributesProcessor = NoopAttributesProcessor;
    var FilteringAttributesProcessor = class extends AttributesProcessor {
      constructor(_allowedAttributeNames) {
        super();
        this._allowedAttributeNames = _allowedAttributeNames;
      }
      process(incoming, _context) {
        const filteredAttributes = {};
        Object.keys(incoming).filter((attributeName) => this._allowedAttributeNames.includes(attributeName)).forEach((attributeName) => filteredAttributes[attributeName] = incoming[attributeName]);
        return filteredAttributes;
      }
    };
    exports.FilteringAttributesProcessor = FilteringAttributesProcessor;
    var NOOP = new NoopAttributesProcessor();
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/MeterSharedState.js
var require_MeterSharedState = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/state/MeterSharedState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MeterSharedState = void 0;
    var InstrumentDescriptor_1 = require_InstrumentDescriptor();
    var Meter_1 = require_Meter();
    var utils_1 = require_utils12();
    var AsyncMetricStorage_1 = require_AsyncMetricStorage();
    var MetricStorageRegistry_1 = require_MetricStorageRegistry();
    var MultiWritableMetricStorage_1 = require_MultiWritableMetricStorage();
    var ObservableRegistry_1 = require_ObservableRegistry();
    var SyncMetricStorage_1 = require_SyncMetricStorage();
    var AttributesProcessor_1 = require_AttributesProcessor();
    var MeterSharedState = class {
      constructor(_meterProviderSharedState, _instrumentationScope) {
        this._meterProviderSharedState = _meterProviderSharedState;
        this._instrumentationScope = _instrumentationScope;
        this.metricStorageRegistry = new MetricStorageRegistry_1.MetricStorageRegistry();
        this.observableRegistry = new ObservableRegistry_1.ObservableRegistry();
        this.meter = new Meter_1.Meter(this);
      }
      registerMetricStorage(descriptor3) {
        const storages = this._registerMetricStorage(descriptor3, SyncMetricStorage_1.SyncMetricStorage);
        if (storages.length === 1) {
          return storages[0];
        }
        return new MultiWritableMetricStorage_1.MultiMetricStorage(storages);
      }
      registerAsyncMetricStorage(descriptor3) {
        const storages = this._registerMetricStorage(descriptor3, AsyncMetricStorage_1.AsyncMetricStorage);
        return storages;
      }
      /**
       * @param collector opaque handle of {@link MetricCollector} which initiated the collection.
       * @param collectionTime the HrTime at which the collection was initiated.
       * @param options options for collection.
       * @returns the list of metric data collected.
       */
      async collect(collector, collectionTime, options) {
        const errors = await this.observableRegistry.observe(collectionTime, options === null || options === void 0 ? void 0 : options.timeoutMillis);
        const storages = this.metricStorageRegistry.getStorages(collector);
        if (storages.length === 0) {
          return null;
        }
        const metricDataList = storages.map((metricStorage) => {
          return metricStorage.collect(collector, collectionTime);
        }).filter(utils_1.isNotNullish);
        if (metricDataList.length === 0) {
          return { errors };
        }
        return {
          scopeMetrics: {
            scope: this._instrumentationScope,
            metrics: metricDataList
          },
          errors
        };
      }
      _registerMetricStorage(descriptor3, MetricStorageType) {
        const views = this._meterProviderSharedState.viewRegistry.findViews(descriptor3, this._instrumentationScope);
        let storages = views.map((view) => {
          const viewDescriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptorWithView)(view, descriptor3);
          const compatibleStorage = this.metricStorageRegistry.findOrUpdateCompatibleStorage(viewDescriptor);
          if (compatibleStorage != null) {
            return compatibleStorage;
          }
          const aggregator = view.aggregation.createAggregator(viewDescriptor);
          const viewStorage = new MetricStorageType(viewDescriptor, aggregator, view.attributesProcessor, this._meterProviderSharedState.metricCollectors);
          this.metricStorageRegistry.register(viewStorage);
          return viewStorage;
        });
        if (storages.length === 0) {
          const perCollectorAggregations = this._meterProviderSharedState.selectAggregations(descriptor3.type);
          const collectorStorages = perCollectorAggregations.map(([collector, aggregation]) => {
            const compatibleStorage = this.metricStorageRegistry.findOrUpdateCompatibleCollectorStorage(collector, descriptor3);
            if (compatibleStorage != null) {
              return compatibleStorage;
            }
            const aggregator = aggregation.createAggregator(descriptor3);
            const storage = new MetricStorageType(descriptor3, aggregator, AttributesProcessor_1.AttributesProcessor.Noop(), [collector]);
            this.metricStorageRegistry.registerForCollector(collector, storage);
            return storage;
          });
          storages = storages.concat(collectorStorages);
        }
        return storages;
      }
    };
    exports.MeterSharedState = MeterSharedState;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/MeterProviderSharedState.js
var require_MeterProviderSharedState = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/state/MeterProviderSharedState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MeterProviderSharedState = void 0;
    var utils_1 = require_utils12();
    var ViewRegistry_1 = require_ViewRegistry();
    var MeterSharedState_1 = require_MeterSharedState();
    var MeterProviderSharedState = class {
      constructor(resource) {
        this.resource = resource;
        this.viewRegistry = new ViewRegistry_1.ViewRegistry();
        this.metricCollectors = [];
        this.meterSharedStates = /* @__PURE__ */ new Map();
      }
      getMeterSharedState(instrumentationScope) {
        const id = (0, utils_1.instrumentationScopeId)(instrumentationScope);
        let meterSharedState = this.meterSharedStates.get(id);
        if (meterSharedState == null) {
          meterSharedState = new MeterSharedState_1.MeterSharedState(this, instrumentationScope);
          this.meterSharedStates.set(id, meterSharedState);
        }
        return meterSharedState;
      }
      selectAggregations(instrumentType) {
        const result4 = [];
        for (const collector of this.metricCollectors) {
          result4.push([collector, collector.selectAggregation(instrumentType)]);
        }
        return result4;
      }
    };
    exports.MeterProviderSharedState = MeterProviderSharedState;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricCollector.js
var require_MetricCollector = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricCollector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MetricCollector = void 0;
    var core_1 = require_src17();
    var MetricCollector = class {
      constructor(_sharedState, _metricReader) {
        this._sharedState = _sharedState;
        this._metricReader = _metricReader;
      }
      async collect(options) {
        const collectionTime = (0, core_1.millisToHrTime)(Date.now());
        const scopeMetrics = [];
        const errors = [];
        const meterCollectionPromises = Array.from(this._sharedState.meterSharedStates.values()).map(async (meterSharedState) => {
          const current = await meterSharedState.collect(this, collectionTime, options);
          if ((current === null || current === void 0 ? void 0 : current.scopeMetrics) != null) {
            scopeMetrics.push(current.scopeMetrics);
          }
          if ((current === null || current === void 0 ? void 0 : current.errors) != null) {
            errors.push(...current.errors);
          }
        });
        await Promise.all(meterCollectionPromises);
        return {
          resourceMetrics: {
            resource: this._sharedState.resource,
            scopeMetrics
          },
          errors
        };
      }
      /**
       * Delegates for MetricReader.forceFlush.
       */
      async forceFlush(options) {
        await this._metricReader.forceFlush(options);
      }
      /**
       * Delegates for MetricReader.shutdown.
       */
      async shutdown(options) {
        await this._metricReader.shutdown(options);
      }
      selectAggregationTemporality(instrumentType) {
        return this._metricReader.selectAggregationTemporality(instrumentType);
      }
      selectAggregation(instrumentType) {
        return this._metricReader.selectAggregation(instrumentType);
      }
    };
    exports.MetricCollector = MetricCollector;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/MeterProvider.js
var require_MeterProvider = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/MeterProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MeterProvider = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var resources_1 = require_src18();
    var MeterProviderSharedState_1 = require_MeterProviderSharedState();
    var MetricCollector_1 = require_MetricCollector();
    var MeterProvider = class {
      constructor(options) {
        var _a12;
        this._shutdown = false;
        const resource = resources_1.Resource.default().merge((_a12 = options === null || options === void 0 ? void 0 : options.resource) !== null && _a12 !== void 0 ? _a12 : resources_1.Resource.empty());
        this._sharedState = new MeterProviderSharedState_1.MeterProviderSharedState(resource);
        if ((options === null || options === void 0 ? void 0 : options.views) != null && options.views.length > 0) {
          for (const view of options.views) {
            this._sharedState.viewRegistry.addView(view);
          }
        }
        if ((options === null || options === void 0 ? void 0 : options.readers) != null && options.readers.length > 0) {
          for (const metricReader of options.readers) {
            this.addMetricReader(metricReader);
          }
        }
      }
      /**
       * Get a meter with the configuration of the MeterProvider.
       */
      getMeter(name, version = "", options = {}) {
        if (this._shutdown) {
          api_1.diag.warn("A shutdown MeterProvider cannot provide a Meter");
          return (0, api_1.createNoopMeter)();
        }
        return this._sharedState.getMeterSharedState({
          name,
          version,
          schemaUrl: options.schemaUrl
        }).meter;
      }
      /**
       * Register a {@link MetricReader} to the meter provider. After the
       * registration, the MetricReader can start metrics collection.
       *
       * <p> NOTE: {@link MetricReader} instances MUST be added before creating any instruments.
       * A {@link MetricReader} instance registered later may receive no or incomplete metric data.
       *
       * @param metricReader the metric reader to be registered.
       *
       * @deprecated This method will be removed in SDK 2.0. Please use
       * {@link MeterProviderOptions.readers} via the {@link MeterProvider} constructor instead
       */
      addMetricReader(metricReader) {
        const collector = new MetricCollector_1.MetricCollector(this._sharedState, metricReader);
        metricReader.setMetricProducer(collector);
        this._sharedState.metricCollectors.push(collector);
      }
      /**
       * Flush all buffered data and shut down the MeterProvider and all registered
       * MetricReaders.
       *
       * Returns a promise which is resolved when all flushes are complete.
       */
      async shutdown(options) {
        if (this._shutdown) {
          api_1.diag.warn("shutdown may only be called once per MeterProvider");
          return;
        }
        this._shutdown = true;
        await Promise.all(this._sharedState.metricCollectors.map((collector) => {
          return collector.shutdown(options);
        }));
      }
      /**
       * Notifies all registered MetricReaders to flush any buffered data.
       *
       * Returns a promise which is resolved when all flushes are complete.
       */
      async forceFlush(options) {
        if (this._shutdown) {
          api_1.diag.warn("invalid attempt to force flush after MeterProvider shutdown");
          return;
        }
        await Promise.all(this._sharedState.metricCollectors.map((collector) => {
          return collector.forceFlush(options);
        }));
      }
    };
    exports.MeterProvider = MeterProvider;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/Predicate.js
var require_Predicate = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/view/Predicate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExactPredicate = exports.PatternPredicate = void 0;
    var ESCAPE = /[\^$\\.+?()[\]{}|]/g;
    var PatternPredicate = class _PatternPredicate {
      constructor(pattern3) {
        if (pattern3 === "*") {
          this._matchAll = true;
          this._regexp = /.*/;
        } else {
          this._matchAll = false;
          this._regexp = new RegExp(_PatternPredicate.escapePattern(pattern3));
        }
      }
      match(str) {
        if (this._matchAll) {
          return true;
        }
        return this._regexp.test(str);
      }
      static escapePattern(pattern3) {
        return `^${pattern3.replace(ESCAPE, "\\$&").replace("*", ".*")}$`;
      }
      static hasWildcard(pattern3) {
        return pattern3.includes("*");
      }
    };
    exports.PatternPredicate = PatternPredicate;
    var ExactPredicate = class {
      constructor(pattern3) {
        this._matchAll = pattern3 === void 0;
        this._pattern = pattern3;
      }
      match(str) {
        if (this._matchAll) {
          return true;
        }
        if (str === this._pattern) {
          return true;
        }
        return false;
      }
    };
    exports.ExactPredicate = ExactPredicate;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/InstrumentSelector.js
var require_InstrumentSelector = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/view/InstrumentSelector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InstrumentSelector = void 0;
    var Predicate_1 = require_Predicate();
    var InstrumentSelector = class {
      constructor(criteria) {
        var _a12;
        this._nameFilter = new Predicate_1.PatternPredicate((_a12 = criteria === null || criteria === void 0 ? void 0 : criteria.name) !== null && _a12 !== void 0 ? _a12 : "*");
        this._type = criteria === null || criteria === void 0 ? void 0 : criteria.type;
        this._unitFilter = new Predicate_1.ExactPredicate(criteria === null || criteria === void 0 ? void 0 : criteria.unit);
      }
      getType() {
        return this._type;
      }
      getNameFilter() {
        return this._nameFilter;
      }
      getUnitFilter() {
        return this._unitFilter;
      }
    };
    exports.InstrumentSelector = InstrumentSelector;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/MeterSelector.js
var require_MeterSelector = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/view/MeterSelector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MeterSelector = void 0;
    var Predicate_1 = require_Predicate();
    var MeterSelector = class {
      constructor(criteria) {
        this._nameFilter = new Predicate_1.ExactPredicate(criteria === null || criteria === void 0 ? void 0 : criteria.name);
        this._versionFilter = new Predicate_1.ExactPredicate(criteria === null || criteria === void 0 ? void 0 : criteria.version);
        this._schemaUrlFilter = new Predicate_1.ExactPredicate(criteria === null || criteria === void 0 ? void 0 : criteria.schemaUrl);
      }
      getNameFilter() {
        return this._nameFilter;
      }
      /**
       * TODO: semver filter? no spec yet.
       */
      getVersionFilter() {
        return this._versionFilter;
      }
      getSchemaUrlFilter() {
        return this._schemaUrlFilter;
      }
    };
    exports.MeterSelector = MeterSelector;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/View.js
var require_View = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/view/View.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.View = void 0;
    var Predicate_1 = require_Predicate();
    var AttributesProcessor_1 = require_AttributesProcessor();
    var InstrumentSelector_1 = require_InstrumentSelector();
    var MeterSelector_1 = require_MeterSelector();
    var Aggregation_1 = require_Aggregation();
    function isSelectorNotProvided(options) {
      return options.instrumentName == null && options.instrumentType == null && options.instrumentUnit == null && options.meterName == null && options.meterVersion == null && options.meterSchemaUrl == null;
    }
    var View = class {
      /**
       * Create a new {@link View} instance.
       *
       * Parameters can be categorized as two types:
       *  Instrument selection criteria: Used to describe the instrument(s) this view will be applied to.
       *  Will be treated as additive (the Instrument has to meet all the provided criteria to be selected).
       *
       *  Metric stream altering: Alter the metric stream of instruments selected by instrument selection criteria.
       *
       * @param viewOptions {@link ViewOptions} for altering the metric stream and instrument selection.
       * @param viewOptions.name
       * Alters the metric stream:
       *  This will be used as the name of the metrics stream.
       *  If not provided, the original Instrument name will be used.
       * @param viewOptions.description
       * Alters the metric stream:
       *  This will be used as the description of the metrics stream.
       *  If not provided, the original Instrument description will be used by default.
       * @param viewOptions.attributeKeys
       * Alters the metric stream:
       *  If provided, the attributes that are not in the list will be ignored.
       *  If not provided, all attribute keys will be used by default.
       * @param viewOptions.aggregation
       * Alters the metric stream:
       *  Alters the {@link Aggregation} of the metric stream.
       * @param viewOptions.instrumentName
       * Instrument selection criteria:
       *  Original name of the Instrument(s) with wildcard support.
       * @param viewOptions.instrumentType
       * Instrument selection criteria:
       *  The original type of the Instrument(s).
       * @param viewOptions.instrumentUnit
       * Instrument selection criteria:
       *  The unit of the Instrument(s).
       * @param viewOptions.meterName
       * Instrument selection criteria:
       *  The name of the Meter. No wildcard support, name must match the meter exactly.
       * @param viewOptions.meterVersion
       * Instrument selection criteria:
       *  The version of the Meter. No wildcard support, version must match exactly.
       * @param viewOptions.meterSchemaUrl
       * Instrument selection criteria:
       *  The schema URL of the Meter. No wildcard support, schema URL must match exactly.
       *
       * @example
       * // Create a view that changes the Instrument 'my.instrument' to use to an
       * // ExplicitBucketHistogramAggregation with the boundaries [20, 30, 40]
       * new View({
       *   aggregation: new ExplicitBucketHistogramAggregation([20, 30, 40]),
       *   instrumentName: 'my.instrument'
       * })
       */
      constructor(viewOptions) {
        var _a12;
        if (isSelectorNotProvided(viewOptions)) {
          throw new Error("Cannot create view with no selector arguments supplied");
        }
        if (viewOptions.name != null && ((viewOptions === null || viewOptions === void 0 ? void 0 : viewOptions.instrumentName) == null || Predicate_1.PatternPredicate.hasWildcard(viewOptions.instrumentName))) {
          throw new Error("Views with a specified name must be declared with an instrument selector that selects at most one instrument per meter.");
        }
        if (viewOptions.attributeKeys != null) {
          this.attributesProcessor = new AttributesProcessor_1.FilteringAttributesProcessor(viewOptions.attributeKeys);
        } else {
          this.attributesProcessor = AttributesProcessor_1.AttributesProcessor.Noop();
        }
        this.name = viewOptions.name;
        this.description = viewOptions.description;
        this.aggregation = (_a12 = viewOptions.aggregation) !== null && _a12 !== void 0 ? _a12 : Aggregation_1.Aggregation.Default();
        this.instrumentSelector = new InstrumentSelector_1.InstrumentSelector({
          name: viewOptions.instrumentName,
          type: viewOptions.instrumentType,
          unit: viewOptions.instrumentUnit
        });
        this.meterSelector = new MeterSelector_1.MeterSelector({
          name: viewOptions.meterName,
          version: viewOptions.meterVersion,
          schemaUrl: viewOptions.meterSchemaUrl
        });
      }
    };
    exports.View = View;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/index.js
var require_src19 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TimeoutError = exports.View = exports.Aggregation = exports.SumAggregation = exports.LastValueAggregation = exports.HistogramAggregation = exports.DropAggregation = exports.ExponentialHistogramAggregation = exports.ExplicitBucketHistogramAggregation = exports.DefaultAggregation = exports.MeterProvider = exports.InstrumentType = exports.ConsoleMetricExporter = exports.InMemoryMetricExporter = exports.PeriodicExportingMetricReader = exports.MetricReader = exports.DataPointType = exports.AggregationTemporality = void 0;
    var AggregationTemporality_1 = require_AggregationTemporality();
    Object.defineProperty(exports, "AggregationTemporality", { enumerable: true, get: function() {
      return AggregationTemporality_1.AggregationTemporality;
    } });
    var MetricData_1 = require_MetricData();
    Object.defineProperty(exports, "DataPointType", { enumerable: true, get: function() {
      return MetricData_1.DataPointType;
    } });
    var MetricReader_1 = require_MetricReader();
    Object.defineProperty(exports, "MetricReader", { enumerable: true, get: function() {
      return MetricReader_1.MetricReader;
    } });
    var PeriodicExportingMetricReader_1 = require_PeriodicExportingMetricReader();
    Object.defineProperty(exports, "PeriodicExportingMetricReader", { enumerable: true, get: function() {
      return PeriodicExportingMetricReader_1.PeriodicExportingMetricReader;
    } });
    var InMemoryMetricExporter_1 = require_InMemoryMetricExporter();
    Object.defineProperty(exports, "InMemoryMetricExporter", { enumerable: true, get: function() {
      return InMemoryMetricExporter_1.InMemoryMetricExporter;
    } });
    var ConsoleMetricExporter_1 = require_ConsoleMetricExporter();
    Object.defineProperty(exports, "ConsoleMetricExporter", { enumerable: true, get: function() {
      return ConsoleMetricExporter_1.ConsoleMetricExporter;
    } });
    var InstrumentDescriptor_1 = require_InstrumentDescriptor();
    Object.defineProperty(exports, "InstrumentType", { enumerable: true, get: function() {
      return InstrumentDescriptor_1.InstrumentType;
    } });
    var MeterProvider_1 = require_MeterProvider();
    Object.defineProperty(exports, "MeterProvider", { enumerable: true, get: function() {
      return MeterProvider_1.MeterProvider;
    } });
    var Aggregation_1 = require_Aggregation();
    Object.defineProperty(exports, "DefaultAggregation", { enumerable: true, get: function() {
      return Aggregation_1.DefaultAggregation;
    } });
    Object.defineProperty(exports, "ExplicitBucketHistogramAggregation", { enumerable: true, get: function() {
      return Aggregation_1.ExplicitBucketHistogramAggregation;
    } });
    Object.defineProperty(exports, "ExponentialHistogramAggregation", { enumerable: true, get: function() {
      return Aggregation_1.ExponentialHistogramAggregation;
    } });
    Object.defineProperty(exports, "DropAggregation", { enumerable: true, get: function() {
      return Aggregation_1.DropAggregation;
    } });
    Object.defineProperty(exports, "HistogramAggregation", { enumerable: true, get: function() {
      return Aggregation_1.HistogramAggregation;
    } });
    Object.defineProperty(exports, "LastValueAggregation", { enumerable: true, get: function() {
      return Aggregation_1.LastValueAggregation;
    } });
    Object.defineProperty(exports, "SumAggregation", { enumerable: true, get: function() {
      return Aggregation_1.SumAggregation;
    } });
    Object.defineProperty(exports, "Aggregation", { enumerable: true, get: function() {
      return Aggregation_1.Aggregation;
    } });
    var View_1 = require_View();
    Object.defineProperty(exports, "View", { enumerable: true, get: function() {
      return View_1.View;
    } });
    var utils_1 = require_utils12();
    Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
      return utils_1.TimeoutError;
    } });
  }
});

// node_modules/@opentelemetry/otlp-transformer/build/src/metrics/internal.js
var require_internal4 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/build/src/metrics/internal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toMetric = exports.toScopeMetrics = exports.toResourceMetrics = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var sdk_metrics_1 = require_src19();
    var common_1 = require_common();
    var internal_1 = require_internal();
    var internal_2 = require_internal3();
    function toResourceMetrics(resourceMetrics, options) {
      const encoder = (0, common_1.getOtlpEncoder)(options);
      return {
        resource: (0, internal_2.createResource)(resourceMetrics.resource),
        schemaUrl: void 0,
        scopeMetrics: toScopeMetrics(resourceMetrics.scopeMetrics, encoder)
      };
    }
    exports.toResourceMetrics = toResourceMetrics;
    function toScopeMetrics(scopeMetrics, encoder) {
      return Array.from(scopeMetrics.map((metrics2) => ({
        scope: (0, internal_1.createInstrumentationScope)(metrics2.scope),
        metrics: metrics2.metrics.map((metricData) => toMetric(metricData, encoder)),
        schemaUrl: metrics2.scope.schemaUrl
      })));
    }
    exports.toScopeMetrics = toScopeMetrics;
    function toMetric(metricData, encoder) {
      const out = {
        name: metricData.descriptor.name,
        description: metricData.descriptor.description,
        unit: metricData.descriptor.unit
      };
      const aggregationTemporality = toAggregationTemporality(metricData.aggregationTemporality);
      switch (metricData.dataPointType) {
        case sdk_metrics_1.DataPointType.SUM:
          out.sum = {
            aggregationTemporality,
            isMonotonic: metricData.isMonotonic,
            dataPoints: toSingularDataPoints(metricData, encoder)
          };
          break;
        case sdk_metrics_1.DataPointType.GAUGE:
          out.gauge = {
            dataPoints: toSingularDataPoints(metricData, encoder)
          };
          break;
        case sdk_metrics_1.DataPointType.HISTOGRAM:
          out.histogram = {
            aggregationTemporality,
            dataPoints: toHistogramDataPoints(metricData, encoder)
          };
          break;
        case sdk_metrics_1.DataPointType.EXPONENTIAL_HISTOGRAM:
          out.exponentialHistogram = {
            aggregationTemporality,
            dataPoints: toExponentialHistogramDataPoints(metricData, encoder)
          };
          break;
      }
      return out;
    }
    exports.toMetric = toMetric;
    function toSingularDataPoint(dataPoint, valueType, encoder) {
      const out = {
        attributes: (0, internal_1.toAttributes)(dataPoint.attributes),
        startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),
        timeUnixNano: encoder.encodeHrTime(dataPoint.endTime)
      };
      switch (valueType) {
        case api_1.ValueType.INT:
          out.asInt = dataPoint.value;
          break;
        case api_1.ValueType.DOUBLE:
          out.asDouble = dataPoint.value;
          break;
      }
      return out;
    }
    function toSingularDataPoints(metricData, encoder) {
      return metricData.dataPoints.map((dataPoint) => {
        return toSingularDataPoint(dataPoint, metricData.descriptor.valueType, encoder);
      });
    }
    function toHistogramDataPoints(metricData, encoder) {
      return metricData.dataPoints.map((dataPoint) => {
        const histogram = dataPoint.value;
        return {
          attributes: (0, internal_1.toAttributes)(dataPoint.attributes),
          bucketCounts: histogram.buckets.counts,
          explicitBounds: histogram.buckets.boundaries,
          count: histogram.count,
          sum: histogram.sum,
          min: histogram.min,
          max: histogram.max,
          startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),
          timeUnixNano: encoder.encodeHrTime(dataPoint.endTime)
        };
      });
    }
    function toExponentialHistogramDataPoints(metricData, encoder) {
      return metricData.dataPoints.map((dataPoint) => {
        const histogram = dataPoint.value;
        return {
          attributes: (0, internal_1.toAttributes)(dataPoint.attributes),
          count: histogram.count,
          min: histogram.min,
          max: histogram.max,
          sum: histogram.sum,
          positive: {
            offset: histogram.positive.offset,
            bucketCounts: histogram.positive.bucketCounts
          },
          negative: {
            offset: histogram.negative.offset,
            bucketCounts: histogram.negative.bucketCounts
          },
          scale: histogram.scale,
          zeroCount: histogram.zeroCount,
          startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),
          timeUnixNano: encoder.encodeHrTime(dataPoint.endTime)
        };
      });
    }
    function toAggregationTemporality(temporality) {
      switch (temporality) {
        case sdk_metrics_1.AggregationTemporality.DELTA:
          return 1;
        case sdk_metrics_1.AggregationTemporality.CUMULATIVE:
          return 2;
      }
    }
  }
});

// node_modules/@opentelemetry/otlp-transformer/build/src/metrics/index.js
var require_metrics = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/build/src/metrics/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createExportMetricsServiceRequest = void 0;
    var internal_1 = require_internal4();
    function createExportMetricsServiceRequest(resourceMetrics, options) {
      return {
        resourceMetrics: resourceMetrics.map((metrics2) => (0, internal_1.toResourceMetrics)(metrics2, options))
      };
    }
    exports.createExportMetricsServiceRequest = createExportMetricsServiceRequest;
  }
});

// node_modules/@opentelemetry/otlp-transformer/build/src/logs/index.js
var require_logs = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/build/src/logs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toLogAttributes = exports.createExportLogsServiceRequest = void 0;
    var common_1 = require_common();
    var internal_1 = require_internal();
    var internal_2 = require_internal3();
    function createExportLogsServiceRequest(logRecords, options) {
      const encoder = (0, common_1.getOtlpEncoder)(options);
      return {
        resourceLogs: logRecordsToResourceLogs(logRecords, encoder)
      };
    }
    exports.createExportLogsServiceRequest = createExportLogsServiceRequest;
    function createResourceMap(logRecords) {
      const resourceMap = /* @__PURE__ */ new Map();
      for (const record2 of logRecords) {
        const { resource, instrumentationScope: { name, version = "", schemaUrl = "" } } = record2;
        let ismMap = resourceMap.get(resource);
        if (!ismMap) {
          ismMap = /* @__PURE__ */ new Map();
          resourceMap.set(resource, ismMap);
        }
        const ismKey = `${name}@${version}:${schemaUrl}`;
        let records = ismMap.get(ismKey);
        if (!records) {
          records = [];
          ismMap.set(ismKey, records);
        }
        records.push(record2);
      }
      return resourceMap;
    }
    function logRecordsToResourceLogs(logRecords, encoder) {
      const resourceMap = createResourceMap(logRecords);
      return Array.from(resourceMap, ([resource, ismMap]) => ({
        resource: (0, internal_2.createResource)(resource),
        scopeLogs: Array.from(ismMap, ([, scopeLogs]) => {
          return {
            scope: (0, internal_1.createInstrumentationScope)(scopeLogs[0].instrumentationScope),
            logRecords: scopeLogs.map((log3) => toLogRecord(log3, encoder)),
            schemaUrl: scopeLogs[0].instrumentationScope.schemaUrl
          };
        }),
        schemaUrl: void 0
      }));
    }
    function toLogRecord(log3, encoder) {
      var _a12, _b5, _c4;
      return {
        timeUnixNano: encoder.encodeHrTime(log3.hrTime),
        observedTimeUnixNano: encoder.encodeHrTime(log3.hrTimeObserved),
        severityNumber: toSeverityNumber(log3.severityNumber),
        severityText: log3.severityText,
        body: (0, internal_1.toAnyValue)(log3.body),
        attributes: toLogAttributes(log3.attributes),
        droppedAttributesCount: log3.droppedAttributesCount,
        flags: (_a12 = log3.spanContext) === null || _a12 === void 0 ? void 0 : _a12.traceFlags,
        traceId: encoder.encodeOptionalSpanContext((_b5 = log3.spanContext) === null || _b5 === void 0 ? void 0 : _b5.traceId),
        spanId: encoder.encodeOptionalSpanContext((_c4 = log3.spanContext) === null || _c4 === void 0 ? void 0 : _c4.spanId)
      };
    }
    function toSeverityNumber(severityNumber) {
      return severityNumber;
    }
    function toLogAttributes(attributes) {
      return Object.keys(attributes).map((key) => (0, internal_1.toKeyValue)(key, attributes[key]));
    }
    exports.toLogAttributes = toLogAttributes;
  }
});

// node_modules/@opentelemetry/otlp-transformer/build/src/index.js
var require_src20 = __commonJS({
  "node_modules/@opentelemetry/otlp-transformer/build/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createExportLogsServiceRequest = exports.createExportMetricsServiceRequest = exports.createExportTraceServiceRequest = void 0;
    __exportStar(require_types6(), exports);
    __exportStar(require_common(), exports);
    __exportStar(require_types8(), exports);
    __exportStar(require_types9(), exports);
    __exportStar(require_types10(), exports);
    __exportStar(require_types11(), exports);
    var trace_1 = require_trace5();
    Object.defineProperty(exports, "createExportTraceServiceRequest", { enumerable: true, get: function() {
      return trace_1.createExportTraceServiceRequest;
    } });
    var metrics_1 = require_metrics();
    Object.defineProperty(exports, "createExportMetricsServiceRequest", { enumerable: true, get: function() {
      return metrics_1.createExportMetricsServiceRequest;
    } });
    var logs_1 = require_logs();
    Object.defineProperty(exports, "createExportLogsServiceRequest", { enumerable: true, get: function() {
      return logs_1.createExportLogsServiceRequest;
    } });
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/build/src/version.js
var require_version7 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/build/src/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VERSION = void 0;
    exports.VERSION = "0.51.1";
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/build/src/OTLPTraceExporter.js
var require_OTLPTraceExporter = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/build/src/OTLPTraceExporter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OTLPTraceExporter = void 0;
    var core_1 = require_src5();
    var otlp_grpc_exporter_base_1 = require_src13();
    var otlp_transformer_1 = require_src20();
    var version_1 = require_version7();
    var USER_AGENT = {
      "User-Agent": `OTel-OTLP-Exporter-JavaScript/${version_1.VERSION}`
    };
    var OTLPTraceExporter2 = class extends otlp_grpc_exporter_base_1.OTLPGRPCExporterNodeBase {
      constructor(config = {}) {
        const signalSpecificMetadata = Object.assign(Object.assign({}, USER_AGENT), core_1.baggageUtils.parseKeyPairsIntoRecord((0, core_1.getEnv)().OTEL_EXPORTER_OTLP_TRACES_HEADERS));
        super(config, signalSpecificMetadata, "TraceExportService", "/opentelemetry.proto.collector.trace.v1.TraceService/Export", otlp_grpc_exporter_base_1.TraceSerializer);
      }
      convert(spans) {
        return (0, otlp_transformer_1.createExportTraceServiceRequest)(spans);
      }
      getDefaultUrl(config) {
        return (0, otlp_grpc_exporter_base_1.validateAndNormalizeUrl)(this.getUrlFromConfig(config));
      }
      getUrlFromConfig(config) {
        if (typeof config.url === "string") {
          return config.url;
        }
        return (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_TRACES_ENDPOINT || (0, core_1.getEnv)().OTEL_EXPORTER_OTLP_ENDPOINT || otlp_grpc_exporter_base_1.DEFAULT_COLLECTOR_URL;
      }
    };
    exports.OTLPTraceExporter = OTLPTraceExporter2;
  }
});

// node_modules/@opentelemetry/exporter-trace-otlp-grpc/build/src/index.js
var require_src21 = __commonJS({
  "node_modules/@opentelemetry/exporter-trace-otlp-grpc/build/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_OTLPTraceExporter(), exports);
  }
});

// contentlayer.config.ts
import path8 from "path";

// node_modules/@js-temporal/polyfill/dist/index.esm.js
import e from "jsbi";
var t = {};
function MakeIntrinsicClass(e2, t2) {
  Object.defineProperty(e2.prototype, Symbol.toStringTag, { value: t2, writable: false, enumerable: false, configurable: true });
  for (const t3 of Object.getOwnPropertyNames(e2)) {
    const r2 = Object.getOwnPropertyDescriptor(e2, t3);
    r2.configurable && r2.enumerable && (r2.enumerable = false, Object.defineProperty(e2, t3, r2));
  }
  for (const t3 of Object.getOwnPropertyNames(e2.prototype)) {
    const r2 = Object.getOwnPropertyDescriptor(e2.prototype, t3);
    r2.configurable && r2.enumerable && (r2.enumerable = false, Object.defineProperty(e2.prototype, t3, r2));
  }
  DefineIntrinsic(t2, e2), DefineIntrinsic(`${t2}.prototype`, e2.prototype);
}
function DefineIntrinsic(e2, r2) {
  const o2 = `%${e2}%`;
  if (void 0 !== t[o2])
    throw new Error(`intrinsic ${e2} already exists`);
  t[o2] = r2;
}
function GetIntrinsic(e2) {
  return t[e2];
}
var r;
var o;
var n = "slot-epochNanoSeconds";
var a = "slot-timezone-identifier";
var i = "slot-year";
var s = "slot-month";
var l = "slot-day";
var d = "slot-hour";
var m = "slot-minute";
var c = "slot-second";
var h = "slot-millisecond";
var u = "slot-microsecond";
var T = "slot-nanosecond";
var p = "slot-calendar";
var f = "slot-date-brand";
var y = "slot-year-month-brand";
var I = "slot-month-day-brand";
var S = "slot-cached-instant";
var g = "slot-time-zone";
var w = "slot-years";
var D = "slot-months";
var G = "slot-weeks";
var v = "slot-days";
var C = "slot-hours";
var O = "slot-minutes";
var b = "slot-seconds";
var E = "slot-milliseconds";
var M = "slot-microseconds";
var R = "slot-nanoseconds";
var F = "slot-calendar-identifier";
var Y = /* @__PURE__ */ new WeakMap();
var P = Symbol.for("@@Temporal__GetSlots");
(r = globalThis)[P] || (r[P] = function _GetSlots(e2) {
  return Y.get(e2);
});
var Z = globalThis[P];
var B = Symbol.for("@@Temporal__CreateSlots");
(o = globalThis)[B] || (o[B] = function _CreateSlots(e2) {
  Y.set(e2, /* @__PURE__ */ Object.create(null));
});
var N = globalThis[B];
function HasSlot(e2, ...t2) {
  if (!e2 || "object" != typeof e2)
    return false;
  const r2 = Z(e2);
  return !!r2 && t2.every((e3) => e3 in r2);
}
function GetSlot(e2, t2) {
  const r2 = Z(e2)?.[t2];
  if (void 0 === r2)
    throw new TypeError(`Missing internal slot ${t2}`);
  return r2;
}
function SetSlot(e2, t2, r2) {
  const o2 = Z(e2);
  if (void 0 === o2)
    throw new TypeError("Missing slots for the given container");
  if (o2[t2])
    throw new TypeError(`${t2} already has set`);
  o2[t2] = r2;
}
var j = /\.[-A-Za-z_]|\.\.[-A-Za-z._]{1,12}|\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/;
var $ = new RegExp("(?:" + [`(?:${j.source})(?:\\/(?:${j.source}))*`, "Etc/GMT(?:0|[-+]\\d{1,2})", "GMT[-+]?0", "EST5EDT", "CST6CDT", "MST7MDT", "PST8PDT", /(?:[+\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\d{1,9})?)?)?)/.source].join("|") + ")");
var k = /(?:[+\u2212-]\d{6}|\d{4})/;
var U = /(?:0[1-9]|1[0-2])/;
var A = /(?:0[1-9]|[12]\d|3[01])/;
var L = new RegExp(`(${k.source})(?:-(${U.source})-(${A.source})|(${U.source})(${A.source}))`);
var x = /(\d{2})(?::(\d{2})(?::(\d{2})(?:[.,](\d{1,9}))?)?|(\d{2})(?:(\d{2})(?:[.,](\d{1,9}))?)?)?/;
var W = /([+\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\d{1,9}))?)?)?/;
var q = new RegExp(`([zZ])|${W.source}?`);
var H = /\[(!)?([a-z_][a-z0-9_-]*)=([A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)\]/g;
var V = new RegExp([`^${L.source}`, `(?:(?:T|\\s+)${x.source}(?:${q.source})?)?`, `(?:\\[!?(${$.source})\\])?`, `((?:${H.source})*)$`].join(""), "i");
var z = new RegExp([`^T?${x.source}`, `(?:${q.source})?`, `(?:\\[!?${$.source}\\])?`, `((?:${H.source})*)$`].join(""), "i");
var _ = new RegExp(`^(${k.source})-?(${U.source})(?:\\[!?${$.source}\\])?((?:${H.source})*)$`);
var J = new RegExp(`^(?:--)?(${U.source})-?(${A.source})(?:\\[!?${$.source}\\])?((?:${H.source})*)$`);
var K = /(\d+)(?:[.,](\d{1,9}))?/;
var X = new RegExp(`(?:${K.source}H)?(?:${K.source}M)?(?:${K.source}S)?`);
var Q = new RegExp(`^([+\u2212-])?P${/(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?/.source}(?:T(?!$)${X.source})?$`, "i");
var ee = Array.prototype.includes;
var te = Array.prototype.push;
var re = globalThis.Intl.DateTimeFormat;
var oe = Math.min;
var ne = Math.max;
var ae = Math.abs;
var ie = Math.floor;
var se = Math.sign;
var le = Math.trunc;
var de = Number.isNaN;
var me = Number.isFinite;
var ce = Number;
var he = String;
var ue = Number.MAX_SAFE_INTEGER;
var Te = Object.create;
var pe = Object.getOwnPropertyDescriptor;
var fe = Reflect.apply;
var ye = Reflect.ownKeys;
var Ie = e.BigInt(0);
var Se = e.BigInt(1);
var ge = e.BigInt(60);
var we = e.BigInt(24);
var De = e.BigInt(1e3);
var Ge = e.BigInt(1e6);
var ve = e.BigInt(1e9);
var Ce = e.BigInt(-1);
var Oe = e.multiply(e.BigInt(3600), ve);
var be = e.multiply(ge, ve);
var Ee = e.multiply(Oe, we);
var Me = e.multiply(e.BigInt(-86400), e.BigInt(1e17));
var Re = e.multiply(e.BigInt(86400), e.BigInt(1e17));
var Fe = -271821;
var Ye = 275760;
var Pe = e.multiply(e.BigInt(-388152), e.BigInt(1e13));
var Ze = e.multiply(Ee, e.BigInt(3660));
var Be = e.multiply(Ee, e.BigInt(366));
var Ne = e.multiply(Ee, e.BigInt(14));
var je = ["iso8601", "hebrew", "islamic", "islamic-umalqura", "islamic-tbla", "islamic-civil", "islamic-rgsa", "islamicc", "persian", "ethiopic", "ethioaa", "coptic", "chinese", "dangi", "roc", "indian", "buddhist", "japanese", "gregory"];
function isZero(t2) {
  return e.equal(t2, Ie);
}
function GetMethod(e2, t2) {
  const r2 = e2[t2];
  if (void 0 !== r2)
    return r2;
}
function Call(e2, t2, r2) {
  const o2 = arguments.length > 2 ? r2 : [];
  return fe(e2, t2, o2);
}
function IsObject(e2) {
  return "object" == typeof e2 && null !== e2 || "function" == typeof e2;
}
function ToNumber(e2) {
  if ("bigint" == typeof e2)
    throw new TypeError("Cannot convert BigInt to number");
  return ce(e2);
}
function ToIntegerOrInfinity(e2) {
  const t2 = ToNumber(e2);
  if (de(t2) || 0 === t2)
    return 0;
  if (!me(t2))
    return t2;
  const r2 = ie(ae(t2));
  return 0 === r2 ? 0 : se(t2) * r2;
}
function IsIntegralNumber(e2) {
  if ("number" != typeof e2 || de(e2) || !me(e2))
    return false;
  const t2 = ae(e2);
  return ie(t2) === t2;
}
function ToString(e2) {
  if ("symbol" == typeof e2)
    throw new TypeError("Cannot convert a Symbol value to a String");
  return he(e2);
}
function ToIntegerWithTruncation(e2) {
  const t2 = ToNumber(e2);
  if (0 === t2)
    return 0;
  if (de(t2) || !me(t2))
    throw new RangeError("invalid number value");
  const r2 = le(t2);
  return 0 === r2 ? 0 : r2;
}
function ToPositiveIntegerWithTruncation(e2, t2) {
  const r2 = ToIntegerWithTruncation(e2);
  if (r2 <= 0) {
    if (void 0 !== t2)
      throw new RangeError(`property '${t2}' cannot be a a number less than one`);
    throw new RangeError("Cannot convert a number less than one to a positive integer");
  }
  return r2;
}
function ToIntegerIfIntegral(e2) {
  const t2 = ToNumber(e2);
  if (!me(t2))
    throw new RangeError("infinity is out of range");
  if (!IsIntegralNumber(t2))
    throw new RangeError(`unsupported fractional value ${e2}`);
  return 0 === t2 ? 0 : t2;
}
function divmod(t2, r2) {
  return { quotient: e.divide(t2, r2), remainder: e.remainder(t2, r2) };
}
function isNegativeJSBI(t2) {
  return e.lessThan(t2, Ie);
}
function signJSBI(e2) {
  return isZero(e2) ? 0 : isNegativeJSBI(e2) ? -1 : 1;
}
function abs(t2) {
  return e.lessThan(t2, Ie) ? e.multiply(t2, Ce) : t2;
}
var $e = /* @__PURE__ */ new Map([["year", ToIntegerWithTruncation], ["month", ToPositiveIntegerWithTruncation], ["monthCode", ToString], ["day", ToPositiveIntegerWithTruncation], ["hour", ToIntegerWithTruncation], ["minute", ToIntegerWithTruncation], ["second", ToIntegerWithTruncation], ["millisecond", ToIntegerWithTruncation], ["microsecond", ToIntegerWithTruncation], ["nanosecond", ToIntegerWithTruncation], ["years", ToIntegerIfIntegral], ["months", ToIntegerIfIntegral], ["weeks", ToIntegerIfIntegral], ["days", ToIntegerIfIntegral], ["hours", ToIntegerIfIntegral], ["minutes", ToIntegerIfIntegral], ["seconds", ToIntegerIfIntegral], ["milliseconds", ToIntegerIfIntegral], ["microseconds", ToIntegerIfIntegral], ["nanoseconds", ToIntegerIfIntegral], ["era", ToString], ["eraYear", ToIntegerOrInfinity], ["offset", ToString]]);
var ke = /* @__PURE__ */ new Map([["hour", 0], ["minute", 0], ["second", 0], ["millisecond", 0], ["microsecond", 0], ["nanosecond", 0]]);
var Ue = [["years", "year", "date"], ["months", "month", "date"], ["weeks", "week", "date"], ["days", "day", "date"], ["hours", "hour", "time"], ["minutes", "minute", "time"], ["seconds", "second", "time"], ["milliseconds", "millisecond", "time"], ["microseconds", "microsecond", "time"], ["nanoseconds", "nanosecond", "time"]];
var Ae = new Map(Ue.map((e2) => [e2[0], e2[1]]));
var Le = new Map(Ue.map(([e2, t2]) => [t2, e2]));
var xe = Ue.map(([, e2]) => e2);
var We = Array.from(Ae.keys()).sort();
var qe = /* @__PURE__ */ new Map();
function getIntlDateTimeFormatEnUsForTimeZone(e2) {
  let t2 = qe.get(e2);
  return void 0 === t2 && (t2 = new re("en-us", { timeZone: he(e2), hour12: false, era: "short", year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric", second: "numeric" }), qe.set(e2, t2)), t2;
}
function ToObject(e2) {
  if (null == e2)
    throw new TypeError(`Expected object not ${e2}`);
  return Object(e2);
}
function CopyDataProperties(e2, t2, r2, o2) {
  if (null == t2)
    return;
  const n2 = ye(t2);
  for (const a2 of n2)
    if (!r2.some((e3) => Object.is(e3, a2)) && Object.prototype.propertyIsEnumerable.call(t2, a2)) {
      const r3 = t2[a2];
      if (o2 && o2.some((e3) => Object.is(e3, r3)))
        continue;
      e2[a2] = r3;
    }
}
function IsTemporalInstant(e2) {
  return HasSlot(e2, n) && !HasSlot(e2, g, p);
}
function IsTemporalTimeZone(e2) {
  return HasSlot(e2, a);
}
function IsTemporalCalendar(e2) {
  return HasSlot(e2, F);
}
function IsTemporalDuration(e2) {
  return HasSlot(e2, w, D, v, C, O, b, E, M, R);
}
function IsTemporalDate(e2) {
  return HasSlot(e2, f);
}
function IsTemporalTime(e2) {
  return HasSlot(e2, d, m, c, h, u, T) && !HasSlot(e2, i, s, l);
}
function IsTemporalDateTime(e2) {
  return HasSlot(e2, i, s, l, d, m, c, h, u, T);
}
function IsTemporalYearMonth(e2) {
  return HasSlot(e2, y);
}
function IsTemporalMonthDay(e2) {
  return HasSlot(e2, I);
}
function IsTemporalZonedDateTime(e2) {
  return HasSlot(e2, n, g, p);
}
function RejectTemporalLikeObject(e2) {
  if (HasSlot(e2, p) || HasSlot(e2, g))
    throw new TypeError("with() does not support a calendar or timeZone property");
  if (IsTemporalTime(e2))
    throw new TypeError("with() does not accept Temporal.PlainTime, use withPlainTime() instead");
  if (void 0 !== e2.calendar)
    throw new TypeError("with() does not support a calendar property");
  if (void 0 !== e2.timeZone)
    throw new TypeError("with() does not support a timeZone property");
}
function ParseTemporalTimeZone(e2) {
  const { ianaName: t2, offset: r2, z: o2 } = function ParseTemporalTimeZoneString(e3) {
    if (new RegExp(`^${$.source}$`, "i").test(e3))
      return { ianaName: e3 };
    try {
      const t3 = ParseISODateTime(e3);
      if (t3.z || t3.offset || t3.ianaName)
        return t3;
    } catch {
    }
    throw new RangeError(`Invalid time zone: ${e3}`);
  }(e2);
  if (t2)
    return GetCanonicalTimeZoneIdentifier(t2);
  if (o2)
    return "UTC";
  return FormatTimeZoneOffsetString(ParseTimeZoneOffsetString(r2));
}
function MaybeFormatCalendarAnnotation(e2, t2) {
  return "never" === t2 ? "" : FormatCalendarAnnotation(ToTemporalCalendarIdentifier(e2), t2);
}
function FormatCalendarAnnotation(e2, t2) {
  if ("never" === t2)
    return "";
  if ("auto" === t2 && "iso8601" === e2)
    return "";
  return `[${"critical" === t2 ? "!" : ""}u-ca=${e2}]`;
}
function ParseISODateTime(e2) {
  const t2 = V.exec(e2);
  if (!t2)
    throw new RangeError(`invalid ISO 8601 string: ${e2}`);
  let r2 = t2[1];
  if ("\u2212" === r2[0] && (r2 = `-${r2.slice(1)}`), "-000000" === r2)
    throw new RangeError(`invalid ISO 8601 string: ${e2}`);
  const o2 = ToIntegerOrInfinity(r2), n2 = ToIntegerOrInfinity(t2[2] || t2[4]), a2 = ToIntegerOrInfinity(t2[3] || t2[5]), i2 = ToIntegerOrInfinity(t2[6]), s2 = void 0 !== t2[6], l2 = ToIntegerOrInfinity(t2[7] || t2[10]);
  let d2 = ToIntegerOrInfinity(t2[8] || t2[11]);
  60 === d2 && (d2 = 59);
  const m2 = (t2[9] || t2[12]) + "000000000", c2 = ToIntegerOrInfinity(m2.slice(0, 3)), h2 = ToIntegerOrInfinity(m2.slice(3, 6)), u2 = ToIntegerOrInfinity(m2.slice(6, 9));
  let T2, p2 = false;
  if (t2[13])
    T2 = void 0, p2 = true;
  else if (t2[14] && t2[15]) {
    const e3 = "-" === t2[14] || "\u2212" === t2[14] ? "-" : "+", r3 = t2[15] || "00", o3 = t2[16] || "00", n3 = t2[17] || "00";
    let a3 = t2[18] || "0";
    if (T2 = `${e3}${r3}:${o3}`, +a3) {
      for (; a3.endsWith("0"); )
        a3 = a3.slice(0, -1);
      T2 += `:${n3}.${a3}`;
    } else
      +n3 && (T2 += `:${n3}`);
    "-00:00" === T2 && (T2 = "+00:00");
  }
  const f2 = t2[19], y2 = t2[20];
  let I2;
  for (const [, e3, t3, r3] of y2.matchAll(H))
    if ("u-ca" === t3)
      void 0 === I2 && (I2 = r3);
    else if ("!" === e3)
      throw new RangeError(`Unrecognized annotation: !${t3}=${r3}`);
  return RejectDateTime(o2, n2, a2, i2, l2, d2, c2, h2, u2), { year: o2, month: n2, day: a2, hasTime: s2, hour: i2, minute: l2, second: d2, millisecond: c2, microsecond: h2, nanosecond: u2, ianaName: f2, offset: T2, z: p2, calendar: I2 };
}
function ParseTemporalYearMonthString(e2) {
  const t2 = _.exec(e2);
  let r2, o2, n2, a2;
  if (t2) {
    let a3 = t2[1];
    if ("\u2212" === a3[0] && (a3 = `-${a3.slice(1)}`), "-000000" === a3)
      throw new RangeError(`invalid ISO 8601 string: ${e2}`);
    r2 = ToIntegerOrInfinity(a3), o2 = ToIntegerOrInfinity(t2[2]);
    const i2 = t2[3];
    for (const [, e3, t3, r3] of i2.matchAll(H))
      if ("u-ca" === t3)
        void 0 === n2 && (n2 = r3);
      else if ("!" === e3)
        throw new RangeError(`Unrecognized annotation: !${t3}=${r3}`);
    if (void 0 !== n2 && "iso8601" !== n2)
      throw new RangeError("YYYY-MM format is only valid with iso8601 calendar");
  } else {
    let t3;
    if ({ year: r2, month: o2, calendar: n2, day: a2, z: t3 } = ParseISODateTime(e2), t3)
      throw new RangeError("Z designator not supported for PlainYearMonth");
  }
  return { year: r2, month: o2, calendar: n2, referenceISODay: a2 };
}
function ParseTemporalMonthDayString(e2) {
  const t2 = J.exec(e2);
  let r2, o2, n2, a2;
  if (t2) {
    r2 = ToIntegerOrInfinity(t2[1]), o2 = ToIntegerOrInfinity(t2[2]);
    const e3 = t2[3];
    for (const [, t3, r3, o3] of e3.matchAll(H))
      if ("u-ca" === r3)
        void 0 === n2 && (n2 = o3);
      else if ("!" === t3)
        throw new RangeError(`Unrecognized annotation: !${r3}=${o3}`);
    if (void 0 !== n2 && "iso8601" !== n2)
      throw new RangeError("MM-DD format is only valid with iso8601 calendar");
  } else {
    let t3;
    if ({ month: r2, day: o2, calendar: n2, year: a2, z: t3 } = ParseISODateTime(e2), t3)
      throw new RangeError("Z designator not supported for PlainMonthDay");
  }
  return { month: r2, day: o2, calendar: n2, referenceISOYear: a2 };
}
function ParseTemporalInstant(e2) {
  let { year: t2, month: r2, day: o2, hour: n2, minute: a2, second: i2, millisecond: s2, microsecond: l2, nanosecond: d2, offset: m2, z: c2 } = function ParseTemporalInstantString(e3) {
    const t3 = ParseISODateTime(e3);
    if (!t3.z && !t3.offset)
      throw new RangeError("Temporal.Instant requires a time zone offset");
    return t3;
  }(e2);
  if (!c2 && !m2)
    throw new RangeError("Temporal.Instant requires a time zone offset");
  const h2 = c2 ? 0 : ParseTimeZoneOffsetString(m2);
  ({ year: t2, month: r2, day: o2, hour: n2, minute: a2, second: i2, millisecond: s2, microsecond: l2, nanosecond: d2 } = BalanceISODateTime(t2, r2, o2, n2, a2, i2, s2, l2, d2 - h2));
  const u2 = GetUTCEpochNanoseconds(t2, r2, o2, n2, a2, i2, s2, l2, d2);
  if (null === u2)
    throw new RangeError("DateTime outside of supported range");
  return u2;
}
function RegulateISODate(e2, t2, r2, o2) {
  let n2 = e2, a2 = t2, i2 = r2;
  switch (o2) {
    case "reject":
      RejectISODate(n2, a2, i2);
      break;
    case "constrain":
      ({ year: n2, month: a2, day: i2 } = ConstrainISODate(n2, a2, i2));
  }
  return { year: n2, month: a2, day: i2 };
}
function RegulateTime(e2, t2, r2, o2, n2, a2, i2) {
  let s2 = e2, l2 = t2, d2 = r2, m2 = o2, c2 = n2, h2 = a2;
  switch (i2) {
    case "reject":
      RejectTime(s2, l2, d2, m2, c2, h2);
      break;
    case "constrain":
      ({ hour: s2, minute: l2, second: d2, millisecond: m2, microsecond: c2, nanosecond: h2 } = function ConstrainTime(e3, t3, r3, o3, n3, a3) {
        const i3 = ConstrainToRange(e3, 0, 23), s3 = ConstrainToRange(t3, 0, 59), l3 = ConstrainToRange(r3, 0, 59), d3 = ConstrainToRange(o3, 0, 999), m3 = ConstrainToRange(n3, 0, 999), c3 = ConstrainToRange(a3, 0, 999);
        return { hour: i3, minute: s3, second: l3, millisecond: d3, microsecond: m3, nanosecond: c3 };
      }(s2, l2, d2, m2, c2, h2));
  }
  return { hour: s2, minute: l2, second: d2, millisecond: m2, microsecond: c2, nanosecond: h2 };
}
function ToTemporalDurationRecord(e2) {
  if (!IsObject(e2))
    return function ParseTemporalDurationString(e3) {
      const t3 = Q.exec(e3);
      if (!t3)
        throw new RangeError(`invalid duration: ${e3}`);
      if (t3.slice(2).every((e4) => void 0 === e4))
        throw new RangeError(`invalid duration: ${e3}`);
      const r3 = "-" === t3[1] || "\u2212" === t3[1] ? -1 : 1, o3 = void 0 === t3[2] ? 0 : ToIntegerWithTruncation(t3[2]) * r3, n3 = void 0 === t3[3] ? 0 : ToIntegerWithTruncation(t3[3]) * r3, a3 = void 0 === t3[4] ? 0 : ToIntegerWithTruncation(t3[4]) * r3, i3 = void 0 === t3[5] ? 0 : ToIntegerWithTruncation(t3[5]) * r3, s3 = void 0 === t3[6] ? 0 : ToIntegerWithTruncation(t3[6]) * r3, l3 = t3[7], d3 = t3[8], m3 = t3[9], c3 = t3[10], h3 = t3[11];
      let u2 = 0, T2 = 0, p2 = 0;
      if (void 0 !== l3) {
        if (d3 ?? m3 ?? c3 ?? h3)
          throw new RangeError("only the smallest unit can be fractional");
        p2 = 3600 * ToIntegerOrInfinity((l3 + "000000000").slice(0, 9)) * r3;
      } else if (u2 = void 0 === d3 ? 0 : ToIntegerWithTruncation(d3) * r3, void 0 !== m3) {
        if (c3 ?? h3)
          throw new RangeError("only the smallest unit can be fractional");
        p2 = 60 * ToIntegerOrInfinity((m3 + "000000000").slice(0, 9)) * r3;
      } else
        T2 = void 0 === c3 ? 0 : ToIntegerWithTruncation(c3) * r3, void 0 !== h3 && (p2 = ToIntegerOrInfinity((h3 + "000000000").slice(0, 9)) * r3);
      const f2 = p2 % 1e3, y2 = le(p2 / 1e3) % 1e3, I2 = le(p2 / 1e6) % 1e3;
      return T2 += le(p2 / 1e9) % 60, u2 += le(p2 / 6e10), RejectDuration(o3, n3, a3, i3, s3, u2, T2, I2, y2, f2), { years: o3, months: n3, weeks: a3, days: i3, hours: s3, minutes: u2, seconds: T2, milliseconds: I2, microseconds: y2, nanoseconds: f2 };
    }(ToString(e2));
  if (IsTemporalDuration(e2))
    return { years: GetSlot(e2, w), months: GetSlot(e2, D), weeks: GetSlot(e2, G), days: GetSlot(e2, v), hours: GetSlot(e2, C), minutes: GetSlot(e2, O), seconds: GetSlot(e2, b), milliseconds: GetSlot(e2, E), microseconds: GetSlot(e2, M), nanoseconds: GetSlot(e2, R) };
  const t2 = { years: 0, months: 0, weeks: 0, days: 0, hours: 0, minutes: 0, seconds: 0, milliseconds: 0, microseconds: 0, nanoseconds: 0 };
  let r2 = function ToTemporalPartialDurationRecord(e3) {
    if (!IsObject(e3))
      throw new TypeError("invalid duration-like");
    const t3 = { years: void 0, months: void 0, weeks: void 0, days: void 0, hours: void 0, minutes: void 0, seconds: void 0, milliseconds: void 0, microseconds: void 0, nanoseconds: void 0 };
    let r3 = false;
    for (const o3 of We) {
      const n3 = e3[o3];
      void 0 !== n3 && (r3 = true, t3[o3] = ToIntegerIfIntegral(n3));
    }
    if (!r3)
      throw new TypeError("invalid duration-like");
    return t3;
  }(e2);
  for (const e3 of We) {
    const o3 = r2[e3];
    void 0 !== o3 && (t2[e3] = o3);
  }
  let { years: o2, months: n2, weeks: a2, days: i2, hours: s2, minutes: l2, seconds: d2, milliseconds: m2, microseconds: c2, nanoseconds: h2 } = t2;
  return RejectDuration(o2, n2, a2, i2, s2, l2, d2, m2, c2, h2), { years: o2, months: n2, weeks: a2, days: i2, hours: s2, minutes: l2, seconds: d2, milliseconds: m2, microseconds: c2, nanoseconds: h2 };
}
function ToTemporalOverflow(e2) {
  return void 0 === e2 ? "constrain" : GetOption(e2, "overflow", ["constrain", "reject"], "constrain");
}
function ToTemporalDisambiguation(e2) {
  return void 0 === e2 ? "compatible" : GetOption(e2, "disambiguation", ["compatible", "earlier", "later", "reject"], "compatible");
}
function ToTemporalRoundingMode(e2, t2) {
  return GetOption(e2, "roundingMode", ["ceil", "floor", "expand", "trunc", "halfCeil", "halfFloor", "halfExpand", "halfTrunc", "halfEven"], t2);
}
function ToTemporalOffset(e2, t2) {
  return void 0 === e2 ? t2 : GetOption(e2, "offset", ["prefer", "use", "ignore", "reject"], t2);
}
function ToCalendarNameOption(e2) {
  return GetOption(e2, "calendarName", ["auto", "always", "never", "critical"], "auto");
}
function ToTemporalRoundingIncrement(e2) {
  let t2 = e2.roundingIncrement;
  if (void 0 === t2)
    return 1;
  if (t2 = ToNumber(t2), !me(t2))
    throw new RangeError("roundingIncrement must be finite");
  const r2 = le(t2);
  if (r2 < 1 || r2 > 1e9)
    throw new RangeError(`roundingIncrement must be at least 1 and at most 1e9, not ${t2}`);
  return r2;
}
function ValidateTemporalRoundingIncrement(e2, t2, r2) {
  const o2 = r2 ? t2 : t2 - 1;
  if (e2 > o2)
    throw new RangeError(`roundingIncrement must be at least 1 and less than ${o2}, not ${e2}`);
  if (t2 % e2 != 0)
    throw new RangeError(`Rounding increment must divide evenly into ${t2}`);
}
function ToFractionalSecondDigits(e2) {
  const t2 = e2.fractionalSecondDigits;
  if (void 0 === t2)
    return "auto";
  if ("number" != typeof t2) {
    if ("auto" !== ToString(t2))
      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${t2}`);
    return "auto";
  }
  const r2 = ie(t2);
  if (!me(r2) || r2 < 0 || r2 > 9)
    throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${t2}`);
  return r2;
}
function ToSecondsStringPrecisionRecord(e2, t2) {
  switch (e2) {
    case "minute":
      return { precision: "minute", unit: "minute", increment: 1 };
    case "second":
      return { precision: 0, unit: "second", increment: 1 };
    case "millisecond":
      return { precision: 3, unit: "millisecond", increment: 1 };
    case "microsecond":
      return { precision: 6, unit: "microsecond", increment: 1 };
    case "nanosecond":
      return { precision: 9, unit: "nanosecond", increment: 1 };
  }
  switch (t2) {
    case "auto":
      return { precision: t2, unit: "nanosecond", increment: 1 };
    case 0:
      return { precision: t2, unit: "second", increment: 1 };
    case 1:
    case 2:
    case 3:
      return { precision: t2, unit: "millisecond", increment: 10 ** (3 - t2) };
    case 4:
    case 5:
    case 6:
      return { precision: t2, unit: "microsecond", increment: 10 ** (6 - t2) };
    case 7:
    case 8:
    case 9:
      return { precision: t2, unit: "nanosecond", increment: 10 ** (9 - t2) };
    default:
      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${t2}`);
  }
}
var He = Symbol("~required~");
function GetTemporalUnit(e2, t2, r2, o2, n2 = []) {
  const a2 = [];
  for (const [, e3, t3] of Ue)
    "datetime" !== r2 && r2 !== t3 || a2.push(e3);
  a2.push(...n2);
  let i2 = o2;
  i2 === He ? i2 = void 0 : void 0 !== i2 && a2.push(i2);
  const s2 = [...a2];
  for (const e3 of a2) {
    const t3 = Le.get(e3);
    void 0 !== t3 && s2.push(t3);
  }
  let l2 = GetOption(e2, t2, s2, i2);
  if (void 0 === l2 && o2 === He)
    throw new RangeError(`${t2} is required`);
  return Ae.has(l2) ? Ae.get(l2) : l2;
}
function ToRelativeTemporalObject(e2) {
  const t2 = e2.relativeTo;
  if (void 0 === t2)
    return t2;
  let r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2 = "option", p2 = false;
  if (IsObject(t2)) {
    if (IsTemporalZonedDateTime(t2) || IsTemporalDate(t2))
      return t2;
    if (IsTemporalDateTime(t2))
      return TemporalDateTimeToDate(t2);
    c2 = GetTemporalCalendarSlotValueWithISODefault(t2);
    const e3 = CalendarFields(c2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]);
    e3.push("timeZone", "offset");
    const p3 = PrepareTemporalFields(t2, e3, []), f2 = Te(null);
    f2.overflow = "constrain", { year: r2, month: o2, day: n2, hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2 } = InterpretTemporalDateTimeFields(c2, p3, f2), u2 = p3.offset, void 0 === u2 && (T2 = "wall"), h2 = p3.timeZone, void 0 !== h2 && (h2 = ToTemporalTimeZoneSlotValue(h2));
  } else {
    let e3, f2;
    if ({ year: r2, month: o2, day: n2, hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2, calendar: c2, ianaName: e3, offset: u2, z: f2 } = ParseISODateTime(ToString(t2)), e3)
      h2 = ToTemporalTimeZoneSlotValue(e3), f2 ? T2 = "exact" : u2 || (T2 = "wall"), p2 = true;
    else if (f2)
      throw new RangeError("Z designator not supported for PlainDate relativeTo; either remove the Z or add a bracketed time zone");
    if (c2 || (c2 = "iso8601"), !IsBuiltinCalendar(c2))
      throw new RangeError(`invalid calendar identifier ${c2}`);
    c2 = ASCIILowercase(c2);
  }
  if (void 0 === h2)
    return CreateTemporalDate(r2, o2, n2, c2);
  return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(r2, o2, n2, a2, i2, s2, l2, d2, m2, T2, "option" === T2 ? ParseTimeZoneOffsetString(u2) : 0, h2, "compatible", "reject", p2), h2, c2);
}
function DefaultTemporalLargestUnit(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2) {
  for (const [m2, c2] of [["years", e2], ["months", t2], ["weeks", r2], ["days", o2], ["hours", n2], ["minutes", a2], ["seconds", i2], ["milliseconds", s2], ["microseconds", l2], ["nanoseconds", d2]])
    if (0 !== c2)
      return Ae.get(m2);
  return "nanosecond";
}
function LargerOfTwoTemporalUnits(e2, t2) {
  return xe.indexOf(e2) > xe.indexOf(t2) ? t2 : e2;
}
function PrepareTemporalFields(e2, t2, r2, { emptySourceErrorMessage: o2 } = { emptySourceErrorMessage: "no supported properties found" }) {
  const n2 = Te(null);
  let a2 = false;
  t2.sort();
  for (const o3 of t2) {
    let t3 = e2[o3];
    if (void 0 !== t3)
      a2 = true, $e.has(o3) && (t3 = $e.get(o3)(t3)), n2[o3] = t3;
    else if ("partial" !== r2) {
      if (ee.call(r2, o3))
        throw new TypeError(`required property '${o3}' missing or undefined`);
      t3 = ke.get(o3), n2[o3] = t3;
    }
  }
  if ("partial" === r2 && !a2)
    throw new TypeError(o2);
  return n2;
}
function ToTemporalTimeRecord(e2, t2 = "complete") {
  const r2 = ["hour", "microsecond", "millisecond", "minute", "nanosecond", "second"], o2 = PrepareTemporalFields(e2, r2, "partial", { emptySourceErrorMessage: "invalid time-like" }), n2 = {};
  for (const e3 of r2) {
    const r3 = pe(o2, e3);
    void 0 !== r3 ? n2[e3] = r3.value : "complete" === t2 && (n2[e3] = 0);
  }
  return n2;
}
function ToTemporalDate(e2, t2) {
  let r2 = e2;
  if (IsObject(r2)) {
    if (IsTemporalDate(r2))
      return r2;
    if (IsTemporalZonedDateTime(r2) && (ToTemporalOverflow(t2), r2 = GetPlainDateTimeFor(GetSlot(r2, g), GetSlot(r2, S), GetSlot(r2, p))), IsTemporalDateTime(r2))
      return ToTemporalOverflow(t2), CreateTemporalDate(GetSlot(r2, i), GetSlot(r2, s), GetSlot(r2, l), GetSlot(r2, p));
    const e3 = GetTemporalCalendarSlotValueWithISODefault(r2);
    return CalendarDateFromFields(e3, PrepareTemporalFields(r2, CalendarFields(e3, ["day", "month", "monthCode", "year"]), []), t2);
  }
  ToTemporalOverflow(t2);
  let { year: o2, month: n2, day: a2, calendar: d2, z: m2 } = function ParseTemporalDateString(e3) {
    return ParseISODateTime(e3);
  }(ToString(r2));
  if (m2)
    throw new RangeError("Z designator not supported for PlainDate");
  if (d2 || (d2 = "iso8601"), !IsBuiltinCalendar(d2))
    throw new RangeError(`invalid calendar identifier ${d2}`);
  return d2 = ASCIILowercase(d2), CreateTemporalDate(o2, n2, a2, d2);
}
function InterpretTemporalDateTimeFields(e2, t2, r2) {
  let { hour: o2, minute: n2, second: a2, millisecond: d2, microsecond: m2, nanosecond: c2 } = ToTemporalTimeRecord(t2);
  const h2 = ToTemporalOverflow(r2), u2 = CalendarDateFromFields(e2, t2, r2), T2 = GetSlot(u2, i), p2 = GetSlot(u2, s), f2 = GetSlot(u2, l);
  return { hour: o2, minute: n2, second: a2, millisecond: d2, microsecond: m2, nanosecond: c2 } = RegulateTime(o2, n2, a2, d2, m2, c2, h2), { year: T2, month: p2, day: f2, hour: o2, minute: n2, second: a2, millisecond: d2, microsecond: m2, nanosecond: c2 };
}
function ToTemporalDateTime(e2, t2) {
  let r2, o2, n2, a2, d2, m2, c2, h2, u2, T2;
  if (IsObject(e2)) {
    if (IsTemporalDateTime(e2))
      return e2;
    if (IsTemporalZonedDateTime(e2))
      return ToTemporalOverflow(t2), GetPlainDateTimeFor(GetSlot(e2, g), GetSlot(e2, S), GetSlot(e2, p));
    if (IsTemporalDate(e2))
      return ToTemporalOverflow(t2), CreateTemporalDateTime(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l), 0, 0, 0, 0, 0, 0, GetSlot(e2, p));
    T2 = GetTemporalCalendarSlotValueWithISODefault(e2);
    const f2 = PrepareTemporalFields(e2, CalendarFields(T2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]), []);
    ({ year: r2, month: o2, day: n2, hour: a2, minute: d2, second: m2, millisecond: c2, microsecond: h2, nanosecond: u2 } = InterpretTemporalDateTimeFields(T2, f2, t2));
  } else {
    let i2;
    if (ToTemporalOverflow(t2), { year: r2, month: o2, day: n2, hour: a2, minute: d2, second: m2, millisecond: c2, microsecond: h2, nanosecond: u2, calendar: T2, z: i2 } = function ParseTemporalDateTimeString(e3) {
      return ParseISODateTime(e3);
    }(ToString(e2)), i2)
      throw new RangeError("Z designator not supported for PlainDateTime");
    if (RejectDateTime(r2, o2, n2, a2, d2, m2, c2, h2, u2), T2 || (T2 = "iso8601"), !IsBuiltinCalendar(T2))
      throw new RangeError(`invalid calendar identifier ${T2}`);
    T2 = ASCIILowercase(T2);
  }
  return CreateTemporalDateTime(r2, o2, n2, a2, d2, m2, c2, h2, u2, T2);
}
function ToTemporalDuration(e2) {
  if (IsTemporalDuration(e2))
    return e2;
  let { years: t2, months: r2, weeks: o2, days: n2, hours: a2, minutes: i2, seconds: s2, milliseconds: l2, microseconds: d2, nanoseconds: m2 } = ToTemporalDurationRecord(e2);
  return new (GetIntrinsic("%Temporal.Duration%"))(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2);
}
function ToTemporalInstant(e2) {
  if (IsTemporalInstant(e2))
    return e2;
  if (IsTemporalZonedDateTime(e2)) {
    return new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(e2, n));
  }
  const t2 = ParseTemporalInstant(ToString(e2));
  return new (GetIntrinsic("%Temporal.Instant%"))(t2);
}
function ToTemporalMonthDay(e2, t2) {
  let r2 = e2;
  if (IsObject(r2)) {
    if (IsTemporalMonthDay(r2))
      return r2;
    let e3, o3;
    if (HasSlot(r2, p))
      e3 = GetSlot(r2, p), o3 = false;
    else {
      let t3 = r2.calendar;
      o3 = void 0 === t3, void 0 === t3 && (t3 = "iso8601"), e3 = ToTemporalCalendarSlotValue(t3);
    }
    const n3 = PrepareTemporalFields(r2, CalendarFields(e3, ["day", "month", "monthCode", "year"]), []);
    return o3 && void 0 !== n3.month && void 0 === n3.monthCode && void 0 === n3.year && (n3.year = 1972), CalendarMonthDayFromFields(e3, n3, t2);
  }
  ToTemporalOverflow(t2);
  let { month: o2, day: n2, referenceISOYear: a2, calendar: i2 } = ParseTemporalMonthDayString(ToString(r2));
  if (void 0 === i2 && (i2 = "iso8601"), !IsBuiltinCalendar(i2))
    throw new RangeError(`invalid calendar identifier ${i2}`);
  if (i2 = ASCIILowercase(i2), void 0 === a2)
    return RejectISODate(1972, o2, n2), CreateTemporalMonthDay(o2, n2, i2);
  return CalendarMonthDayFromFields(i2, CreateTemporalMonthDay(o2, n2, i2, a2));
}
function ToTemporalTime(e2, t2 = "constrain") {
  let r2, o2, n2, a2, i2, s2, l2 = e2;
  if (IsObject(l2)) {
    if (IsTemporalTime(l2))
      return l2;
    if (IsTemporalZonedDateTime(l2) && (l2 = GetPlainDateTimeFor(GetSlot(l2, g), GetSlot(l2, S), GetSlot(l2, p))), IsTemporalDateTime(l2)) {
      return new (GetIntrinsic("%Temporal.PlainTime%"))(GetSlot(l2, d), GetSlot(l2, m), GetSlot(l2, c), GetSlot(l2, h), GetSlot(l2, u), GetSlot(l2, T));
    }
    ({ hour: r2, minute: o2, second: n2, millisecond: a2, microsecond: i2, nanosecond: s2 } = ToTemporalTimeRecord(l2)), { hour: r2, minute: o2, second: n2, millisecond: a2, microsecond: i2, nanosecond: s2 } = RegulateTime(r2, o2, n2, a2, i2, s2, t2);
  } else
    ({ hour: r2, minute: o2, second: n2, millisecond: a2, microsecond: i2, nanosecond: s2 } = function ParseTemporalTimeString(e3) {
      const t3 = z.exec(e3);
      let r3, o3, n3, a3, i3, s3, l3;
      if (t3) {
        r3 = ToIntegerOrInfinity(t3[1]), o3 = ToIntegerOrInfinity(t3[2] || t3[5]), n3 = ToIntegerOrInfinity(t3[3] || t3[6]), 60 === n3 && (n3 = 59);
        const e4 = (t3[4] || t3[7]) + "000000000";
        a3 = ToIntegerOrInfinity(e4.slice(0, 3)), i3 = ToIntegerOrInfinity(e4.slice(3, 6)), s3 = ToIntegerOrInfinity(e4.slice(6, 9)), l3 = t3[14];
        for (const [, e5, t4, r4] of l3.matchAll(H))
          if ("u-ca" !== t4 && "!" === e5)
            throw new RangeError(`Unrecognized annotation: !${t4}=${r4}`);
        if (t3[8])
          throw new RangeError("Z designator not supported for PlainTime");
      } else {
        let t4, l4;
        if ({ hasTime: l4, hour: r3, minute: o3, second: n3, millisecond: a3, microsecond: i3, nanosecond: s3, z: t4 } = ParseISODateTime(e3), !l4)
          throw new RangeError(`time is missing in string: ${e3}`);
        if (t4)
          throw new RangeError("Z designator not supported for PlainTime");
      }
      if (/[tT ][0-9][0-9]/.test(e3))
        return { hour: r3, minute: o3, second: n3, millisecond: a3, microsecond: i3, nanosecond: s3 };
      try {
        const { month: t4, day: r4 } = ParseTemporalMonthDayString(e3);
        RejectISODate(1972, t4, r4);
      } catch {
        try {
          const { year: t4, month: r4 } = ParseTemporalYearMonthString(e3);
          RejectISODate(t4, r4, 1);
        } catch {
          return { hour: r3, minute: o3, second: n3, millisecond: a3, microsecond: i3, nanosecond: s3 };
        }
      }
      throw new RangeError(`invalid ISO 8601 time-only string ${e3}; may need a T prefix`);
    }(ToString(l2))), RejectTime(r2, o2, n2, a2, i2, s2);
  return new (GetIntrinsic("%Temporal.PlainTime%"))(r2, o2, n2, a2, i2, s2);
}
function ToTemporalYearMonth(e2, t2) {
  if (IsObject(e2)) {
    if (IsTemporalYearMonth(e2))
      return e2;
    const r3 = GetTemporalCalendarSlotValueWithISODefault(e2);
    return CalendarYearMonthFromFields(r3, PrepareTemporalFields(e2, CalendarFields(r3, ["month", "monthCode", "year"]), []), t2);
  }
  ToTemporalOverflow(t2);
  let { year: r2, month: o2, referenceISODay: n2, calendar: a2 } = ParseTemporalYearMonthString(ToString(e2));
  if (void 0 === a2 && (a2 = "iso8601"), !IsBuiltinCalendar(a2))
    throw new RangeError(`invalid calendar identifier ${a2}`);
  if (a2 = ASCIILowercase(a2), void 0 === n2)
    return RejectISODate(r2, o2, 1), CreateTemporalYearMonth(r2, o2, a2);
  return CalendarYearMonthFromFields(a2, CreateTemporalYearMonth(r2, o2, a2, n2));
}
function InterpretISODateTimeOffset(t2, r2, o2, i2, s2, l2, d2, m2, c2, h2, u2, T2, p2, f2, y2) {
  const I2 = new (GetIntrinsic("%Temporal.PlainDateTime%"))(t2, r2, o2, i2, s2, l2, d2, m2, c2);
  if ("wall" === h2 || "ignore" === f2) {
    return GetSlot(GetInstantFor(T2, I2, p2), n);
  }
  if ("exact" === h2 || "use" === f2) {
    const n2 = GetUTCEpochNanoseconds(t2, r2, o2, i2, s2, l2, d2, m2, c2);
    if (null === n2)
      throw new RangeError("ZonedDateTime outside of supported range");
    return e.subtract(n2, e.BigInt(u2));
  }
  const S2 = GetPossibleInstantsFor(T2, I2);
  for (const t3 of S2) {
    const r3 = GetOffsetNanosecondsFor(T2, t3), o3 = e.toNumber(RoundNumberToIncrement(e.BigInt(r3), be, "halfExpand"));
    if (r3 === u2 || y2 && o3 === u2)
      return GetSlot(t3, n);
  }
  if ("reject" === f2) {
    const e2 = FormatTimeZoneOffsetString(u2), t3 = IsTemporalTimeZone(T2) ? GetSlot(T2, a) : "time zone";
    throw new RangeError(`Offset ${e2} is invalid for ${I2.toString()} in ${t3}`);
  }
  return GetSlot(DisambiguatePossibleInstants(S2, T2, I2, p2), n);
}
function ToTemporalZonedDateTime(e2, t2) {
  let r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2, p2, f2 = false, y2 = "option";
  if (IsObject(e2)) {
    if (IsTemporalZonedDateTime(e2))
      return e2;
    u2 = GetTemporalCalendarSlotValueWithISODefault(e2);
    const f3 = CalendarFields(u2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]);
    f3.push("timeZone", "offset");
    const I3 = PrepareTemporalFields(e2, f3, ["timeZone"]);
    c2 = ToTemporalTimeZoneSlotValue(I3.timeZone), h2 = I3.offset, void 0 === h2 && (y2 = "wall"), T2 = ToTemporalDisambiguation(t2), p2 = ToTemporalOffset(t2, "reject"), { year: r2, month: o2, day: n2, hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2 } = InterpretTemporalDateTimeFields(u2, I3, t2);
  } else {
    let I3, S2;
    if ({ year: r2, month: o2, day: n2, hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2, ianaName: I3, offset: h2, z: S2, calendar: u2 } = function ParseTemporalZonedDateTimeString(e3) {
      const t3 = ParseISODateTime(e3);
      if (!t3.ianaName)
        throw new RangeError("Temporal.ZonedDateTime requires a time zone ID in brackets");
      return t3;
    }(ToString(e2)), c2 = ToTemporalTimeZoneSlotValue(I3), S2 ? y2 = "exact" : h2 || (y2 = "wall"), u2 || (u2 = "iso8601"), !IsBuiltinCalendar(u2))
      throw new RangeError(`invalid calendar identifier ${u2}`);
    u2 = ASCIILowercase(u2), f2 = true, T2 = ToTemporalDisambiguation(t2), p2 = ToTemporalOffset(t2, "reject"), ToTemporalOverflow(t2);
  }
  let I2 = 0;
  "option" === y2 && (I2 = ParseTimeZoneOffsetString(h2));
  return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(r2, o2, n2, a2, i2, s2, l2, d2, m2, y2, I2, c2, T2, p2, f2), c2, u2);
}
function CreateTemporalDateSlots(e2, t2, r2, o2, n2) {
  RejectISODate(t2, r2, o2), RejectDateRange(t2, r2, o2), N(e2), SetSlot(e2, i, t2), SetSlot(e2, s, r2), SetSlot(e2, l, o2), SetSlot(e2, p, n2), SetSlot(e2, f, true);
}
function CreateTemporalDate(e2, t2, r2, o2 = "iso8601") {
  const n2 = GetIntrinsic("%Temporal.PlainDate%"), a2 = Te(n2.prototype);
  return CreateTemporalDateSlots(a2, e2, t2, r2, o2), a2;
}
function CreateTemporalDateTimeSlots(e2, t2, r2, o2, n2, a2, f2, y2, I2, S2, g2) {
  RejectDateTime(t2, r2, o2, n2, a2, f2, y2, I2, S2), RejectDateTimeRange(t2, r2, o2, n2, a2, f2, y2, I2, S2), N(e2), SetSlot(e2, i, t2), SetSlot(e2, s, r2), SetSlot(e2, l, o2), SetSlot(e2, d, n2), SetSlot(e2, m, a2), SetSlot(e2, c, f2), SetSlot(e2, h, y2), SetSlot(e2, u, I2), SetSlot(e2, T, S2), SetSlot(e2, p, g2);
}
function CreateTemporalDateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2 = "iso8601") {
  const m2 = GetIntrinsic("%Temporal.PlainDateTime%"), c2 = Te(m2.prototype);
  return CreateTemporalDateTimeSlots(c2, e2, t2, r2, o2, n2, a2, i2, s2, l2, d2), c2;
}
function CreateTemporalMonthDaySlots(e2, t2, r2, o2, n2) {
  RejectISODate(n2, t2, r2), RejectDateRange(n2, t2, r2), N(e2), SetSlot(e2, s, t2), SetSlot(e2, l, r2), SetSlot(e2, i, n2), SetSlot(e2, p, o2), SetSlot(e2, I, true);
}
function CreateTemporalMonthDay(e2, t2, r2 = "iso8601", o2 = 1972) {
  const n2 = GetIntrinsic("%Temporal.PlainMonthDay%"), a2 = Te(n2.prototype);
  return CreateTemporalMonthDaySlots(a2, e2, t2, r2, o2), a2;
}
function CreateTemporalYearMonthSlots(e2, t2, r2, o2, n2) {
  RejectISODate(t2, r2, n2), function RejectYearMonthRange(e3, t3) {
    RejectToRange(e3, Fe, Ye), e3 === Fe ? RejectToRange(t3, 4, 12) : e3 === Ye && RejectToRange(t3, 1, 9);
  }(t2, r2), N(e2), SetSlot(e2, i, t2), SetSlot(e2, s, r2), SetSlot(e2, l, n2), SetSlot(e2, p, o2), SetSlot(e2, y, true);
}
function CreateTemporalYearMonth(e2, t2, r2 = "iso8601", o2 = 1) {
  const n2 = GetIntrinsic("%Temporal.PlainYearMonth%"), a2 = Te(n2.prototype);
  return CreateTemporalYearMonthSlots(a2, e2, t2, r2, o2), a2;
}
function CreateTemporalZonedDateTimeSlots(e2, t2, r2, o2) {
  ValidateEpochNanoseconds(t2), N(e2), SetSlot(e2, n, t2), SetSlot(e2, g, r2), SetSlot(e2, p, o2);
  const a2 = new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(e2, n));
  SetSlot(e2, S, a2);
}
function CreateTemporalZonedDateTime(e2, t2, r2 = "iso8601") {
  const o2 = GetIntrinsic("%Temporal.ZonedDateTime%"), n2 = Te(o2.prototype);
  return CreateTemporalZonedDateTimeSlots(n2, e2, t2, r2), n2;
}
function CalendarFields(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.fields%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e2, "fields"), e2, [t2]), o2 = [];
  for (const e3 of r2) {
    if ("string" != typeof e3)
      throw new TypeError("bad return from calendar.fields()");
    te.call(o2, e3);
  }
  return o2;
}
function CalendarMergeFields(e2, t2, r2) {
  if ("string" == typeof e2) {
    const o3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.mergeFields%"), o3, [t2, r2]);
  }
  const o2 = Call(GetMethod(e2, "mergeFields"), e2, [t2, r2]);
  if (!IsObject(o2))
    throw new TypeError("bad return from calendar.mergeFields()");
  return o2;
}
function CalendarDateAdd(e2, t2, r2, o2, n2) {
  let a2 = n2;
  if ("string" == typeof e2) {
    const n3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dateAdd%"), n3, [t2, r2, o2]);
  }
  void 0 === a2 && (a2 = GetMethod(e2, "dateAdd"));
  const i2 = fe(a2, e2, [t2, r2, o2]);
  if (!IsTemporalDate(i2))
    throw new TypeError("invalid result");
  return i2;
}
function CalendarDateUntil(e2, t2, r2, o2, n2) {
  let a2 = n2;
  if ("string" == typeof e2) {
    const n3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dateUntil%"), n3, [t2, r2, o2]);
  }
  void 0 === a2 && (a2 = GetMethod(e2, "dateUntil"));
  const i2 = fe(a2, e2, [t2, r2, o2]);
  if (!IsTemporalDuration(i2))
    throw new TypeError("invalid result");
  return i2;
}
function CalendarYear(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.year%"), r3, [t2]);
  }
  let r2 = Call(GetMethod(e2, "year"), e2, [t2]);
  if ("number" != typeof r2)
    throw new TypeError("calendar year result must be an integer");
  if (!IsIntegralNumber(r2))
    throw new RangeError("calendar year result must be an integer");
  return r2;
}
function CalendarMonth(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.month%"), r3, [t2]);
  }
  let r2 = Call(GetMethod(e2, "month"), e2, [t2]);
  if ("number" != typeof r2)
    throw new TypeError("calendar month result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1)
    throw new RangeError("calendar month result must be a positive integer");
  return r2;
}
function CalendarMonthCode(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.monthCode%"), r3, [t2]);
  }
  let r2 = Call(GetMethod(e2, "monthCode"), e2, [t2]);
  if ("string" != typeof r2)
    throw new TypeError("calendar monthCode result must be a string");
  return r2;
}
function CalendarDay(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.day%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e2, "day"), e2, [t2]);
  if ("number" != typeof r2)
    throw new TypeError("calendar day result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1)
    throw new RangeError("calendar day result must be a positive integer");
  return r2;
}
function CalendarEra(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.era%"), r3, [t2]);
  }
  let r2 = Call(GetMethod(e2, "era"), e2, [t2]);
  if (void 0 === r2)
    return r2;
  if ("string" != typeof r2)
    throw new TypeError("calendar era result must be a string or undefined");
  return r2;
}
function CalendarEraYear(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.eraYear%"), r3, [t2]);
  }
  let r2 = Call(GetMethod(e2, "eraYear"), e2, [t2]);
  if (void 0 === r2)
    return r2;
  if ("number" != typeof r2)
    throw new TypeError("calendar eraYear result must be an integer or undefined");
  if (!IsIntegralNumber(r2))
    throw new RangeError("calendar eraYear result must be an integer or undefined");
  return r2;
}
function CalendarDayOfWeek(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dayOfWeek%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e2, "dayOfWeek"), e2, [t2]);
  if ("number" != typeof r2)
    throw new TypeError("calendar dayOfWeek result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1)
    throw new RangeError("calendar dayOfWeek result must be a positive integer");
  return r2;
}
function CalendarDayOfYear(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dayOfYear%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e2, "dayOfYear"), e2, [t2]);
  if ("number" != typeof r2)
    throw new TypeError("calendar dayOfYear result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1)
    throw new RangeError("calendar dayOfYear result must be a positive integer");
  return r2;
}
function CalendarWeekOfYear(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.weekOfYear%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e2, "weekOfYear"), e2, [t2]);
  if ("number" != typeof r2)
    throw new TypeError("calendar weekOfYear result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1)
    throw new RangeError("calendar weekOfYear result must be a positive integer");
  return r2;
}
function CalendarYearOfWeek(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.yearOfWeek%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e2, "yearOfWeek"), e2, [t2]);
  if ("number" != typeof r2)
    throw new TypeError("calendar yearOfWeek result must be an integer");
  if (!IsIntegralNumber(r2))
    throw new RangeError("calendar yearOfWeek result must be an integer");
  return r2;
}
function CalendarDaysInWeek(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.daysInWeek%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e2, "daysInWeek"), e2, [t2]);
  if ("number" != typeof r2)
    throw new TypeError("calendar daysInWeek result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1)
    throw new RangeError("calendar daysInWeek result must be a positive integer");
  return r2;
}
function CalendarDaysInMonth(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.daysInMonth%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e2, "daysInMonth"), e2, [t2]);
  if ("number" != typeof r2)
    throw new TypeError("calendar daysInMonth result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1)
    throw new RangeError("calendar daysInMonth result must be a positive integer");
  return r2;
}
function CalendarDaysInYear(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.daysInYear%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e2, "daysInYear"), e2, [t2]);
  if ("number" != typeof r2)
    throw new TypeError("calendar daysInYear result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1)
    throw new RangeError("calendar daysInYear result must be a positive integer");
  return r2;
}
function CalendarMonthsInYear(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.monthsInYear%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e2, "monthsInYear"), e2, [t2]);
  if ("number" != typeof r2)
    throw new TypeError("calendar monthsInYear result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1)
    throw new RangeError("calendar monthsInYear result must be a positive integer");
  return r2;
}
function CalendarInLeapYear(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.inLeapYear%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e2, "inLeapYear"), e2, [t2]);
  if ("boolean" != typeof r2)
    throw new TypeError("calendar inLeapYear result must be a boolean");
  return r2;
}
function ToTemporalCalendarSlotValue(e2) {
  if (IsObject(e2)) {
    if (HasSlot(e2, p))
      return GetSlot(e2, p);
    if (!function ObjectImplementsTemporalCalendarProtocol(e3) {
      return !!IsTemporalCalendar(e3) || "dateAdd" in e3 && "dateFromFields" in e3 && "dateUntil" in e3 && "day" in e3 && "dayOfWeek" in e3 && "dayOfYear" in e3 && "daysInMonth" in e3 && "daysInWeek" in e3 && "daysInYear" in e3 && "fields" in e3 && "id" in e3 && "inLeapYear" in e3 && "mergeFields" in e3 && "month" in e3 && "monthCode" in e3 && "monthDayFromFields" in e3 && "monthsInYear" in e3 && "weekOfYear" in e3 && "year" in e3 && "yearMonthFromFields" in e3 && "yearOfWeek" in e3;
    }(e2))
      throw new TypeError("expected a Temporal.Calendar or object implementing the Temporal.Calendar protocol");
    return e2;
  }
  const t2 = ToString(e2);
  if (IsBuiltinCalendar(t2))
    return ASCIILowercase(t2);
  let r2;
  try {
    ({ calendar: r2 } = ParseISODateTime(t2));
  } catch {
    try {
      ({ calendar: r2 } = ParseTemporalYearMonthString(t2));
    } catch {
      ({ calendar: r2 } = ParseTemporalMonthDayString(t2));
    }
  }
  if (r2 || (r2 = "iso8601"), !IsBuiltinCalendar(r2))
    throw new RangeError(`invalid calendar identifier ${r2}`);
  return ASCIILowercase(r2);
}
function GetTemporalCalendarSlotValueWithISODefault(e2) {
  if (HasSlot(e2, p))
    return GetSlot(e2, p);
  const { calendar: t2 } = e2;
  return void 0 === t2 ? "iso8601" : ToTemporalCalendarSlotValue(t2);
}
function ToTemporalCalendarIdentifier(e2) {
  if ("string" == typeof e2)
    return e2;
  const t2 = e2.id;
  if ("string" != typeof t2)
    throw new TypeError("calendar.id should be a string");
  return t2;
}
function ToTemporalCalendarObject(e2) {
  if (IsObject(e2))
    return e2;
  return new (GetIntrinsic("%Temporal.Calendar%"))(e2);
}
function CalendarEquals(e2, t2) {
  if (e2 === t2)
    return true;
  return ToTemporalCalendarIdentifier(e2) === ToTemporalCalendarIdentifier(t2);
}
function ThrowIfCalendarsNotEqual(e2, t2, r2) {
  if (e2 === t2)
    return;
  const o2 = ToTemporalCalendarIdentifier(e2), n2 = ToTemporalCalendarIdentifier(t2);
  if (o2 !== n2)
    throw new RangeError(`cannot ${r2} of ${o2} and ${n2} calendars`);
}
function ConsolidateCalendars(e2, t2) {
  if (e2 === t2)
    return t2;
  const r2 = ToTemporalCalendarIdentifier(e2), o2 = ToTemporalCalendarIdentifier(t2);
  if (r2 === o2 || "iso8601" === r2)
    return t2;
  if ("iso8601" === o2)
    return e2;
  throw new RangeError("irreconcilable calendars");
}
function CalendarDateFromFields(e2, t2, r2, o2) {
  if ("string" == typeof e2) {
    const o3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dateFromFields%"), o3, [t2, r2]);
  }
  const n2 = Call(o2 ?? GetMethod(e2, "dateFromFields"), e2, [t2, r2]);
  if (!IsTemporalDate(n2))
    throw new TypeError("invalid result");
  return n2;
}
function CalendarYearMonthFromFields(e2, t2, r2) {
  if ("string" == typeof e2) {
    const o3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.yearMonthFromFields%"), o3, [t2, r2]);
  }
  let o2 = Call(GetMethod(e2, "yearMonthFromFields"), e2, [t2, r2]);
  if (!IsTemporalYearMonth(o2))
    throw new TypeError("invalid result");
  return o2;
}
function CalendarMonthDayFromFields(e2, t2, r2) {
  if ("string" == typeof e2) {
    const o3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.monthDayFromFields%"), o3, [t2, r2]);
  }
  let o2 = Call(GetMethod(e2, "monthDayFromFields"), e2, [t2, r2]);
  if (!IsTemporalMonthDay(o2))
    throw new TypeError("invalid result");
  return o2;
}
function ToTemporalTimeZoneSlotValue(e2) {
  if (IsObject(e2)) {
    if (IsTemporalZonedDateTime(e2))
      return GetSlot(e2, g);
    if (!function ObjectImplementsTemporalTimeZoneProtocol(e3) {
      return !!IsTemporalTimeZone(e3) || "getOffsetNanosecondsFor" in e3 && "getPossibleInstantsFor" in e3 && "id" in e3;
    }(e2))
      throw new TypeError("expected a Temporal.TimeZone or object implementing the Temporal.TimeZone protocol");
    return e2;
  }
  return ParseTemporalTimeZone(ToString(e2));
}
function ToTemporalTimeZoneIdentifier(e2) {
  if ("string" == typeof e2)
    return e2;
  const t2 = e2.id;
  if ("string" != typeof t2)
    throw new TypeError("timeZone.id should be a string");
  return t2;
}
function ToTemporalTimeZoneObject(e2) {
  if (IsObject(e2))
    return e2;
  return new (GetIntrinsic("%Temporal.TimeZone%"))(e2);
}
function TimeZoneEquals(e2, t2) {
  if (e2 === t2)
    return true;
  return ToTemporalTimeZoneIdentifier(e2) === ToTemporalTimeZoneIdentifier(t2);
}
function TemporalDateTimeToDate(e2) {
  return CreateTemporalDate(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l), GetSlot(e2, p));
}
function TemporalDateTimeToTime(e2) {
  return new (GetIntrinsic("%Temporal.PlainTime%"))(GetSlot(e2, d), GetSlot(e2, m), GetSlot(e2, c), GetSlot(e2, h), GetSlot(e2, u), GetSlot(e2, T));
}
function GetOffsetNanosecondsFor(e2, t2, r2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.TimeZone%"))(e2);
    return Call(GetIntrinsic("%Temporal.TimeZone.prototype.getOffsetNanosecondsFor%"), r3, [t2]);
  }
  const o2 = Call(r2 ?? GetMethod(e2, "getOffsetNanosecondsFor"), e2, [t2]);
  if ("number" != typeof o2)
    throw new TypeError("bad return from getOffsetNanosecondsFor");
  if (!IsIntegralNumber(o2) || ae(o2) >= 864e11)
    throw new RangeError("out-of-range return from getOffsetNanosecondsFor");
  return o2;
}
function GetOffsetStringFor(e2, t2) {
  return FormatTimeZoneOffsetString(GetOffsetNanosecondsFor(e2, t2));
}
function GetPlainDateTimeFor(e2, t2, r2) {
  const o2 = GetSlot(t2, n), a2 = GetOffsetNanosecondsFor(e2, t2);
  let { year: i2, month: s2, day: l2, hour: d2, minute: m2, second: c2, millisecond: h2, microsecond: u2, nanosecond: T2 } = GetISOPartsFromEpoch(o2);
  return { year: i2, month: s2, day: l2, hour: d2, minute: m2, second: c2, millisecond: h2, microsecond: u2, nanosecond: T2 } = BalanceISODateTime(i2, s2, l2, d2, m2, c2, h2, u2, T2 + a2), CreateTemporalDateTime(i2, s2, l2, d2, m2, c2, h2, u2, T2, r2);
}
function GetInstantFor(e2, t2, r2) {
  return DisambiguatePossibleInstants(GetPossibleInstantsFor(e2, t2), e2, t2, r2);
}
function DisambiguatePossibleInstants(t2, r2, o2, n2) {
  const a2 = GetIntrinsic("%Temporal.Instant%"), f2 = t2.length;
  if (1 === f2)
    return t2[0];
  if (f2)
    switch (n2) {
      case "compatible":
      case "earlier":
        return t2[0];
      case "later":
        return t2[f2 - 1];
      case "reject":
        throw new RangeError("multiple instants found");
    }
  const y2 = GetSlot(o2, i), I2 = GetSlot(o2, s), S2 = GetSlot(o2, l), g2 = GetSlot(o2, d), w2 = GetSlot(o2, m), D2 = GetSlot(o2, c), G2 = GetSlot(o2, h), v2 = GetSlot(o2, u), C2 = GetSlot(o2, T), O2 = GetUTCEpochNanoseconds(y2, I2, S2, g2, w2, D2, G2, v2, C2);
  if (null === O2)
    throw new RangeError("DateTime outside of supported range");
  const b2 = new a2(e.subtract(O2, Ee)), E2 = new a2(e.add(O2, Ee)), M2 = GetOffsetNanosecondsFor(r2, b2), R2 = GetOffsetNanosecondsFor(r2, E2) - M2;
  switch (n2) {
    case "earlier": {
      const e2 = GetSlot(o2, p), t3 = GetIntrinsic("%Temporal.PlainDateTime%"), n3 = AddDateTime(y2, I2, S2, g2, w2, D2, G2, v2, C2, e2, 0, 0, 0, 0, 0, 0, 0, 0, 0, -R2, void 0);
      return GetPossibleInstantsFor(r2, new t3(n3.year, n3.month, n3.day, n3.hour, n3.minute, n3.second, n3.millisecond, n3.microsecond, n3.nanosecond, e2))[0];
    }
    case "compatible":
    case "later": {
      const e2 = GetSlot(o2, p), t3 = GetIntrinsic("%Temporal.PlainDateTime%"), n3 = AddDateTime(y2, I2, S2, g2, w2, D2, G2, v2, C2, e2, 0, 0, 0, 0, 0, 0, 0, 0, 0, R2, void 0), a3 = GetPossibleInstantsFor(r2, new t3(n3.year, n3.month, n3.day, n3.hour, n3.minute, n3.second, n3.millisecond, n3.microsecond, n3.nanosecond, e2));
      return a3[a3.length - 1];
    }
    case "reject":
      throw new RangeError("no such instant found");
  }
}
function GetPossibleInstantsFor(e2, t2, r2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.TimeZone%"))(e2);
    return Call(GetIntrinsic("%Temporal.TimeZone.prototype.getPossibleInstantsFor%"), r3, [t2]);
  }
  const o2 = Call(r2 ?? GetMethod(e2, "getPossibleInstantsFor"), e2, [t2]), n2 = [];
  for (const e3 of o2) {
    if (!IsTemporalInstant(e3))
      throw new TypeError("bad return from getPossibleInstantsFor");
    te.call(n2, e3);
  }
  return n2;
}
function ISOYearString(e2) {
  let t2;
  if (e2 < 0 || e2 > 9999) {
    t2 = (e2 < 0 ? "-" : "+") + `000000${ae(e2)}`.slice(-6);
  } else
    t2 = `0000${e2}`.slice(-4);
  return t2;
}
function ISODateTimePartString(e2) {
  return `00${e2}`.slice(-2);
}
function FormatSecondsStringPart(e2, t2, r2, o2, n2) {
  if ("minute" === n2)
    return "";
  const a2 = `:${ISODateTimePartString(e2)}`;
  let i2, s2 = 1e6 * t2 + 1e3 * r2 + o2;
  if ("auto" === n2) {
    if (0 === s2)
      return a2;
    for (i2 = `${s2}`.padStart(9, "0"); "0" === i2[i2.length - 1]; )
      i2 = i2.slice(0, -1);
  } else {
    if (0 === n2)
      return a2;
    i2 = `${s2}`.padStart(9, "0").slice(0, n2);
  }
  return `${a2}.${i2}`;
}
function TemporalInstantToString(e2, t2, r2) {
  let o2 = t2;
  void 0 === o2 && (o2 = "UTC");
  const n2 = GetPlainDateTimeFor(o2, e2, "iso8601"), a2 = ISOYearString(GetSlot(n2, i)), p2 = ISODateTimePartString(GetSlot(n2, s)), f2 = ISODateTimePartString(GetSlot(n2, l)), y2 = ISODateTimePartString(GetSlot(n2, d)), I2 = ISODateTimePartString(GetSlot(n2, m)), S2 = FormatSecondsStringPart(GetSlot(n2, c), GetSlot(n2, h), GetSlot(n2, u), GetSlot(n2, T), r2);
  let g2 = "Z";
  if (void 0 !== t2) {
    g2 = FormatISOTimeZoneOffsetString(GetOffsetNanosecondsFor(o2, e2));
  }
  return `${a2}-${p2}-${f2}T${y2}:${I2}${S2}${g2}`;
}
function TemporalDurationToString(t2, r2 = "auto", o2) {
  function formatNumber(t3) {
    return t3 <= ue ? t3.toString(10) : e.BigInt(t3).toString(10);
  }
  const n2 = GetSlot(t2, w), a2 = GetSlot(t2, D), i2 = GetSlot(t2, G), s2 = GetSlot(t2, v), l2 = GetSlot(t2, C), d2 = GetSlot(t2, O);
  let m2 = GetSlot(t2, b), c2 = GetSlot(t2, E), h2 = GetSlot(t2, M), u2 = GetSlot(t2, R);
  const T2 = DurationSign(n2, a2, i2, s2, l2, d2, m2, c2, h2, u2);
  if (o2) {
    const { unit: e2, increment: t3, roundingMode: r3 } = o2;
    ({ seconds: m2, milliseconds: c2, microseconds: h2, nanoseconds: u2 } = RoundDuration(0, 0, 0, 0, 0, 0, m2, c2, h2, u2, t3, e2, r3));
  }
  const p2 = [];
  n2 && p2.push(`${formatNumber(ae(n2))}Y`), a2 && p2.push(`${formatNumber(ae(a2))}M`), i2 && p2.push(`${formatNumber(ae(i2))}W`), s2 && p2.push(`${formatNumber(ae(s2))}D`);
  const f2 = [];
  l2 && f2.push(`${formatNumber(ae(l2))}H`), d2 && f2.push(`${formatNumber(ae(d2))}M`);
  const y2 = [];
  let I2, S2, g2, F2, Y2 = TotalDurationNanoseconds(0, 0, 0, m2, c2, h2, u2, 0);
  ({ quotient: Y2, remainder: I2 } = divmod(Y2, De)), { quotient: Y2, remainder: S2 } = divmod(Y2, De), { quotient: F2, remainder: g2 } = divmod(Y2, De);
  const P2 = 1e6 * ae(e.toNumber(g2)) + 1e3 * ae(e.toNumber(S2)) + ae(e.toNumber(I2));
  let Z2;
  if ("auto" === r2) {
    if (0 !== P2)
      for (Z2 = `${P2}`.padStart(9, "0"); "0" === Z2[Z2.length - 1]; )
        Z2 = Z2.slice(0, -1);
  } else
    0 !== r2 && (Z2 = `${P2}`.padStart(9, "0").slice(0, r2));
  return Z2 && y2.unshift(".", Z2), e.equal(F2, Ie) && !y2.length && "auto" === r2 || y2.unshift(abs(F2).toString()), y2.length && f2.push(`${y2.join("")}S`), f2.length && f2.unshift("T"), p2.length || f2.length ? `${T2 < 0 ? "-" : ""}P${p2.join("")}${f2.join("")}` : "PT0S";
}
function TemporalDateToString(e2, t2 = "auto") {
  return `${ISOYearString(GetSlot(e2, i))}-${ISODateTimePartString(GetSlot(e2, s))}-${ISODateTimePartString(GetSlot(e2, l))}${MaybeFormatCalendarAnnotation(GetSlot(e2, p), t2)}`;
}
function TemporalDateTimeToString(e2, t2, r2 = "auto", o2) {
  let n2 = GetSlot(e2, i), a2 = GetSlot(e2, s), f2 = GetSlot(e2, l), y2 = GetSlot(e2, d), I2 = GetSlot(e2, m), S2 = GetSlot(e2, c), g2 = GetSlot(e2, h), w2 = GetSlot(e2, u), D2 = GetSlot(e2, T);
  if (o2) {
    const { unit: e3, increment: t3, roundingMode: r3 } = o2;
    ({ year: n2, month: a2, day: f2, hour: y2, minute: I2, second: S2, millisecond: g2, microsecond: w2, nanosecond: D2 } = RoundISODateTime(n2, a2, f2, y2, I2, S2, g2, w2, D2, t3, e3, r3));
  }
  return `${ISOYearString(n2)}-${ISODateTimePartString(a2)}-${ISODateTimePartString(f2)}T${ISODateTimePartString(y2)}:${ISODateTimePartString(I2)}${FormatSecondsStringPart(S2, g2, w2, D2, t2)}${MaybeFormatCalendarAnnotation(GetSlot(e2, p), r2)}`;
}
function TemporalMonthDayToString(e2, t2 = "auto") {
  let r2 = `${ISODateTimePartString(GetSlot(e2, s))}-${ISODateTimePartString(GetSlot(e2, l))}`;
  const o2 = ToTemporalCalendarIdentifier(GetSlot(e2, p));
  if ("always" === t2 || "critical" === t2 || "iso8601" !== o2) {
    r2 = `${ISOYearString(GetSlot(e2, i))}-${r2}`;
  }
  const n2 = FormatCalendarAnnotation(o2, t2);
  return n2 && (r2 += n2), r2;
}
function TemporalYearMonthToString(e2, t2 = "auto") {
  let r2 = `${ISOYearString(GetSlot(e2, i))}-${ISODateTimePartString(GetSlot(e2, s))}`;
  const o2 = ToTemporalCalendarIdentifier(GetSlot(e2, p));
  if ("always" === t2 || "critical" === t2 || "iso8601" !== o2) {
    r2 += `-${ISODateTimePartString(GetSlot(e2, l))}`;
  }
  const n2 = FormatCalendarAnnotation(o2, t2);
  return n2 && (r2 += n2), r2;
}
function TemporalZonedDateTimeToString(e2, t2, r2 = "auto", o2 = "auto", a2 = "auto", f2) {
  let y2 = GetSlot(e2, S);
  if (f2) {
    const { unit: t3, increment: r3, roundingMode: o3 } = f2, a3 = RoundInstant(GetSlot(e2, n), r3, t3, o3);
    y2 = new (GetIntrinsic("%Temporal.Instant%"))(a3);
  }
  const I2 = GetSlot(e2, g), w2 = GetPlainDateTimeFor(I2, y2, "iso8601");
  let D2 = `${ISOYearString(GetSlot(w2, i))}-${ISODateTimePartString(GetSlot(w2, s))}-${ISODateTimePartString(GetSlot(w2, l))}T${ISODateTimePartString(GetSlot(w2, d))}:${ISODateTimePartString(GetSlot(w2, m))}${FormatSecondsStringPart(GetSlot(w2, c), GetSlot(w2, h), GetSlot(w2, u), GetSlot(w2, T), t2)}`;
  if ("never" !== a2) {
    D2 += FormatISOTimeZoneOffsetString(GetOffsetNanosecondsFor(I2, y2));
  }
  if ("never" !== o2) {
    D2 += `[${"critical" === o2 ? "!" : ""}${ToTemporalTimeZoneIdentifier(I2)}]`;
  }
  return D2 += MaybeFormatCalendarAnnotation(GetSlot(e2, p), r2), D2;
}
function IsTimeZoneOffsetString(e2) {
  return ze.test(he(e2));
}
function ParseTimeZoneOffsetString(e2) {
  const t2 = ze.exec(he(e2));
  if (!t2)
    throw new RangeError(`invalid time zone offset: ${e2}`);
  return ("-" === t2[1] || "\u2212" === t2[1] ? -1 : 1) * (1e9 * (60 * (60 * +t2[2] + +(t2[3] || 0)) + +(t2[4] || 0)) + +((t2[5] || 0) + "000000000").slice(0, 9));
}
function GetCanonicalTimeZoneIdentifier(e2) {
  if (IsTimeZoneOffsetString(e2)) {
    return FormatTimeZoneOffsetString(ParseTimeZoneOffsetString(e2));
  }
  return getIntlDateTimeFormatEnUsForTimeZone(he(e2)).resolvedOptions().timeZone;
}
function GetNamedTimeZoneOffsetNanoseconds(t2, r2) {
  const { year: o2, month: n2, day: a2, hour: i2, minute: s2, second: l2, millisecond: d2, microsecond: m2, nanosecond: c2 } = GetNamedTimeZoneDateTimeParts(t2, r2), h2 = o2 % 400, u2 = (o2 - h2) / 400, T2 = e.multiply(e.BigInt(146097), Ee), p2 = GetUTCEpochNanoseconds(h2, n2, a2, i2, s2, l2, d2, m2, c2), f2 = e.add(p2, e.multiply(T2, e.BigInt(u2)));
  return e.toNumber(e.subtract(f2, r2));
}
function FormatTimeZoneOffsetString(e2) {
  const t2 = e2 < 0 ? "-" : "+", r2 = ae(e2), o2 = r2 % 1e9, n2 = ie(r2 / 1e9) % 60, a2 = ie(r2 / 6e10) % 60, i2 = ISODateTimePartString(ie(r2 / 36e11)), s2 = ISODateTimePartString(a2), l2 = ISODateTimePartString(n2);
  let d2 = "";
  if (o2) {
    let e3 = `${o2}`.padStart(9, "0");
    for (; "0" === e3[e3.length - 1]; )
      e3 = e3.slice(0, -1);
    d2 = `:${l2}.${e3}`;
  } else
    n2 && (d2 = `:${l2}`);
  return `${t2}${i2}:${s2}${d2}`;
}
function FormatISOTimeZoneOffsetString(t2) {
  let r2 = e.toNumber(RoundNumberToIncrement(e.BigInt(t2), be, "halfExpand"));
  const o2 = r2 < 0 ? "-" : "+";
  r2 = ae(r2);
  const n2 = r2 / 6e10 % 60;
  return `${o2}${ISODateTimePartString(ie(r2 / 36e11))}:${ISODateTimePartString(n2)}`;
}
function GetUTCEpochNanoseconds(t2, r2, o2, n2, a2, i2, s2, l2, d2) {
  const m2 = /* @__PURE__ */ new Date();
  m2.setUTCHours(n2, a2, i2, s2), m2.setUTCFullYear(t2, r2 - 1, o2);
  const c2 = m2.getTime();
  if (de(c2))
    return null;
  let h2 = e.multiply(e.BigInt(c2), Ge);
  return h2 = e.add(h2, e.multiply(e.BigInt(l2), De)), h2 = e.add(h2, e.BigInt(d2)), e.lessThan(h2, Me) || e.greaterThan(h2, Re) ? null : h2;
}
function GetISOPartsFromEpoch(t2) {
  const { quotient: r2, remainder: o2 } = divmod(t2, Ge);
  let n2 = e.toNumber(r2), a2 = e.toNumber(o2);
  a2 < 0 && (a2 += 1e6, n2 -= 1);
  const i2 = ie(a2 / 1e3) % 1e3, s2 = a2 % 1e3, l2 = new Date(n2);
  return { epochMilliseconds: n2, year: l2.getUTCFullYear(), month: l2.getUTCMonth() + 1, day: l2.getUTCDate(), hour: l2.getUTCHours(), minute: l2.getUTCMinutes(), second: l2.getUTCSeconds(), millisecond: l2.getUTCMilliseconds(), microsecond: i2, nanosecond: s2 };
}
function GetNamedTimeZoneDateTimeParts(e2, t2) {
  const { epochMilliseconds: r2, millisecond: o2, microsecond: n2, nanosecond: a2 } = GetISOPartsFromEpoch(t2), { year: i2, month: s2, day: l2, hour: d2, minute: m2, second: c2 } = function GetFormatterParts(e3, t3) {
    const r3 = getIntlDateTimeFormatEnUsForTimeZone(e3).format(new Date(t3));
    return function parseFromEnUsFormat(e4) {
      const t4 = e4.split(/[^\w]+/);
      if (7 !== t4.length)
        throw new RangeError(`expected 7 parts in "${e4}`);
      const r4 = +t4[0], o3 = +t4[1];
      let n3 = +t4[2];
      const a3 = t4[3].toUpperCase();
      if ("B" === a3 || "BC" === a3)
        n3 = 1 - n3;
      else if ("A" !== a3 && "AD" !== a3)
        throw new RangeError(`Unknown era ${a3} in "${e4}`);
      let i3 = +t4[4];
      24 === i3 && (i3 = 0);
      const s3 = +t4[5], l3 = +t4[6];
      if (!(me(n3) && me(r4) && me(o3) && me(i3) && me(s3) && me(l3)))
        throw new RangeError(`Invalid number in "${e4}`);
      return { year: n3, month: r4, day: o3, hour: i3, minute: s3, second: l3 };
    }(r3);
  }(e2, r2);
  return BalanceISODateTime(i2, s2, l2, d2, m2, c2, o2, n2, a2);
}
function maxJSBI(t2, r2) {
  return e.lessThan(t2, r2) ? r2 : t2;
}
function afterLatestPossibleTzdbRuleChange() {
  return e.add(Ve(), Ze);
}
function GetNamedTimeZoneNextTransition(t2, r2) {
  if (e.lessThan(r2, Pe))
    return GetNamedTimeZoneNextTransition(t2, Pe);
  const o2 = e.add(r2, Be), n2 = maxJSBI(afterLatestPossibleTzdbRuleChange(), o2);
  let a2 = maxJSBI(Pe, r2);
  const i2 = GetNamedTimeZoneOffsetNanoseconds(t2, a2);
  let s2 = a2, l2 = i2;
  for (; i2 === l2 && e.lessThan(e.BigInt(a2), n2); ) {
    if (s2 = e.add(a2, Ne), e.greaterThan(s2, Re))
      return null;
    l2 = GetNamedTimeZoneOffsetNanoseconds(t2, s2), i2 === l2 && (a2 = s2);
  }
  if (i2 === l2)
    return null;
  return bisect((e2) => GetNamedTimeZoneOffsetNanoseconds(t2, e2), a2, s2, i2, l2);
}
function GetNamedTimeZonePreviousTransition(t2, r2) {
  const o2 = afterLatestPossibleTzdbRuleChange(), a2 = e.greaterThan(r2, o2), i2 = a2 ? e.subtract(r2, Be) : Pe;
  if ("Africa/Casablanca" === t2 || "Africa/El_Aaiun" === t2) {
    const o3 = GetSlot(ToTemporalInstant("2088-01-01T00Z"), n);
    if (e.lessThan(o3, r2))
      return GetNamedTimeZonePreviousTransition(t2, o3);
  }
  let s2 = e.subtract(r2, Se);
  if (e.lessThan(s2, Pe))
    return null;
  const l2 = GetNamedTimeZoneOffsetNanoseconds(t2, s2);
  let d2 = s2, m2 = l2;
  for (; l2 === m2 && e.greaterThan(s2, i2); ) {
    if (d2 = e.subtract(s2, Ne), e.lessThan(d2, Pe))
      return null;
    m2 = GetNamedTimeZoneOffsetNanoseconds(t2, d2), l2 === m2 && (s2 = d2);
  }
  if (l2 === m2) {
    if (a2) {
      const r3 = e.subtract(o2, Ee);
      return GetNamedTimeZonePreviousTransition(t2, r3);
    }
    return null;
  }
  return bisect((e2) => GetNamedTimeZoneOffsetNanoseconds(t2, e2), d2, s2, m2, l2);
}
function LeapYear(e2) {
  if (void 0 === e2)
    return false;
  return e2 % 4 == 0 && (!(e2 % 100 == 0) || e2 % 400 == 0);
}
function ISODaysInMonth(e2, t2) {
  return { standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] }[LeapYear(e2) ? "leapyear" : "standard"][t2 - 1];
}
function DayOfWeek(e2, t2, r2) {
  const o2 = t2 + (t2 < 3 ? 10 : -2), n2 = e2 - (t2 < 3 ? 1 : 0), a2 = ie(n2 / 100), i2 = n2 - 100 * a2, s2 = (r2 + ie(2.6 * o2 - 0.2) + (i2 + ie(i2 / 4)) + (ie(a2 / 4) - 2 * a2)) % 7;
  return s2 + (s2 <= 0 ? 7 : 0);
}
function DayOfYear(e2, t2, r2) {
  let o2 = r2;
  for (let r3 = t2 - 1; r3 > 0; r3--)
    o2 += ISODaysInMonth(e2, r3);
  return o2;
}
function WeekOfYear(e2, t2, r2) {
  const o2 = DayOfYear(e2, t2, r2), n2 = DayOfWeek(e2, t2, r2) || 7, a2 = DayOfWeek(e2, 1, 1), i2 = ie((o2 - n2 + 10) / 7);
  return i2 < 1 ? 5 === a2 || 6 === a2 && LeapYear(e2 - 1) ? { week: 53, year: e2 - 1 } : { week: 52, year: e2 - 1 } : 53 === i2 && (LeapYear(e2) ? 366 : 365) - o2 < 4 - n2 ? { week: 1, year: e2 + 1 } : { week: i2, year: e2 };
}
function DurationSign(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2) {
  for (const m2 of [e2, t2, r2, o2, n2, a2, i2, s2, l2, d2])
    if (0 !== m2)
      return m2 < 0 ? -1 : 1;
  return 0;
}
function BalanceISOYearMonth(e2, t2) {
  let r2 = e2, o2 = t2;
  if (!me(r2) || !me(o2))
    throw new RangeError("infinity is out of range");
  return o2 -= 1, r2 += ie(o2 / 12), o2 %= 12, o2 < 0 && (o2 += 12), o2 += 1, { year: r2, month: o2 };
}
function BalanceISODate(e2, t2, r2) {
  let o2 = e2, n2 = t2, a2 = r2;
  if (!me(a2))
    throw new RangeError("infinity is out of range");
  ({ year: o2, month: n2 } = BalanceISOYearMonth(o2, n2));
  const i2 = 146097;
  if (ae(a2) > i2) {
    const e3 = le(a2 / i2);
    o2 += 400 * e3, a2 -= e3 * i2;
  }
  let s2 = 0, l2 = n2 > 2 ? o2 : o2 - 1;
  for (; s2 = LeapYear(l2) ? 366 : 365, a2 < -s2; )
    o2 -= 1, l2 -= 1, a2 += s2;
  for (l2 += 1; s2 = LeapYear(l2) ? 366 : 365, a2 > s2; )
    o2 += 1, l2 += 1, a2 -= s2;
  for (; a2 < 1; )
    ({ year: o2, month: n2 } = BalanceISOYearMonth(o2, n2 - 1)), a2 += ISODaysInMonth(o2, n2);
  for (; a2 > ISODaysInMonth(o2, n2); )
    a2 -= ISODaysInMonth(o2, n2), { year: o2, month: n2 } = BalanceISOYearMonth(o2, n2 + 1);
  return { year: o2, month: n2, day: a2 };
}
function BalanceISODateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2) {
  const { deltaDays: d2, hour: m2, minute: c2, second: h2, millisecond: u2, microsecond: T2, nanosecond: p2 } = BalanceTime(o2, n2, a2, i2, s2, l2), { year: f2, month: y2, day: I2 } = BalanceISODate(e2, t2, r2 + d2);
  return { year: f2, month: y2, day: I2, hour: m2, minute: c2, second: h2, millisecond: u2, microsecond: T2, nanosecond: p2 };
}
function BalanceTime(t2, r2, o2, n2, a2, i2) {
  let s2, l2 = e.BigInt(t2), d2 = e.BigInt(r2), m2 = e.BigInt(o2), c2 = e.BigInt(n2), h2 = e.BigInt(a2), u2 = e.BigInt(i2);
  return { quotient: s2, remainder: u2 } = NonNegativeBigIntDivmod(u2, De), h2 = e.add(h2, s2), { quotient: s2, remainder: h2 } = NonNegativeBigIntDivmod(h2, De), c2 = e.add(c2, s2), { quotient: s2, remainder: c2 } = NonNegativeBigIntDivmod(c2, De), m2 = e.add(m2, s2), { quotient: s2, remainder: m2 } = NonNegativeBigIntDivmod(m2, ge), d2 = e.add(d2, s2), { quotient: s2, remainder: d2 } = NonNegativeBigIntDivmod(d2, ge), l2 = e.add(l2, s2), { quotient: s2, remainder: l2 } = NonNegativeBigIntDivmod(l2, we), { deltaDays: e.toNumber(s2), hour: e.toNumber(l2), minute: e.toNumber(d2), second: e.toNumber(m2), millisecond: e.toNumber(c2), microsecond: e.toNumber(h2), nanosecond: e.toNumber(u2) };
}
function TotalDurationNanoseconds(t2, r2, o2, n2, a2, i2, s2, l2) {
  const d2 = e.BigInt(t2);
  let m2 = e.BigInt(s2);
  0 !== t2 && (m2 = e.subtract(e.BigInt(s2), e.BigInt(l2)));
  const c2 = e.add(e.BigInt(r2), e.multiply(d2, e.BigInt(24))), h2 = e.add(e.BigInt(o2), e.multiply(c2, ge)), u2 = e.add(e.BigInt(n2), e.multiply(h2, ge)), T2 = e.add(e.BigInt(a2), e.multiply(u2, De)), p2 = e.add(e.BigInt(i2), e.multiply(T2, De));
  return e.add(e.BigInt(m2), e.multiply(p2, De));
}
function NanosecondsToDays(t2, r2) {
  const o2 = GetIntrinsic("%Temporal.Instant%"), a2 = se(e.toNumber(t2));
  let f2 = e.BigInt(t2), y2 = 864e11;
  if (0 === a2)
    return { days: 0, nanoseconds: Ie, dayLengthNs: y2 };
  if (!IsTemporalZonedDateTime(r2)) {
    let t3;
    return { quotient: t3, remainder: f2 } = divmod(f2, e.BigInt(y2)), { days: e.toNumber(t3), nanoseconds: f2, dayLengthNs: y2 };
  }
  const I2 = GetSlot(r2, n), w2 = GetSlot(r2, S), D2 = e.add(I2, f2), G2 = new o2(D2), v2 = GetSlot(r2, g), C2 = GetSlot(r2, p), O2 = GetPlainDateTimeFor(v2, w2, C2), b2 = GetPlainDateTimeFor(v2, G2, C2);
  let { days: E2 } = DifferenceISODateTime(GetSlot(O2, i), GetSlot(O2, s), GetSlot(O2, l), GetSlot(O2, d), GetSlot(O2, m), GetSlot(O2, c), GetSlot(O2, h), GetSlot(O2, u), GetSlot(O2, T), GetSlot(b2, i), GetSlot(b2, s), GetSlot(b2, l), GetSlot(b2, d), GetSlot(b2, m), GetSlot(b2, c), GetSlot(b2, h), GetSlot(b2, u), GetSlot(b2, T), C2, "day", Te(null)), M2 = AddZonedDateTime(w2, v2, C2, 0, 0, 0, E2, 0, 0, 0, 0, 0, 0), R2 = e.BigInt(E2);
  if (1 === a2)
    for (; e.greaterThan(R2, Ie) && e.greaterThan(M2, D2); )
      R2 = e.subtract(R2, Se), M2 = AddZonedDateTime(w2, v2, C2, 0, 0, 0, e.toNumber(R2), 0, 0, 0, 0, 0, 0);
  f2 = e.subtract(D2, M2);
  let F2 = false, Y2 = new o2(M2);
  do {
    const t3 = AddZonedDateTime(Y2, v2, C2, 0, 0, 0, a2, 0, 0, 0, 0, 0, 0), r3 = GetSlot(Y2, n);
    y2 = e.toNumber(e.subtract(t3, r3)), F2 = e.greaterThanOrEqual(e.multiply(e.subtract(f2, e.BigInt(y2)), e.BigInt(a2)), Ie), F2 && (f2 = e.subtract(f2, e.BigInt(y2)), Y2 = new o2(t3), R2 = e.add(R2, e.BigInt(a2)));
  } while (F2);
  if (!isZero(R2) && signJSBI(R2) !== a2)
    throw new RangeError("Time zone or calendar converted nanoseconds into a number of days with the opposite sign");
  if (!isZero(f2) && signJSBI(f2) !== a2) {
    if (isNegativeJSBI(f2) && 1 === a2)
      throw new Error("assert not reached");
    throw new RangeError("Time zone or calendar ended up with a remainder of nanoseconds with the opposite sign");
  }
  if (e.greaterThanOrEqual(abs(f2), abs(e.BigInt(y2))))
    throw new Error("assert not reached");
  return { days: e.toNumber(R2), nanoseconds: f2, dayLengthNs: ae(y2) };
}
function BalanceDuration(e2, t2, r2, o2, n2, a2, i2, s2, l2) {
  let d2 = BalancePossiblyInfiniteDuration(e2, t2, r2, o2, n2, a2, i2, s2, l2);
  if ("positive overflow" === d2 || "negative overflow" === d2)
    throw new RangeError("Duration out of range");
  return d2;
}
function BalancePossiblyInfiniteDuration(t2, r2, o2, a2, i2, s2, l2, d2, m2) {
  let c2, h2, u2, T2, f2, y2, I2 = t2;
  if (IsTemporalZonedDateTime(m2)) {
    const t3 = AddZonedDateTime(GetSlot(m2, S), GetSlot(m2, g), GetSlot(m2, p), 0, 0, 0, I2, r2, o2, a2, i2, s2, l2), d3 = GetSlot(m2, n);
    c2 = e.subtract(t3, d3);
  } else
    c2 = TotalDurationNanoseconds(I2, r2, o2, a2, i2, s2, l2, 0);
  "year" === d2 || "month" === d2 || "week" === d2 || "day" === d2 ? { days: I2, nanoseconds: c2 } = NanosecondsToDays(c2, m2) : I2 = 0;
  const w2 = e.lessThan(c2, Ie) ? -1 : 1;
  switch (c2 = abs(c2), h2 = u2 = T2 = f2 = y2 = Ie, d2) {
    case "year":
    case "month":
    case "week":
    case "day":
    case "hour":
      ({ quotient: h2, remainder: c2 } = divmod(c2, De)), { quotient: u2, remainder: h2 } = divmod(h2, De), { quotient: T2, remainder: u2 } = divmod(u2, De), { quotient: f2, remainder: T2 } = divmod(T2, ge), { quotient: y2, remainder: f2 } = divmod(f2, ge);
      break;
    case "minute":
      ({ quotient: h2, remainder: c2 } = divmod(c2, De)), { quotient: u2, remainder: h2 } = divmod(h2, De), { quotient: T2, remainder: u2 } = divmod(u2, De), { quotient: f2, remainder: T2 } = divmod(T2, ge);
      break;
    case "second":
      ({ quotient: h2, remainder: c2 } = divmod(c2, De)), { quotient: u2, remainder: h2 } = divmod(h2, De), { quotient: T2, remainder: u2 } = divmod(u2, De);
      break;
    case "millisecond":
      ({ quotient: h2, remainder: c2 } = divmod(c2, De)), { quotient: u2, remainder: h2 } = divmod(h2, De);
      break;
    case "microsecond":
      ({ quotient: h2, remainder: c2 } = divmod(c2, De));
      break;
    case "nanosecond":
      break;
    default:
      throw new Error("assert not reached");
  }
  const D2 = e.toNumber(y2) * w2, G2 = e.toNumber(f2) * w2, v2 = e.toNumber(T2) * w2, C2 = e.toNumber(u2) * w2, O2 = e.toNumber(h2) * w2, b2 = e.toNumber(c2) * w2;
  for (const e2 of [I2, D2, G2, v2, C2, O2, b2])
    if (!me(e2))
      return 1 === w2 ? "positive overflow" : "negative overflow";
  return { days: I2, hours: D2, minutes: G2, seconds: v2, milliseconds: C2, microseconds: O2, nanoseconds: b2 };
}
function UnbalanceDurationRelative(t2, r2, o2, n2, a2, i2) {
  const s2 = GetIntrinsic("%Temporal.Duration%"), l2 = DurationSign(t2, r2, o2, n2, 0, 0, 0, 0, 0, 0);
  if (0 === l2)
    return { years: t2, months: r2, weeks: o2, days: n2 };
  const d2 = e.BigInt(l2);
  let m2, c2, h2 = e.BigInt(t2), u2 = e.BigInt(r2), T2 = e.BigInt(o2), f2 = e.BigInt(n2);
  i2 && (c2 = ToTemporalDate(i2), m2 = GetSlot(c2, p));
  const y2 = new s2(l2), I2 = new s2(0, l2), S2 = new s2(0, 0, l2);
  switch (a2) {
    case "year":
      break;
    case "month":
      {
        if (!m2)
          throw new RangeError("a starting point is required for months balancing");
        let t3, r3;
        for ("string" != typeof m2 && (t3 = GetMethod(m2, "dateAdd"), r3 = GetMethod(m2, "dateUntil")); !isZero(h2); ) {
          const o3 = CalendarDateAdd(m2, c2, y2, void 0, t3), n3 = Te(null);
          n3.largestUnit = "month";
          const a3 = CalendarDateUntil(m2, c2, o3, n3, r3), i3 = e.BigInt(GetSlot(a3, D));
          c2 = o3, u2 = e.add(u2, i3), h2 = e.subtract(h2, d2);
        }
      }
      break;
    case "week": {
      if (!m2)
        throw new RangeError("a starting point is required for weeks balancing");
      const t3 = "string" != typeof m2 ? GetMethod(m2, "dateAdd") : void 0;
      for (; !isZero(h2); ) {
        let r3;
        ({ relativeTo: c2, days: r3 } = MoveRelativeDate(m2, c2, y2, t3)), f2 = e.add(f2, e.BigInt(r3)), h2 = e.subtract(h2, d2);
      }
      for (; !isZero(u2); ) {
        let r3;
        ({ relativeTo: c2, days: r3 } = MoveRelativeDate(m2, c2, I2, t3)), f2 = e.add(f2, e.BigInt(r3)), u2 = e.subtract(u2, d2);
      }
      break;
    }
    default: {
      if (isZero(h2) && isZero(u2) && isZero(T2))
        break;
      if (!m2)
        throw new RangeError("a starting point is required for balancing calendar units");
      const t3 = "string" != typeof m2 ? GetMethod(m2, "dateAdd") : void 0;
      for (; !isZero(h2); ) {
        let r3;
        ({ relativeTo: c2, days: r3 } = MoveRelativeDate(m2, c2, y2, t3)), f2 = e.add(f2, e.BigInt(r3)), h2 = e.subtract(h2, d2);
      }
      for (; !isZero(u2); ) {
        let r3;
        ({ relativeTo: c2, days: r3 } = MoveRelativeDate(m2, c2, I2, t3)), f2 = e.add(f2, e.BigInt(r3)), u2 = e.subtract(u2, d2);
      }
      for (; !isZero(T2); ) {
        let r3;
        ({ relativeTo: c2, days: r3 } = MoveRelativeDate(m2, c2, S2, t3)), f2 = e.add(f2, e.BigInt(r3)), T2 = e.subtract(T2, d2);
      }
      break;
    }
  }
  return { years: e.toNumber(h2), months: e.toNumber(u2), weeks: e.toNumber(T2), days: e.toNumber(f2) };
}
function CalculateOffsetShift(e2, t2, r2, o2, n2) {
  if (IsTemporalZonedDateTime(e2)) {
    const a2 = GetSlot(e2, S), i2 = GetSlot(e2, g), s2 = GetSlot(e2, p), l2 = GetOffsetNanosecondsFor(i2, a2), d2 = AddZonedDateTime(a2, i2, s2, t2, r2, o2, n2, 0, 0, 0, 0, 0, 0);
    return GetOffsetNanosecondsFor(i2, new (GetIntrinsic("%Temporal.Instant%"))(d2)) - l2;
  }
  return 0;
}
function CreateNegatedTemporalDuration(e2) {
  return new (GetIntrinsic("%Temporal.Duration%"))(-GetSlot(e2, w), -GetSlot(e2, D), -GetSlot(e2, G), -GetSlot(e2, v), -GetSlot(e2, C), -GetSlot(e2, O), -GetSlot(e2, b), -GetSlot(e2, E), -GetSlot(e2, M), -GetSlot(e2, R));
}
function ConstrainToRange(e2, t2, r2) {
  return oe(r2, ne(t2, e2));
}
function ConstrainISODate(e2, t2, r2) {
  const o2 = ConstrainToRange(t2, 1, 12);
  return { year: e2, month: o2, day: ConstrainToRange(r2, 1, ISODaysInMonth(e2, o2)) };
}
function RejectToRange(e2, t2, r2) {
  if (e2 < t2 || e2 > r2)
    throw new RangeError(`value out of range: ${t2} <= ${e2} <= ${r2}`);
}
function RejectISODate(e2, t2, r2) {
  RejectToRange(t2, 1, 12), RejectToRange(r2, 1, ISODaysInMonth(e2, t2));
}
function RejectDateRange(e2, t2, r2) {
  RejectDateTimeRange(e2, t2, r2, 12, 0, 0, 0, 0, 0);
}
function RejectTime(e2, t2, r2, o2, n2, a2) {
  RejectToRange(e2, 0, 23), RejectToRange(t2, 0, 59), RejectToRange(r2, 0, 59), RejectToRange(o2, 0, 999), RejectToRange(n2, 0, 999), RejectToRange(a2, 0, 999);
}
function RejectDateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2) {
  RejectISODate(e2, t2, r2), RejectTime(o2, n2, a2, i2, s2, l2);
}
function RejectDateTimeRange(e2, t2, r2, o2, n2, a2, i2, s2, l2) {
  if (RejectToRange(e2, Fe, Ye), e2 === Fe && null == GetUTCEpochNanoseconds(e2, t2, r2 + 1, o2, n2, a2, i2, s2, l2 - 1) || e2 === Ye && null == GetUTCEpochNanoseconds(e2, t2, r2 - 1, o2, n2, a2, i2, s2, l2 + 1))
    throw new RangeError("DateTime outside of supported range");
}
function ValidateEpochNanoseconds(t2) {
  if (e.lessThan(t2, Me) || e.greaterThan(t2, Re))
    throw new RangeError("Instant outside of supported range");
}
function RejectDuration(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2) {
  const m2 = DurationSign(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2);
  for (const c2 of [e2, t2, r2, o2, n2, a2, i2, s2, l2, d2]) {
    if (!me(c2))
      throw new RangeError("infinite values not allowed as duration fields");
    const e3 = se(c2);
    if (0 !== e3 && e3 !== m2)
      throw new RangeError("mixed-sign values not allowed as duration fields");
  }
}
function DifferenceISODate(e2, t2, r2, o2, n2, a2, i2) {
  switch (i2) {
    case "year":
    case "month": {
      const s2 = -CompareISODate(e2, t2, r2, o2, n2, a2);
      if (0 === s2)
        return { years: 0, months: 0, weeks: 0, days: 0 };
      const l2 = { year: e2, month: t2, day: r2 }, d2 = { year: o2, month: n2, day: a2 };
      let m2 = d2.year - l2.year, c2 = AddISODate(e2, t2, r2, m2, 0, 0, 0, "constrain"), h2 = -CompareISODate(c2.year, c2.month, c2.day, o2, n2, a2);
      if (0 === h2)
        return "year" === i2 ? { years: m2, months: 0, weeks: 0, days: 0 } : { years: 0, months: 12 * m2, weeks: 0, days: 0 };
      let u2 = d2.month - l2.month;
      if (h2 !== s2 && (m2 -= s2, u2 += 12 * s2), c2 = AddISODate(e2, t2, r2, m2, u2, 0, 0, "constrain"), h2 = -CompareISODate(c2.year, c2.month, c2.day, o2, n2, a2), 0 === h2)
        return "year" === i2 ? { years: m2, months: u2, weeks: 0, days: 0 } : { years: 0, months: u2 + 12 * m2, weeks: 0, days: 0 };
      h2 !== s2 && (u2 -= s2, u2 === -s2 && (m2 -= s2, u2 = 11 * s2), c2 = AddISODate(e2, t2, r2, m2, u2, 0, 0, "constrain"));
      let T2 = 0;
      return T2 = c2.month === d2.month ? d2.day - c2.day : s2 < 0 ? -c2.day - (ISODaysInMonth(d2.year, d2.month) - d2.day) : d2.day + (ISODaysInMonth(c2.year, c2.month) - c2.day), "month" === i2 && (u2 += 12 * m2, m2 = 0), { years: m2, months: u2, weeks: 0, days: T2 };
    }
    case "week":
    case "day": {
      let s2, l2, d2;
      CompareISODate(e2, t2, r2, o2, n2, a2) < 0 ? (l2 = { year: e2, month: t2, day: r2 }, s2 = { year: o2, month: n2, day: a2 }, d2 = 1) : (l2 = { year: o2, month: n2, day: a2 }, s2 = { year: e2, month: t2, day: r2 }, d2 = -1);
      let m2 = DayOfYear(s2.year, s2.month, s2.day) - DayOfYear(l2.year, l2.month, l2.day);
      for (let e3 = l2.year; e3 < s2.year; ++e3)
        m2 += LeapYear(e3) ? 366 : 365;
      let c2 = 0;
      return "week" === i2 && (c2 = ie(m2 / 7), m2 %= 7), c2 *= d2, m2 *= d2, { years: 0, months: 0, weeks: c2, days: m2 };
    }
    default:
      throw new Error("assert not reached");
  }
}
function DifferenceTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2) {
  let h2 = i2 - e2, u2 = s2 - t2, T2 = l2 - r2, p2 = d2 - o2, f2 = m2 - n2, y2 = c2 - a2;
  const I2 = DurationSign(0, 0, 0, 0, h2, u2, T2, p2, f2, y2);
  h2 *= I2, u2 *= I2, T2 *= I2, p2 *= I2, f2 *= I2, y2 *= I2;
  let S2 = 0;
  if ({ deltaDays: S2, hour: h2, minute: u2, second: T2, millisecond: p2, microsecond: f2, nanosecond: y2 } = BalanceTime(h2, u2, T2, p2, f2, y2), 0 != S2)
    throw new Error("assertion failure in DifferenceTime: _bt_.[[Days]] should be 0");
  return h2 *= I2, u2 *= I2, T2 *= I2, p2 *= I2, f2 *= I2, y2 *= I2, { hours: h2, minutes: u2, seconds: T2, milliseconds: p2, microseconds: f2, nanoseconds: y2 };
}
function DifferenceInstant(t2, r2, o2, n2, a2, i2) {
  const s2 = e.subtract(r2, t2);
  let l2 = 0, d2 = 0, m2 = e.toNumber(e.remainder(s2, De)), c2 = e.toNumber(e.remainder(e.divide(s2, De), De)), h2 = e.toNumber(e.remainder(e.divide(s2, Ge), De)), u2 = e.toNumber(e.divide(s2, ve));
  return { hours: l2, minutes: d2, seconds: u2, milliseconds: h2, microseconds: c2, nanoseconds: m2 } = RoundDuration(0, 0, 0, 0, 0, 0, u2, h2, c2, m2, o2, n2, i2), BalanceDuration(0, l2, d2, u2, h2, c2, m2, a2);
}
function DifferenceISODateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2, p2, f2, y2, I2, S2, g2) {
  let w2 = e2, D2 = t2, G2 = r2, { hours: v2, minutes: C2, seconds: O2, milliseconds: b2, microseconds: E2, nanoseconds: M2 } = DifferenceTime(o2, n2, a2, i2, s2, l2, h2, u2, T2, p2, f2, y2);
  const R2 = DurationSign(0, 0, 0, 0, v2, C2, O2, b2, E2, M2);
  CompareISODate(d2, m2, c2, w2, D2, G2) === -R2 && ({ year: w2, month: D2, day: G2 } = BalanceISODate(w2, D2, G2 - R2), { hours: v2, minutes: C2, seconds: O2, milliseconds: b2, microseconds: E2, nanoseconds: M2 } = BalanceDuration(-R2, v2, C2, O2, b2, E2, M2, S2));
  const F2 = CreateTemporalDate(w2, D2, G2, I2), Y2 = CreateTemporalDate(d2, m2, c2, I2), P2 = LargerOfTwoTemporalUnits("day", S2), Z2 = CopyOptions(g2);
  Z2.largestUnit = P2;
  let { years: B2, months: N2, weeks: j2, days: $2 } = CalendarDateUntil(I2, F2, Y2, Z2);
  return { days: $2, hours: v2, minutes: C2, seconds: O2, milliseconds: b2, microseconds: E2, nanoseconds: M2 } = BalanceDuration($2, v2, C2, O2, b2, E2, M2, S2), { years: B2, months: N2, weeks: j2, days: $2, hours: v2, minutes: C2, seconds: O2, milliseconds: b2, microseconds: E2, nanoseconds: M2 };
}
function DifferenceZonedDateTime(t2, r2, o2, n2, a2, p2) {
  const f2 = e.subtract(r2, t2);
  if (e.equal(f2, Ie))
    return { years: 0, months: 0, weeks: 0, days: 0, hours: 0, minutes: 0, seconds: 0, milliseconds: 0, microseconds: 0, nanoseconds: 0 };
  const y2 = GetIntrinsic("%Temporal.Instant%"), I2 = new y2(t2), S2 = new y2(r2), g2 = GetPlainDateTimeFor(o2, I2, n2), w2 = GetPlainDateTimeFor(o2, S2, n2);
  let { years: D2, months: G2, weeks: v2, days: C2 } = DifferenceISODateTime(GetSlot(g2, i), GetSlot(g2, s), GetSlot(g2, l), GetSlot(g2, d), GetSlot(g2, m), GetSlot(g2, c), GetSlot(g2, h), GetSlot(g2, u), GetSlot(g2, T), GetSlot(w2, i), GetSlot(w2, s), GetSlot(w2, l), GetSlot(w2, d), GetSlot(w2, m), GetSlot(w2, c), GetSlot(w2, h), GetSlot(w2, u), GetSlot(w2, T), n2, a2, p2);
  const O2 = AddZonedDateTime(I2, o2, n2, D2, G2, v2, 0, 0, 0, 0, 0, 0, 0);
  let b2 = e.subtract(r2, O2);
  const E2 = CreateTemporalZonedDateTime(O2, o2, n2);
  ({ nanoseconds: b2, days: C2 } = NanosecondsToDays(b2, E2));
  const { hours: M2, minutes: R2, seconds: F2, milliseconds: Y2, microseconds: P2, nanoseconds: Z2 } = BalanceDuration(0, 0, 0, 0, 0, 0, e.toNumber(b2), "hour");
  return { years: D2, months: G2, weeks: v2, days: C2, hours: M2, minutes: R2, seconds: F2, milliseconds: Y2, microseconds: P2, nanoseconds: Z2 };
}
function GetDifferenceSettings(e2, t2, r2, o2, n2, a2) {
  const i2 = Ue.reduce((e3, t3) => {
    const n3 = t3[0], a3 = t3[1], i3 = t3[2];
    return "datetime" !== r2 && i3 !== r2 || o2.includes(a3) || e3.push(a3, n3), e3;
  }, []);
  let s2 = GetTemporalUnit(t2, "largestUnit", r2, "auto");
  if (o2.includes(s2))
    throw new RangeError(`largestUnit must be one of ${i2.join(", ")}, not ${s2}`);
  const l2 = ToTemporalRoundingIncrement(t2);
  let d2 = ToTemporalRoundingMode(t2, "trunc");
  "since" === e2 && (d2 = function NegateTemporalRoundingMode(e3) {
    switch (e3) {
      case "ceil":
        return "floor";
      case "floor":
        return "ceil";
      case "halfCeil":
        return "halfFloor";
      case "halfFloor":
        return "halfCeil";
      default:
        return e3;
    }
  }(d2));
  const m2 = GetTemporalUnit(t2, "smallestUnit", r2, n2);
  if (o2.includes(m2))
    throw new RangeError(`smallestUnit must be one of ${i2.join(", ")}, not ${m2}`);
  const c2 = LargerOfTwoTemporalUnits(a2, m2);
  if ("auto" === s2 && (s2 = c2), LargerOfTwoTemporalUnits(s2, m2) !== s2)
    throw new RangeError(`largestUnit ${s2} cannot be smaller than smallestUnit ${m2}`);
  const h2 = { hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[m2];
  return void 0 !== h2 && ValidateTemporalRoundingIncrement(l2, h2, false), { largestUnit: s2, roundingIncrement: l2, roundingMode: d2, smallestUnit: m2 };
}
function DifferenceTemporalInstant(e2, t2, r2, o2) {
  const a2 = "since" === e2 ? -1 : 1, i2 = ToTemporalInstant(r2), s2 = GetDifferenceSettings(e2, CopyOptions(o2), "time", [], "nanosecond", "second"), l2 = GetSlot(t2, n), d2 = GetSlot(i2, n);
  let { hours: m2, minutes: c2, seconds: h2, milliseconds: u2, microseconds: T2, nanoseconds: p2 } = DifferenceInstant(l2, d2, s2.roundingIncrement, s2.smallestUnit, s2.largestUnit, s2.roundingMode);
  return new (GetIntrinsic("%Temporal.Duration%"))(0, 0, 0, 0, a2 * m2, a2 * c2, a2 * h2, a2 * u2, a2 * T2, a2 * p2);
}
function DifferenceTemporalPlainDate(e2, t2, r2, o2) {
  const n2 = "since" === e2 ? -1 : 1, a2 = ToTemporalDate(r2), i2 = GetSlot(t2, p);
  ThrowIfCalendarsNotEqual(i2, GetSlot(a2, p), "compute difference between dates");
  const s2 = CopyOptions(o2), l2 = GetDifferenceSettings(e2, s2, "date", [], "day", "day");
  s2.largestUnit = l2.largestUnit;
  let { years: d2, months: m2, weeks: c2, days: h2 } = CalendarDateUntil(i2, t2, a2, s2);
  "day" === l2.smallestUnit && 1 === l2.roundingIncrement || ({ years: d2, months: m2, weeks: c2, days: h2 } = RoundDuration(d2, m2, c2, h2, 0, 0, 0, 0, 0, 0, l2.roundingIncrement, l2.smallestUnit, l2.roundingMode, t2));
  return new (GetIntrinsic("%Temporal.Duration%"))(n2 * d2, n2 * m2, n2 * c2, n2 * h2, 0, 0, 0, 0, 0, 0);
}
function DifferenceTemporalPlainDateTime(e2, t2, r2, o2) {
  const n2 = "since" === e2 ? -1 : 1, a2 = ToTemporalDateTime(r2), f2 = GetSlot(t2, p);
  ThrowIfCalendarsNotEqual(f2, GetSlot(a2, p), "compute difference between dates");
  const y2 = CopyOptions(o2), I2 = GetDifferenceSettings(e2, y2, "datetime", [], "nanosecond", "day");
  let { years: S2, months: g2, weeks: w2, days: D2, hours: G2, minutes: v2, seconds: C2, milliseconds: O2, microseconds: b2, nanoseconds: E2 } = DifferenceISODateTime(GetSlot(t2, i), GetSlot(t2, s), GetSlot(t2, l), GetSlot(t2, d), GetSlot(t2, m), GetSlot(t2, c), GetSlot(t2, h), GetSlot(t2, u), GetSlot(t2, T), GetSlot(a2, i), GetSlot(a2, s), GetSlot(a2, l), GetSlot(a2, d), GetSlot(a2, m), GetSlot(a2, c), GetSlot(a2, h), GetSlot(a2, u), GetSlot(a2, T), f2, I2.largestUnit, y2);
  const M2 = TemporalDateTimeToDate(t2);
  ({ years: S2, months: g2, weeks: w2, days: D2, hours: G2, minutes: v2, seconds: C2, milliseconds: O2, microseconds: b2, nanoseconds: E2 } = RoundDuration(S2, g2, w2, D2, G2, v2, C2, O2, b2, E2, I2.roundingIncrement, I2.smallestUnit, I2.roundingMode, M2)), { days: D2, hours: G2, minutes: v2, seconds: C2, milliseconds: O2, microseconds: b2, nanoseconds: E2 } = BalanceDuration(D2, G2, v2, C2, O2, b2, E2, I2.largestUnit);
  return new (GetIntrinsic("%Temporal.Duration%"))(n2 * S2, n2 * g2, n2 * w2, n2 * D2, n2 * G2, n2 * v2, n2 * C2, n2 * O2, n2 * b2, n2 * E2);
}
function DifferenceTemporalPlainTime(e2, t2, r2, o2) {
  const n2 = "since" === e2 ? -1 : 1, a2 = ToTemporalTime(r2), i2 = GetDifferenceSettings(e2, CopyOptions(o2), "time", [], "nanosecond", "hour");
  let { hours: s2, minutes: l2, seconds: p2, milliseconds: f2, microseconds: y2, nanoseconds: I2 } = DifferenceTime(GetSlot(t2, d), GetSlot(t2, m), GetSlot(t2, c), GetSlot(t2, h), GetSlot(t2, u), GetSlot(t2, T), GetSlot(a2, d), GetSlot(a2, m), GetSlot(a2, c), GetSlot(a2, h), GetSlot(a2, u), GetSlot(a2, T));
  ({ hours: s2, minutes: l2, seconds: p2, milliseconds: f2, microseconds: y2, nanoseconds: I2 } = RoundDuration(0, 0, 0, 0, s2, l2, p2, f2, y2, I2, i2.roundingIncrement, i2.smallestUnit, i2.roundingMode)), { hours: s2, minutes: l2, seconds: p2, milliseconds: f2, microseconds: y2, nanoseconds: I2 } = BalanceDuration(0, s2, l2, p2, f2, y2, I2, i2.largestUnit);
  return new (GetIntrinsic("%Temporal.Duration%"))(0, 0, 0, 0, n2 * s2, n2 * l2, n2 * p2, n2 * f2, n2 * y2, n2 * I2);
}
function DifferenceTemporalPlainYearMonth(e2, t2, r2, o2) {
  const n2 = "since" === e2 ? -1 : 1, a2 = ToTemporalYearMonth(r2), i2 = GetSlot(t2, p);
  ThrowIfCalendarsNotEqual(i2, GetSlot(a2, p), "compute difference between months");
  const s2 = CopyOptions(o2), l2 = GetDifferenceSettings(e2, s2, "date", ["week", "day"], "month", "year");
  s2.largestUnit = l2.largestUnit;
  const d2 = CalendarFields(i2, ["monthCode", "year"]), m2 = PrepareTemporalFields(t2, d2, []);
  m2.day = 1;
  const c2 = CalendarDateFromFields(i2, m2), h2 = PrepareTemporalFields(a2, d2, []);
  h2.day = 1;
  const u2 = CalendarDateFromFields(i2, h2);
  let { years: T2, months: f2 } = CalendarDateUntil(i2, c2, u2, s2);
  "month" === l2.smallestUnit && 1 === l2.roundingIncrement || ({ years: T2, months: f2 } = RoundDuration(T2, f2, 0, 0, 0, 0, 0, 0, 0, 0, l2.roundingIncrement, l2.smallestUnit, l2.roundingMode, c2));
  return new (GetIntrinsic("%Temporal.Duration%"))(n2 * T2, n2 * f2, 0, 0, 0, 0, 0, 0, 0, 0);
}
function DifferenceTemporalZonedDateTime(e2, t2, r2, o2) {
  const a2 = "since" === e2 ? -1 : 1, i2 = ToTemporalZonedDateTime(r2), s2 = GetSlot(t2, p);
  ThrowIfCalendarsNotEqual(s2, GetSlot(i2, p), "compute difference between dates");
  const l2 = CopyOptions(o2), d2 = GetDifferenceSettings(e2, l2, "datetime", [], "nanosecond", "hour");
  l2.largestUnit = d2.largestUnit;
  const m2 = GetSlot(t2, n), c2 = GetSlot(i2, n);
  let h2, u2, T2, f2, y2, I2, S2, w2, D2, G2;
  if ("year" !== d2.largestUnit && "month" !== d2.largestUnit && "week" !== d2.largestUnit && "day" !== d2.largestUnit)
    h2 = 0, u2 = 0, T2 = 0, f2 = 0, { hours: y2, minutes: I2, seconds: S2, milliseconds: w2, microseconds: D2, nanoseconds: G2 } = DifferenceInstant(m2, c2, d2.roundingIncrement, d2.smallestUnit, d2.largestUnit, d2.roundingMode);
  else {
    const e3 = GetSlot(t2, g);
    if (!TimeZoneEquals(e3, GetSlot(i2, g)))
      throw new RangeError("When calculating difference between time zones, largestUnit must be 'hours' or smaller because day lengths can vary between time zones due to DST or time zone offset changes.");
    ({ years: h2, months: u2, weeks: T2, days: f2, hours: y2, minutes: I2, seconds: S2, milliseconds: w2, microseconds: D2, nanoseconds: G2 } = DifferenceZonedDateTime(m2, c2, e3, s2, d2.largestUnit, l2)), { years: h2, months: u2, weeks: T2, days: f2, hours: y2, minutes: I2, seconds: S2, milliseconds: w2, microseconds: D2, nanoseconds: G2 } = RoundDuration(h2, u2, T2, f2, y2, I2, S2, w2, D2, G2, d2.roundingIncrement, d2.smallestUnit, d2.roundingMode, t2), { years: h2, months: u2, weeks: T2, days: f2, hours: y2, minutes: I2, seconds: S2, milliseconds: w2, microseconds: D2, nanoseconds: G2 } = AdjustRoundedDurationDays(h2, u2, T2, f2, y2, I2, S2, w2, D2, G2, d2.roundingIncrement, d2.smallestUnit, d2.roundingMode, t2);
  }
  return new (GetIntrinsic("%Temporal.Duration%"))(a2 * h2, a2 * u2, a2 * T2, a2 * f2, a2 * y2, a2 * I2, a2 * S2, a2 * w2, a2 * D2, a2 * G2);
}
function AddISODate(e2, t2, r2, o2, n2, a2, i2, s2) {
  let l2 = e2, d2 = t2, m2 = r2, c2 = a2, h2 = i2;
  return l2 += o2, d2 += n2, { year: l2, month: d2 } = BalanceISOYearMonth(l2, d2), { year: l2, month: d2, day: m2 } = RegulateISODate(l2, d2, m2, s2), h2 += 7 * c2, m2 += h2, { year: l2, month: d2, day: m2 } = BalanceISODate(l2, d2, m2), { year: l2, month: d2, day: m2 };
}
function AddTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2) {
  let h2 = e2, u2 = t2, T2 = r2, p2 = o2, f2 = n2, y2 = a2;
  h2 += i2, u2 += s2, T2 += l2, p2 += d2, f2 += m2, y2 += c2;
  let I2 = 0;
  return { deltaDays: I2, hour: h2, minute: u2, second: T2, millisecond: p2, microsecond: f2, nanosecond: y2 } = BalanceTime(h2, u2, T2, p2, f2, y2), { deltaDays: I2, hour: h2, minute: u2, second: T2, millisecond: p2, microsecond: f2, nanosecond: y2 };
}
function AddDuration(t2, r2, o2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2, f2, y2, I2, w2, D2, G2, v2, C2) {
  const O2 = LargerOfTwoTemporalUnits(DefaultTemporalLargestUnit(t2, r2, o2, a2, i2, s2, l2, d2, m2, c2), DefaultTemporalLargestUnit(h2, u2, T2, f2, y2, I2, w2, D2, G2, v2));
  let b2, E2, M2, R2, F2, Y2, P2, Z2, B2, N2;
  if (C2)
    if (IsTemporalDate(C2)) {
      const n2 = GetIntrinsic("%Temporal.Duration%"), S2 = GetSlot(C2, p), g2 = new n2(t2, r2, o2, a2, 0, 0, 0, 0, 0, 0), j2 = new n2(h2, u2, T2, f2, 0, 0, 0, 0, 0, 0), $2 = "string" != typeof S2 ? GetMethod(S2, "dateAdd") : void 0, k2 = CalendarDateAdd(S2, C2, g2, void 0, $2), U2 = CalendarDateAdd(S2, k2, j2, void 0, $2), A2 = LargerOfTwoTemporalUnits("day", O2), L2 = Te(null);
      L2.largestUnit = A2, { years: b2, months: E2, weeks: M2, days: R2 } = CalendarDateUntil(S2, C2, U2, L2), { days: R2, hours: F2, minutes: Y2, seconds: P2, milliseconds: Z2, microseconds: B2, nanoseconds: N2 } = BalanceDuration(R2, e.add(e.BigInt(i2), e.BigInt(y2)), e.add(e.BigInt(s2), e.BigInt(I2)), e.add(e.BigInt(l2), e.BigInt(w2)), e.add(e.BigInt(d2), e.BigInt(D2)), e.add(e.BigInt(m2), e.BigInt(G2)), e.add(e.BigInt(c2), e.BigInt(v2)), O2);
    } else {
      const e2 = GetIntrinsic("%Temporal.Instant%"), j2 = GetSlot(C2, g), $2 = GetSlot(C2, p), k2 = AddZonedDateTime(GetSlot(C2, S), j2, $2, t2, r2, o2, a2, i2, s2, l2, d2, m2, c2), U2 = AddZonedDateTime(new e2(k2), j2, $2, h2, u2, T2, f2, y2, I2, w2, D2, G2, v2);
      "year" !== O2 && "month" !== O2 && "week" !== O2 && "day" !== O2 ? (b2 = 0, E2 = 0, M2 = 0, R2 = 0, { hours: F2, minutes: Y2, seconds: P2, milliseconds: Z2, microseconds: B2, nanoseconds: N2 } = DifferenceInstant(GetSlot(C2, n), U2, 1, "nanosecond", O2, "halfExpand")) : { years: b2, months: E2, weeks: M2, days: R2, hours: F2, minutes: Y2, seconds: P2, milliseconds: Z2, microseconds: B2, nanoseconds: N2 } = DifferenceZonedDateTime(GetSlot(C2, n), U2, j2, $2, O2, Te(null));
    }
  else {
    if ("year" === O2 || "month" === O2 || "week" === O2)
      throw new RangeError("relativeTo is required for years, months, or weeks arithmetic");
    b2 = E2 = M2 = 0, { days: R2, hours: F2, minutes: Y2, seconds: P2, milliseconds: Z2, microseconds: B2, nanoseconds: N2 } = BalanceDuration(a2 + f2, e.add(e.BigInt(i2), e.BigInt(y2)), e.add(e.BigInt(s2), e.BigInt(I2)), e.add(e.BigInt(l2), e.BigInt(w2)), e.add(e.BigInt(d2), e.BigInt(D2)), e.add(e.BigInt(m2), e.BigInt(G2)), e.add(e.BigInt(c2), e.BigInt(v2)), O2);
  }
  return RejectDuration(b2, E2, M2, R2, F2, Y2, P2, Z2, B2, N2), { years: b2, months: E2, weeks: M2, days: R2, hours: F2, minutes: Y2, seconds: P2, milliseconds: Z2, microseconds: B2, nanoseconds: N2 };
}
function AddInstant(t2, r2, o2, n2, a2, i2, s2) {
  let l2 = Ie;
  l2 = e.add(l2, e.BigInt(s2)), l2 = e.add(l2, e.multiply(e.BigInt(i2), De)), l2 = e.add(l2, e.multiply(e.BigInt(a2), Ge)), l2 = e.add(l2, e.multiply(e.BigInt(n2), ve)), l2 = e.add(l2, e.multiply(e.BigInt(o2), e.BigInt(6e10))), l2 = e.add(l2, e.multiply(e.BigInt(r2), e.BigInt(36e11)));
  const d2 = e.add(t2, l2);
  return ValidateEpochNanoseconds(d2), d2;
}
function AddDateTime(e2, t2, r2, o2, n2, a2, d2, m2, c2, h2, u2, T2, p2, f2, y2, I2, S2, g2, w2, D2, G2) {
  let v2 = f2, { deltaDays: C2, hour: O2, minute: b2, second: E2, millisecond: M2, microsecond: R2, nanosecond: F2 } = AddTime(o2, n2, a2, d2, m2, c2, y2, I2, S2, g2, w2, D2);
  v2 += C2;
  const Y2 = GetIntrinsic("%Temporal.Duration%"), P2 = CalendarDateAdd(h2, CreateTemporalDate(e2, t2, r2, h2), new Y2(u2, T2, p2, v2, 0, 0, 0, 0, 0, 0), G2);
  return { year: GetSlot(P2, i), month: GetSlot(P2, s), day: GetSlot(P2, l), hour: O2, minute: b2, second: E2, millisecond: M2, microsecond: R2, nanosecond: F2 };
}
function AddZonedDateTime(e2, t2, r2, o2, a2, p2, f2, y2, I2, S2, g2, w2, D2, G2) {
  const v2 = GetIntrinsic("%Temporal.Duration%");
  if (0 === DurationSign(o2, a2, p2, f2, 0, 0, 0, 0, 0, 0))
    return AddInstant(GetSlot(e2, n), y2, I2, S2, g2, w2, D2);
  const C2 = GetPlainDateTimeFor(t2, e2, r2), O2 = CalendarDateAdd(r2, CreateTemporalDate(GetSlot(C2, i), GetSlot(C2, s), GetSlot(C2, l), r2), new v2(o2, a2, p2, f2, 0, 0, 0, 0, 0, 0), G2), b2 = CreateTemporalDateTime(GetSlot(O2, i), GetSlot(O2, s), GetSlot(O2, l), GetSlot(C2, d), GetSlot(C2, m), GetSlot(C2, c), GetSlot(C2, h), GetSlot(C2, u), GetSlot(C2, T), r2);
  return AddInstant(GetSlot(GetInstantFor(t2, b2, "compatible"), n), y2, I2, S2, g2, w2, D2);
}
function AddDurationToOrSubtractDurationFromDuration(e2, t2, r2, o2) {
  const n2 = "subtract" === e2 ? -1 : 1;
  let { years: a2, months: i2, weeks: s2, days: l2, hours: d2, minutes: m2, seconds: c2, milliseconds: h2, microseconds: u2, nanoseconds: T2 } = ToTemporalDurationRecord(r2);
  const p2 = ToRelativeTemporalObject(GetOptionsObject(o2));
  ({ years: a2, months: i2, weeks: s2, days: l2, hours: d2, minutes: m2, seconds: c2, milliseconds: h2, microseconds: u2, nanoseconds: T2 } = AddDuration(GetSlot(t2, w), GetSlot(t2, D), GetSlot(t2, G), GetSlot(t2, v), GetSlot(t2, C), GetSlot(t2, O), GetSlot(t2, b), GetSlot(t2, E), GetSlot(t2, M), GetSlot(t2, R), n2 * a2, n2 * i2, n2 * s2, n2 * l2, n2 * d2, n2 * m2, n2 * c2, n2 * h2, n2 * u2, n2 * T2, p2));
  return new (GetIntrinsic("%Temporal.Duration%"))(a2, i2, s2, l2, d2, m2, c2, h2, u2, T2);
}
function AddDurationToOrSubtractDurationFromInstant(e2, t2, r2) {
  const o2 = "subtract" === e2 ? -1 : 1, { hours: a2, minutes: i2, seconds: s2, milliseconds: l2, microseconds: d2, nanoseconds: m2 } = function ToLimitedTemporalDuration(e3, t3) {
    let r3 = ToTemporalDurationRecord(e3);
    for (const e4 of t3)
      if (0 !== r3[e4])
        throw new RangeError(`Duration field ${e4} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`);
    return r3;
  }(r2, ["years", "months", "weeks", "days"]), c2 = AddInstant(GetSlot(t2, n), o2 * a2, o2 * i2, o2 * s2, o2 * l2, o2 * d2, o2 * m2);
  return new (GetIntrinsic("%Temporal.Instant%"))(c2);
}
function AddDurationToOrSubtractDurationFromPlainDateTime(e2, t2, r2, o2) {
  const n2 = "subtract" === e2 ? -1 : 1, { years: a2, months: f2, weeks: y2, days: I2, hours: S2, minutes: g2, seconds: w2, milliseconds: D2, microseconds: G2, nanoseconds: v2 } = ToTemporalDurationRecord(r2), C2 = GetOptionsObject(o2), O2 = GetSlot(t2, p), { year: b2, month: E2, day: M2, hour: R2, minute: F2, second: Y2, millisecond: P2, microsecond: Z2, nanosecond: B2 } = AddDateTime(GetSlot(t2, i), GetSlot(t2, s), GetSlot(t2, l), GetSlot(t2, d), GetSlot(t2, m), GetSlot(t2, c), GetSlot(t2, h), GetSlot(t2, u), GetSlot(t2, T), O2, n2 * a2, n2 * f2, n2 * y2, n2 * I2, n2 * S2, n2 * g2, n2 * w2, n2 * D2, n2 * G2, n2 * v2, C2);
  return CreateTemporalDateTime(b2, E2, M2, R2, F2, Y2, P2, Z2, B2, O2);
}
function AddDurationToOrSubtractDurationFromPlainTime(e2, t2, r2) {
  const o2 = "subtract" === e2 ? -1 : 1, { hours: n2, minutes: a2, seconds: i2, milliseconds: s2, microseconds: l2, nanoseconds: p2 } = ToTemporalDurationRecord(r2);
  let { hour: f2, minute: y2, second: I2, millisecond: S2, microsecond: g2, nanosecond: w2 } = AddTime(GetSlot(t2, d), GetSlot(t2, m), GetSlot(t2, c), GetSlot(t2, h), GetSlot(t2, u), GetSlot(t2, T), o2 * n2, o2 * a2, o2 * i2, o2 * s2, o2 * l2, o2 * p2);
  ({ hour: f2, minute: y2, second: I2, millisecond: S2, microsecond: g2, nanosecond: w2 } = RegulateTime(f2, y2, I2, S2, g2, w2, "reject"));
  return new (GetIntrinsic("%Temporal.PlainTime%"))(f2, y2, I2, S2, g2, w2);
}
function AddDurationToOrSubtractDurationFromPlainYearMonth(e2, t2, r2, o2) {
  let n2 = ToTemporalDurationRecord(r2);
  "subtract" === e2 && (n2 = { years: -n2.years, months: -n2.months, weeks: -n2.weeks, days: -n2.days, hours: -n2.hours, minutes: -n2.minutes, seconds: -n2.seconds, milliseconds: -n2.milliseconds, microseconds: -n2.microseconds, nanoseconds: -n2.nanoseconds });
  let { years: a2, months: i2, weeks: s2, days: l2, hours: d2, minutes: m2, seconds: c2, milliseconds: h2, microseconds: u2, nanoseconds: T2 } = n2;
  ({ days: l2 } = BalanceDuration(l2, d2, m2, c2, h2, u2, T2, "day"));
  const f2 = GetOptionsObject(o2), y2 = GetSlot(t2, p), I2 = CalendarFields(y2, ["monthCode", "year"]), S2 = PrepareTemporalFields(t2, I2, []), g2 = Te(null);
  CopyDataProperties(g2, S2, []), S2.day = 1;
  let w2 = CalendarDateFromFields(y2, S2);
  const D2 = DurationSign(a2, i2, s2, l2, 0, 0, 0, 0, 0, 0), G2 = GetMethod(y2, "dateAdd"), v2 = GetIntrinsic("%Temporal.Duration%");
  if (D2 < 0) {
    const e3 = CalendarDateAdd(y2, w2, new v2(0, 1, 0, 0, 0, 0, 0, 0, 0, 0), void 0, G2), t3 = CalendarDateAdd(y2, e3, new v2(0, 0, 0, -1, 0, 0, 0, 0, 0, 0), void 0, G2);
    g2.day = CalendarDay(y2, t3), w2 = CalendarDateFromFields(y2, g2);
  }
  const C2 = new v2(a2, i2, s2, l2, 0, 0, 0, 0, 0, 0), O2 = CopyOptions(f2);
  return CalendarYearMonthFromFields(y2, PrepareTemporalFields(CalendarDateAdd(y2, w2, C2, f2, G2), I2, []), O2);
}
function AddDurationToOrSubtractDurationFromZonedDateTime(e2, t2, r2, o2) {
  const n2 = "subtract" === e2 ? -1 : 1, { years: a2, months: i2, weeks: s2, days: l2, hours: d2, minutes: m2, seconds: c2, milliseconds: h2, microseconds: u2, nanoseconds: T2 } = ToTemporalDurationRecord(r2), f2 = GetOptionsObject(o2), y2 = GetSlot(t2, g), I2 = GetSlot(t2, p);
  return CreateTemporalZonedDateTime(AddZonedDateTime(GetSlot(t2, S), y2, I2, n2 * a2, n2 * i2, n2 * s2, n2 * l2, n2 * d2, n2 * m2, n2 * c2, n2 * h2, n2 * u2, n2 * T2, f2), y2, I2);
}
function RoundNumberToIncrement(t2, r2, o2) {
  if (e.equal(r2, Se))
    return t2;
  let { quotient: n2, remainder: a2 } = divmod(t2, r2);
  if (e.equal(a2, Ie))
    return t2;
  const i2 = e.lessThan(a2, Ie) ? -1 : 1, s2 = abs(e.multiply(a2, e.BigInt(2))), l2 = e.equal(s2, r2), d2 = e.greaterThan(s2, r2);
  switch (o2) {
    case "ceil":
      i2 > 0 && (n2 = e.add(n2, e.BigInt(i2)));
      break;
    case "floor":
      i2 < 0 && (n2 = e.add(n2, e.BigInt(i2)));
      break;
    case "expand":
      n2 = e.add(n2, e.BigInt(i2));
      break;
    case "trunc":
      break;
    case "halfCeil":
      (d2 || l2 && i2 > 0) && (n2 = e.add(n2, e.BigInt(i2)));
      break;
    case "halfFloor":
      (d2 || l2 && i2 < 0) && (n2 = e.add(n2, e.BigInt(i2)));
      break;
    case "halfExpand":
      (d2 || l2) && (n2 = e.add(n2, e.BigInt(i2)));
      break;
    case "halfTrunc":
      d2 && (n2 = e.add(n2, e.BigInt(i2)));
      break;
    case "halfEven":
      (d2 || l2 && 1 === e.toNumber(e.remainder(abs(n2), e.BigInt(2)))) && (n2 = e.add(n2, e.BigInt(i2)));
  }
  return e.multiply(n2, r2);
}
function RoundInstant(t2, r2, o2, n2) {
  let { remainder: a2 } = NonNegativeBigIntDivmod(t2, Ee);
  const i2 = e.subtract(t2, a2), s2 = RoundNumberToIncrement(a2, e.BigInt(_e[o2] * r2), n2);
  return e.add(i2, s2);
}
function RoundISODateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2 = 864e11) {
  const { deltaDays: u2, hour: T2, minute: p2, second: f2, millisecond: y2, microsecond: I2, nanosecond: S2 } = RoundTime(o2, n2, a2, i2, s2, l2, d2, m2, c2, h2), { year: g2, month: w2, day: D2 } = BalanceISODate(e2, t2, r2 + u2);
  return { year: g2, month: w2, day: D2, hour: T2, minute: p2, second: f2, millisecond: y2, microsecond: I2, nanosecond: S2 };
}
function RoundTime(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2 = 864e11) {
  let c2 = Ie;
  switch (l2) {
    case "day":
    case "hour":
      c2 = e.BigInt(t2);
    case "minute":
      c2 = e.add(e.multiply(c2, ge), e.BigInt(r2));
    case "second":
      c2 = e.add(e.multiply(c2, ge), e.BigInt(o2));
    case "millisecond":
      c2 = e.add(e.multiply(c2, De), e.BigInt(n2));
    case "microsecond":
      c2 = e.add(e.multiply(c2, De), e.BigInt(a2));
    case "nanosecond":
      c2 = e.add(e.multiply(c2, De), e.BigInt(i2));
  }
  const h2 = "day" === l2 ? m2 : _e[l2], u2 = RoundNumberToIncrement(c2, e.BigInt(h2 * s2), d2), T2 = e.toNumber(e.divide(u2, e.BigInt(h2)));
  switch (l2) {
    case "day":
      return { deltaDays: T2, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };
    case "hour":
      return BalanceTime(T2, 0, 0, 0, 0, 0);
    case "minute":
      return BalanceTime(t2, T2, 0, 0, 0, 0);
    case "second":
      return BalanceTime(t2, r2, T2, 0, 0, 0);
    case "millisecond":
      return BalanceTime(t2, r2, o2, T2, 0, 0);
    case "microsecond":
      return BalanceTime(t2, r2, o2, n2, T2, 0);
    case "nanosecond":
      return BalanceTime(t2, r2, o2, n2, a2, T2);
    default:
      throw new Error(`Invalid unit ${l2}`);
  }
}
function DaysUntil(e2, t2) {
  return DifferenceISODate(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l), GetSlot(t2, i), GetSlot(t2, s), GetSlot(t2, l), "day").days;
}
function MoveRelativeDate(e2, t2, r2, o2) {
  const n2 = CalendarDateAdd(e2, t2, r2, void 0, o2);
  return { relativeTo: n2, days: DaysUntil(t2, n2) };
}
function MoveRelativeZonedDateTime(e2, t2, r2, o2, n2) {
  const a2 = GetSlot(e2, g), i2 = GetSlot(e2, p);
  return CreateTemporalZonedDateTime(AddZonedDateTime(GetSlot(e2, S), a2, i2, t2, r2, o2, n2, 0, 0, 0, 0, 0, 0), a2, i2);
}
function AdjustRoundedDurationDays(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2) {
  let f2 = t2, y2 = r2, I2 = o2, w2 = n2, D2 = a2, G2 = i2, v2 = s2, C2 = l2, O2 = d2, b2 = m2;
  if (!IsTemporalZonedDateTime(T2) || "year" === h2 || "month" === h2 || "week" === h2 || "day" === h2 || "nanosecond" === h2 && 1 === c2)
    return { years: f2, months: y2, weeks: I2, days: w2, hours: D2, minutes: G2, seconds: v2, milliseconds: C2, microseconds: O2, nanoseconds: b2 };
  let E2 = TotalDurationNanoseconds(0, D2, G2, v2, C2, O2, b2, 0);
  const M2 = se(e.toNumber(E2)), R2 = GetSlot(T2, g), F2 = GetSlot(T2, p), Y2 = AddZonedDateTime(GetSlot(T2, S), R2, F2, f2, y2, I2, w2, 0, 0, 0, 0, 0, 0), P2 = AddZonedDateTime(new (GetIntrinsic("%Temporal.Instant%"))(Y2), R2, F2, 0, 0, 0, M2, 0, 0, 0, 0, 0, 0), Z2 = e.subtract(P2, Y2);
  return e.greaterThanOrEqual(e.multiply(e.subtract(E2, Z2), e.BigInt(M2)), Ie) && ({ years: f2, months: y2, weeks: I2, days: w2 } = AddDuration(f2, y2, I2, w2, 0, 0, 0, 0, 0, 0, 0, 0, 0, M2, 0, 0, 0, 0, 0, 0, T2), E2 = RoundInstant(e.subtract(E2, Z2), c2, h2, u2), { hours: D2, minutes: G2, seconds: v2, milliseconds: C2, microseconds: O2, nanoseconds: b2 } = BalanceDuration(0, 0, 0, 0, 0, 0, e.toNumber(E2), "hour")), { years: f2, months: y2, weeks: I2, days: w2, hours: D2, minutes: G2, seconds: v2, milliseconds: C2, microseconds: O2, nanoseconds: b2 };
}
function RoundDuration(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2) {
  let f2 = t2, y2 = r2, I2 = o2, S2 = n2, g2 = a2, w2 = i2, D2 = s2, G2 = l2, v2 = d2, C2 = e.BigInt(m2);
  const O2 = GetIntrinsic("%Temporal.Duration%");
  let b2, E2, M2, R2, F2 = T2;
  if (F2) {
    if (IsTemporalZonedDateTime(F2))
      E2 = F2, F2 = ToTemporalDate(F2);
    else if (!IsTemporalDate(F2))
      throw new TypeError("starting point must be PlainDate or ZonedDateTime");
    b2 = GetSlot(F2, p);
  }
  if ("year" === h2 || "month" === h2 || "week" === h2 || "day" === h2) {
    let t3, r3, o3;
    C2 = TotalDurationNanoseconds(0, g2, w2, D2, G2, v2, m2, 0), E2 && (t3 = MoveRelativeZonedDateTime(E2, f2, y2, I2, S2)), { days: r3, nanoseconds: C2, dayLengthNs: o3 } = NanosecondsToDays(C2, t3), M2 = e.BigInt(o3), S2 += r3, g2 = w2 = D2 = G2 = v2 = 0;
  }
  switch (h2) {
    case "year": {
      if (!b2)
        throw new RangeError("A starting point is required for years rounding");
      const t3 = new O2(f2), r3 = "string" != typeof b2 ? GetMethod(b2, "dateAdd") : void 0, o3 = CalendarDateAdd(b2, F2, t3, void 0, r3), n3 = CalendarDateAdd(b2, F2, new O2(f2, y2, I2), void 0, r3);
      F2 = o3, S2 += DaysUntil(o3, n3);
      const a3 = CalendarDateAdd(b2, F2, new O2(0, 0, 0, S2), void 0, r3), i3 = Te(null);
      i3.largestUnit = "year";
      const s3 = CalendarDateUntil(b2, F2, a3, i3).years;
      f2 += s3;
      const l3 = F2;
      F2 = CalendarDateAdd(b2, F2, new O2(s3), void 0, r3);
      S2 -= DaysUntil(l3, F2);
      const d3 = new O2(S2 < 0 ? -1 : 1);
      let { days: m3 } = MoveRelativeDate(b2, F2, d3, r3);
      m3 = ae(m3);
      const h3 = e.multiply(e.BigInt(m3), M2);
      C2 = e.add(e.add(e.multiply(h3, e.BigInt(f2)), e.multiply(e.BigInt(S2), M2)), C2);
      const T3 = RoundNumberToIncrement(C2, e.multiply(h3, e.BigInt(c2)), u2);
      R2 = BigIntDivideToNumber(C2, h3), f2 = e.toNumber(e.divide(T3, h3)), C2 = Ie, y2 = I2 = S2 = 0;
      break;
    }
    case "month": {
      if (!b2)
        throw new RangeError("A starting point is required for months rounding");
      const t3 = new O2(f2, y2), r3 = "string" != typeof b2 ? GetMethod(b2, "dateAdd") : void 0, o3 = CalendarDateAdd(b2, F2, t3, void 0, r3), n3 = CalendarDateAdd(b2, F2, new O2(f2, y2, I2), void 0, r3);
      F2 = o3, S2 += DaysUntil(o3, n3);
      const a3 = se(S2), i3 = new O2(0, S2 < 0 ? -1 : 1);
      let s3;
      for ({ relativeTo: F2, days: s3 } = MoveRelativeDate(b2, F2, i3, r3); ae(S2) >= ae(s3); )
        y2 += a3, S2 -= s3, { relativeTo: F2, days: s3 } = MoveRelativeDate(b2, F2, i3, r3);
      s3 = ae(s3);
      const l3 = e.multiply(e.BigInt(s3), M2);
      C2 = e.add(e.add(e.multiply(l3, e.BigInt(y2)), e.multiply(e.BigInt(S2), M2)), C2);
      const d3 = RoundNumberToIncrement(C2, e.multiply(l3, e.BigInt(c2)), u2);
      R2 = BigIntDivideToNumber(C2, l3), y2 = e.toNumber(e.divide(d3, l3)), C2 = Ie, I2 = S2 = 0;
      break;
    }
    case "week": {
      if (!b2)
        throw new RangeError("A starting point is required for weeks rounding");
      const t3 = se(S2), r3 = new O2(0, 0, S2 < 0 ? -1 : 1), o3 = "string" != typeof b2 ? GetMethod(b2, "dateAdd") : void 0;
      let n3;
      for ({ relativeTo: F2, days: n3 } = MoveRelativeDate(b2, F2, r3, o3); ae(S2) >= ae(n3); )
        I2 += t3, S2 -= n3, { relativeTo: F2, days: n3 } = MoveRelativeDate(b2, F2, r3, o3);
      n3 = ae(n3);
      const a3 = e.multiply(e.BigInt(n3), M2);
      C2 = e.add(e.add(e.multiply(a3, e.BigInt(I2)), e.multiply(e.BigInt(S2), M2)), C2);
      const i3 = RoundNumberToIncrement(C2, e.multiply(a3, e.BigInt(c2)), u2);
      R2 = BigIntDivideToNumber(C2, a3), I2 = e.toNumber(e.divide(i3, a3)), C2 = Ie, S2 = 0;
      break;
    }
    case "day": {
      const t3 = M2;
      C2 = e.add(e.multiply(t3, e.BigInt(S2)), C2);
      const r3 = RoundNumberToIncrement(C2, e.multiply(t3, e.BigInt(c2)), u2);
      R2 = BigIntDivideToNumber(C2, t3), S2 = e.toNumber(e.divide(r3, t3)), C2 = Ie;
      break;
    }
    case "hour": {
      const t3 = 36e11;
      let r3 = e.multiply(e.BigInt(g2), e.BigInt(36e11));
      r3 = e.add(r3, e.multiply(e.BigInt(w2), e.BigInt(6e10))), r3 = e.add(r3, e.multiply(e.BigInt(D2), ve)), r3 = e.add(r3, e.multiply(e.BigInt(G2), Ge)), r3 = e.add(r3, e.multiply(e.BigInt(v2), De)), r3 = e.add(r3, C2), R2 = BigIntDivideToNumber(r3, e.BigInt(t3));
      const o3 = RoundNumberToIncrement(r3, e.BigInt(t3 * c2), u2);
      g2 = e.toNumber(e.divide(o3, e.BigInt(t3))), C2 = Ie, w2 = D2 = G2 = v2 = 0;
      break;
    }
    case "minute": {
      const t3 = 6e10;
      let r3 = e.multiply(e.BigInt(w2), e.BigInt(6e10));
      r3 = e.add(r3, e.multiply(e.BigInt(D2), ve)), r3 = e.add(r3, e.multiply(e.BigInt(G2), Ge)), r3 = e.add(r3, e.multiply(e.BigInt(v2), De)), r3 = e.add(r3, C2), R2 = BigIntDivideToNumber(r3, e.BigInt(t3));
      const o3 = RoundNumberToIncrement(r3, e.BigInt(t3 * c2), u2);
      w2 = e.toNumber(e.divide(o3, e.BigInt(t3))), C2 = Ie, D2 = G2 = v2 = 0;
      break;
    }
    case "second": {
      const t3 = 1e9;
      let r3 = e.multiply(e.BigInt(D2), ve);
      r3 = e.add(r3, e.multiply(e.BigInt(G2), Ge)), r3 = e.add(r3, e.multiply(e.BigInt(v2), De)), r3 = e.add(r3, C2), R2 = BigIntDivideToNumber(r3, e.BigInt(t3));
      const o3 = RoundNumberToIncrement(r3, e.BigInt(t3 * c2), u2);
      D2 = e.toNumber(e.divide(o3, e.BigInt(t3))), C2 = Ie, G2 = v2 = 0;
      break;
    }
    case "millisecond": {
      const t3 = 1e6;
      let r3 = e.multiply(e.BigInt(G2), Ge);
      r3 = e.add(r3, e.multiply(e.BigInt(v2), De)), r3 = e.add(r3, C2), R2 = BigIntDivideToNumber(r3, e.BigInt(t3));
      const o3 = RoundNumberToIncrement(r3, e.BigInt(t3 * c2), u2);
      G2 = e.toNumber(e.divide(o3, e.BigInt(t3))), C2 = Ie, v2 = 0;
      break;
    }
    case "microsecond": {
      const t3 = 1e3;
      let r3 = e.multiply(e.BigInt(v2), De);
      r3 = e.add(r3, C2), R2 = BigIntDivideToNumber(r3, e.BigInt(t3));
      const o3 = RoundNumberToIncrement(r3, e.BigInt(t3 * c2), u2);
      v2 = e.toNumber(e.divide(o3, e.BigInt(t3))), C2 = Ie;
      break;
    }
    case "nanosecond":
      R2 = e.toNumber(C2), C2 = RoundNumberToIncrement(e.BigInt(C2), e.BigInt(c2), u2);
  }
  return { years: f2, months: y2, weeks: I2, days: S2, hours: g2, minutes: w2, seconds: D2, milliseconds: G2, microseconds: v2, nanoseconds: e.toNumber(C2), total: R2 };
}
function CompareISODate(e2, t2, r2, o2, n2, a2) {
  for (const [i2, s2] of [[e2, o2], [t2, n2], [r2, a2]])
    if (i2 !== s2)
      return ComparisonResult(i2 - s2);
  return 0;
}
function NonNegativeBigIntDivmod(t2, r2) {
  let { quotient: o2, remainder: n2 } = divmod(t2, r2);
  return e.lessThan(n2, Ie) && (o2 = e.subtract(o2, Se), n2 = e.add(n2, r2)), { quotient: o2, remainder: n2 };
}
function BigIntFloorDiv(t2, r2) {
  const { quotient: o2, remainder: n2 } = divmod(t2, r2);
  return isZero(n2) || !isNegativeJSBI(t2) == !isNegativeJSBI(r2) ? o2 : e.subtract(o2, Se);
}
function BigIntDivideToNumber(t2, r2) {
  const { quotient: o2, remainder: n2 } = divmod(t2, r2);
  return e.toNumber(o2) + e.toNumber(n2) / e.toNumber(r2);
}
function ToBigIntExternal(e2) {
  const t2 = ToBigInt(e2);
  return void 0 !== globalThis.BigInt ? globalThis.BigInt(t2.toString(10)) : t2;
}
function ToBigInt(t2) {
  let r2 = t2;
  if ("object" == typeof t2) {
    const e2 = t2[Symbol.toPrimitive];
    e2 && "function" == typeof e2 && (r2 = fe(e2, t2, ["number"]));
  }
  if ("number" == typeof r2)
    throw new TypeError("cannot convert number to bigint");
  return "bigint" == typeof r2 ? e.BigInt(r2.toString(10)) : e.BigInt(r2);
}
var Ve = (() => {
  let t2 = e.BigInt(Date.now() % 1e6);
  return () => {
    const r2 = e.BigInt(Date.now()), o2 = e.add(e.multiply(r2, Ge), t2);
    return t2 = e.remainder(r2, Ge), e.greaterThan(o2, Re) ? Re : e.lessThan(o2, Me) ? Me : o2;
  };
})();
function DefaultTimeZone() {
  return new re().resolvedOptions().timeZone;
}
function ComparisonResult(e2) {
  return e2 < 0 ? -1 : e2 > 0 ? 1 : e2;
}
function GetOptionsObject(e2) {
  if (void 0 === e2)
    return Te(null);
  if (IsObject(e2) && null !== e2)
    return e2;
  throw new TypeError("Options parameter must be an object, not " + (null === e2 ? "null" : typeof e2));
}
function CreateOnePropObject(e2, t2) {
  const r2 = Te(null);
  return r2[e2] = t2, r2;
}
function CopyOptions(e2) {
  const t2 = Te(null);
  return CopyDataProperties(t2, GetOptionsObject(e2), []), t2;
}
function GetOption(e2, t2, r2, o2) {
  let n2 = e2[t2];
  if (void 0 !== n2) {
    if (n2 = ToString(n2), !r2.includes(n2))
      throw new RangeError(`${t2} must be one of ${r2.join(", ")}, not ${n2}`);
    return n2;
  }
  return o2;
}
function IsBuiltinCalendar(e2) {
  return je.includes(ASCIILowercase(e2));
}
function ASCIILowercase(e2) {
  return e2.replace(/[A-Z]/g, (e3) => {
    const t2 = e3.charCodeAt(0);
    return String.fromCharCode(t2 + 32);
  });
}
var ze = new RegExp(`^${W.source}$`);
function bisect(t2, r2, o2, n2 = t2(r2), a2 = t2(o2)) {
  let i2 = e.BigInt(r2), s2 = e.BigInt(o2), l2 = n2, d2 = a2;
  for (; e.greaterThan(e.subtract(s2, i2), Se); ) {
    const r3 = e.divide(e.add(i2, s2), e.BigInt(2)), o3 = t2(r3);
    if (o3 === l2)
      i2 = r3, l2 = o3;
    else {
      if (o3 !== d2)
        throw new Error(`invalid state in bisection ${l2} - ${o3} - ${d2}`);
      s2 = r3, d2 = o3;
    }
  }
  return s2;
}
var _e = { hour: 36e11, minute: 6e10, second: 1e9, millisecond: 1e6, microsecond: 1e3, nanosecond: 1 };
var Je = Symbol("date");
var Ke = Symbol("ym");
var Xe = Symbol("md");
var Qe = Symbol("time");
var et = Symbol("datetime");
var tt = Symbol("instant");
var rt = Symbol("original");
var ot = Symbol("timezone");
var nt = Symbol("calendar-id");
var at = Symbol("locale");
var it = Symbol("options");
var descriptor = (e2) => ({ value: e2, enumerable: true, writable: false, configurable: true });
var st = globalThis.Intl.DateTimeFormat;
var lt = Object.assign;
var dt = Object.prototype.hasOwnProperty;
var mt = Reflect.apply;
function getPropLazy(e2, t2) {
  let r2 = e2[t2];
  return "function" == typeof r2 && (r2 = new st(e2[at], r2(e2[it])), e2[t2] = r2), r2;
}
function DateTimeFormatImpl(e2, t2 = {}) {
  if (!(this instanceof DateTimeFormatImpl))
    return new DateTimeFormatImpl(e2, t2);
  const r2 = void 0 !== t2, o2 = r2 ? lt({}, t2) : {}, n2 = new st(e2, o2), a2 = n2.resolvedOptions();
  if (r2) {
    const e3 = lt({}, a2);
    for (const t3 in e3)
      mt(dt, o2, [t3]) || delete e3[t3];
    this[it] = e3;
  } else
    this[it] = o2;
  this[at] = a2.locale, this[rt] = n2, this[ot] = a2.timeZone, this[nt] = a2.calendar, this[Je] = dateAmend, this[Ke] = yearMonthAmend, this[Xe] = monthDayAmend, this[Qe] = timeAmend, this[et] = datetimeAmend, this[tt] = instantAmend;
}
Object.defineProperty(DateTimeFormatImpl, "name", { writable: true, value: "DateTimeFormat" }), DateTimeFormatImpl.supportedLocalesOf = function(e2, t2) {
  return st.supportedLocalesOf(e2, t2);
};
var ct = { resolvedOptions: descriptor(function resolvedOptions() {
  return this[rt].resolvedOptions();
}), format: descriptor(function format(e2, ...t2) {
  let { instant: r2, formatter: o2 } = extractOverrides(e2, this);
  if (r2 && o2)
    return o2.format(r2.epochMilliseconds);
  return this[rt].format(e2, ...t2);
}), formatRange: descriptor(function formatRange(e2, t2) {
  if (isTemporalObject(e2) || isTemporalObject(t2)) {
    if (!sameTemporalType(e2, t2))
      throw new TypeError("Intl.DateTimeFormat.formatRange accepts two values of the same type");
    const { instant: r2, formatter: o2 } = extractOverrides(e2, this), { instant: n2, formatter: a2 } = extractOverrides(t2, this);
    if (r2 && n2 && o2 && a2 && o2 === a2)
      return o2.formatRange(r2.epochMilliseconds, n2.epochMilliseconds);
  }
  return this[rt].formatRange(e2, t2);
}) };
"formatToParts" in st.prototype && (ct.formatToParts = descriptor(function formatToParts(e2, ...t2) {
  let { instant: r2, formatter: o2 } = extractOverrides(e2, this);
  if (r2 && o2)
    return o2.formatToParts(r2.epochMilliseconds);
  return this[rt].formatToParts(e2, ...t2);
})), "formatRangeToParts" in st.prototype && (ct.formatRangeToParts = descriptor(function formatRangeToParts(e2, t2) {
  if (isTemporalObject(e2) || isTemporalObject(t2)) {
    if (!sameTemporalType(e2, t2))
      throw new TypeError("Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type");
    const { instant: r2, formatter: o2 } = extractOverrides(e2, this), { instant: n2, formatter: a2 } = extractOverrides(t2, this);
    if (r2 && n2 && o2 && a2 && o2 === a2)
      return o2.formatRangeToParts(r2.epochMilliseconds, n2.epochMilliseconds);
  }
  return this[rt].formatRangeToParts(e2, t2);
})), DateTimeFormatImpl.prototype = Object.create(st.prototype, ct), Object.defineProperty(DateTimeFormatImpl, "prototype", { writable: false, enumerable: false, configurable: false });
var ht = DateTimeFormatImpl;
function amend(e2 = {}, t2 = {}) {
  const r2 = lt({}, e2);
  for (const e3 of ["year", "month", "day", "hour", "minute", "second", "weekday", "dayPeriod", "timeZoneName", "dateStyle", "timeStyle"])
    r2[e3] = e3 in t2 ? t2[e3] : r2[e3], false !== r2[e3] && void 0 !== r2[e3] || delete r2[e3];
  return r2;
}
function timeAmend(e2) {
  let t2 = amend(e2, { year: false, month: false, day: false, weekday: false, timeZoneName: false, dateStyle: false });
  return hasTimeOptions(t2) || (t2 = lt({}, t2, { hour: "numeric", minute: "numeric", second: "numeric" })), t2;
}
function yearMonthAmend(e2) {
  let t2 = amend(e2, { day: false, hour: false, minute: false, second: false, weekday: false, dayPeriod: false, timeZoneName: false, dateStyle: false, timeStyle: false });
  return "year" in t2 || "month" in t2 || (t2 = lt(t2, { year: "numeric", month: "numeric" })), t2;
}
function monthDayAmend(e2) {
  let t2 = amend(e2, { year: false, hour: false, minute: false, second: false, weekday: false, dayPeriod: false, timeZoneName: false, dateStyle: false, timeStyle: false });
  return "month" in t2 || "day" in t2 || (t2 = lt({}, t2, { month: "numeric", day: "numeric" })), t2;
}
function dateAmend(e2) {
  let t2 = amend(e2, { hour: false, minute: false, second: false, dayPeriod: false, timeZoneName: false, timeStyle: false });
  return hasDateOptions(t2) || (t2 = lt({}, t2, { year: "numeric", month: "numeric", day: "numeric" })), t2;
}
function datetimeAmend(e2) {
  let t2 = amend(e2, { timeZoneName: false });
  return hasTimeOptions(t2) || hasDateOptions(t2) || (t2 = lt({}, t2, { year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric", second: "numeric" })), t2;
}
function instantAmend(e2) {
  let t2 = e2;
  return hasTimeOptions(t2) || hasDateOptions(t2) || (t2 = lt({}, t2, { year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric", second: "numeric" })), t2;
}
function hasDateOptions(e2) {
  return "year" in e2 || "month" in e2 || "day" in e2 || "weekday" in e2 || "dateStyle" in e2;
}
function hasTimeOptions(e2) {
  return "hour" in e2 || "minute" in e2 || "second" in e2 || "timeStyle" in e2 || "dayPeriod" in e2;
}
function isTemporalObject(e2) {
  return IsTemporalDate(e2) || IsTemporalTime(e2) || IsTemporalDateTime(e2) || IsTemporalZonedDateTime(e2) || IsTemporalYearMonth(e2) || IsTemporalMonthDay(e2) || IsTemporalInstant(e2);
}
function sameTemporalType(e2, t2) {
  return !(!isTemporalObject(e2) || !isTemporalObject(t2)) && (!(IsTemporalTime(e2) && !IsTemporalTime(t2)) && (!(IsTemporalDate(e2) && !IsTemporalDate(t2)) && (!(IsTemporalDateTime(e2) && !IsTemporalDateTime(t2)) && (!(IsTemporalZonedDateTime(e2) && !IsTemporalZonedDateTime(t2)) && (!(IsTemporalYearMonth(e2) && !IsTemporalYearMonth(t2)) && (!(IsTemporalMonthDay(e2) && !IsTemporalMonthDay(t2)) && !(IsTemporalInstant(e2) && !IsTemporalInstant(t2))))))));
}
function extractOverrides(e2, t2) {
  const r2 = GetIntrinsic("%Temporal.PlainDateTime%");
  if (IsTemporalTime(e2)) {
    const o2 = new r2(1970, 1, 1, GetSlot(e2, d), GetSlot(e2, m), GetSlot(e2, c), GetSlot(e2, h), GetSlot(e2, u), GetSlot(e2, T), t2[nt]);
    return { instant: GetInstantFor(t2[ot], o2, "compatible"), formatter: getPropLazy(t2, Qe) };
  }
  if (IsTemporalYearMonth(e2)) {
    const o2 = GetSlot(e2, i), n2 = GetSlot(e2, s), a2 = GetSlot(e2, l), d2 = ToTemporalCalendarIdentifier(GetSlot(e2, p));
    if (d2 !== t2[nt])
      throw new RangeError(`cannot format PlainYearMonth with calendar ${d2} in locale with calendar ${t2[nt]}`);
    const m2 = new r2(o2, n2, a2, 12, 0, 0, 0, 0, 0, d2);
    return { instant: GetInstantFor(t2[ot], m2, "compatible"), formatter: getPropLazy(t2, Ke) };
  }
  if (IsTemporalMonthDay(e2)) {
    const o2 = GetSlot(e2, i), n2 = GetSlot(e2, s), a2 = GetSlot(e2, l), d2 = ToTemporalCalendarIdentifier(GetSlot(e2, p));
    if (d2 !== t2[nt])
      throw new RangeError(`cannot format PlainMonthDay with calendar ${d2} in locale with calendar ${t2[nt]}`);
    const m2 = new r2(o2, n2, a2, 12, 0, 0, 0, 0, 0, d2);
    return { instant: GetInstantFor(t2[ot], m2, "compatible"), formatter: getPropLazy(t2, Xe) };
  }
  if (IsTemporalDate(e2)) {
    const o2 = GetSlot(e2, i), n2 = GetSlot(e2, s), a2 = GetSlot(e2, l), d2 = ToTemporalCalendarIdentifier(GetSlot(e2, p));
    if ("iso8601" !== d2 && d2 !== t2[nt])
      throw new RangeError(`cannot format PlainDate with calendar ${d2} in locale with calendar ${t2[nt]}`);
    const m2 = new r2(o2, n2, a2, 12, 0, 0, 0, 0, 0, t2[nt]);
    return { instant: GetInstantFor(t2[ot], m2, "compatible"), formatter: getPropLazy(t2, Je) };
  }
  if (IsTemporalDateTime(e2)) {
    const o2 = GetSlot(e2, i), n2 = GetSlot(e2, s), a2 = GetSlot(e2, l), f2 = GetSlot(e2, d), y2 = GetSlot(e2, m), I2 = GetSlot(e2, c), S2 = GetSlot(e2, h), g2 = GetSlot(e2, u), w2 = GetSlot(e2, T), D2 = ToTemporalCalendarIdentifier(GetSlot(e2, p));
    if ("iso8601" !== D2 && D2 !== t2[nt])
      throw new RangeError(`cannot format PlainDateTime with calendar ${D2} in locale with calendar ${t2[nt]}`);
    let G2 = e2;
    return "iso8601" === D2 && (G2 = new r2(o2, n2, a2, f2, y2, I2, S2, g2, w2, t2[nt])), { instant: GetInstantFor(t2[ot], G2, "compatible"), formatter: getPropLazy(t2, et) };
  }
  if (IsTemporalZonedDateTime(e2))
    throw new TypeError("Temporal.ZonedDateTime not supported in DateTimeFormat methods. Use toLocaleString() instead.");
  return IsTemporalInstant(e2) ? { instant: e2, formatter: getPropLazy(t2, tt) } : {};
}
var ut = Object.freeze({ __proto__: null, DateTimeFormat: ht });
var Instant = class _Instant {
  constructor(e2) {
    if (arguments.length < 1)
      throw new TypeError("missing argument: epochNanoseconds is required");
    const t2 = ToBigInt(e2);
    ValidateEpochNanoseconds(t2), N(this), SetSlot(this, n, t2);
  }
  get epochSeconds() {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, n);
    return e.toNumber(BigIntFloorDiv(t2, ve));
  }
  get epochMilliseconds() {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    const t2 = e.BigInt(GetSlot(this, n));
    return e.toNumber(BigIntFloorDiv(t2, Ge));
  }
  get epochMicroseconds() {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    return ToBigIntExternal(BigIntFloorDiv(e.BigInt(GetSlot(this, n)), De));
  }
  get epochNanoseconds() {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    return ToBigIntExternal(e.BigInt(GetSlot(this, n)));
  }
  add(e2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromInstant("add", this, e2);
  }
  subtract(e2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromInstant("subtract", this, e2);
  }
  until(e2, t2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalInstant("until", this, e2, t2);
  }
  since(e2, t2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalInstant("since", this, e2, t2);
  }
  round(e2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    if (void 0 === e2)
      throw new TypeError("options parameter is required");
    const t2 = "string" == typeof e2 ? CreateOnePropObject("smallestUnit", e2) : GetOptionsObject(e2), r2 = ToTemporalRoundingIncrement(t2), o2 = ToTemporalRoundingMode(t2, "halfExpand"), a2 = GetTemporalUnit(t2, "smallestUnit", "time", He);
    ValidateTemporalRoundingIncrement(r2, { hour: 24, minute: 1440, second: 86400, millisecond: 864e5, microsecond: 864e8, nanosecond: 864e11 }[a2], true);
    const i2 = RoundInstant(GetSlot(this, n), r2, a2, o2);
    return new _Instant(i2);
  }
  equals(t2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    const r2 = ToTemporalInstant(t2), o2 = GetSlot(this, n), a2 = GetSlot(r2, n);
    return e.equal(e.BigInt(o2), e.BigInt(a2));
  }
  toString(e2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e2), r2 = ToFractionalSecondDigits(t2), o2 = ToTemporalRoundingMode(t2, "trunc"), a2 = GetTemporalUnit(t2, "smallestUnit", "time", void 0);
    if ("hour" === a2)
      throw new RangeError('smallestUnit must be a time unit other than "hour"');
    let i2 = t2.timeZone;
    void 0 !== i2 && (i2 = ToTemporalTimeZoneSlotValue(i2));
    const { precision: s2, unit: l2, increment: d2 } = ToSecondsStringPrecisionRecord(a2, r2), m2 = RoundInstant(GetSlot(this, n), d2, l2, o2);
    return TemporalInstantToString(new _Instant(m2), i2, s2);
  }
  toJSON() {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    return TemporalInstantToString(this, void 0, "auto");
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    return new ht(e2, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.Instant");
  }
  toZonedDateTime(e2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid argument in toZonedDateTime");
    const t2 = e2.calendar;
    if (void 0 === t2)
      throw new TypeError("missing calendar property in toZonedDateTime");
    const r2 = ToTemporalCalendarSlotValue(t2), o2 = e2.timeZone;
    if (void 0 === o2)
      throw new TypeError("missing timeZone property in toZonedDateTime");
    const a2 = ToTemporalTimeZoneSlotValue(o2);
    return CreateTemporalZonedDateTime(GetSlot(this, n), a2, r2);
  }
  toZonedDateTimeISO(e2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalTimeZoneSlotValue(e2);
    return CreateTemporalZonedDateTime(GetSlot(this, n), t2, "iso8601");
  }
  static fromEpochSeconds(t2) {
    const r2 = ToNumber(t2), o2 = e.multiply(e.BigInt(r2), ve);
    return ValidateEpochNanoseconds(o2), new _Instant(o2);
  }
  static fromEpochMilliseconds(t2) {
    const r2 = ToNumber(t2), o2 = e.multiply(e.BigInt(r2), Ge);
    return ValidateEpochNanoseconds(o2), new _Instant(o2);
  }
  static fromEpochMicroseconds(t2) {
    const r2 = ToBigInt(t2), o2 = e.multiply(r2, De);
    return ValidateEpochNanoseconds(o2), new _Instant(o2);
  }
  static fromEpochNanoseconds(e2) {
    const t2 = ToBigInt(e2);
    return ValidateEpochNanoseconds(t2), new _Instant(t2);
  }
  static from(e2) {
    return IsTemporalInstant(e2) ? new _Instant(GetSlot(e2, n)) : ToTemporalInstant(e2);
  }
  static compare(t2, r2) {
    const o2 = ToTemporalInstant(t2), a2 = ToTemporalInstant(r2), i2 = GetSlot(o2, n), s2 = GetSlot(a2, n);
    return e.lessThan(i2, s2) ? -1 : e.greaterThan(i2, s2) ? 1 : 0;
  }
};
MakeIntrinsicClass(Instant, "Temporal.Instant");
var Tt = Array.prototype.includes;
var pt = Array.prototype.push;
var ft = globalThis.Intl.DateTimeFormat;
var yt = Array.prototype.sort;
var It = Math.abs;
var St = Math.floor;
var gt = Object.create;
var wt = Object.entries;
var Dt = Set;
var Gt = Reflect.ownKeys;
var vt = Set.prototype.add;
var Ct = Set.prototype.values;
var Ot = {};
var Calendar = class {
  constructor(e2) {
    if (arguments.length < 1)
      throw new RangeError("missing argument: id is required");
    const t2 = ToString(e2);
    if (!IsBuiltinCalendar(t2))
      throw new RangeError(`invalid calendar identifier ${t2}`);
    N(this), SetSlot(this, F, ASCIILowercase(t2));
  }
  get id() {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, F);
  }
  dateFromFields(e2, t2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid fields");
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, F);
    return Ot[o2].dateFromFields(e2, r2, o2);
  }
  yearMonthFromFields(e2, t2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid fields");
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, F);
    return Ot[o2].yearMonthFromFields(e2, r2, o2);
  }
  monthDayFromFields(e2, t2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid fields");
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, F);
    return Ot[o2].monthDayFromFields(e2, r2, o2);
  }
  fields(e2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const t2 = [], r2 = /* @__PURE__ */ new Set(["year", "month", "monthCode", "day", "hour", "minute", "second", "millisecond", "microsecond", "nanosecond"]);
    for (const o2 of e2) {
      if ("string" != typeof o2)
        throw new TypeError("invalid fields");
      if (!r2.has(o2))
        throw new RangeError(`invalid field name ${o2}`);
      r2.delete(o2), pt.call(t2, o2);
    }
    return Ot[GetSlot(this, F)].fields(t2);
  }
  mergeFields(e2, t2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const r2 = ToObject(e2), o2 = gt(null);
    CopyDataProperties(o2, r2, [], [void 0]);
    const n2 = ToObject(t2), a2 = gt(null);
    CopyDataProperties(a2, n2, [], [void 0]);
    const i2 = Gt(a2), s2 = Ot[GetSlot(this, F)].fieldKeysToIgnore(i2), l2 = gt(null), d2 = Gt(o2);
    for (const e3 of d2) {
      let t3;
      t3 = Call(Tt, s2, [e3]) ? a2[e3] : o2[e3], void 0 !== t3 && (l2[e3] = t3);
    }
    return CopyDataProperties(l2, a2, []), l2;
  }
  dateAdd(e2, t2, r2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const o2 = ToTemporalDate(e2), n2 = ToTemporalDuration(t2), a2 = ToTemporalOverflow(GetOptionsObject(r2)), { days: i2 } = BalanceDuration(GetSlot(n2, v), GetSlot(n2, C), GetSlot(n2, O), GetSlot(n2, b), GetSlot(n2, E), GetSlot(n2, M), GetSlot(n2, R), "day"), s2 = GetSlot(this, F);
    return Ot[s2].dateAdd(o2, GetSlot(n2, w), GetSlot(n2, D), GetSlot(n2, G), i2, a2, s2);
  }
  dateUntil(e2, t2, r2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const o2 = ToTemporalDate(e2), n2 = ToTemporalDate(t2);
    let a2 = GetTemporalUnit(GetOptionsObject(r2), "largestUnit", "date", "auto");
    "auto" === a2 && (a2 = "day");
    const { years: i2, months: s2, weeks: l2, days: d2 } = Ot[GetSlot(this, F)].dateUntil(o2, n2, a2);
    return new (GetIntrinsic("%Temporal.Duration%"))(i2, s2, l2, d2, 0, 0, 0, 0, 0, 0);
  }
  year(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].year(t2);
  }
  month(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    if (IsTemporalMonthDay(t2))
      throw new TypeError("use monthCode on PlainMonthDay instead");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].month(t2);
  }
  monthCode(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || IsTemporalMonthDay(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].monthCode(t2);
  }
  day(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalMonthDay(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].day(t2);
  }
  era(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].era(t2);
  }
  eraYear(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].eraYear(t2);
  }
  dayOfWeek(e2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2);
    return Ot[GetSlot(this, F)].dayOfWeek(t2);
  }
  dayOfYear(e2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2);
    return Ot[GetSlot(this, F)].dayOfYear(t2);
  }
  weekOfYear(e2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2);
    return Ot[GetSlot(this, F)].weekOfYear(t2);
  }
  yearOfWeek(e2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2);
    return Ot[GetSlot(this, F)].yearOfWeek(t2);
  }
  daysInWeek(e2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2);
    return Ot[GetSlot(this, F)].daysInWeek(t2);
  }
  daysInMonth(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].daysInMonth(t2);
  }
  daysInYear(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].daysInYear(t2);
  }
  monthsInYear(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].monthsInYear(t2);
  }
  inLeapYear(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].inLeapYear(t2);
  }
  toString() {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, F);
  }
  toJSON() {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, F);
  }
  static from(e2) {
    return ToTemporalCalendarObject(ToTemporalCalendarSlotValue(e2));
  }
};
function monthCodeNumberPart(e2) {
  if (!e2.startsWith("M"))
    throw new RangeError(`Invalid month code: ${e2}.  Month codes must start with M.`);
  const t2 = +e2.slice(1);
  if (isNaN(t2))
    throw new RangeError(`Invalid month code: ${e2}`);
  return t2;
}
function buildMonthCode(e2, t2 = false) {
  return `M${e2.toString().padStart(2, "0")}${t2 ? "L" : ""}`;
}
function resolveNonLunisolarMonth(e2, t2, r2 = 12) {
  let { month: o2, monthCode: n2 } = e2;
  if (void 0 === n2) {
    if (void 0 === o2)
      throw new TypeError("Either month or monthCode are required");
    "reject" === t2 && RejectToRange(o2, 1, r2), "constrain" === t2 && (o2 = ConstrainToRange(o2, 1, r2)), n2 = buildMonthCode(o2);
  } else {
    const e3 = monthCodeNumberPart(n2);
    if (void 0 !== o2 && o2 !== e3)
      throw new RangeError(`monthCode ${n2} and month ${o2} must match if both are present`);
    if (n2 !== buildMonthCode(e3))
      throw new RangeError(`Invalid month code: ${n2}`);
    if (o2 = e3, o2 < 1 || o2 > r2)
      throw new RangeError(`Invalid monthCode: ${n2}`);
  }
  return { ...e2, month: o2, monthCode: n2 };
}
MakeIntrinsicClass(Calendar, "Temporal.Calendar"), DefineIntrinsic("Temporal.Calendar.from", Calendar.from), DefineIntrinsic("Temporal.Calendar.prototype.dateAdd", Calendar.prototype.dateAdd), DefineIntrinsic("Temporal.Calendar.prototype.dateFromFields", Calendar.prototype.dateFromFields), DefineIntrinsic("Temporal.Calendar.prototype.dateUntil", Calendar.prototype.dateUntil), DefineIntrinsic("Temporal.Calendar.prototype.day", Calendar.prototype.day), DefineIntrinsic("Temporal.Calendar.prototype.dayOfWeek", Calendar.prototype.dayOfWeek), DefineIntrinsic("Temporal.Calendar.prototype.dayOfYear", Calendar.prototype.dayOfYear), DefineIntrinsic("Temporal.Calendar.prototype.daysInMonth", Calendar.prototype.daysInMonth), DefineIntrinsic("Temporal.Calendar.prototype.daysInWeek", Calendar.prototype.daysInWeek), DefineIntrinsic("Temporal.Calendar.prototype.daysInYear", Calendar.prototype.daysInYear), DefineIntrinsic("Temporal.Calendar.prototype.era", Calendar.prototype.era), DefineIntrinsic("Temporal.Calendar.prototype.eraYear", Calendar.prototype.eraYear), DefineIntrinsic("Temporal.Calendar.prototype.fields", Calendar.prototype.fields), DefineIntrinsic("Temporal.Calendar.prototype.inLeapYear", Calendar.prototype.inLeapYear), DefineIntrinsic("Temporal.Calendar.prototype.mergeFields", Calendar.prototype.mergeFields), DefineIntrinsic("Temporal.Calendar.prototype.month", Calendar.prototype.month), DefineIntrinsic("Temporal.Calendar.prototype.monthCode", Calendar.prototype.monthCode), DefineIntrinsic("Temporal.Calendar.prototype.monthDayFromFields", Calendar.prototype.monthDayFromFields), DefineIntrinsic("Temporal.Calendar.prototype.monthsInYear", Calendar.prototype.monthsInYear), DefineIntrinsic("Temporal.Calendar.prototype.weekOfYear", Calendar.prototype.weekOfYear), DefineIntrinsic("Temporal.Calendar.prototype.year", Calendar.prototype.year), DefineIntrinsic("Temporal.Calendar.prototype.yearMonthFromFields", Calendar.prototype.yearMonthFromFields), DefineIntrinsic("Temporal.Calendar.prototype.yearOfWeek", Calendar.prototype.yearOfWeek), Ot.iso8601 = { dateFromFields(e2, t2, r2) {
  let o2 = PrepareTemporalFields(e2, ["day", "month", "monthCode", "year"], ["year", "day"]);
  const n2 = ToTemporalOverflow(t2);
  o2 = resolveNonLunisolarMonth(o2);
  let { year: a2, month: i2, day: s2 } = o2;
  return { year: a2, month: i2, day: s2 } = RegulateISODate(a2, i2, s2, n2), CreateTemporalDate(a2, i2, s2, r2);
}, yearMonthFromFields(e2, t2, r2) {
  let o2 = PrepareTemporalFields(e2, ["month", "monthCode", "year"], ["year"]);
  const n2 = ToTemporalOverflow(t2);
  o2 = resolveNonLunisolarMonth(o2);
  let { year: a2, month: i2 } = o2;
  return { year: a2, month: i2 } = function RegulateISOYearMonth(e3, t3, r3) {
    let o3 = e3, n3 = t3;
    switch (r3) {
      case "reject":
        RejectISODate(o3, n3, 1);
        break;
      case "constrain":
        ({ year: o3, month: n3 } = ConstrainISODate(o3, n3));
    }
    return { year: o3, month: n3 };
  }(a2, i2, n2), CreateTemporalYearMonth(a2, i2, r2, 1);
}, monthDayFromFields(e2, t2, r2) {
  let o2 = PrepareTemporalFields(e2, ["day", "month", "monthCode", "year"], ["day"]);
  const n2 = ToTemporalOverflow(t2);
  if (void 0 !== o2.month && void 0 === o2.year && void 0 === o2.monthCode)
    throw new TypeError("either year or monthCode required with month");
  const a2 = void 0 === o2.monthCode;
  o2 = resolveNonLunisolarMonth(o2);
  let { month: i2, day: s2, year: l2 } = o2;
  return { month: i2, day: s2 } = RegulateISODate(a2 ? l2 : 1972, i2, s2, n2), CreateTemporalMonthDay(i2, s2, r2, 1972);
}, fields: (e2) => e2, fieldKeysToIgnore(e2) {
  const t2 = new Dt();
  for (let r2 = 0; r2 < e2.length; r2++) {
    const o2 = e2[r2];
    Call(vt, t2, [o2]), "month" === o2 ? Call(vt, t2, ["monthCode"]) : "monthCode" === o2 && Call(vt, t2, ["month"]);
  }
  return [...Call(Ct, t2, [])];
}, dateAdd(e2, t2, r2, o2, n2, a2, d2) {
  let m2 = GetSlot(e2, i), c2 = GetSlot(e2, s), h2 = GetSlot(e2, l);
  return { year: m2, month: c2, day: h2 } = AddISODate(m2, c2, h2, t2, r2, o2, n2, a2), CreateTemporalDate(m2, c2, h2, d2);
}, dateUntil: (e2, t2, r2) => DifferenceISODate(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l), GetSlot(t2, i), GetSlot(t2, s), GetSlot(t2, l), r2), year: (e2) => GetSlot(e2, i), era() {
}, eraYear() {
}, month: (e2) => GetSlot(e2, s), monthCode: (e2) => buildMonthCode(GetSlot(e2, s)), day: (e2) => GetSlot(e2, l), dayOfWeek: (e2) => DayOfWeek(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l)), dayOfYear: (e2) => DayOfYear(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l)), weekOfYear: (e2) => WeekOfYear(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l)).week, yearOfWeek: (e2) => WeekOfYear(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l)).year, daysInWeek: () => 7, daysInMonth: (e2) => ISODaysInMonth(GetSlot(e2, i), GetSlot(e2, s)), daysInYear(e2) {
  let t2 = e2;
  return HasSlot(t2, i) || (t2 = ToTemporalDate(t2)), LeapYear(GetSlot(t2, i)) ? 366 : 365;
}, monthsInYear: () => 12, inLeapYear(e2) {
  let t2 = e2;
  return HasSlot(t2, i) || (t2 = ToTemporalDate(t2)), LeapYear(GetSlot(t2, i));
} };
var OneObjectCache = class _OneObjectCache {
  constructor(e2) {
    if (this.map = /* @__PURE__ */ new Map(), this.calls = 0, this.hits = 0, this.misses = 0, this.now = globalThis.performance ? globalThis.performance.now() : Date.now(), void 0 !== e2) {
      let t2 = 0;
      for (const r2 of e2.map.entries()) {
        if (++t2 > _OneObjectCache.MAX_CACHE_ENTRIES)
          break;
        this.map.set(...r2);
      }
    }
  }
  get(e2) {
    const t2 = this.map.get(e2);
    return t2 && (this.hits++, this.report()), this.calls++, t2;
  }
  set(e2, t2) {
    this.map.set(e2, t2), this.misses++, this.report();
  }
  report() {
  }
  setObject(e2) {
    if (_OneObjectCache.objectMap.get(e2))
      throw new RangeError("object already cached");
    _OneObjectCache.objectMap.set(e2, this), this.report();
  }
  static getCacheForObject(e2) {
    let t2 = _OneObjectCache.objectMap.get(e2);
    return t2 || (t2 = new _OneObjectCache(), _OneObjectCache.objectMap.set(e2, t2)), t2;
  }
};
function toUtcIsoDateString({ isoYear: e2, isoMonth: t2, isoDay: r2 }) {
  return `${ISOYearString(e2)}-${ISODateTimePartString(t2)}-${ISODateTimePartString(r2)}T00:00Z`;
}
function simpleDateDiff(e2, t2) {
  return { years: e2.year - t2.year, months: e2.month - t2.month, days: e2.day - t2.day };
}
OneObjectCache.objectMap = /* @__PURE__ */ new WeakMap(), OneObjectCache.MAX_CACHE_ENTRIES = 1e3;
var HelperBase = class {
  constructor() {
    this.eraLength = "short", this.hasEra = true, this.erasBeginMidYear = false;
  }
  getFormatter() {
    return void 0 === this.formatter && (this.formatter = new ft(`en-US-u-ca-${this.id}`, { day: "numeric", month: "numeric", year: "numeric", era: this.eraLength, timeZone: "UTC" })), this.formatter;
  }
  isoToCalendarDate(e2, t2) {
    const { year: r2, month: o2, day: n2 } = e2, a2 = JSON.stringify({ func: "isoToCalendarDate", isoYear: r2, isoMonth: o2, isoDay: n2, id: this.id }), i2 = t2.get(a2);
    if (i2)
      return i2;
    const s2 = this.getFormatter();
    let l2, d2;
    try {
      d2 = toUtcIsoDateString({ isoYear: r2, isoMonth: o2, isoDay: n2 }), l2 = s2.formatToParts(new Date(d2));
    } catch (e3) {
      throw new RangeError(`Invalid ISO date: ${JSON.stringify({ isoYear: r2, isoMonth: o2, isoDay: n2 })}`);
    }
    const m2 = {};
    for (let { type: e3, value: t3 } of l2) {
      if ("year" === e3 && (m2.eraYear = +t3), "relatedYear" === e3 && (m2.eraYear = +t3), "month" === e3) {
        const e4 = /^([0-9]*)(.*?)$/.exec(t3);
        if (!e4 || 3 != e4.length || !e4[1] && !e4[2])
          throw new RangeError(`Unexpected month: ${t3}`);
        if (m2.month = e4[1] ? +e4[1] : 1, m2.month < 1)
          throw new RangeError(`Invalid month ${t3} from ${d2}[u-ca-${this.id}] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)`);
        if (m2.month > 13)
          throw new RangeError(`Invalid month ${t3} from ${d2}[u-ca-${this.id}] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)`);
        e4[2] && (m2.monthExtra = e4[2]);
      }
      "day" === e3 && (m2.day = +t3), this.hasEra && "era" === e3 && null != t3 && "" !== t3 && (t3 = t3.split(" (")[0], m2.era = t3.normalize("NFD").replace(/[^-0-9 \p{L}]/gu, "").replace(" ", "-").toLowerCase());
    }
    if (void 0 === m2.eraYear)
      throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);
    if (this.reviseIntlEra) {
      const { era: t3, eraYear: r3 } = this.reviseIntlEra(m2, e2);
      m2.era = t3, m2.eraYear = r3;
    }
    this.checkIcuBugs && this.checkIcuBugs(e2);
    const c2 = this.adjustCalendarDate(m2, t2, "constrain", true);
    if (void 0 === c2.year)
      throw new RangeError(`Missing year converting ${JSON.stringify(e2)}`);
    if (void 0 === c2.month)
      throw new RangeError(`Missing month converting ${JSON.stringify(e2)}`);
    if (void 0 === c2.day)
      throw new RangeError(`Missing day converting ${JSON.stringify(e2)}`);
    return t2.set(a2, c2), ["constrain", "reject"].forEach((r3) => {
      const o3 = JSON.stringify({ func: "calendarToIsoDate", year: c2.year, month: c2.month, day: c2.day, overflow: r3, id: this.id });
      t2.set(o3, e2);
    }), c2;
  }
  validateCalendarDate(e2) {
    const { era: t2, month: r2, year: o2, day: n2, eraYear: a2, monthCode: i2, monthExtra: s2 } = e2;
    if (void 0 !== s2)
      throw new RangeError("Unexpected `monthExtra` value");
    if (void 0 === o2 && void 0 === a2)
      throw new TypeError("year or eraYear is required");
    if (void 0 === r2 && void 0 === i2)
      throw new TypeError("month or monthCode is required");
    if (void 0 === n2)
      throw new RangeError("Missing day");
    if (void 0 !== i2) {
      if ("string" != typeof i2)
        throw new RangeError("monthCode must be a string, not " + typeof i2);
      if (!/^M([01]?\d)(L?)$/.test(i2))
        throw new RangeError(`Invalid monthCode: ${i2}`);
    }
    if (this.constantEra) {
      if (void 0 !== t2 && t2 !== this.constantEra)
        throw new RangeError(`era must be ${this.constantEra}, not ${t2}`);
      if (void 0 !== a2 && void 0 !== o2 && a2 !== o2)
        throw new RangeError(`eraYear ${a2} does not match year ${o2}`);
    }
    if (this.hasEra && void 0 === e2.era != (void 0 === e2.eraYear))
      throw new RangeError("properties 'era' and 'eraYear' must be provided together");
  }
  adjustCalendarDate(e2, t2, r2 = "constrain", o2 = false) {
    if ("lunisolar" === this.calendarType)
      throw new RangeError("Override required for lunisolar calendars");
    let n2 = e2;
    if (this.validateCalendarDate(n2), this.constantEra) {
      const { year: e3, eraYear: t3 } = n2;
      n2 = { ...n2, era: this.constantEra, year: void 0 !== e3 ? e3 : t3, eraYear: void 0 !== t3 ? t3 : e3 };
    }
    const a2 = this.monthsInYear(n2, t2);
    let { month: i2, monthCode: s2 } = n2;
    return { month: i2, monthCode: s2 } = resolveNonLunisolarMonth(n2, r2, a2), { ...n2, month: i2, monthCode: s2 };
  }
  regulateMonthDayNaive(e2, t2, r2) {
    const o2 = this.monthsInYear(e2, r2);
    let { month: n2, day: a2 } = e2;
    return "reject" === t2 ? (RejectToRange(n2, 1, o2), RejectToRange(a2, 1, this.maximumMonthLength(e2))) : (n2 = ConstrainToRange(n2, 1, o2), a2 = ConstrainToRange(a2, 1, this.maximumMonthLength({ ...e2, month: n2 }))), { ...e2, month: n2, day: a2 };
  }
  calendarToIsoDate(e2, t2 = "constrain", r2) {
    const o2 = e2;
    let n2 = this.adjustCalendarDate(e2, r2, t2, false);
    n2 = this.regulateMonthDayNaive(n2, t2, r2);
    const { year: a2, month: i2, day: s2 } = n2, l2 = JSON.stringify({ func: "calendarToIsoDate", year: a2, month: i2, day: s2, overflow: t2, id: this.id });
    let d2, m2 = r2.get(l2);
    if (m2)
      return m2;
    if (void 0 !== o2.year && void 0 !== o2.month && void 0 !== o2.day && (o2.year !== n2.year || o2.month !== n2.month || o2.day !== n2.day) && (d2 = JSON.stringify({ func: "calendarToIsoDate", year: o2.year, month: o2.month, day: o2.day, overflow: t2, id: this.id }), m2 = r2.get(d2), m2))
      return m2;
    let c2 = this.estimateIsoDate({ year: a2, month: i2, day: s2 });
    const calculateSameMonthResult = (e3) => {
      let o3 = this.addDaysIso(c2, e3);
      if (n2.day > this.minimumMonthLength(n2)) {
        let e4 = this.isoToCalendarDate(o3, r2);
        for (; e4.month !== i2 || e4.year !== a2; ) {
          if ("reject" === t2)
            throw new RangeError(`day ${s2} does not exist in month ${i2} of year ${a2}`);
          o3 = this.addDaysIso(o3, -1), e4 = this.isoToCalendarDate(o3, r2);
        }
      }
      return o3;
    };
    let h2 = 0, u2 = this.isoToCalendarDate(c2, r2), T2 = simpleDateDiff(n2, u2);
    if (0 !== T2.years || 0 !== T2.months || 0 !== T2.days) {
      const e3 = 365 * T2.years + 30 * T2.months + T2.days;
      c2 = this.addDaysIso(c2, e3), u2 = this.isoToCalendarDate(c2, r2), T2 = simpleDateDiff(n2, u2), 0 === T2.years && 0 === T2.months ? c2 = calculateSameMonthResult(T2.days) : h2 = this.compareCalendarDates(n2, u2);
    }
    let p2 = 8;
    for (; h2; ) {
      c2 = this.addDaysIso(c2, h2 * p2);
      const e3 = u2;
      u2 = this.isoToCalendarDate(c2, r2);
      const a3 = h2;
      if (h2 = this.compareCalendarDates(n2, u2), h2) {
        if (T2 = simpleDateDiff(n2, u2), 0 === T2.years && 0 === T2.months)
          c2 = calculateSameMonthResult(T2.days), h2 = 0;
        else if (a3 && h2 !== a3)
          if (p2 > 1)
            p2 /= 2;
          else {
            if ("reject" === t2)
              throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify({ ...o2 })}`);
            this.compareCalendarDates(u2, e3) > 0 && (c2 = this.addDaysIso(c2, -1)), h2 = 0;
          }
      }
    }
    if (r2.set(l2, c2), d2 && r2.set(d2, c2), void 0 === n2.year || void 0 === n2.month || void 0 === n2.day || void 0 === n2.monthCode || this.hasEra && (void 0 === n2.era || void 0 === n2.eraYear))
      throw new RangeError("Unexpected missing property");
    return c2;
  }
  temporalToCalendarDate(e2, t2) {
    const r2 = { year: GetSlot(e2, i), month: GetSlot(e2, s), day: GetSlot(e2, l) };
    return this.isoToCalendarDate(r2, t2);
  }
  compareCalendarDates(e2, t2) {
    const r2 = PrepareTemporalFields(e2, ["day", "month", "year"], ["day", "month", "year"]), o2 = PrepareTemporalFields(t2, ["day", "month", "year"], ["day", "month", "year"]);
    return r2.year !== o2.year ? ComparisonResult(r2.year - o2.year) : r2.month !== o2.month ? ComparisonResult(r2.month - o2.month) : r2.day !== o2.day ? ComparisonResult(r2.day - o2.day) : 0;
  }
  regulateDate(e2, t2 = "constrain", r2) {
    const o2 = this.calendarToIsoDate(e2, t2, r2);
    return this.isoToCalendarDate(o2, r2);
  }
  addDaysIso(e2, t2) {
    return AddISODate(e2.year, e2.month, e2.day, 0, 0, 0, t2, "constrain");
  }
  addDaysCalendar(e2, t2, r2) {
    const o2 = this.calendarToIsoDate(e2, "constrain", r2), n2 = this.addDaysIso(o2, t2);
    return this.isoToCalendarDate(n2, r2);
  }
  addMonthsCalendar(e2, t2, r2, o2) {
    let n2 = e2;
    const { day: a2 } = n2;
    for (let e3 = 0, r3 = It(t2); e3 < r3; e3++) {
      const { month: e4 } = n2, r4 = n2, i2 = t2 < 0 ? -Math.max(a2, this.daysInPreviousMonth(n2, o2)) : this.daysInMonth(n2, o2), s2 = this.calendarToIsoDate(n2, "constrain", o2);
      let l2 = this.addDaysIso(s2, i2);
      if (n2 = this.isoToCalendarDate(l2, o2), t2 > 0) {
        const t3 = this.monthsInYear(r4, o2);
        for (; n2.month - 1 != e4 % t3; )
          l2 = this.addDaysIso(l2, -1), n2 = this.isoToCalendarDate(l2, o2);
      }
      n2.day !== a2 && (n2 = this.regulateDate({ ...n2, day: a2 }, "constrain", o2));
    }
    if ("reject" === r2 && n2.day !== a2)
      throw new RangeError(`Day ${a2} does not exist in resulting calendar month`);
    return n2;
  }
  addCalendar(e2, { years: t2 = 0, months: r2 = 0, weeks: o2 = 0, days: n2 = 0 }, a2, i2) {
    const { year: s2, day: l2, monthCode: d2 } = e2, m2 = this.adjustCalendarDate({ year: s2 + t2, monthCode: d2, day: l2 }, i2), c2 = this.addMonthsCalendar(m2, r2, a2, i2), h2 = n2 + 7 * o2;
    return this.addDaysCalendar(c2, h2, i2);
  }
  untilCalendar(e2, t2, r2, o2) {
    let n2 = 0, a2 = 0, i2 = 0, s2 = 0;
    switch (r2) {
      case "day":
        n2 = this.calendarDaysUntil(e2, t2, o2);
        break;
      case "week": {
        const r3 = this.calendarDaysUntil(e2, t2, o2);
        n2 = r3 % 7, a2 = (r3 - n2) / 7;
        break;
      }
      case "month":
      case "year": {
        const a3 = this.compareCalendarDates(t2, e2);
        if (!a3)
          return { years: 0, months: 0, weeks: 0, days: 0 };
        const l2 = t2.year - e2.year, d2 = t2.day - e2.day;
        if ("year" === r2 && l2) {
          let r3 = 0;
          t2.monthCode > e2.monthCode && (r3 = 1), t2.monthCode < e2.monthCode && (r3 = -1), r3 || (r3 = Math.sign(d2));
          s2 = r3 * a3 < 0 ? l2 - a3 : l2;
        }
        let m2, c2 = s2 ? this.addCalendar(e2, { years: s2 }, "constrain", o2) : e2;
        do {
          i2 += a3, m2 = c2, c2 = this.addMonthsCalendar(m2, a3, "constrain", o2), c2.day !== e2.day && (c2 = this.regulateDate({ ...c2, day: e2.day }, "constrain", o2));
        } while (this.compareCalendarDates(t2, c2) * a3 >= 0);
        i2 -= a3;
        n2 = this.calendarDaysUntil(m2, t2, o2);
        break;
      }
    }
    return { years: s2, months: i2, weeks: a2, days: n2 };
  }
  daysInMonth(e2, t2) {
    const { day: r2 } = e2, o2 = this.maximumMonthLength(e2), n2 = this.minimumMonthLength(e2);
    if (n2 === o2)
      return n2;
    const a2 = r2 <= o2 - n2 ? o2 : n2, i2 = this.calendarToIsoDate(e2, "constrain", t2), s2 = this.addDaysIso(i2, a2), l2 = this.isoToCalendarDate(s2, t2), d2 = this.addDaysIso(s2, -l2.day);
    return this.isoToCalendarDate(d2, t2).day;
  }
  daysInPreviousMonth(e2, t2) {
    const { day: r2, month: o2, year: n2 } = e2;
    let a2 = { year: o2 > 1 ? n2 : n2 - 1, month: o2, day: 1 };
    const i2 = o2 > 1 ? o2 - 1 : this.monthsInYear(a2, t2);
    a2 = { ...a2, month: i2 };
    const s2 = this.minimumMonthLength(a2), l2 = this.maximumMonthLength(a2);
    if (s2 === l2)
      return l2;
    const d2 = this.calendarToIsoDate(e2, "constrain", t2), m2 = this.addDaysIso(d2, -r2);
    return this.isoToCalendarDate(m2, t2).day;
  }
  startOfCalendarYear(e2) {
    return { year: e2.year, month: 1, monthCode: "M01", day: 1 };
  }
  startOfCalendarMonth(e2) {
    return { year: e2.year, month: e2.month, day: 1 };
  }
  calendarDaysUntil(e2, t2, r2) {
    const o2 = this.calendarToIsoDate(e2, "constrain", r2), n2 = this.calendarToIsoDate(t2, "constrain", r2);
    return this.isoDaysUntil(o2, n2);
  }
  isoDaysUntil(e2, t2) {
    return DifferenceISODate(e2.year, e2.month, e2.day, t2.year, t2.month, t2.day, "day").days;
  }
  monthDayFromFields(e2, t2, r2) {
    let o2, n2, a2, i2, s2, { monthCode: l2, day: d2 } = e2;
    if (void 0 === l2) {
      let { year: o3, era: n3, eraYear: a3 } = e2;
      if (void 0 === o3 && (void 0 === n3 || void 0 === a3))
        throw new TypeError("when `monthCode` is omitted, `year` (or `era` and `eraYear`) and `month` are required");
      ({ monthCode: l2, day: d2 } = this.isoToCalendarDate(this.calendarToIsoDate(e2, t2, r2), r2));
    }
    const m2 = this.isoToCalendarDate({ year: 1972, month: 12, day: 31 }, r2), c2 = m2.monthCode > l2 || m2.monthCode === l2 && m2.day >= d2 ? m2.year : m2.year - 1;
    for (let e3 = 0; e3 < 100; e3++) {
      const m3 = this.adjustCalendarDate({ day: d2, monthCode: l2, year: c2 - e3 }, r2), h2 = this.calendarToIsoDate(m3, "constrain", r2), u2 = this.isoToCalendarDate(h2, r2);
      if ({ year: o2, month: n2, day: a2 } = h2, u2.monthCode === l2 && u2.day === d2)
        return { month: n2, day: a2, year: o2 };
      "constrain" === t2 && (void 0 === i2 || u2.monthCode === i2.monthCode && u2.day > i2.day) && (i2 = u2, s2 = h2);
    }
    if ("constrain" === t2 && void 0 !== s2)
      return s2;
    throw new RangeError(`No recent ${this.id} year with monthCode ${l2} and day ${d2}`);
  }
};
var HebrewHelper = class extends HelperBase {
  constructor() {
    super(...arguments), this.id = "hebrew", this.calendarType = "lunisolar", this.months = { Tishri: { leap: 1, regular: 1, monthCode: "M01", days: 30 }, Heshvan: { leap: 2, regular: 2, monthCode: "M02", days: { min: 29, max: 30 } }, Kislev: { leap: 3, regular: 3, monthCode: "M03", days: { min: 29, max: 30 } }, Tevet: { leap: 4, regular: 4, monthCode: "M04", days: 29 }, Shevat: { leap: 5, regular: 5, monthCode: "M05", days: 30 }, Adar: { leap: void 0, regular: 6, monthCode: "M06", days: 29 }, "Adar I": { leap: 6, regular: void 0, monthCode: "M05L", days: 30 }, "Adar II": { leap: 7, regular: void 0, monthCode: "M06", days: 29 }, Nisan: { leap: 8, regular: 7, monthCode: "M07", days: 30 }, Iyar: { leap: 9, regular: 8, monthCode: "M08", days: 29 }, Sivan: { leap: 10, regular: 9, monthCode: "M09", days: 30 }, Tamuz: { leap: 11, regular: 10, monthCode: "M10", days: 29 }, Av: { leap: 12, regular: 11, monthCode: "M11", days: 30 }, Elul: { leap: 13, regular: 12, monthCode: "M12", days: 29 } }, this.hasEra = false;
  }
  inLeapYear(e2) {
    const { year: t2 } = e2;
    return (7 * t2 + 1) % 19 < 7;
  }
  monthsInYear(e2) {
    return this.inLeapYear(e2) ? 13 : 12;
  }
  minimumMonthLength(e2) {
    return this.minMaxMonthLength(e2, "min");
  }
  maximumMonthLength(e2) {
    return this.minMaxMonthLength(e2, "max");
  }
  minMaxMonthLength(e2, t2) {
    const { month: r2, year: o2 } = e2, n2 = this.getMonthCode(o2, r2), a2 = wt(this.months).find((e3) => e3[1].monthCode === n2);
    if (void 0 === a2)
      throw new RangeError(`unmatched Hebrew month: ${r2}`);
    const i2 = a2[1].days;
    return "number" == typeof i2 ? i2 : i2[t2];
  }
  estimateIsoDate(e2) {
    const { year: t2 } = e2;
    return { year: t2 - 3760, month: 1, day: 1 };
  }
  getMonthCode(e2, t2) {
    return this.inLeapYear({ year: e2 }) ? 6 === t2 ? buildMonthCode(5, true) : buildMonthCode(t2 < 6 ? t2 : t2 - 1) : buildMonthCode(t2);
  }
  adjustCalendarDate(e2, t2, r2 = "constrain", o2 = false) {
    let { year: n2, eraYear: a2, month: i2, monthCode: s2, day: l2, monthExtra: d2 } = e2;
    if (void 0 === n2 && void 0 !== a2 && (n2 = a2), void 0 === a2 && void 0 !== n2 && (a2 = n2), o2) {
      if (d2) {
        const e3 = this.months[d2];
        if (!e3)
          throw new RangeError(`Unrecognized month from formatToParts: ${d2}`);
        i2 = this.inLeapYear({ year: n2 }) ? e3.leap : e3.regular;
      }
      s2 = this.getMonthCode(n2, i2);
      return { year: n2, month: i2, day: l2, era: void 0, eraYear: a2, monthCode: s2 };
    }
    if (this.validateCalendarDate(e2), void 0 === i2)
      if (s2.endsWith("L")) {
        if ("M05L" !== s2)
          throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${s2}`);
        if (i2 = 6, !this.inLeapYear({ year: n2 })) {
          if ("reject" === r2)
            throw new RangeError(`Hebrew monthCode M05L is invalid in year ${n2} which is not a leap year`);
          i2 = 6, s2 = "M06";
        }
      } else {
        i2 = monthCodeNumberPart(s2), this.inLeapYear({ year: n2 }) && i2 >= 6 && i2++;
        const e3 = this.monthsInYear({ year: n2 });
        if (i2 < 1 || i2 > e3)
          throw new RangeError(`Invalid monthCode: ${s2}`);
      }
    else if ("reject" === r2 ? (RejectToRange(i2, 1, this.monthsInYear({ year: n2 })), RejectToRange(l2, 1, this.maximumMonthLength({ year: n2, month: i2 }))) : (i2 = ConstrainToRange(i2, 1, this.monthsInYear({ year: n2 })), l2 = ConstrainToRange(l2, 1, this.maximumMonthLength({ year: n2, month: i2 }))), void 0 === s2)
      s2 = this.getMonthCode(n2, i2);
    else {
      if (this.getMonthCode(n2, i2) !== s2)
        throw new RangeError(`monthCode ${s2} doesn't correspond to month ${i2} in Hebrew year ${n2}`);
    }
    return { ...e2, day: l2, month: i2, monthCode: s2, year: n2, eraYear: a2 };
  }
};
var IslamicBaseHelper = class extends HelperBase {
  constructor() {
    super(...arguments), this.calendarType = "lunar", this.DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30, this.DAYS_PER_ISO_YEAR = 365.2425, this.constantEra = "ah";
  }
  inLeapYear(e2, t2) {
    return 30 === this.daysInMonth({ year: e2.year, month: 12, day: 1 }, t2);
  }
  monthsInYear() {
    return 12;
  }
  minimumMonthLength() {
    return 29;
  }
  maximumMonthLength() {
    return 30;
  }
  estimateIsoDate(e2) {
    const { year: t2 } = this.adjustCalendarDate(e2);
    return { year: St(t2 * this.DAYS_PER_ISLAMIC_YEAR / this.DAYS_PER_ISO_YEAR) + 622, month: 1, day: 1 };
  }
};
var IslamicHelper = class extends IslamicBaseHelper {
  constructor() {
    super(...arguments), this.id = "islamic";
  }
};
var IslamicUmalquraHelper = class extends IslamicBaseHelper {
  constructor() {
    super(...arguments), this.id = "islamic-umalqura";
  }
};
var IslamicTblaHelper = class extends IslamicBaseHelper {
  constructor() {
    super(...arguments), this.id = "islamic-tbla";
  }
};
var IslamicCivilHelper = class extends IslamicBaseHelper {
  constructor() {
    super(...arguments), this.id = "islamic-civil";
  }
};
var IslamicRgsaHelper = class extends IslamicBaseHelper {
  constructor() {
    super(...arguments), this.id = "islamic-rgsa";
  }
};
var IslamicCcHelper = class extends IslamicBaseHelper {
  constructor() {
    super(...arguments), this.id = "islamicc";
  }
};
var PersianHelper = class extends HelperBase {
  constructor() {
    super(...arguments), this.id = "persian", this.calendarType = "solar", this.constantEra = "ap";
  }
  inLeapYear(e2, t2) {
    return IslamicHelper.prototype.inLeapYear.call(this, e2, t2);
  }
  monthsInYear() {
    return 12;
  }
  minimumMonthLength(e2) {
    const { month: t2 } = e2;
    return 12 === t2 ? 29 : t2 <= 6 ? 31 : 30;
  }
  maximumMonthLength(e2) {
    const { month: t2 } = e2;
    return 12 === t2 ? 30 : t2 <= 6 ? 31 : 30;
  }
  estimateIsoDate(e2) {
    const { year: t2 } = this.adjustCalendarDate(e2);
    return { year: t2 + 621, month: 1, day: 1 };
  }
};
var IndianHelper = class extends HelperBase {
  constructor() {
    super(...arguments), this.id = "indian", this.calendarType = "solar", this.constantEra = "saka", this.months = { 1: { length: 30, month: 3, day: 22, leap: { length: 31, month: 3, day: 21 } }, 2: { length: 31, month: 4, day: 21 }, 3: { length: 31, month: 5, day: 22 }, 4: { length: 31, month: 6, day: 22 }, 5: { length: 31, month: 7, day: 23 }, 6: { length: 31, month: 8, day: 23 }, 7: { length: 30, month: 9, day: 23 }, 8: { length: 30, month: 10, day: 23 }, 9: { length: 30, month: 11, day: 22 }, 10: { length: 30, month: 12, day: 22 }, 11: { length: 30, month: 1, nextYear: true, day: 21 }, 12: { length: 30, month: 2, nextYear: true, day: 20 } }, this.vulnerableToBceBug = "10/11/-79 Saka" !== (/* @__PURE__ */ new Date("0000-01-01T00:00Z")).toLocaleDateString("en-US-u-ca-indian", { timeZone: "UTC" });
  }
  inLeapYear(e2) {
    return isGregorianLeapYear(e2.year + 78);
  }
  monthsInYear() {
    return 12;
  }
  minimumMonthLength(e2) {
    return this.getMonthInfo(e2).length;
  }
  maximumMonthLength(e2) {
    return this.getMonthInfo(e2).length;
  }
  getMonthInfo(e2) {
    const { month: t2 } = e2;
    let r2 = this.months[t2];
    if (void 0 === r2)
      throw new RangeError(`Invalid month: ${t2}`);
    return this.inLeapYear(e2) && r2.leap && (r2 = r2.leap), r2;
  }
  estimateIsoDate(e2) {
    const t2 = this.adjustCalendarDate(e2), r2 = this.getMonthInfo(t2);
    return AddISODate(t2.year + 78 + (r2.nextYear ? 1 : 0), r2.month, r2.day, 0, 0, 0, t2.day - 1, "constrain");
  }
  checkIcuBugs(e2) {
    if (this.vulnerableToBceBug && e2.year < 1)
      throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 0001-01-01 (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)`);
  }
};
function isGregorianLeapYear(e2) {
  return e2 % 4 == 0 && (e2 % 100 != 0 || e2 % 400 == 0);
}
var GregorianBaseHelper = class extends HelperBase {
  constructor(e2, t2) {
    super(), this.calendarType = "solar", this.v8IsVulnerableToJulianBug = (/* @__PURE__ */ new Date("+001001-01-01T00:00Z")).toLocaleDateString("en-US-u-ca-japanese", { timeZone: "UTC" }).startsWith("12"), this.calendarIsVulnerableToJulianBug = false, this.id = e2;
    const { eras: r2, anchorEra: o2 } = function adjustEras(e3) {
      let t3, r3 = e3;
      if (0 === r3.length)
        throw new RangeError("Invalid era data: eras are required");
      if (1 === r3.length && r3[0].reverseOf)
        throw new RangeError("Invalid era data: anchor era cannot count years backwards");
      if (1 === r3.length && !r3[0].name)
        throw new RangeError("Invalid era data: at least one named era is required");
      if (r3.filter((e4) => null != e4.reverseOf).length > 1)
        throw new RangeError("Invalid era data: only one era can count years backwards");
      r3.forEach((e4) => {
        if (e4.isAnchor || !e4.anchorEpoch && !e4.reverseOf) {
          if (t3)
            throw new RangeError("Invalid era data: cannot have multiple anchor eras");
          t3 = e4, e4.anchorEpoch = { year: e4.hasYearZero ? 0 : 1 };
        } else if (!e4.name)
          throw new RangeError("If era name is blank, it must be the anchor era");
      }), r3 = r3.filter((e4) => e4.name), r3.forEach((e4) => {
        const { reverseOf: t4 } = e4;
        if (t4) {
          const o4 = r3.find((e5) => e5.name === t4);
          if (void 0 === o4)
            throw new RangeError(`Invalid era data: unmatched reverseOf era: ${t4}`);
          e4.reverseOf = o4, e4.anchorEpoch = o4.anchorEpoch, e4.isoEpoch = o4.isoEpoch;
        }
        void 0 === e4.anchorEpoch.month && (e4.anchorEpoch.month = 1), void 0 === e4.anchorEpoch.day && (e4.anchorEpoch.day = 1);
      }), yt.call(r3, (e4, t4) => {
        if (e4.reverseOf)
          return 1;
        if (t4.reverseOf)
          return -1;
        if (!e4.isoEpoch || !t4.isoEpoch)
          throw new RangeError("Invalid era data: missing ISO epoch");
        return t4.isoEpoch.year - e4.isoEpoch.year;
      });
      const o3 = r3[r3.length - 1].reverseOf;
      if (o3 && o3 !== r3[r3.length - 2])
        throw new RangeError("Invalid era data: invalid reverse-sign era");
      return r3.forEach((e4, t4) => {
        e4.genericName = "era" + (r3.length - 1 - t4);
      }), { eras: r3, anchorEra: t3 || r3[0] };
    }(t2);
    this.anchorEra = o2, this.eras = r2;
  }
  inLeapYear(e2) {
    const { year: t2 } = this.estimateIsoDate({ month: 1, day: 1, year: e2.year });
    return isGregorianLeapYear(t2);
  }
  monthsInYear() {
    return 12;
  }
  minimumMonthLength(e2) {
    const { month: t2 } = e2;
    return 2 === t2 ? this.inLeapYear(e2) ? 29 : 28 : [4, 6, 9, 11].indexOf(t2) >= 0 ? 30 : 31;
  }
  maximumMonthLength(e2) {
    return this.minimumMonthLength(e2);
  }
  completeEraYear(e2) {
    const checkField = (t3, r3) => {
      const o3 = e2[t3];
      if (null != o3 && o3 != r3)
        throw new RangeError(`Input ${t3} ${o3} doesn't match calculated value ${r3}`);
    }, eraFromYear = (t3) => {
      let r3;
      const o3 = { ...e2, year: t3 }, n2 = this.eras.find((e3, n3) => {
        if (n3 === this.eras.length - 1) {
          if (e3.reverseOf) {
            if (t3 > 0)
              throw new RangeError(`Signed year ${t3} is invalid for era ${e3.name}`);
            return r3 = e3.anchorEpoch.year - t3, true;
          }
          return r3 = t3 - e3.anchorEpoch.year + (e3.hasYearZero ? 0 : 1), true;
        }
        return this.compareCalendarDates(o3, e3.anchorEpoch) >= 0 && (r3 = t3 - e3.anchorEpoch.year + (e3.hasYearZero ? 0 : 1), true);
      });
      if (!n2)
        throw new RangeError(`Year ${t3} was not matched by any era`);
      return { eraYear: r3, era: n2.name };
    };
    let { year: t2, eraYear: r2, era: o2 } = e2;
    if (null != t2)
      ({ eraYear: r2, era: o2 } = eraFromYear(t2)), checkField("era", o2), checkField("eraYear", r2);
    else {
      if (null == r2)
        throw new RangeError("Either `year` or `eraYear` and `era` are required");
      {
        const e3 = void 0 === o2 ? void 0 : this.eras.find((e4) => e4.name === o2 || e4.genericName === o2);
        if (!e3)
          throw new RangeError(`Era ${o2} (ISO year ${r2}) was not matched by any era`);
        if (r2 < 1 && e3.reverseOf)
          throw new RangeError(`Years in ${o2} era must be positive, not ${t2}`);
        t2 = e3.reverseOf ? e3.anchorEpoch.year - r2 : r2 + e3.anchorEpoch.year - (e3.hasYearZero ? 0 : 1), checkField("year", t2), { eraYear: r2, era: o2 } = eraFromYear(t2);
      }
    }
    return { ...e2, year: t2, eraYear: r2, era: o2 };
  }
  adjustCalendarDate(e2, t2, r2 = "constrain") {
    let o2 = e2;
    const { month: n2, monthCode: a2 } = o2;
    return void 0 === n2 && (o2 = { ...o2, month: monthCodeNumberPart(a2) }), this.validateCalendarDate(o2), o2 = this.completeEraYear(o2), super.adjustCalendarDate(o2, t2, r2);
  }
  estimateIsoDate(e2) {
    const t2 = this.adjustCalendarDate(e2), { year: r2, month: o2, day: n2 } = t2, { anchorEra: a2 } = this;
    return RegulateISODate(r2 + a2.isoEpoch.year - (a2.hasYearZero ? 0 : 1), o2, n2, "constrain");
  }
  checkIcuBugs(e2) {
    if (this.calendarIsVulnerableToJulianBug && this.v8IsVulnerableToJulianBug) {
      if (CompareISODate(e2.year, e2.month, e2.day, 1582, 10, 15) < 0)
        throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 1582-10-15 (see https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)`);
    }
  }
};
var OrthodoxBaseHelper = class extends GregorianBaseHelper {
  constructor(e2, t2) {
    super(e2, t2);
  }
  inLeapYear(e2) {
    const { year: t2 } = e2;
    return (t2 + 1) % 4 == 0;
  }
  monthsInYear() {
    return 13;
  }
  minimumMonthLength(e2) {
    const { month: t2 } = e2;
    return 13 === t2 ? this.inLeapYear(e2) ? 6 : 5 : 30;
  }
  maximumMonthLength(e2) {
    return this.minimumMonthLength(e2);
  }
};
var EthioaaHelper = class extends OrthodoxBaseHelper {
  constructor() {
    super("ethioaa", [{ name: "era0", isoEpoch: { year: -5492, month: 7, day: 17 } }]);
  }
};
var CopticHelper = class extends OrthodoxBaseHelper {
  constructor() {
    super("coptic", [{ name: "era1", isoEpoch: { year: 284, month: 8, day: 29 } }, { name: "era0", reverseOf: "era1" }]);
  }
};
var EthiopicHelper = class extends OrthodoxBaseHelper {
  constructor() {
    super("ethiopic", [{ name: "era0", isoEpoch: { year: -5492, month: 7, day: 17 } }, { name: "era1", isoEpoch: { year: 8, month: 8, day: 27 }, anchorEpoch: { year: 5501 } }]);
  }
};
var RocHelper = class extends GregorianBaseHelper {
  constructor() {
    super("roc", [{ name: "minguo", isoEpoch: { year: 1912, month: 1, day: 1 } }, { name: "before-roc", reverseOf: "minguo" }]), this.calendarIsVulnerableToJulianBug = true;
  }
};
var BuddhistHelper = class extends GregorianBaseHelper {
  constructor() {
    super("buddhist", [{ name: "be", hasYearZero: true, isoEpoch: { year: -543, month: 1, day: 1 } }]), this.calendarIsVulnerableToJulianBug = true;
  }
};
var GregoryHelper = class extends GregorianBaseHelper {
  constructor() {
    super("gregory", [{ name: "ce", isoEpoch: { year: 1, month: 1, day: 1 } }, { name: "bce", reverseOf: "ce" }]);
  }
  reviseIntlEra(e2) {
    let { era: t2, eraYear: r2 } = e2;
    return "bc" !== t2 && "b" !== t2 || (t2 = "bce"), "ad" !== t2 && "a" !== t2 || (t2 = "ce"), { era: t2, eraYear: r2 };
  }
};
var JapaneseHelper = class extends GregorianBaseHelper {
  constructor() {
    super("japanese", [{ name: "reiwa", isoEpoch: { year: 2019, month: 5, day: 1 }, anchorEpoch: { year: 2019, month: 5, day: 1 } }, { name: "heisei", isoEpoch: { year: 1989, month: 1, day: 8 }, anchorEpoch: { year: 1989, month: 1, day: 8 } }, { name: "showa", isoEpoch: { year: 1926, month: 12, day: 25 }, anchorEpoch: { year: 1926, month: 12, day: 25 } }, { name: "taisho", isoEpoch: { year: 1912, month: 7, day: 30 }, anchorEpoch: { year: 1912, month: 7, day: 30 } }, { name: "meiji", isoEpoch: { year: 1868, month: 9, day: 8 }, anchorEpoch: { year: 1868, month: 9, day: 8 } }, { name: "ce", isoEpoch: { year: 1, month: 1, day: 1 } }, { name: "bce", reverseOf: "ce" }]), this.calendarIsVulnerableToJulianBug = true, this.eraLength = "long", this.erasBeginMidYear = true;
  }
  reviseIntlEra(e2, t2) {
    const { era: r2, eraYear: o2 } = e2, { year: n2 } = t2;
    return this.eras.find((e3) => e3.name === r2) ? { era: r2, eraYear: o2 } : n2 < 1 ? { era: "bce", eraYear: 1 - n2 } : { era: "ce", eraYear: n2 };
  }
};
var ChineseBaseHelper = class extends HelperBase {
  constructor() {
    super(...arguments), this.calendarType = "lunisolar", this.hasEra = false;
  }
  inLeapYear(e2, t2) {
    const r2 = this.getMonthList(e2.year, t2);
    return 13 === wt(r2).length;
  }
  monthsInYear(e2, t2) {
    return this.inLeapYear(e2, t2) ? 13 : 12;
  }
  minimumMonthLength() {
    return 29;
  }
  maximumMonthLength() {
    return 30;
  }
  getMonthList(e2, t2) {
    if (void 0 === e2)
      throw new TypeError("Missing year");
    const r2 = JSON.stringify({ func: "getMonthList", calendarYear: e2, id: this.id }), o2 = t2.get(r2);
    if (o2)
      return o2;
    const n2 = this.getFormatter(), getCalendarDate = (e3, t3) => {
      const r3 = toUtcIsoDateString({ isoYear: e3, isoMonth: 2, isoDay: 1 }), o3 = new Date(r3);
      o3.setUTCDate(t3 + 1);
      const a3 = n2.formatToParts(o3), i3 = a3.find((e4) => "month" === e4.type).value, s3 = +a3.find((e4) => "day" === e4.type).value;
      let l3 = a3.find((e4) => "relatedYear" === e4.type);
      if (void 0 === l3)
        throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);
      return l3 = +l3.value, { calendarMonthString: i3, calendarDay: s3, calendarYearToVerify: l3 };
    };
    let a2 = 17, { calendarMonthString: i2, calendarDay: s2, calendarYearToVerify: l2 } = getCalendarDate(e2, a2);
    "1" !== i2 && (a2 += 29, { calendarMonthString: i2, calendarDay: s2 } = getCalendarDate(e2, a2)), a2 -= s2 - 5;
    const d2 = {};
    let m2, c2, h2 = 1, u2 = false;
    do {
      ({ calendarMonthString: i2, calendarDay: s2, calendarYearToVerify: l2 } = getCalendarDate(e2, a2)), m2 && (d2[c2].daysInMonth = m2 + 30 - s2), l2 !== e2 ? u2 = true : (d2[i2] = { monthIndex: h2++ }, a2 += 30), m2 = s2, c2 = i2;
    } while (!u2);
    return d2[c2].daysInMonth = m2 + 30 - s2, t2.set(r2, d2), d2;
  }
  estimateIsoDate(e2) {
    const { year: t2, month: r2 } = e2;
    return { year: t2, month: r2 >= 12 ? 12 : r2 + 1, day: 1 };
  }
  adjustCalendarDate(e2, t2, r2 = "constrain", o2 = false) {
    let { year: n2, month: a2, monthExtra: i2, day: s2, monthCode: l2, eraYear: d2 } = e2;
    if (o2) {
      if (n2 = d2, i2 && "bis" !== i2)
        throw new RangeError(`Unexpected leap month suffix: ${i2}`);
      const e3 = buildMonthCode(a2, void 0 !== i2), r3 = `${a2}${i2 || ""}`, o3 = this.getMonthList(n2, t2)[r3];
      if (void 0 === o3)
        throw new RangeError(`Unmatched month ${r3} in Chinese year ${n2}`);
      return a2 = o3.monthIndex, { year: n2, month: a2, day: s2, era: void 0, eraYear: d2, monthCode: e3 };
    }
    if (this.validateCalendarDate(e2), void 0 === n2 && (n2 = d2), void 0 === d2 && (d2 = n2), void 0 === a2) {
      const e3 = this.getMonthList(n2, t2);
      let o3 = l2.replace("L", "bis").slice(1);
      "0" === o3[0] && (o3 = o3.slice(1));
      let i3 = e3[o3];
      if (a2 = i3 && i3.monthIndex, void 0 === a2 && l2.endsWith("L") && "M13L" != l2 && "constrain" === r2) {
        let t3 = l2.slice(1, -1);
        "0" === t3[0] && (t3 = t3.slice(1)), i3 = e3[t3], i3 && (a2 = i3.monthIndex, l2 = buildMonthCode(t3));
      }
      if (void 0 === a2)
        throw new RangeError(`Unmatched month ${l2} in Chinese year ${n2}`);
    } else if (void 0 === l2) {
      const e3 = this.getMonthList(n2, t2), o3 = wt(e3), i3 = o3.length;
      "reject" === r2 ? (RejectToRange(a2, 1, i3), RejectToRange(s2, 1, this.maximumMonthLength())) : (a2 = ConstrainToRange(a2, 1, i3), s2 = ConstrainToRange(s2, 1, this.maximumMonthLength()));
      const d3 = o3.find(([, e4]) => e4.monthIndex === a2);
      if (void 0 === d3)
        throw new RangeError(`Invalid month ${a2} in Chinese year ${n2}`);
      l2 = buildMonthCode(d3[0].replace("bis", ""), -1 !== d3[0].indexOf("bis"));
    } else {
      const e3 = this.getMonthList(n2, t2);
      let r3 = l2.replace("L", "bis").slice(1);
      "0" === r3[0] && (r3 = r3.slice(1));
      const o3 = e3[r3];
      if (!o3)
        throw new RangeError(`Unmatched monthCode ${l2} in Chinese year ${n2}`);
      if (a2 !== o3.monthIndex)
        throw new RangeError(`monthCode ${l2} doesn't correspond to month ${a2} in Chinese year ${n2}`);
    }
    return { ...e2, year: n2, eraYear: d2, month: a2, monthCode: l2, day: s2 };
  }
};
var ChineseHelper = class extends ChineseBaseHelper {
  constructor() {
    super(...arguments), this.id = "chinese";
  }
};
var DangiHelper = class extends ChineseBaseHelper {
  constructor() {
    super(...arguments), this.id = "dangi";
  }
};
var NonIsoCalendar = class {
  constructor(e2) {
    this.helper = e2;
  }
  dateFromFields(e2, t2, r2) {
    const o2 = new OneObjectCache(), n2 = PrepareTemporalFields(e2, this.fields(["day", "month", "monthCode", "year"]), []), a2 = ToTemporalOverflow(t2), { year: i2, month: s2, day: l2 } = this.helper.calendarToIsoDate(n2, a2, o2), d2 = CreateTemporalDate(i2, s2, l2, r2);
    return o2.setObject(d2), d2;
  }
  yearMonthFromFields(e2, t2, r2) {
    const o2 = new OneObjectCache(), n2 = PrepareTemporalFields(e2, this.fields(["month", "monthCode", "year"]), []), a2 = ToTemporalOverflow(t2), { year: i2, month: s2, day: l2 } = this.helper.calendarToIsoDate({ ...n2, day: 1 }, a2, o2), d2 = CreateTemporalYearMonth(i2, s2, r2, l2);
    return o2.setObject(d2), d2;
  }
  monthDayFromFields(e2, t2, r2) {
    const o2 = new OneObjectCache(), n2 = PrepareTemporalFields(e2, this.fields(["day", "month", "monthCode", "year"]), []), a2 = ToTemporalOverflow(t2), { year: i2, month: s2, day: l2 } = this.helper.monthDayFromFields(n2, a2, o2), d2 = CreateTemporalMonthDay(s2, l2, r2, i2);
    return o2.setObject(d2), d2;
  }
  fields(e2) {
    let t2 = e2;
    return Tt.call(t2, "year") && (t2 = [...t2, "era", "eraYear"]), t2;
  }
  fieldKeysToIgnore(e2) {
    const t2 = new Dt();
    for (let r2 = 0; r2 < e2.length; r2++) {
      const o2 = e2[r2];
      switch (Call(vt, t2, [o2]), o2) {
        case "era":
          Call(vt, t2, ["eraYear"]), Call(vt, t2, ["year"]);
          break;
        case "eraYear":
          Call(vt, t2, ["era"]), Call(vt, t2, ["year"]);
          break;
        case "year":
          Call(vt, t2, ["era"]), Call(vt, t2, ["eraYear"]);
          break;
        case "month":
          Call(vt, t2, ["monthCode"]), this.helper.erasBeginMidYear && (Call(vt, t2, ["era"]), Call(vt, t2, ["eraYear"]));
          break;
        case "monthCode":
          Call(vt, t2, ["month"]), this.helper.erasBeginMidYear && (Call(vt, t2, ["era"]), Call(vt, t2, ["eraYear"]));
          break;
        case "day":
          this.helper.erasBeginMidYear && (Call(vt, t2, ["era"]), Call(vt, t2, ["eraYear"]));
      }
    }
    return [...Call(Ct, t2, [])];
  }
  dateAdd(e2, t2, r2, o2, n2, a2, i2) {
    const s2 = OneObjectCache.getCacheForObject(e2), l2 = this.helper.temporalToCalendarDate(e2, s2), d2 = this.helper.addCalendar(l2, { years: t2, months: r2, weeks: o2, days: n2 }, a2, s2), m2 = this.helper.calendarToIsoDate(d2, "constrain", s2), { year: c2, month: h2, day: u2 } = m2, T2 = CreateTemporalDate(c2, h2, u2, i2);
    return new OneObjectCache(s2).setObject(T2), T2;
  }
  dateUntil(e2, t2, r2) {
    const o2 = OneObjectCache.getCacheForObject(e2), n2 = OneObjectCache.getCacheForObject(t2), a2 = this.helper.temporalToCalendarDate(e2, o2), i2 = this.helper.temporalToCalendarDate(t2, n2);
    return this.helper.untilCalendar(a2, i2, r2, o2);
  }
  year(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2);
    return this.helper.temporalToCalendarDate(e2, t2).year;
  }
  month(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2);
    return this.helper.temporalToCalendarDate(e2, t2).month;
  }
  day(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2);
    return this.helper.temporalToCalendarDate(e2, t2).day;
  }
  era(e2) {
    if (!this.helper.hasEra)
      return;
    const t2 = OneObjectCache.getCacheForObject(e2);
    return this.helper.temporalToCalendarDate(e2, t2).era;
  }
  eraYear(e2) {
    if (!this.helper.hasEra)
      return;
    const t2 = OneObjectCache.getCacheForObject(e2);
    return this.helper.temporalToCalendarDate(e2, t2).eraYear;
  }
  monthCode(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2);
    return this.helper.temporalToCalendarDate(e2, t2).monthCode;
  }
  dayOfWeek(e2) {
    return Ot.iso8601.dayOfWeek(e2);
  }
  dayOfYear(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2), r2 = this.helper.isoToCalendarDate(e2, t2), o2 = this.helper.startOfCalendarYear(r2);
    return this.helper.calendarDaysUntil(o2, r2, t2) + 1;
  }
  weekOfYear(e2) {
    return Ot.iso8601.weekOfYear(e2);
  }
  yearOfWeek(e2) {
    return Ot.iso8601.yearOfWeek(e2);
  }
  daysInWeek(e2) {
    return Ot.iso8601.daysInWeek(e2);
  }
  daysInMonth(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2), r2 = this.helper.temporalToCalendarDate(e2, t2), o2 = this.helper.maximumMonthLength(r2);
    if (o2 === this.helper.minimumMonthLength(r2))
      return o2;
    const n2 = this.helper.startOfCalendarMonth(r2), a2 = this.helper.addMonthsCalendar(n2, 1, "constrain", t2);
    return this.helper.calendarDaysUntil(n2, a2, t2);
  }
  daysInYear(e2) {
    let t2 = e2;
    HasSlot(t2, i) || (t2 = ToTemporalDate(t2));
    const r2 = OneObjectCache.getCacheForObject(t2), o2 = this.helper.temporalToCalendarDate(t2, r2), n2 = this.helper.startOfCalendarYear(o2), a2 = this.helper.addCalendar(n2, { years: 1 }, "constrain", r2);
    return this.helper.calendarDaysUntil(n2, a2, r2);
  }
  monthsInYear(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2), r2 = this.helper.temporalToCalendarDate(e2, t2);
    return this.helper.monthsInYear(r2, t2);
  }
  inLeapYear(e2) {
    let t2 = e2;
    HasSlot(t2, i) || (t2 = ToTemporalDate(t2));
    const r2 = OneObjectCache.getCacheForObject(t2), o2 = this.helper.temporalToCalendarDate(t2, r2);
    return this.helper.inLeapYear(o2, r2);
  }
};
for (const e2 of [HebrewHelper, PersianHelper, EthiopicHelper, EthioaaHelper, CopticHelper, ChineseHelper, DangiHelper, RocHelper, IndianHelper, BuddhistHelper, GregoryHelper, JapaneseHelper, IslamicHelper, IslamicUmalquraHelper, IslamicTblaHelper, IslamicCivilHelper, IslamicRgsaHelper, IslamicCcHelper]) {
  const t2 = new e2();
  Ot[t2.id] = new NonIsoCalendar(t2);
}
var PlainDate = class _PlainDate {
  constructor(e2, t2, r2, o2 = "iso8601") {
    CreateTemporalDateSlots(this, ToIntegerWithTruncation(e2), ToIntegerWithTruncation(t2), ToIntegerWithTruncation(r2), ToTemporalCalendarSlotValue(o2));
  }
  get calendarId() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return ToTemporalCalendarIdentifier(GetSlot(this, p));
  }
  get era() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarEra(GetSlot(this, p), this);
  }
  get eraYear() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarEraYear(GetSlot(this, p), this);
  }
  get year() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarYear(GetSlot(this, p), this);
  }
  get month() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarMonth(GetSlot(this, p), this);
  }
  get monthCode() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, p), this);
  }
  get day() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarDay(GetSlot(this, p), this);
  }
  get dayOfWeek() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarDayOfWeek(GetSlot(this, p), this);
  }
  get dayOfYear() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarDayOfYear(GetSlot(this, p), this);
  }
  get weekOfYear() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarWeekOfYear(GetSlot(this, p), this);
  }
  get yearOfWeek() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarYearOfWeek(GetSlot(this, p), this);
  }
  get daysInWeek() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInWeek(GetSlot(this, p), this);
  }
  get daysInMonth() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInMonth(GetSlot(this, p), this);
  }
  get daysInYear() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInYear(GetSlot(this, p), this);
  }
  get monthsInYear() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthsInYear(GetSlot(this, p), this);
  }
  get inLeapYear() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarInLeapYear(GetSlot(this, p), this);
  }
  with(e2, t2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid argument");
    RejectTemporalLikeObject(e2);
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, p), n2 = CalendarFields(o2, ["day", "month", "monthCode", "year"]);
    let a2 = PrepareTemporalFields(this, n2, []);
    return a2 = CalendarMergeFields(o2, a2, PrepareTemporalFields(e2, n2, "partial")), a2 = PrepareTemporalFields(a2, n2, []), CalendarDateFromFields(o2, a2, r2);
  }
  withCalendar(e2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalCalendarSlotValue(e2);
    return new _PlainDate(GetSlot(this, i), GetSlot(this, s), GetSlot(this, l), t2);
  }
  add(e2, t2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    const r2 = ToTemporalDuration(e2), o2 = GetOptionsObject(t2);
    return CalendarDateAdd(GetSlot(this, p), this, r2, o2);
  }
  subtract(e2, t2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    const r2 = CreateNegatedTemporalDuration(ToTemporalDuration(e2)), o2 = GetOptionsObject(t2);
    return CalendarDateAdd(GetSlot(this, p), this, r2, o2);
  }
  until(e2, t2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainDate("until", this, e2, t2);
  }
  since(e2, t2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainDate("since", this, e2, t2);
  }
  equals(e2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2);
    for (const e3 of [i, s, l]) {
      if (GetSlot(this, e3) !== GetSlot(t2, e3))
        return false;
    }
    return CalendarEquals(GetSlot(this, p), GetSlot(t2, p));
  }
  toString(e2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return TemporalDateToString(this, ToCalendarNameOption(GetOptionsObject(e2)));
  }
  toJSON() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return TemporalDateToString(this);
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return new ht(e2, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.PlainDate");
  }
  toPlainDateTime(e2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, i), r2 = GetSlot(this, s), o2 = GetSlot(this, l), n2 = GetSlot(this, p);
    if (void 0 === e2)
      return CreateTemporalDateTime(t2, r2, o2, 0, 0, 0, 0, 0, 0, n2);
    const a2 = ToTemporalTime(e2);
    return CreateTemporalDateTime(t2, r2, o2, GetSlot(a2, d), GetSlot(a2, m), GetSlot(a2, c), GetSlot(a2, h), GetSlot(a2, u), GetSlot(a2, T), n2);
  }
  toZonedDateTime(e2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    let t2, r2;
    if (IsObject(e2))
      if (IsTemporalTimeZone(e2))
        t2 = e2;
      else {
        const o3 = e2.timeZone;
        void 0 === o3 ? t2 = ToTemporalTimeZoneSlotValue(e2) : (t2 = ToTemporalTimeZoneSlotValue(o3), r2 = e2.plainTime);
      }
    else
      t2 = ToTemporalTimeZoneSlotValue(e2);
    const o2 = GetSlot(this, i), a2 = GetSlot(this, s), f2 = GetSlot(this, l), y2 = GetSlot(this, p);
    let I2 = 0, S2 = 0, g2 = 0, w2 = 0, D2 = 0, G2 = 0;
    void 0 !== r2 && (r2 = ToTemporalTime(r2), I2 = GetSlot(r2, d), S2 = GetSlot(r2, m), g2 = GetSlot(r2, c), w2 = GetSlot(r2, h), D2 = GetSlot(r2, u), G2 = GetSlot(r2, T));
    return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(t2, CreateTemporalDateTime(o2, a2, f2, I2, S2, g2, w2, D2, G2, y2), "compatible"), n), t2, y2);
  }
  toPlainYearMonth() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    const e2 = GetSlot(this, p);
    return CalendarYearMonthFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, ["monthCode", "year"]), []));
  }
  toPlainMonthDay() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    const e2 = GetSlot(this, p);
    return CalendarMonthDayFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, ["day", "monthCode"]), []));
  }
  getISOFields() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return { calendar: GetSlot(this, p), isoDay: GetSlot(this, l), isoMonth: GetSlot(this, s), isoYear: GetSlot(this, i) };
  }
  getCalendar() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return ToTemporalCalendarObject(GetSlot(this, p));
  }
  static from(e2, t2) {
    const r2 = GetOptionsObject(t2);
    return IsTemporalDate(e2) ? (ToTemporalOverflow(r2), CreateTemporalDate(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l), GetSlot(e2, p))) : ToTemporalDate(e2, r2);
  }
  static compare(e2, t2) {
    const r2 = ToTemporalDate(e2), o2 = ToTemporalDate(t2);
    return CompareISODate(GetSlot(r2, i), GetSlot(r2, s), GetSlot(r2, l), GetSlot(o2, i), GetSlot(o2, s), GetSlot(o2, l));
  }
};
MakeIntrinsicClass(PlainDate, "Temporal.PlainDate");
var PlainDateTime = class _PlainDateTime {
  constructor(e2, t2, r2, o2 = 0, n2 = 0, a2 = 0, i2 = 0, s2 = 0, l2 = 0, d2 = "iso8601") {
    CreateTemporalDateTimeSlots(this, ToIntegerWithTruncation(e2), ToIntegerWithTruncation(t2), ToIntegerWithTruncation(r2), void 0 === o2 ? 0 : ToIntegerWithTruncation(o2), void 0 === n2 ? 0 : ToIntegerWithTruncation(n2), void 0 === a2 ? 0 : ToIntegerWithTruncation(a2), void 0 === i2 ? 0 : ToIntegerWithTruncation(i2), void 0 === s2 ? 0 : ToIntegerWithTruncation(s2), void 0 === l2 ? 0 : ToIntegerWithTruncation(l2), ToTemporalCalendarSlotValue(d2));
  }
  get calendarId() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return ToTemporalCalendarIdentifier(GetSlot(this, p));
  }
  get year() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarYear(GetSlot(this, p), this);
  }
  get month() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarMonth(GetSlot(this, p), this);
  }
  get monthCode() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, p), this);
  }
  get day() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDay(GetSlot(this, p), this);
  }
  get hour() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, d);
  }
  get minute() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, m);
  }
  get second() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, c);
  }
  get millisecond() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, h);
  }
  get microsecond() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, u);
  }
  get nanosecond() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, T);
  }
  get era() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarEra(GetSlot(this, p), this);
  }
  get eraYear() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarEraYear(GetSlot(this, p), this);
  }
  get dayOfWeek() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDayOfWeek(GetSlot(this, p), this);
  }
  get dayOfYear() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDayOfYear(GetSlot(this, p), this);
  }
  get weekOfYear() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarWeekOfYear(GetSlot(this, p), this);
  }
  get yearOfWeek() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarYearOfWeek(GetSlot(this, p), this);
  }
  get daysInWeek() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInWeek(GetSlot(this, p), this);
  }
  get daysInYear() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInYear(GetSlot(this, p), this);
  }
  get daysInMonth() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInMonth(GetSlot(this, p), this);
  }
  get monthsInYear() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthsInYear(GetSlot(this, p), this);
  }
  get inLeapYear() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarInLeapYear(GetSlot(this, p), this);
  }
  with(e2, t2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid argument");
    RejectTemporalLikeObject(e2);
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, p), n2 = CalendarFields(o2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]);
    let a2 = PrepareTemporalFields(this, n2, []);
    a2 = CalendarMergeFields(o2, a2, PrepareTemporalFields(e2, n2, "partial")), a2 = PrepareTemporalFields(a2, n2, []);
    const { year: i2, month: s2, day: l2, hour: d2, minute: m2, second: c2, millisecond: h2, microsecond: u2, nanosecond: T2 } = InterpretTemporalDateTimeFields(o2, a2, r2);
    return CreateTemporalDateTime(i2, s2, l2, d2, m2, c2, h2, u2, T2, o2);
  }
  withPlainTime(e2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, i), r2 = GetSlot(this, s), o2 = GetSlot(this, l), n2 = GetSlot(this, p);
    if (void 0 === e2)
      return CreateTemporalDateTime(t2, r2, o2, 0, 0, 0, 0, 0, 0, n2);
    const a2 = ToTemporalTime(e2);
    return CreateTemporalDateTime(t2, r2, o2, GetSlot(a2, d), GetSlot(a2, m), GetSlot(a2, c), GetSlot(a2, h), GetSlot(a2, u), GetSlot(a2, T), n2);
  }
  withPlainDate(e2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2), r2 = GetSlot(t2, i), o2 = GetSlot(t2, s), n2 = GetSlot(t2, l);
    let a2 = GetSlot(t2, p);
    const f2 = GetSlot(this, d), y2 = GetSlot(this, m), I2 = GetSlot(this, c), S2 = GetSlot(this, h), g2 = GetSlot(this, u), w2 = GetSlot(this, T);
    return a2 = ConsolidateCalendars(GetSlot(this, p), a2), CreateTemporalDateTime(r2, o2, n2, f2, y2, I2, S2, g2, w2, a2);
  }
  withCalendar(e2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalCalendarSlotValue(e2);
    return new _PlainDateTime(GetSlot(this, i), GetSlot(this, s), GetSlot(this, l), GetSlot(this, d), GetSlot(this, m), GetSlot(this, c), GetSlot(this, h), GetSlot(this, u), GetSlot(this, T), t2);
  }
  add(e2, t2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainDateTime("add", this, e2, t2);
  }
  subtract(e2, t2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainDateTime("subtract", this, e2, t2);
  }
  until(e2, t2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainDateTime("until", this, e2, t2);
  }
  since(e2, t2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainDateTime("since", this, e2, t2);
  }
  round(e2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    if (void 0 === e2)
      throw new TypeError("options parameter is required");
    const t2 = "string" == typeof e2 ? CreateOnePropObject("smallestUnit", e2) : GetOptionsObject(e2), r2 = ToTemporalRoundingIncrement(t2), o2 = ToTemporalRoundingMode(t2, "halfExpand"), n2 = GetTemporalUnit(t2, "smallestUnit", "time", He, ["day"]), a2 = { day: 1, hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[n2];
    ValidateTemporalRoundingIncrement(r2, a2, 1 === a2);
    let f2 = GetSlot(this, i), y2 = GetSlot(this, s), I2 = GetSlot(this, l), S2 = GetSlot(this, d), g2 = GetSlot(this, m), w2 = GetSlot(this, c), D2 = GetSlot(this, h), G2 = GetSlot(this, u), v2 = GetSlot(this, T);
    return { year: f2, month: y2, day: I2, hour: S2, minute: g2, second: w2, millisecond: D2, microsecond: G2, nanosecond: v2 } = RoundISODateTime(f2, y2, I2, S2, g2, w2, D2, G2, v2, r2, n2, o2), CreateTemporalDateTime(f2, y2, I2, S2, g2, w2, D2, G2, v2, GetSlot(this, p));
  }
  equals(e2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDateTime(e2);
    for (const e3 of [i, s, l, d, m, c, h, u, T]) {
      if (GetSlot(this, e3) !== GetSlot(t2, e3))
        return false;
    }
    return CalendarEquals(GetSlot(this, p), GetSlot(t2, p));
  }
  toString(e2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e2), r2 = ToCalendarNameOption(t2), o2 = ToFractionalSecondDigits(t2), n2 = ToTemporalRoundingMode(t2, "trunc"), a2 = GetTemporalUnit(t2, "smallestUnit", "time", void 0);
    if ("hour" === a2)
      throw new RangeError('smallestUnit must be a time unit other than "hour"');
    const { precision: i2, unit: s2, increment: l2 } = ToSecondsStringPrecisionRecord(a2, o2);
    return TemporalDateTimeToString(this, i2, r2, { unit: s2, increment: l2, roundingMode: n2 });
  }
  toJSON() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return TemporalDateTimeToString(this, "auto");
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return new ht(e2, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.PlainDateTime");
  }
  toZonedDateTime(e2, t2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    const r2 = ToTemporalTimeZoneSlotValue(e2);
    return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(r2, this, ToTemporalDisambiguation(GetOptionsObject(t2))), n), r2, GetSlot(this, p));
  }
  toPlainDate() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return TemporalDateTimeToDate(this);
  }
  toPlainYearMonth() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    const e2 = GetSlot(this, p);
    return CalendarYearMonthFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, ["monthCode", "year"]), []));
  }
  toPlainMonthDay() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    const e2 = GetSlot(this, p);
    return CalendarMonthDayFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, ["day", "monthCode"]), []));
  }
  toPlainTime() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return TemporalDateTimeToTime(this);
  }
  getISOFields() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return { calendar: GetSlot(this, p), isoDay: GetSlot(this, l), isoHour: GetSlot(this, d), isoMicrosecond: GetSlot(this, u), isoMillisecond: GetSlot(this, h), isoMinute: GetSlot(this, m), isoMonth: GetSlot(this, s), isoNanosecond: GetSlot(this, T), isoSecond: GetSlot(this, c), isoYear: GetSlot(this, i) };
  }
  getCalendar() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return ToTemporalCalendarObject(GetSlot(this, p));
  }
  static from(e2, t2) {
    const r2 = GetOptionsObject(t2);
    return IsTemporalDateTime(e2) ? (ToTemporalOverflow(r2), CreateTemporalDateTime(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l), GetSlot(e2, d), GetSlot(e2, m), GetSlot(e2, c), GetSlot(e2, h), GetSlot(e2, u), GetSlot(e2, T), GetSlot(e2, p))) : ToTemporalDateTime(e2, r2);
  }
  static compare(e2, t2) {
    const r2 = ToTemporalDateTime(e2), o2 = ToTemporalDateTime(t2);
    for (const e3 of [i, s, l, d, m, c, h, u, T]) {
      const t3 = GetSlot(r2, e3), n2 = GetSlot(o2, e3);
      if (t3 !== n2)
        return ComparisonResult(t3 - n2);
    }
    return 0;
  }
};
MakeIntrinsicClass(PlainDateTime, "Temporal.PlainDateTime");
var Duration = class _Duration {
  constructor(e2 = 0, t2 = 0, r2 = 0, o2 = 0, n2 = 0, a2 = 0, i2 = 0, s2 = 0, l2 = 0, d2 = 0) {
    const m2 = void 0 === e2 ? 0 : ToIntegerIfIntegral(e2), c2 = void 0 === t2 ? 0 : ToIntegerIfIntegral(t2), h2 = void 0 === r2 ? 0 : ToIntegerIfIntegral(r2), u2 = void 0 === o2 ? 0 : ToIntegerIfIntegral(o2), T2 = void 0 === n2 ? 0 : ToIntegerIfIntegral(n2), p2 = void 0 === a2 ? 0 : ToIntegerIfIntegral(a2), f2 = void 0 === i2 ? 0 : ToIntegerIfIntegral(i2), y2 = void 0 === s2 ? 0 : ToIntegerIfIntegral(s2), I2 = void 0 === l2 ? 0 : ToIntegerIfIntegral(l2), S2 = void 0 === d2 ? 0 : ToIntegerIfIntegral(d2);
    RejectDuration(m2, c2, h2, u2, T2, p2, f2, y2, I2, S2), N(this), SetSlot(this, w, m2), SetSlot(this, D, c2), SetSlot(this, G, h2), SetSlot(this, v, u2), SetSlot(this, C, T2), SetSlot(this, O, p2), SetSlot(this, b, f2), SetSlot(this, E, y2), SetSlot(this, M, I2), SetSlot(this, R, S2);
  }
  get years() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, w);
  }
  get months() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, D);
  }
  get weeks() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, G);
  }
  get days() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, v);
  }
  get hours() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, C);
  }
  get minutes() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, O);
  }
  get seconds() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, b);
  }
  get milliseconds() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, E);
  }
  get microseconds() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, M);
  }
  get nanoseconds() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, R);
  }
  get sign() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return DurationSign(GetSlot(this, w), GetSlot(this, D), GetSlot(this, G), GetSlot(this, v), GetSlot(this, C), GetSlot(this, O), GetSlot(this, b), GetSlot(this, E), GetSlot(this, M), GetSlot(this, R));
  }
  get blank() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return 0 === DurationSign(GetSlot(this, w), GetSlot(this, D), GetSlot(this, G), GetSlot(this, v), GetSlot(this, C), GetSlot(this, O), GetSlot(this, b), GetSlot(this, E), GetSlot(this, M), GetSlot(this, R));
  }
  with(e2) {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    const t2 = PrepareTemporalFields(e2, ["days", "hours", "microseconds", "milliseconds", "minutes", "months", "nanoseconds", "seconds", "weeks", "years"], "partial"), { years: r2 = GetSlot(this, w), months: o2 = GetSlot(this, D), weeks: n2 = GetSlot(this, G), days: a2 = GetSlot(this, v), hours: i2 = GetSlot(this, C), minutes: s2 = GetSlot(this, O), seconds: l2 = GetSlot(this, b), milliseconds: d2 = GetSlot(this, E), microseconds: m2 = GetSlot(this, M), nanoseconds: c2 = GetSlot(this, R) } = t2;
    return new _Duration(r2, o2, n2, a2, i2, s2, l2, d2, m2, c2);
  }
  negated() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return CreateNegatedTemporalDuration(this);
  }
  abs() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return new _Duration(Math.abs(GetSlot(this, w)), Math.abs(GetSlot(this, D)), Math.abs(GetSlot(this, G)), Math.abs(GetSlot(this, v)), Math.abs(GetSlot(this, C)), Math.abs(GetSlot(this, O)), Math.abs(GetSlot(this, b)), Math.abs(GetSlot(this, E)), Math.abs(GetSlot(this, M)), Math.abs(GetSlot(this, R)));
  }
  add(e2, t2) {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromDuration("add", this, e2, t2);
  }
  subtract(e2, t2) {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromDuration("subtract", this, e2, t2);
  }
  round(t2) {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    if (void 0 === t2)
      throw new TypeError("options parameter is required");
    let r2 = GetSlot(this, w), o2 = GetSlot(this, D), n2 = GetSlot(this, G), a2 = GetSlot(this, v), i2 = GetSlot(this, C), s2 = GetSlot(this, O), l2 = GetSlot(this, b), d2 = GetSlot(this, E), m2 = GetSlot(this, M), c2 = GetSlot(this, R), h2 = DefaultTemporalLargestUnit(r2, o2, n2, a2, i2, s2, l2, d2, m2, c2);
    const u2 = "string" == typeof t2 ? CreateOnePropObject("smallestUnit", t2) : GetOptionsObject(t2);
    let T2 = GetTemporalUnit(u2, "largestUnit", "datetime", void 0, ["auto"]), f2 = ToRelativeTemporalObject(u2);
    const y2 = ToTemporalRoundingIncrement(u2), I2 = ToTemporalRoundingMode(u2, "halfExpand");
    let S2 = GetTemporalUnit(u2, "smallestUnit", "datetime", void 0), g2 = true;
    S2 || (g2 = false, S2 = "nanosecond"), h2 = LargerOfTwoTemporalUnits(h2, S2);
    let F2 = true;
    if (T2 || (F2 = false, T2 = h2), "auto" === T2 && (T2 = h2), !g2 && !F2)
      throw new RangeError("at least one of smallestUnit or largestUnit is required");
    if (LargerOfTwoTemporalUnits(T2, S2) !== T2)
      throw new RangeError(`largestUnit ${T2} cannot be smaller than smallestUnit ${S2}`);
    const Y2 = { hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[S2];
    return void 0 !== Y2 && ValidateTemporalRoundingIncrement(y2, Y2, false), { years: r2, months: o2, weeks: n2, days: a2 } = UnbalanceDurationRelative(r2, o2, n2, a2, T2, f2), { years: r2, months: o2, weeks: n2, days: a2, hours: i2, minutes: s2, seconds: l2, milliseconds: d2, microseconds: m2, nanoseconds: c2 } = RoundDuration(r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, y2, S2, I2, f2), { years: r2, months: o2, weeks: n2, days: a2, hours: i2, minutes: s2, seconds: l2, milliseconds: d2, microseconds: m2, nanoseconds: c2 } = AdjustRoundedDurationDays(r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, y2, S2, I2, f2), { days: a2, hours: i2, minutes: s2, seconds: l2, milliseconds: d2, microseconds: m2, nanoseconds: c2 } = BalanceDuration(a2, i2, s2, l2, d2, m2, c2, T2, f2), { years: r2, months: o2, weeks: n2, days: a2 } = function BalanceDurationRelative(t3, r3, o3, n3, a3, i3) {
      const s3 = GetIntrinsic("%Temporal.Duration%"), l3 = DurationSign(t3, r3, o3, n3, 0, 0, 0, 0, 0, 0);
      if (0 === l3)
        return { years: t3, months: r3, weeks: o3, days: n3 };
      const d3 = e.BigInt(l3);
      let m3, c3, h3 = e.BigInt(t3), u3 = e.BigInt(r3), T3 = e.BigInt(o3), f3 = e.BigInt(n3);
      i3 && (c3 = ToTemporalDate(i3), m3 = GetSlot(c3, p));
      const y3 = new s3(l3), I3 = new s3(0, l3), S3 = new s3(0, 0, l3);
      switch (a3) {
        case "year": {
          if (!m3)
            throw new RangeError("a starting point is required for years balancing");
          const t4 = "string" != typeof m3 ? GetMethod(m3, "dateAdd") : void 0;
          let r4, o4, n4;
          for ({ relativeTo: r4, days: o4 } = MoveRelativeDate(m3, c3, y3, t4); e.greaterThanOrEqual(abs(f3), e.BigInt(ae(o4))); )
            f3 = e.subtract(f3, e.BigInt(o4)), h3 = e.add(h3, d3), c3 = r4, { relativeTo: r4, days: o4 } = MoveRelativeDate(m3, c3, y3, t4);
          for ({ relativeTo: r4, days: n4 } = MoveRelativeDate(m3, c3, I3, t4); e.greaterThanOrEqual(abs(f3), e.BigInt(ae(n4))); )
            f3 = e.subtract(f3, e.BigInt(n4)), u3 = e.add(u3, d3), c3 = r4, { relativeTo: r4, days: n4 } = MoveRelativeDate(m3, c3, I3, t4);
          r4 = CalendarDateAdd(m3, c3, y3, void 0, t4);
          const a4 = "string" != typeof m3 ? GetMethod(m3, "dateUntil") : void 0, i4 = Te(null);
          i4.largestUnit = "month";
          let s4 = CalendarDateUntil(m3, c3, r4, i4, a4), l4 = GetSlot(s4, D);
          for (; e.greaterThanOrEqual(abs(u3), e.BigInt(ae(l4))); ) {
            u3 = e.subtract(u3, e.BigInt(l4)), h3 = e.add(h3, d3), c3 = r4, r4 = CalendarDateAdd(m3, c3, y3, void 0, t4);
            const o5 = Te(null);
            o5.largestUnit = "month", s4 = CalendarDateUntil(m3, c3, r4, o5, a4), l4 = GetSlot(s4, D);
          }
          break;
        }
        case "month": {
          if (!m3)
            throw new RangeError("a starting point is required for months balancing");
          const t4 = "string" != typeof m3 ? GetMethod(m3, "dateAdd") : void 0;
          let r4, o4;
          for ({ relativeTo: r4, days: o4 } = MoveRelativeDate(m3, c3, I3, t4); e.greaterThanOrEqual(abs(f3), e.BigInt(ae(o4))); )
            f3 = e.subtract(f3, e.BigInt(o4)), u3 = e.add(u3, d3), c3 = r4, { relativeTo: r4, days: o4 } = MoveRelativeDate(m3, c3, I3, t4);
          break;
        }
        case "week": {
          if (!m3)
            throw new RangeError("a starting point is required for weeks balancing");
          const t4 = "string" != typeof m3 ? GetMethod(m3, "dateAdd") : void 0;
          let r4, o4;
          for ({ relativeTo: r4, days: o4 } = MoveRelativeDate(m3, c3, S3, t4); e.greaterThanOrEqual(abs(f3), e.BigInt(ae(o4))); )
            f3 = e.subtract(f3, e.BigInt(o4)), T3 = e.add(T3, d3), c3 = r4, { relativeTo: r4, days: o4 } = MoveRelativeDate(m3, c3, S3, t4);
          break;
        }
      }
      return { years: e.toNumber(h3), months: e.toNumber(u3), weeks: e.toNumber(T3), days: e.toNumber(f3) };
    }(r2, o2, n2, a2, T2, f2), new _Duration(r2, o2, n2, a2, i2, s2, l2, d2, m2, c2);
  }
  total(e2) {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    let t2 = GetSlot(this, w), r2 = GetSlot(this, D), o2 = GetSlot(this, G), n2 = GetSlot(this, v), a2 = GetSlot(this, C), i2 = GetSlot(this, O), s2 = GetSlot(this, b), l2 = GetSlot(this, E), d2 = GetSlot(this, M), m2 = GetSlot(this, R);
    if (void 0 === e2)
      throw new TypeError("options argument is required");
    const c2 = "string" == typeof e2 ? CreateOnePropObject("unit", e2) : GetOptionsObject(e2), h2 = ToRelativeTemporalObject(c2), u2 = GetTemporalUnit(c2, "unit", "datetime", He);
    let T2;
    ({ years: t2, months: r2, weeks: o2, days: n2 } = UnbalanceDurationRelative(t2, r2, o2, n2, u2, h2)), IsTemporalZonedDateTime(h2) && (T2 = MoveRelativeZonedDateTime(h2, t2, r2, o2, 0));
    let p2 = BalancePossiblyInfiniteDuration(n2, a2, i2, s2, l2, d2, m2, u2, T2);
    if ("positive overflow" === p2)
      return 1 / 0;
    if ("negative overflow" === p2)
      return -1 / 0;
    ({ days: n2, hours: a2, minutes: i2, seconds: s2, milliseconds: l2, microseconds: d2, nanoseconds: m2 } = p2);
    const { total: f2 } = RoundDuration(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, 1, u2, "trunc", h2);
    return f2;
  }
  toString(e2) {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e2), r2 = ToFractionalSecondDigits(t2), o2 = ToTemporalRoundingMode(t2, "trunc"), n2 = GetTemporalUnit(t2, "smallestUnit", "time", void 0);
    if ("hour" === n2 || "minute" === n2)
      throw new RangeError('smallestUnit must be a time unit other than "hours" or "minutes"');
    const { precision: a2, unit: i2, increment: s2 } = ToSecondsStringPrecisionRecord(n2, r2);
    return TemporalDurationToString(this, a2, { unit: i2, increment: s2, roundingMode: o2 });
  }
  toJSON() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return TemporalDurationToString(this);
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return "undefined" != typeof Intl && void 0 !== Intl.DurationFormat ? new Intl.DurationFormat(e2, t2).format(this) : (console.warn("Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat."), TemporalDurationToString(this));
  }
  valueOf() {
    throw new TypeError("use compare() to compare Temporal.Duration");
  }
  static from(e2) {
    return IsTemporalDuration(e2) ? new _Duration(GetSlot(e2, w), GetSlot(e2, D), GetSlot(e2, G), GetSlot(e2, v), GetSlot(e2, C), GetSlot(e2, O), GetSlot(e2, b), GetSlot(e2, E), GetSlot(e2, M), GetSlot(e2, R)) : ToTemporalDuration(e2);
  }
  static compare(t2, r2, o2) {
    const n2 = ToTemporalDuration(t2), a2 = ToTemporalDuration(r2), i2 = ToRelativeTemporalObject(GetOptionsObject(o2)), s2 = GetSlot(n2, w), l2 = GetSlot(n2, D), d2 = GetSlot(n2, G);
    let m2 = GetSlot(n2, v);
    const c2 = GetSlot(n2, C), h2 = GetSlot(n2, O), u2 = GetSlot(n2, b), T2 = GetSlot(n2, E), p2 = GetSlot(n2, M);
    let f2 = GetSlot(n2, R);
    const y2 = GetSlot(a2, w), I2 = GetSlot(a2, D), S2 = GetSlot(a2, G);
    let g2 = GetSlot(a2, v);
    const F2 = GetSlot(a2, C), Y2 = GetSlot(a2, O), P2 = GetSlot(a2, b), Z2 = GetSlot(a2, E), B2 = GetSlot(a2, M);
    let N2 = GetSlot(a2, R);
    const j2 = CalculateOffsetShift(i2, s2, l2, d2, m2), $2 = CalculateOffsetShift(i2, y2, I2, S2, g2);
    0 === s2 && 0 === y2 && 0 === l2 && 0 === I2 && 0 === d2 && 0 === S2 || ({ days: m2 } = UnbalanceDurationRelative(s2, l2, d2, m2, "day", i2), { days: g2 } = UnbalanceDurationRelative(y2, I2, S2, g2, "day", i2));
    const k2 = TotalDurationNanoseconds(m2, c2, h2, u2, T2, p2, f2, j2), U2 = TotalDurationNanoseconds(g2, F2, Y2, P2, Z2, B2, N2, $2);
    return ComparisonResult(e.toNumber(e.subtract(k2, U2)));
  }
};
MakeIntrinsicClass(Duration, "Temporal.Duration");
var bt = Object.create;
var PlainMonthDay = class {
  constructor(e2, t2, r2 = "iso8601", o2 = 1972) {
    CreateTemporalMonthDaySlots(this, ToIntegerWithTruncation(e2), ToIntegerWithTruncation(t2), ToTemporalCalendarSlotValue(r2), ToIntegerWithTruncation(o2));
  }
  get monthCode() {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, p), this);
  }
  get day() {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    return CalendarDay(GetSlot(this, p), this);
  }
  get calendarId() {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    return ToTemporalCalendarIdentifier(GetSlot(this, p));
  }
  with(e2, t2) {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid argument");
    RejectTemporalLikeObject(e2);
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, p), n2 = CalendarFields(o2, ["day", "month", "monthCode", "year"]);
    let a2 = PrepareTemporalFields(this, n2, []);
    return a2 = CalendarMergeFields(o2, a2, PrepareTemporalFields(e2, n2, "partial")), a2 = PrepareTemporalFields(a2, n2, []), CalendarMonthDayFromFields(o2, a2, r2);
  }
  equals(e2) {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalMonthDay(e2);
    for (const e3 of [s, l, i]) {
      if (GetSlot(this, e3) !== GetSlot(t2, e3))
        return false;
    }
    return CalendarEquals(GetSlot(this, p), GetSlot(t2, p));
  }
  toString(e2) {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    return TemporalMonthDayToString(this, ToCalendarNameOption(GetOptionsObject(e2)));
  }
  toJSON() {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    return TemporalMonthDayToString(this);
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    return new ht(e2, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use equals() to compare Temporal.PlainMonthDay");
  }
  toPlainDate(e2) {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("argument should be an object");
    const t2 = GetSlot(this, p), r2 = CalendarFields(t2, ["day", "monthCode"]), o2 = PrepareTemporalFields(this, r2, []), n2 = CalendarFields(t2, ["year"]);
    let a2 = CalendarMergeFields(t2, o2, PrepareTemporalFields(e2, n2, []));
    a2 = PrepareTemporalFields(a2, [.../* @__PURE__ */ new Set([...r2, ...n2])], []);
    const i2 = bt(null);
    return i2.overflow = "reject", CalendarDateFromFields(t2, a2, i2);
  }
  getISOFields() {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    return { calendar: GetSlot(this, p), isoDay: GetSlot(this, l), isoMonth: GetSlot(this, s), isoYear: GetSlot(this, i) };
  }
  getCalendar() {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    return ToTemporalCalendarObject(GetSlot(this, p));
  }
  static from(e2, t2) {
    const r2 = GetOptionsObject(t2);
    return IsTemporalMonthDay(e2) ? (ToTemporalOverflow(r2), CreateTemporalMonthDay(GetSlot(e2, s), GetSlot(e2, l), GetSlot(e2, p), GetSlot(e2, i))) : ToTemporalMonthDay(e2, r2);
  }
};
MakeIntrinsicClass(PlainMonthDay, "Temporal.PlainMonthDay");
var instant = () => new (GetIntrinsic("%Temporal.Instant%"))(Ve());
var plainDateTime = (e2, t2 = DefaultTimeZone()) => {
  const r2 = ToTemporalTimeZoneSlotValue(t2), o2 = ToTemporalCalendarSlotValue(e2);
  return GetPlainDateTimeFor(r2, instant(), o2);
};
var plainDateTimeISO = (e2 = DefaultTimeZone()) => GetPlainDateTimeFor(ToTemporalTimeZoneSlotValue(e2), instant(), "iso8601");
var zonedDateTime = (e2, t2 = DefaultTimeZone()) => {
  const r2 = ToTemporalTimeZoneSlotValue(t2), o2 = ToTemporalCalendarSlotValue(e2);
  return CreateTemporalZonedDateTime(Ve(), r2, o2);
};
var Et = { instant, plainDateTime, plainDateTimeISO, plainDate: (e2, t2 = DefaultTimeZone()) => TemporalDateTimeToDate(plainDateTime(e2, t2)), plainDateISO: (e2 = DefaultTimeZone()) => TemporalDateTimeToDate(plainDateTimeISO(e2)), plainTimeISO: (e2 = DefaultTimeZone()) => TemporalDateTimeToTime(plainDateTimeISO(e2)), timeZoneId: () => DefaultTimeZone(), zonedDateTime, zonedDateTimeISO: (e2 = DefaultTimeZone()) => zonedDateTime("iso8601", e2), [Symbol.toStringTag]: "Temporal.Now" };
Object.defineProperty(Et, Symbol.toStringTag, { value: "Temporal.Now", writable: false, enumerable: false, configurable: true });
var Mt = Object.assign;
function TemporalTimeToString(e2, t2, r2) {
  let o2 = GetSlot(e2, d), n2 = GetSlot(e2, m), a2 = GetSlot(e2, c), i2 = GetSlot(e2, h), s2 = GetSlot(e2, u), l2 = GetSlot(e2, T);
  if (r2) {
    const { unit: e3, increment: t3, roundingMode: d2 } = r2;
    ({ hour: o2, minute: n2, second: a2, millisecond: i2, microsecond: s2, nanosecond: l2 } = RoundTime(o2, n2, a2, i2, s2, l2, t3, e3, d2));
  }
  return `${ISODateTimePartString(o2)}:${ISODateTimePartString(n2)}${FormatSecondsStringPart(a2, i2, s2, l2, t2)}`;
}
var PlainTime = class _PlainTime {
  constructor(e2 = 0, t2 = 0, r2 = 0, o2 = 0, n2 = 0, a2 = 0) {
    const i2 = void 0 === e2 ? 0 : ToIntegerWithTruncation(e2), s2 = void 0 === t2 ? 0 : ToIntegerWithTruncation(t2), l2 = void 0 === r2 ? 0 : ToIntegerWithTruncation(r2), p2 = void 0 === o2 ? 0 : ToIntegerWithTruncation(o2), f2 = void 0 === n2 ? 0 : ToIntegerWithTruncation(n2), y2 = void 0 === a2 ? 0 : ToIntegerWithTruncation(a2);
    RejectTime(i2, s2, l2, p2, f2, y2), N(this), SetSlot(this, d, i2), SetSlot(this, m, s2), SetSlot(this, c, l2), SetSlot(this, h, p2), SetSlot(this, u, f2), SetSlot(this, T, y2);
  }
  get hour() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, d);
  }
  get minute() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, m);
  }
  get second() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, c);
  }
  get millisecond() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, h);
  }
  get microsecond() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, u);
  }
  get nanosecond() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, T);
  }
  with(e2, t2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid argument");
    RejectTemporalLikeObject(e2);
    const r2 = ToTemporalOverflow(GetOptionsObject(t2)), o2 = ToTemporalTimeRecord(e2, "partial"), n2 = ToTemporalTimeRecord(this);
    let { hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2 } = Mt(n2, o2);
    return { hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2 } = RegulateTime(a2, i2, s2, l2, d2, m2, r2), new _PlainTime(a2, i2, s2, l2, d2, m2);
  }
  add(e2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainTime("add", this, e2);
  }
  subtract(e2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainTime("subtract", this, e2);
  }
  until(e2, t2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainTime("until", this, e2, t2);
  }
  since(e2, t2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainTime("since", this, e2, t2);
  }
  round(e2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    if (void 0 === e2)
      throw new TypeError("options parameter is required");
    const t2 = "string" == typeof e2 ? CreateOnePropObject("smallestUnit", e2) : GetOptionsObject(e2), r2 = ToTemporalRoundingIncrement(t2), o2 = ToTemporalRoundingMode(t2, "halfExpand"), n2 = GetTemporalUnit(t2, "smallestUnit", "time", He);
    ValidateTemporalRoundingIncrement(r2, { hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[n2], false);
    let a2 = GetSlot(this, d), i2 = GetSlot(this, m), s2 = GetSlot(this, c), l2 = GetSlot(this, h), p2 = GetSlot(this, u), f2 = GetSlot(this, T);
    return { hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: p2, nanosecond: f2 } = RoundTime(a2, i2, s2, l2, p2, f2, r2, n2, o2), new _PlainTime(a2, i2, s2, l2, p2, f2);
  }
  equals(e2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalTime(e2);
    for (const e3 of [d, m, c, h, u, T]) {
      if (GetSlot(this, e3) !== GetSlot(t2, e3))
        return false;
    }
    return true;
  }
  toString(e2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e2), r2 = ToFractionalSecondDigits(t2), o2 = ToTemporalRoundingMode(t2, "trunc"), n2 = GetTemporalUnit(t2, "smallestUnit", "time", void 0);
    if ("hour" === n2)
      throw new RangeError('smallestUnit must be a time unit other than "hour"');
    const { precision: a2, unit: i2, increment: s2 } = ToSecondsStringPrecisionRecord(n2, r2);
    return TemporalTimeToString(this, a2, { unit: i2, increment: s2, roundingMode: o2 });
  }
  toJSON() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return TemporalTimeToString(this, "auto");
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return new ht(e2, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.PlainTime");
  }
  toPlainDateTime(e2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2), r2 = GetSlot(t2, i), o2 = GetSlot(t2, s), n2 = GetSlot(t2, l), a2 = GetSlot(t2, p);
    return CreateTemporalDateTime(r2, o2, n2, GetSlot(this, d), GetSlot(this, m), GetSlot(this, c), GetSlot(this, h), GetSlot(this, u), GetSlot(this, T), a2);
  }
  toZonedDateTime(e2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid argument");
    const t2 = e2.plainDate;
    if (void 0 === t2)
      throw new TypeError("missing date property");
    const r2 = ToTemporalDate(t2), o2 = e2.timeZone;
    if (void 0 === o2)
      throw new TypeError("missing timeZone property");
    const a2 = ToTemporalTimeZoneSlotValue(o2), f2 = GetSlot(r2, i), y2 = GetSlot(r2, s), I2 = GetSlot(r2, l), S2 = GetSlot(r2, p), g2 = GetSlot(this, d), w2 = GetSlot(this, m), D2 = GetSlot(this, c), G2 = GetSlot(this, h), v2 = GetSlot(this, u), C2 = GetSlot(this, T);
    return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(a2, new (GetIntrinsic("%Temporal.PlainDateTime%"))(f2, y2, I2, g2, w2, D2, G2, v2, C2, S2), "compatible"), n), a2, S2);
  }
  getISOFields() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return { isoHour: GetSlot(this, d), isoMicrosecond: GetSlot(this, u), isoMillisecond: GetSlot(this, h), isoMinute: GetSlot(this, m), isoNanosecond: GetSlot(this, T), isoSecond: GetSlot(this, c) };
  }
  static from(e2, t2) {
    const r2 = ToTemporalOverflow(GetOptionsObject(t2));
    return IsTemporalTime(e2) ? new _PlainTime(GetSlot(e2, d), GetSlot(e2, m), GetSlot(e2, c), GetSlot(e2, h), GetSlot(e2, u), GetSlot(e2, T)) : ToTemporalTime(e2, r2);
  }
  static compare(e2, t2) {
    const r2 = ToTemporalTime(e2), o2 = ToTemporalTime(t2);
    for (const e3 of [d, m, c, h, u, T]) {
      const t3 = GetSlot(r2, e3), n2 = GetSlot(o2, e3);
      if (t3 !== n2)
        return ComparisonResult(t3 - n2);
    }
    return 0;
  }
};
MakeIntrinsicClass(PlainTime, "Temporal.PlainTime");
var TimeZone = class {
  constructor(e2) {
    if (arguments.length < 1)
      throw new RangeError("missing argument: identifier is required");
    const t2 = GetCanonicalTimeZoneIdentifier(e2);
    N(this), SetSlot(this, a, t2);
  }
  get id() {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, a);
  }
  getOffsetNanosecondsFor(e2) {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalInstant(e2), r2 = GetSlot(this, a);
    return IsTimeZoneOffsetString(r2) ? ParseTimeZoneOffsetString(r2) : GetNamedTimeZoneOffsetNanoseconds(r2, GetSlot(t2, n));
  }
  getOffsetStringFor(e2) {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    return GetOffsetStringFor(this, ToTemporalInstant(e2));
  }
  getPlainDateTimeFor(e2, t2 = "iso8601") {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    return GetPlainDateTimeFor(this, ToTemporalInstant(e2), ToTemporalCalendarSlotValue(t2));
  }
  getInstantFor(e2, t2) {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    return GetInstantFor(this, ToTemporalDateTime(e2), ToTemporalDisambiguation(GetOptionsObject(t2)));
  }
  getPossibleInstantsFor(t2) {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    const r2 = ToTemporalDateTime(t2), o2 = GetIntrinsic("%Temporal.Instant%"), n2 = GetSlot(this, a);
    if (IsTimeZoneOffsetString(n2)) {
      const t3 = GetUTCEpochNanoseconds(GetSlot(r2, i), GetSlot(r2, s), GetSlot(r2, l), GetSlot(r2, d), GetSlot(r2, m), GetSlot(r2, c), GetSlot(r2, h), GetSlot(r2, u), GetSlot(r2, T));
      if (null === t3)
        throw new RangeError("DateTime outside of supported range");
      const a2 = ParseTimeZoneOffsetString(n2);
      return [new o2(e.subtract(t3, e.BigInt(a2)))];
    }
    const p2 = function GetNamedTimeZoneEpochNanoseconds(t3, r3, o3, n3, a2, i2, s2, l2, d2, m2) {
      const c2 = GetUTCEpochNanoseconds(r3, o3, n3, a2, i2, s2, l2, d2, m2);
      if (null === c2)
        throw new RangeError("DateTime outside of supported range");
      let h2 = e.subtract(c2, Ee);
      e.lessThan(h2, Me) && (h2 = c2);
      let u2 = e.add(c2, Ee);
      e.greaterThan(u2, Re) && (u2 = c2);
      const T2 = GetNamedTimeZoneOffsetNanoseconds(t3, h2), p3 = GetNamedTimeZoneOffsetNanoseconds(t3, u2);
      return (T2 === p3 ? [T2] : [T2, p3]).map((h3) => {
        const u3 = e.subtract(c2, e.BigInt(h3)), T3 = GetNamedTimeZoneDateTimeParts(t3, u3);
        if (r3 === T3.year && o3 === T3.month && n3 === T3.day && a2 === T3.hour && i2 === T3.minute && s2 === T3.second && l2 === T3.millisecond && d2 === T3.microsecond && m2 === T3.nanosecond)
          return u3;
      }).filter((e2) => void 0 !== e2);
    }(n2, GetSlot(r2, i), GetSlot(r2, s), GetSlot(r2, l), GetSlot(r2, d), GetSlot(r2, m), GetSlot(r2, c), GetSlot(r2, h), GetSlot(r2, u), GetSlot(r2, T));
    return p2.map((e2) => new o2(e2));
  }
  getNextTransition(e2) {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalInstant(e2), r2 = GetSlot(this, a);
    if (IsTimeZoneOffsetString(r2) || "UTC" === r2)
      return null;
    let o2 = GetSlot(t2, n);
    const i2 = GetIntrinsic("%Temporal.Instant%");
    return o2 = GetNamedTimeZoneNextTransition(r2, o2), null === o2 ? null : new i2(o2);
  }
  getPreviousTransition(e2) {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalInstant(e2), r2 = GetSlot(this, a);
    if (IsTimeZoneOffsetString(r2) || "UTC" === r2)
      return null;
    let o2 = GetSlot(t2, n);
    const i2 = GetIntrinsic("%Temporal.Instant%");
    return o2 = GetNamedTimeZonePreviousTransition(r2, o2), null === o2 ? null : new i2(o2);
  }
  toString() {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, a);
  }
  toJSON() {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, a);
  }
  static from(e2) {
    return ToTemporalTimeZoneObject(ToTemporalTimeZoneSlotValue(e2));
  }
};
MakeIntrinsicClass(TimeZone, "Temporal.TimeZone"), DefineIntrinsic("Temporal.TimeZone.prototype.getOffsetNanosecondsFor", TimeZone.prototype.getOffsetNanosecondsFor), DefineIntrinsic("Temporal.TimeZone.prototype.getPossibleInstantsFor", TimeZone.prototype.getPossibleInstantsFor);
var Rt = Object.create;
var PlainYearMonth = class {
  constructor(e2, t2, r2 = "iso8601", o2 = 1) {
    CreateTemporalYearMonthSlots(this, ToIntegerWithTruncation(e2), ToIntegerWithTruncation(t2), ToTemporalCalendarSlotValue(r2), ToIntegerWithTruncation(o2));
  }
  get year() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarYear(GetSlot(this, p), this);
  }
  get month() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarMonth(GetSlot(this, p), this);
  }
  get monthCode() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, p), this);
  }
  get calendarId() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return ToTemporalCalendarIdentifier(GetSlot(this, p));
  }
  get era() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarEra(GetSlot(this, p), this);
  }
  get eraYear() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarEraYear(GetSlot(this, p), this);
  }
  get daysInMonth() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInMonth(GetSlot(this, p), this);
  }
  get daysInYear() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInYear(GetSlot(this, p), this);
  }
  get monthsInYear() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthsInYear(GetSlot(this, p), this);
  }
  get inLeapYear() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarInLeapYear(GetSlot(this, p), this);
  }
  with(e2, t2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid argument");
    RejectTemporalLikeObject(e2);
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, p), n2 = CalendarFields(o2, ["month", "monthCode", "year"]);
    let a2 = PrepareTemporalFields(this, n2, []);
    return a2 = CalendarMergeFields(o2, a2, PrepareTemporalFields(e2, n2, "partial")), a2 = PrepareTemporalFields(a2, n2, []), CalendarYearMonthFromFields(o2, a2, r2);
  }
  add(e2, t2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainYearMonth("add", this, e2, t2);
  }
  subtract(e2, t2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainYearMonth("subtract", this, e2, t2);
  }
  until(e2, t2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainYearMonth("until", this, e2, t2);
  }
  since(e2, t2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainYearMonth("since", this, e2, t2);
  }
  equals(e2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalYearMonth(e2);
    for (const e3 of [i, s, l]) {
      if (GetSlot(this, e3) !== GetSlot(t2, e3))
        return false;
    }
    return CalendarEquals(GetSlot(this, p), GetSlot(t2, p));
  }
  toString(e2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return TemporalYearMonthToString(this, ToCalendarNameOption(GetOptionsObject(e2)));
  }
  toJSON() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return TemporalYearMonthToString(this);
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return new ht(e2, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.PlainYearMonth");
  }
  toPlainDate(e2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("argument should be an object");
    const t2 = GetSlot(this, p), r2 = CalendarFields(t2, ["monthCode", "year"]), o2 = PrepareTemporalFields(this, r2, []), n2 = CalendarFields(t2, ["day"]);
    let a2 = CalendarMergeFields(t2, o2, PrepareTemporalFields(e2, n2, []));
    a2 = PrepareTemporalFields(a2, [.../* @__PURE__ */ new Set([...r2, ...n2])], []);
    const i2 = Rt(null);
    return i2.overflow = "reject", CalendarDateFromFields(t2, a2, i2);
  }
  getISOFields() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return { calendar: GetSlot(this, p), isoDay: GetSlot(this, l), isoMonth: GetSlot(this, s), isoYear: GetSlot(this, i) };
  }
  getCalendar() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return ToTemporalCalendarObject(GetSlot(this, p));
  }
  static from(e2, t2) {
    const r2 = GetOptionsObject(t2);
    return IsTemporalYearMonth(e2) ? (ToTemporalOverflow(r2), CreateTemporalYearMonth(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, p), GetSlot(e2, l))) : ToTemporalYearMonth(e2, r2);
  }
  static compare(e2, t2) {
    const r2 = ToTemporalYearMonth(e2), o2 = ToTemporalYearMonth(t2);
    return CompareISODate(GetSlot(r2, i), GetSlot(r2, s), GetSlot(r2, l), GetSlot(o2, i), GetSlot(o2, s), GetSlot(o2, l));
  }
};
MakeIntrinsicClass(PlainYearMonth, "Temporal.PlainYearMonth");
var Ft = ht.prototype.resolvedOptions;
var Yt = Object.create;
var ZonedDateTime = class {
  constructor(e2, t2, r2 = "iso8601") {
    if (arguments.length < 1)
      throw new TypeError("missing argument: epochNanoseconds is required");
    CreateTemporalZonedDateTimeSlots(this, ToBigInt(e2), ToTemporalTimeZoneSlotValue(t2), ToTemporalCalendarSlotValue(r2));
  }
  get calendarId() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return ToTemporalCalendarIdentifier(GetSlot(this, p));
  }
  get timeZoneId() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return ToTemporalTimeZoneIdentifier(GetSlot(this, g));
  }
  get year() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarYear(GetSlot(this, p), dateTime(this));
  }
  get month() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarMonth(GetSlot(this, p), dateTime(this));
  }
  get monthCode() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, p), dateTime(this));
  }
  get day() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDay(GetSlot(this, p), dateTime(this));
  }
  get hour() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), d);
  }
  get minute() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), m);
  }
  get second() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), c);
  }
  get millisecond() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), h);
  }
  get microsecond() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), u);
  }
  get nanosecond() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), T);
  }
  get era() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarEra(GetSlot(this, p), dateTime(this));
  }
  get eraYear() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarEraYear(GetSlot(this, p), dateTime(this));
  }
  get epochSeconds() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, n);
    return e.toNumber(BigIntFloorDiv(t2, ve));
  }
  get epochMilliseconds() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, n);
    return e.toNumber(BigIntFloorDiv(t2, Ge));
  }
  get epochMicroseconds() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return ToBigIntExternal(BigIntFloorDiv(GetSlot(this, n), De));
  }
  get epochNanoseconds() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return ToBigIntExternal(GetSlot(this, n));
  }
  get dayOfWeek() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDayOfWeek(GetSlot(this, p), dateTime(this));
  }
  get dayOfYear() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDayOfYear(GetSlot(this, p), dateTime(this));
  }
  get weekOfYear() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarWeekOfYear(GetSlot(this, p), dateTime(this));
  }
  get yearOfWeek() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarYearOfWeek(GetSlot(this, p), dateTime(this));
  }
  get hoursInDay() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = dateTime(this), r2 = GetIntrinsic("%Temporal.PlainDateTime%"), o2 = GetSlot(t2, i), a2 = GetSlot(t2, s), d2 = GetSlot(t2, l), m2 = new r2(o2, a2, d2, 0, 0, 0, 0, 0, 0), c2 = AddISODate(o2, a2, d2, 0, 0, 0, 1, "reject"), h2 = new r2(c2.year, c2.month, c2.day, 0, 0, 0, 0, 0, 0), u2 = GetSlot(this, g), T2 = GetSlot(GetInstantFor(u2, m2, "compatible"), n), p2 = GetSlot(GetInstantFor(u2, h2, "compatible"), n);
    return BigIntDivideToNumber(e.subtract(p2, T2), Oe);
  }
  get daysInWeek() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInWeek(GetSlot(this, p), dateTime(this));
  }
  get daysInMonth() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInMonth(GetSlot(this, p), dateTime(this));
  }
  get daysInYear() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInYear(GetSlot(this, p), dateTime(this));
  }
  get monthsInYear() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthsInYear(GetSlot(this, p), dateTime(this));
  }
  get inLeapYear() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarInLeapYear(GetSlot(this, p), dateTime(this));
  }
  get offset() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetOffsetStringFor(GetSlot(this, g), GetSlot(this, S));
  }
  get offsetNanoseconds() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetOffsetNanosecondsFor(GetSlot(this, g), GetSlot(this, S));
  }
  with(e2, t2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid zoned-date-time-like");
    RejectTemporalLikeObject(e2);
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, p);
    let n2 = CalendarFields(o2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]);
    n2.push("offset");
    let a2 = PrepareTemporalFields(this, n2, ["offset"]);
    a2 = CalendarMergeFields(o2, a2, PrepareTemporalFields(e2, n2, "partial")), a2 = PrepareTemporalFields(a2, n2, ["offset"]);
    const i2 = ToTemporalDisambiguation(r2), s2 = ToTemporalOffset(r2, "prefer");
    let { year: l2, month: d2, day: m2, hour: c2, minute: h2, second: u2, millisecond: T2, microsecond: f2, nanosecond: y2 } = InterpretTemporalDateTimeFields(o2, a2, r2);
    const I2 = ParseTimeZoneOffsetString(a2.offset), S2 = GetSlot(this, g);
    return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(l2, d2, m2, c2, h2, u2, T2, f2, y2, "option", I2, S2, i2, s2, false), S2, o2);
  }
  withPlainDate(e2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2), r2 = GetSlot(t2, i), o2 = GetSlot(t2, s), a2 = GetSlot(t2, l);
    let f2 = GetSlot(t2, p);
    const y2 = dateTime(this), I2 = GetSlot(y2, d), S2 = GetSlot(y2, m), w2 = GetSlot(y2, c), D2 = GetSlot(y2, h), G2 = GetSlot(y2, u), v2 = GetSlot(y2, T);
    f2 = ConsolidateCalendars(GetSlot(this, p), f2);
    const C2 = GetSlot(this, g);
    return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(C2, new (GetIntrinsic("%Temporal.PlainDateTime%"))(r2, o2, a2, I2, S2, w2, D2, G2, v2, f2), "compatible"), n), C2, f2);
  }
  withPlainTime(e2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = GetIntrinsic("%Temporal.PlainTime%"), r2 = void 0 === e2 ? new t2() : ToTemporalTime(e2), o2 = dateTime(this), a2 = GetSlot(o2, i), f2 = GetSlot(o2, s), y2 = GetSlot(o2, l), I2 = GetSlot(this, p), S2 = GetSlot(r2, d), w2 = GetSlot(r2, m), D2 = GetSlot(r2, c), G2 = GetSlot(r2, h), v2 = GetSlot(r2, u), C2 = GetSlot(r2, T), O2 = GetSlot(this, g);
    return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(O2, new (GetIntrinsic("%Temporal.PlainDateTime%"))(a2, f2, y2, S2, w2, D2, G2, v2, C2, I2), "compatible"), n), O2, I2);
  }
  withTimeZone(e2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalTimeZoneSlotValue(e2);
    return CreateTemporalZonedDateTime(GetSlot(this, n), t2, GetSlot(this, p));
  }
  withCalendar(e2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalCalendarSlotValue(e2);
    return CreateTemporalZonedDateTime(GetSlot(this, n), GetSlot(this, g), t2);
  }
  add(e2, t2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromZonedDateTime("add", this, e2, t2);
  }
  subtract(e2, t2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromZonedDateTime("subtract", this, e2, t2);
  }
  until(e2, t2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalZonedDateTime("until", this, e2, t2);
  }
  since(e2, t2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalZonedDateTime("since", this, e2, t2);
  }
  round(t2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    if (void 0 === t2)
      throw new TypeError("options parameter is required");
    const r2 = "string" == typeof t2 ? CreateOnePropObject("smallestUnit", t2) : GetOptionsObject(t2), o2 = ToTemporalRoundingIncrement(r2), a2 = ToTemporalRoundingMode(r2, "halfExpand"), f2 = GetTemporalUnit(r2, "smallestUnit", "time", He, ["day"]), y2 = { day: 1, hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[f2];
    ValidateTemporalRoundingIncrement(o2, y2, 1 === y2);
    const I2 = dateTime(this);
    let w2 = GetSlot(I2, i), D2 = GetSlot(I2, s), G2 = GetSlot(I2, l), v2 = GetSlot(I2, d), C2 = GetSlot(I2, m), O2 = GetSlot(I2, c), b2 = GetSlot(I2, h), E2 = GetSlot(I2, u), M2 = GetSlot(I2, T);
    const R2 = GetIntrinsic("%Temporal.PlainDateTime%"), F2 = GetSlot(this, g), Y2 = GetSlot(this, p), P2 = GetInstantFor(F2, new R2(GetSlot(I2, i), GetSlot(I2, s), GetSlot(I2, l), 0, 0, 0, 0, 0, 0), "compatible"), Z2 = AddZonedDateTime(P2, F2, Y2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0), B2 = e.subtract(Z2, e.BigInt(GetSlot(P2, n)));
    if (e.lessThanOrEqual(B2, Ie))
      throw new RangeError("cannot round a ZonedDateTime in a calendar with zero or negative length days");
    ({ year: w2, month: D2, day: G2, hour: v2, minute: C2, second: O2, millisecond: b2, microsecond: E2, nanosecond: M2 } = RoundISODateTime(w2, D2, G2, v2, C2, O2, b2, E2, M2, o2, f2, a2, e.toNumber(B2)));
    return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(w2, D2, G2, v2, C2, O2, b2, E2, M2, "option", GetOffsetNanosecondsFor(F2, GetSlot(this, S)), F2, "compatible", "prefer", false), F2, GetSlot(this, p));
  }
  equals(t2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const r2 = ToTemporalZonedDateTime(t2), o2 = GetSlot(this, n), a2 = GetSlot(r2, n);
    return !!e.equal(e.BigInt(o2), e.BigInt(a2)) && (!!TimeZoneEquals(GetSlot(this, g), GetSlot(r2, g)) && CalendarEquals(GetSlot(this, p), GetSlot(r2, p)));
  }
  toString(e2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e2), r2 = ToCalendarNameOption(t2), o2 = ToFractionalSecondDigits(t2), n2 = function ToShowOffsetOption(e3) {
      return GetOption(e3, "offset", ["auto", "never"], "auto");
    }(t2), a2 = ToTemporalRoundingMode(t2, "trunc"), i2 = GetTemporalUnit(t2, "smallestUnit", "time", void 0);
    if ("hour" === i2)
      throw new RangeError('smallestUnit must be a time unit other than "hour"');
    const s2 = function ToTimeZoneNameOption(e3) {
      return GetOption(e3, "timeZoneName", ["auto", "never", "critical"], "auto");
    }(t2), { precision: l2, unit: d2, increment: m2 } = ToSecondsStringPrecisionRecord(i2, o2);
    return TemporalZonedDateTimeToString(this, l2, r2, s2, n2, { unit: d2, increment: m2, roundingMode: a2 });
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const r2 = GetOptionsObject(t2), o2 = Yt(null);
    if (CopyDataProperties(o2, r2, ["timeZone"]), void 0 !== r2.timeZone)
      throw new TypeError("ZonedDateTime toLocaleString does not accept a timeZone option");
    void 0 === o2.year && void 0 === o2.month && void 0 === o2.day && void 0 === o2.weekday && void 0 === o2.dateStyle && void 0 === o2.hour && void 0 === o2.minute && void 0 === o2.second && void 0 === o2.timeStyle && void 0 === o2.dayPeriod && void 0 === o2.timeZoneName && (o2.timeZoneName = "short");
    let n2 = ToTemporalTimeZoneIdentifier(GetSlot(this, g));
    if (IsTimeZoneOffsetString(n2))
      throw new RangeError("toLocaleString does not support offset string time zones");
    n2 = GetCanonicalTimeZoneIdentifier(n2), o2.timeZone = n2;
    const a2 = new ht(e2, o2), i2 = Call(Ft, a2, []).calendar, s2 = ToTemporalCalendarIdentifier(GetSlot(this, p));
    if ("iso8601" !== s2 && "iso8601" !== i2 && i2 !== s2)
      throw new RangeError(`cannot format ZonedDateTime with calendar ${s2} in locale with calendar ${i2}`);
    return a2.format(GetSlot(this, S));
  }
  toJSON() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return TemporalZonedDateTimeToString(this, "auto");
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.ZonedDateTime");
  }
  startOfDay() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const e2 = dateTime(this), t2 = GetIntrinsic("%Temporal.PlainDateTime%"), r2 = GetSlot(this, p), o2 = new t2(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l), 0, 0, 0, 0, 0, 0, r2), a2 = GetSlot(this, g);
    return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(a2, o2, "compatible"), n), a2, r2);
  }
  toInstant() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(this, n));
  }
  toPlainDate() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return TemporalDateTimeToDate(dateTime(this));
  }
  toPlainTime() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return TemporalDateTimeToTime(dateTime(this));
  }
  toPlainDateTime() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return dateTime(this);
  }
  toPlainYearMonth() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const e2 = GetSlot(this, p);
    return CalendarYearMonthFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, ["monthCode", "year"]), []));
  }
  toPlainMonthDay() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const e2 = GetSlot(this, p);
    return CalendarMonthDayFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, ["day", "monthCode"]), []));
  }
  getISOFields() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const e2 = dateTime(this), t2 = GetSlot(this, g);
    return { calendar: GetSlot(this, p), isoDay: GetSlot(e2, l), isoHour: GetSlot(e2, d), isoMicrosecond: GetSlot(e2, u), isoMillisecond: GetSlot(e2, h), isoMinute: GetSlot(e2, m), isoMonth: GetSlot(e2, s), isoNanosecond: GetSlot(e2, T), isoSecond: GetSlot(e2, c), isoYear: GetSlot(e2, i), offset: GetOffsetStringFor(t2, GetSlot(this, S)), timeZone: t2 };
  }
  getCalendar() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return ToTemporalCalendarObject(GetSlot(this, p));
  }
  getTimeZone() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return ToTemporalTimeZoneObject(GetSlot(this, g));
  }
  static from(e2, t2) {
    const r2 = GetOptionsObject(t2);
    return IsTemporalZonedDateTime(e2) ? (ToTemporalDisambiguation(r2), ToTemporalOffset(r2, "reject"), ToTemporalOverflow(r2), CreateTemporalZonedDateTime(GetSlot(e2, n), GetSlot(e2, g), GetSlot(e2, p))) : ToTemporalZonedDateTime(e2, r2);
  }
  static compare(t2, r2) {
    const o2 = ToTemporalZonedDateTime(t2), a2 = ToTemporalZonedDateTime(r2), i2 = GetSlot(o2, n), s2 = GetSlot(a2, n);
    return e.lessThan(e.BigInt(i2), e.BigInt(s2)) ? -1 : e.greaterThan(e.BigInt(i2), e.BigInt(s2)) ? 1 : 0;
  }
};
function dateTime(e2) {
  return GetPlainDateTimeFor(GetSlot(e2, g), GetSlot(e2, S), GetSlot(e2, p));
}
MakeIntrinsicClass(ZonedDateTime, "Temporal.ZonedDateTime");
var Pt = Object.freeze({ __proto__: null, Calendar, Duration, Instant, Now: Et, PlainDate, PlainDateTime, PlainMonthDay, PlainTime, PlainYearMonth, TimeZone, ZonedDateTime });
function toTemporalInstant() {
  const t2 = e.multiply(e.BigInt(+this), Ge);
  return new Instant(t2);
}
var Zt = [Instant, Calendar, PlainDate, PlainDateTime, Duration, PlainMonthDay, PlainTime, TimeZone, PlainYearMonth, ZonedDateTime];
for (const e2 of Zt) {
  const t2 = Object.getOwnPropertyDescriptor(e2, "prototype");
  (t2.configurable || t2.enumerable || t2.writable) && (t2.configurable = false, t2.enumerable = false, t2.writable = false, Object.defineProperty(e2, "prototype", t2));
}

// node_modules/@contentlayer2/utils/dist/string.js
var uppercaseFirstChar = (str) => str.charAt(0).toUpperCase() + str.slice(1);

// node_modules/@contentlayer2/utils/dist/object/pick.js
var pick = (obj, keys4, filterUndefined = true) => {
  return keys4.reduce((acc, key) => {
    const val = obj[key];
    if (val === void 0 && filterUndefined)
      return acc;
    acc[key] = val;
    return acc;
  }, {});
};

// node_modules/@contentlayer2/utils/dist/tracing.js
init_esm();
var tracer = trace.getTracer("contentlayer");

// node_modules/@contentlayer2/utils/dist/hash.js
import { xxhash64 } from "hash-wasm";

// node_modules/@effect-ts/core/_mjs/Effect/index.mjs
var Effect_exports2 = {};
__export(Effect_exports2, {
  Access: () => Access2,
  Any: () => Any,
  Applicative: () => Applicative,
  AssociativeBoth: () => AssociativeBoth,
  AssociativeEither: () => AssociativeEither,
  AssociativeFlatten: () => AssociativeFlatten,
  Base: () => Base2,
  Category: () => Category,
  Covariant: () => Covariant,
  CustomRuntime: () => CustomRuntime,
  EffectURI: () => EffectURI,
  Fail: () => Fail3,
  ForkScopeRestore: () => ForkScopeRestore,
  GenEffect: () => GenEffect,
  ICheckInterrupt: () => ICheckInterrupt,
  ICheckTracingStatus: () => ICheckTracingStatus,
  IDescriptor: () => IDescriptor,
  IEffectAsync: () => IEffectAsync,
  IEffectPartial: () => IEffectPartial,
  IEffectTotal: () => IEffectTotal,
  IFail: () => IFail,
  IFiberRefModify: () => IFiberRefModify,
  IFiberRefNew: () => IFiberRefNew,
  IFlatMap: () => IFlatMap,
  IFold: () => IFold,
  IFork: () => IFork,
  IGetForkScope: () => IGetForkScope,
  IInterruptStatus: () => IInterruptStatus,
  IOverrideForkScope: () => IOverrideForkScope,
  IPlatform: () => IPlatform,
  IProvide: () => IProvide,
  IRaceWith: () => IRaceWith,
  IRead: () => IRead,
  ISucceed: () => ISucceed,
  ISupervise: () => ISupervise,
  ISuspend: () => ISuspend,
  ISuspendPartial: () => ISuspendPartial,
  ITrace: () => ITrace,
  ITracer: () => ITracer,
  ITracingStatus: () => ITracingStatus,
  IYield: () => IYield,
  IdentityBoth: () => IdentityBoth,
  IdentityFlatten: () => IdentityFlatten,
  InterruptStatusRestoreImpl: () => InterruptStatusRestoreImpl,
  Monad: () => Monad,
  Parallel: () => Parallel2,
  ParallelN: () => ParallelN,
  Provide: () => Provide2,
  Run: () => Run,
  Sequential: () => Sequential2,
  _A: () => _A,
  _C: () => _C,
  _E: () => _E,
  _I: () => _I,
  _L: () => _L,
  _O: () => _O,
  _R: () => _R,
  _RIn: () => _RIn,
  _ROut: () => _ROut,
  _S1: () => _S1,
  _S2: () => _S2,
  _T: () => _T,
  _U: () => _U,
  _W: () => _W,
  absolve: () => absolve,
  absorb: () => absorb,
  absorbWith: () => absorbWith,
  absorbWith_: () => absorbWith_,
  access: () => access3,
  accessM: () => accessM3,
  accessService: () => accessService2,
  accessServiceM: () => accessServiceM2,
  accessServices: () => accessServices,
  accessServicesM: () => accessServicesM,
  accessServicesT: () => accessServicesT,
  accessServicesTM: () => accessServicesTM,
  andThen: () => andThen,
  andThen_: () => andThen_,
  ap: () => ap4,
  ap_: () => ap_3,
  as: () => as2,
  asService: () => asService,
  asService_: () => asService_,
  asSome: () => asSome,
  asSomeError: () => asSomeError,
  asUnit: () => asUnit,
  as_: () => as_,
  awaitAllChildren: () => awaitAllChildren,
  bimap: () => bimap4,
  bimap_: () => bimap_3,
  bind: () => bind2,
  bindAll: () => bindAll,
  bindAllPar: () => bindAllPar,
  bindAllParN: () => bindAllParN,
  bindAllParN_: () => bindAllParN_,
  bindAllPar_: () => bindAllPar_,
  bindAll_: () => bindAll_,
  bind_: () => bind_,
  bracket: () => bracket,
  bracketExit: () => bracketExit,
  bracketExit_: () => bracketExit_,
  bracketFiber: () => bracketFiber,
  bracketFiber_: () => bracketFiber_,
  bracketOnError: () => bracketOnError,
  bracketOnError_: () => bracketOnError_,
  bracket_: () => bracket_,
  cached: () => cached,
  cachedInvalidate: () => cachedInvalidate,
  cachedInvalidate_: () => cachedInvalidate_,
  cached_: () => cached_,
  catch: () => _catch,
  catchAll: () => catchAll2,
  catchAllCause: () => catchAllCause,
  catchAllCause_: () => catchAllCause_,
  catchAllDefect: () => catchAllDefect,
  catchAllDefect_: () => catchAllDefect_,
  catchAll_: () => catchAll_2,
  catchSome: () => catchSome,
  catchSomeCause: () => catchSomeCause,
  catchSomeCause_: () => catchSomeCause_,
  catchSomeDefect: () => catchSomeDefect,
  catchSomeDefect_: () => catchSomeDefect_,
  catchSome_: () => catchSome_,
  catchTag: () => catchTag,
  catchTag_: () => catchTag_,
  catch_: () => catch_,
  cause: () => cause,
  chain: () => chain8,
  chainError: () => chainError,
  chainError_: () => chainError_,
  chain_: () => chain_12,
  checkInterruptible: () => checkInterruptible,
  checkPlatform: () => checkPlatform,
  checkTraced: () => checkTraced,
  collect: () => collect2,
  collectAll: () => collectAll2,
  collectAllPar: () => collectAllPar2,
  collectAllParN: () => collectAllParN,
  collectAllParN_: () => collectAllParN_,
  collectAllSuccesses: () => collectAllSuccesses,
  collectAllSuccessesPar: () => collectAllSuccessesPar,
  collectAllSuccessesParN: () => collectAllSuccessesParN,
  collectAllUnit: () => collectAllUnit,
  collectAllUnitPar: () => collectAllUnitPar,
  collectAllUnitParN: () => collectAllUnitParN,
  collectAllUnitParN_: () => collectAllUnitParN_,
  collectAllWith: () => collectAllWith,
  collectAllWithPar: () => collectAllWithPar,
  collectAllWithParN: () => collectAllWithParN,
  collectAllWithParN_: () => collectAllWithParN_,
  collectAllWithPar_: () => collectAllWithPar_,
  collectAllWith_: () => collectAllWith_,
  collectPar: () => collectPar,
  collectParN: () => collectParN,
  collectParN_: () => collectParN_,
  collectPar_: () => collectPar_,
  collect_: () => collect_3,
  compose: () => compose,
  compose_: () => compose_2,
  cond: () => cond,
  condM: () => condM,
  condM_: () => condM_,
  cond_: () => cond_,
  continueOrFail: () => continueOrFail,
  continueOrFailM: () => continueOrFailM,
  continueOrFailM_: () => continueOrFailM_,
  continueOrFail_: () => continueOrFail_,
  defaultEnv: () => defaultEnv,
  defaultPlatform: () => defaultPlatform,
  defaultRuntime: () => defaultRuntime,
  delay: () => delay,
  delay_: () => delay_,
  deriveAccess: () => deriveAccess,
  deriveAccessM: () => deriveAccessM,
  deriveLifted: () => deriveLifted,
  descriptor: () => descriptor2,
  descriptorWith: () => descriptorWith,
  die: () => die3,
  dieMessage: () => dieMessage,
  dieWith: () => dieWith,
  disconnect: () => disconnect,
  do: () => do_2,
  done: () => done,
  dropWhile: () => dropWhile,
  dropWhile_: () => dropWhile_,
  effectAsync: () => effectAsync,
  effectAsyncBlockingOn: () => effectAsyncBlockingOn,
  effectAsyncInterrupt: () => effectAsyncInterrupt,
  effectAsyncInterruptBlockingOn: () => effectAsyncInterruptBlockingOn,
  effectAsyncM: () => effectAsyncM,
  effectAsyncOption: () => effectAsyncOption,
  effectAsyncOptionBlockingOn: () => effectAsyncOptionBlockingOn,
  effectMaybeAsyncInterrupt: () => effectMaybeAsyncInterrupt,
  effectMaybeAsyncInterruptBlockingOn: () => effectMaybeAsyncInterruptBlockingOn,
  either: () => either2,
  ensuring: () => ensuring,
  ensuringChild: () => ensuringChild,
  ensuringChild_: () => ensuringChild_,
  ensuringChildren: () => ensuringChildren,
  ensuringChildren_: () => ensuringChildren_,
  ensuring_: () => ensuring_,
  environment: () => environment2,
  eventually: () => eventually,
  fail: () => fail6,
  failWith: () => failWith,
  fiberId: () => fiberId,
  filter: () => filter3,
  filterNot: () => filterNot,
  filterNotPar: () => filterNotPar,
  filterNotParN: () => filterNotParN,
  filterNotParN_: () => filterNotParN_,
  filterNotPar_: () => filterNotPar_,
  filterNot_: () => filterNot_,
  filterOrDie: () => filterOrDie,
  filterOrDieMessage: () => filterOrDieMessage,
  filterOrDieMessage_: () => filterOrDieMessage_,
  filterOrDie_: () => filterOrDie_,
  filterOrElse: () => filterOrElse2,
  filterOrElse_: () => filterOrElse_2,
  filterOrFail: () => filterOrFail,
  filterOrFail_: () => filterOrFail_,
  filterPar: () => filterPar,
  filterParN: () => filterParN,
  filterParN_: () => filterParN_,
  filterPar_: () => filterPar_,
  filter_: () => filter_5,
  first: () => first2,
  firstSuccessOf: () => firstSuccessOf,
  flatten: () => flatten8,
  flattenErrorOption: () => flattenErrorOption,
  flattenErrorOption_: () => flattenErrorOption_,
  flip: () => flip,
  flipWith: () => flipWith,
  flipWith_: () => flipWith_,
  fold: () => fold6,
  foldCause: () => foldCause,
  foldCauseM: () => foldCauseM,
  foldCauseM_: () => foldCauseM_,
  foldCause_: () => foldCause_,
  foldM: () => foldM2,
  foldM_: () => foldM_2,
  fold_: () => fold_5,
  forEach: () => forEach4,
  forEachExec: () => forEachExec,
  forEachExec_: () => forEachExec_,
  forEachOf: () => forEachOf,
  forEachPar: () => forEachPar,
  forEachParN: () => forEachParN,
  forEachParNOf: () => forEachParNOf,
  forEachParN_: () => forEachParN_,
  forEachParOf: () => forEachParOf,
  forEachParWithIndex: () => forEachParWithIndex,
  forEachParWithIndexN: () => forEachParWithIndexN,
  forEachParWithIndexN_: () => forEachParWithIndexN_,
  forEachParWithIndex_: () => forEachParWithIndex_,
  forEachPar_: () => forEachPar_,
  forEachUnit: () => forEachUnit,
  forEachUnitPar: () => forEachUnitPar,
  forEachUnitParN: () => forEachUnitParN,
  forEachUnitParN_: () => forEachUnitParN_,
  forEachUnitPar_: () => forEachUnitPar_,
  forEachUnit_: () => forEachUnit_,
  forEachWithIndex: () => forEachWithIndex2,
  forEachWithIndex_: () => forEachWithIndex_2,
  forEach_: () => forEach_5,
  forever: () => forever2,
  fork: () => fork,
  forkAll: () => forkAll,
  forkAllUnit: () => forkAllUnit,
  forkAs: () => forkAs,
  forkAs_: () => forkAs_,
  forkDaemon: () => forkDaemon,
  forkDaemonReport: () => forkDaemonReport,
  forkDaemonReport_: () => forkDaemonReport_,
  forkIn: () => forkIn,
  forkInReport: () => forkInReport,
  forkInReport_: () => forkInReport_,
  forkIn_: () => forkIn_,
  forkManaged: () => forkManaged,
  forkReport: () => forkReport,
  forkReport_: () => forkReport_,
  forkScope: () => forkScope,
  forkScopeMask: () => forkScopeMask,
  forkScopeMask_: () => forkScopeMask_,
  forkScopeWith: () => forkScopeWith,
  forkWithErrorHandler: () => forkWithErrorHandler,
  forkWithErrorHandler_: () => forkWithErrorHandler_,
  fromAsync: () => fromAsync,
  fromEither: () => fromEither2,
  fromFiber: () => fromFiber,
  fromFiberM: () => fromFiberM,
  fromIO: () => fromIO,
  fromNodeCb: () => fromNodeCb,
  fromNullable: () => fromNullable3,
  fromOption: () => fromOption3,
  fromPredicate: () => fromPredicate3,
  gen: () => gen4,
  genM: () => genM,
  get: () => get6,
  getIdentity: () => getIdentity,
  getIdentityPar: () => getIdentityPar,
  getOrFail: () => getOrFail,
  getOrFailUnit: () => getOrFailUnit,
  getValidationApplicative: () => getValidationApplicative,
  halt: () => halt2,
  haltWith: () => haltWith,
  head: () => head4,
  if: () => _if,
  ifM: () => ifM,
  ifM_: () => ifM_,
  if_: () => if_,
  ignore: () => ignore,
  in: () => _in,
  in_: () => in_,
  instruction: () => instruction,
  interrupt: () => interrupt3,
  interruptAllChildren: () => interruptAllChildren,
  interruptAs: () => interruptAs,
  interruptStatus: () => interruptStatus,
  interruptStatus_: () => interruptStatus_,
  interruptible: () => interruptible2,
  interruptibleMask: () => interruptibleMask,
  isFailure: () => isFailure,
  isSuccess: () => isSuccess,
  iterate: () => iterate,
  join: () => join2,
  joinEither: () => joinEither,
  joinEither_: () => joinEither_,
  join_: () => join_,
  left: () => left2,
  leftOrFail: () => leftOrFail,
  leftOrFailException: () => leftOrFailException,
  leftOrFail_: () => leftOrFail_,
  let: () => let__,
  let_: () => let_2,
  loop: () => loop,
  loopUnit: () => loopUnit,
  makeCustomRuntime: () => makeCustomRuntime,
  map: () => map9,
  mapBoth: () => mapBoth,
  mapBoth_: () => mapBoth_2,
  mapError: () => mapError2,
  mapErrorCause: () => mapErrorCause2,
  mapErrorCause_: () => mapErrorCause_,
  mapError_: () => mapError_3,
  mapN: () => mapN,
  mapNPar: () => mapNPar,
  mapNParN: () => mapNParN,
  mapNParN_: () => mapNParN_,
  mapNPar_: () => mapNPar_,
  mapN_: () => mapN_,
  mapTryCatch: () => mapTryCatch,
  mapTryCatch_: () => mapTryCatch_,
  map_: () => map_13,
  match: () => match,
  matchIn: () => matchIn,
  matchMorph: () => matchMorph,
  matchTag: () => matchTag2,
  matchTagIn: () => matchTagIn,
  memoize: () => memoize,
  memoizeEq: () => memoizeEq,
  merge: () => merge2,
  mergeAll: () => mergeAll,
  mergeAllPar: () => mergeAllPar,
  mergeAllParN: () => mergeAllParN,
  mergeAllParN_: () => mergeAllParN_,
  mergeAllPar_: () => mergeAllPar_,
  mergeAll_: () => mergeAll_,
  never: () => never,
  noEnv: () => noEnv,
  none: () => none3,
  onError: () => onError,
  onError_: () => onError_,
  onExit: () => onExit2,
  onExit_: () => onExit_2,
  onFirst: () => onFirst,
  onInterrupt: () => onInterrupt,
  onInterruptExtended_: () => onInterruptExtended_,
  onInterrupt_: () => onInterrupt_,
  onLeft: () => onLeft,
  onRight: () => onRight,
  onSecond: () => onSecond,
  onTermination: () => onTermination,
  onTermination_: () => onTermination_,
  once: () => once,
  onlyDefaultEnv: () => onlyDefaultEnv,
  option: () => option,
  optional: () => optional,
  orDie: () => orDie,
  orDieKeep: () => orDieKeep,
  orDieWith: () => orDieWith,
  orDieWith_: () => orDieWith_,
  orElse: () => orElse2,
  orElseEither: () => orElseEither3,
  orElseEither_: () => orElseEither_3,
  orElseFail: () => orElseFail2,
  orElseFail_: () => orElseFail_,
  orElseOptional: () => orElseOptional,
  orElseOptional_: () => orElseOptional_,
  orElseSucceed: () => orElseSucceed,
  orElseSucceed_: () => orElseSucceed_,
  orElse_: () => orElse_2,
  overrideForkScope: () => overrideForkScope,
  overrideForkScope_: () => overrideForkScope_,
  parallel: () => parallel,
  parallelErrors: () => parallelErrors,
  parallelN: () => parallelN,
  partition: () => partition,
  partitionPar: () => partitionPar,
  partitionParN: () => partitionParN,
  partitionParN_: () => partitionParN_,
  partitionPar_: () => partitionPar_,
  partition_: () => partition_,
  prettyReporter: () => prettyReporter,
  promise: () => promise,
  provide: () => provide2,
  provideAll: () => provideAll2,
  provideAll_: () => provideAll_3,
  provideLayer: () => provideLayer,
  provideLayer_: () => provideLayer_,
  provideService: () => provideService,
  provideServiceM: () => provideServiceM,
  provideServiceM_: () => provideServiceM_,
  provideServiceManaged: () => provideServiceManaged,
  provideService_: () => provideService_,
  provideSome: () => provideSome2,
  provideSomeLayer: () => provideSomeLayer,
  provideSomeLayer_: () => provideSomeLayer_,
  provideSomeManaged: () => provideSomeManaged,
  provideSome_: () => provideSome_,
  provide_: () => provide_,
  race: () => race,
  raceAll: () => raceAll,
  raceAllWait: () => raceAllWait,
  raceAllWithStrategy: () => raceAllWithStrategy,
  raceEither: () => raceEither,
  raceEither_: () => raceEither_,
  raceFirst: () => raceFirst,
  raceFirst_: () => raceFirst_,
  raceWith: () => raceWith,
  raceWithScope: () => raceWithScope,
  raceWithScope_: () => raceWithScope_,
  raceWith_: () => raceWith_,
  race_: () => race_,
  reduce: () => reduce3,
  reduceAll: () => reduceAll,
  reduceAllPar: () => reduceAllPar,
  reduceAllParN: () => reduceAllParN,
  reduceAllParN_: () => reduceAllParN_,
  reduceAllPar_: () => reduceAllPar_,
  reduceAll_: () => reduceAll_,
  reduceRight: () => reduceRight3,
  reduceRight_: () => reduceRight_6,
  reduce_: () => reduce_6,
  refailWithTrace: () => refailWithTrace,
  refineOrDie: () => refineOrDie,
  refineOrDieWith: () => refineOrDieWith,
  refineOrDieWith_: () => refineOrDieWith_,
  refineOrDie_: () => refineOrDie_,
  reject: () => reject,
  rejectM: () => rejectM,
  rejectM_: () => rejectM_,
  reject_: () => reject_,
  repeat: () => repeat,
  repeatN: () => repeatN,
  repeatN_: () => repeatN_,
  repeatOrElse: () => repeatOrElse,
  repeatOrElseEither: () => repeatOrElseEither,
  repeatOrElseEither_: () => repeatOrElseEither_,
  repeatOrElse_: () => repeatOrElse_,
  repeatUntil: () => repeatUntil,
  repeatUntilM: () => repeatUntilM,
  repeatUntilM_: () => repeatUntilM_,
  repeatUntil_: () => repeatUntil_,
  repeatWhile: () => repeatWhile,
  repeatWhileM: () => repeatWhileM,
  repeatWhileM_: () => repeatWhileM_,
  repeatWhile_: () => repeatWhile_,
  repeat_: () => repeat_,
  replaceService: () => replaceService,
  replaceServiceM: () => replaceServiceM,
  replaceServiceM_: () => replaceServiceM_,
  replaceService_: () => replaceService_,
  replicate: () => replicate,
  replicateMUnit: () => replicateMUnit,
  replicateMUnit_: () => replicateMUnit_,
  replicate_: () => replicate_,
  require: () => _require,
  require_: () => require_,
  reserve: () => reserve2,
  reserve_: () => reserve_,
  resetForkScope: () => resetForkScope,
  result: () => result,
  resurrect: () => resurrect,
  retry: () => retry,
  retryOrElse: () => retryOrElse,
  retryOrElseEither: () => retryOrElseEither,
  retryOrElseEither_: () => retryOrElseEither_,
  retryOrElse_: () => retryOrElse_,
  retryUntil: () => retryUntil,
  retryUntilM: () => retryUntilM,
  retryUntilM_: () => retryUntilM_,
  retryUntil_: () => retryUntil_,
  retryWhile: () => retryWhile,
  retryWhileM: () => retryWhileM,
  retryWhileM_: () => retryWhileM_,
  retryWhile_: () => retryWhile_,
  retry_: () => retry_,
  right: () => right2,
  run: () => run4,
  runCancel: () => runCancel,
  runFiber: () => runFiber,
  runPromise: () => runPromise,
  runPromiseExit: () => runPromiseExit,
  runtime: () => runtime,
  sandbox: () => sandbox,
  sandboxWith: () => sandboxWith,
  sandboxWith_: () => sandboxWith_,
  scopeWith: () => scopeWith,
  second: () => second,
  sequential: () => sequential,
  service: () => service,
  services: () => services,
  sleep: () => sleep2,
  some: () => some2,
  someOrElse: () => someOrElse,
  someOrElseM: () => someOrElseM,
  someOrElseM_: () => someOrElseM_,
  someOrElse_: () => someOrElse_,
  someOrFail: () => someOrFail,
  someOrFailException: () => someOrFailException,
  someOrFail_: () => someOrFail_,
  struct: () => struct,
  structPar: () => structPar,
  structParN: () => structParN,
  structParN_: () => structParN_,
  succeed: () => succeed5,
  succeedWith: () => succeedWith3,
  summarized: () => summarized,
  summarized_: () => summarized_,
  supervised: () => supervised,
  supervised_: () => supervised_,
  suspend: () => suspend4,
  swap: () => swap2,
  tap: () => tap4,
  tapBoth: () => tapBoth,
  tapBoth_: () => tapBoth_,
  tapCause: () => tapCause,
  tapCause_: () => tapCause_,
  tapEither: () => tapEither,
  tapEither_: () => tapEither_,
  tapError: () => tapError,
  tapError_: () => tapError_,
  tapExit: () => tapExit,
  tapExit_: () => tapExit_,
  tap_: () => tap_4,
  timed: () => timed,
  timedWith: () => timedWith,
  timedWith_: () => timedWith_,
  timeout: () => timeout,
  timeoutFail: () => timeoutFail,
  timeoutFailCause: () => timeoutFailCause,
  timeoutFailCause_: () => timeoutFailCause_,
  timeoutFail_: () => timeoutFail_,
  timeoutTo: () => timeoutTo,
  timeoutTo_: () => timeoutTo_,
  timeout_: () => timeout_,
  to: () => to,
  toLayer: () => toLayer,
  toLayerRaw: () => toLayerRaw,
  toLeft: () => toLeft,
  toLeftWith: () => toLeftWith,
  toManaged: () => toManaged,
  toManagedRelease: () => toManagedRelease,
  toManagedRelease_: () => toManagedRelease_,
  to_: () => to_,
  trace: () => trace2,
  traced: () => traced2,
  tracedMask: () => tracedMask,
  tracingStatus: () => tracingStatus,
  tracingStatus_: () => tracingStatus_,
  transplant: () => transplant,
  try: () => try_,
  tryCatch: () => tryCatch4,
  tryCatchOption: () => tryCatchOption,
  tryCatchPromise: () => tryCatchPromise,
  tryCatchSuspend: () => tryCatchSuspend,
  tryOrElse: () => tryOrElse,
  tryOrElse_: () => tryOrElse_,
  tryPromise: () => tryPromise,
  tuple: () => tuple3,
  tuplePar: () => tuplePar,
  tupleParN: () => tupleParN,
  uncause: () => uncause,
  unfailable: () => unfailable,
  uninterruptible: () => uninterruptible2,
  uninterruptibleMask: () => uninterruptibleMask,
  union: () => union,
  unionFn: () => unionFn,
  unit: () => unit3,
  unitTraced: () => unitTraced,
  unless: () => unless,
  unlessM: () => unlessM,
  unlessM_: () => unlessM_,
  unless_: () => unless_,
  unoption: () => unoption,
  unrefine: () => unrefine,
  unrefineWith: () => unrefineWith,
  unrefineWith_: () => unrefineWith_,
  unrefine_: () => unrefine_,
  unsandbox: () => unsandbox,
  unsome: () => unsome,
  untraced: () => untraced2,
  untracedMask: () => untracedMask,
  updateService: () => updateService,
  updateService_: () => updateService_,
  validate: () => validate,
  validateExec: () => validateExec,
  validateExec_: () => validateExec_,
  validateFirst: () => validateFirst,
  validateFirstPar: () => validateFirstPar,
  validateFirstParN: () => validateFirstParN,
  validateFirstParN_: () => validateFirstParN_,
  validateFirstPar_: () => validateFirstPar_,
  validateFirst_: () => validateFirst_,
  validatePar: () => validatePar,
  validateParN: () => validateParN,
  validateParN_: () => validateParN_,
  validatePar_: () => validatePar_,
  validate_: () => validate_,
  when: () => when,
  whenCase: () => whenCase,
  whenCase_: () => whenCase_,
  whenM: () => whenM,
  whenM_: () => whenM_,
  when_: () => when_,
  withChildren: () => withChildren,
  withRuntime: () => withRuntime,
  withRuntimeM: () => withRuntimeM,
  yieldNow: () => yieldNow,
  zip: () => zip5,
  zipLeft: () => zipLeft2,
  zipLeftPar: () => zipLeftPar,
  zipLeftPar_: () => zipLeftPar_,
  zipLeft_: () => zipLeft_,
  zipPar: () => zipPar2,
  zipPar_: () => zipPar_,
  zipRight: () => zipRight2,
  zipRightPar: () => zipRightPar,
  zipRightPar_: () => zipRightPar_,
  zipRight_: () => zipRight_2,
  zipWith: () => zipWith3,
  zipWithPar: () => zipWithPar,
  zipWithPar_: () => zipWithPar_,
  zipWith_: () => zipWith_4,
  zip_: () => zip_4
});

// node_modules/@effect-ts/system/_mjs/Operator/index.mjs
var patched = false;
function patch() {
  if (patched || Object.prototype["|>"]) {
    return;
  }
  Object.defineProperty(Object.prototype, "|>", {
    value(next2) {
      return next2(this);
    },
    enumerable: false,
    writable: true
  });
  patched = true;
}
patch();

// node_modules/@effect-ts/system/_mjs/Function/pipe.mjs
function pipe(a2, ab, bc, cd, de2, ef, fg, gh, hi, ij, jk, kl, lm, mn, no, op, pq, qr, rs, st2) {
  switch (arguments.length) {
    case 1:
      return a2;
    case 2:
      return ab(a2);
    case 3:
      return bc(ab(a2));
    case 4:
      return cd(bc(ab(a2)));
    case 5:
      return de2(cd(bc(ab(a2))));
    case 6:
      return ef(de2(cd(bc(ab(a2)))));
    case 7:
      return fg(ef(de2(cd(bc(ab(a2))))));
    case 8:
      return gh(fg(ef(de2(cd(bc(ab(a2)))))));
    case 9:
      return hi(gh(fg(ef(de2(cd(bc(ab(a2))))))));
    case 10:
      return ij(hi(gh(fg(ef(de2(cd(bc(ab(a2)))))))));
    case 11:
      return jk(ij(hi(gh(fg(ef(de2(cd(bc(ab(a2))))))))));
    case 12:
      return kl(jk(ij(hi(gh(fg(ef(de2(cd(bc(ab(a2)))))))))));
    case 13:
      return lm(kl(jk(ij(hi(gh(fg(ef(de2(cd(bc(ab(a2))))))))))));
    case 14:
      return mn(lm(kl(jk(ij(hi(gh(fg(ef(de2(cd(bc(ab(a2)))))))))))));
    case 15:
      return no(mn(lm(kl(jk(ij(hi(gh(fg(ef(de2(cd(bc(ab(a2))))))))))))));
    case 16:
      return op(no(mn(lm(kl(jk(ij(hi(gh(fg(ef(de2(cd(bc(ab(a2)))))))))))))));
    case 17:
      return pq(op(no(mn(lm(kl(jk(ij(hi(gh(fg(ef(de2(cd(bc(ab(a2))))))))))))))));
    case 18:
      return qr(pq(op(no(mn(lm(kl(jk(ij(hi(gh(fg(ef(de2(cd(bc(ab(a2)))))))))))))))));
    case 19:
      return rs(qr(pq(op(no(mn(lm(kl(jk(ij(hi(gh(fg(ef(de2(cd(bc(ab(a2))))))))))))))))));
    case 20:
      return st2(rs(qr(pq(op(no(mn(lm(kl(jk(ij(hi(gh(fg(ef(de2(cd(bc(ab(a2)))))))))))))))))));
    default:
      throw new Error("BUG");
  }
}

// node_modules/@effect-ts/system/_mjs/Function/core.mjs
function absurd(_2) {
  throw new Error("Called `absurd` function which should be uncallable");
}
function constant(a2) {
  return () => a2;
}
var constVoid = () => {
  return;
};
function identity(a2) {
  return a2;
}
function tuple(...t2) {
  return t2;
}

// node_modules/@effect-ts/system/_mjs/Random/PCG/index.mjs
function isNothing(value) {
  return value === void 0 || value === null;
}
var defaultIncHi = 335903614;
var defaultIncLo = 4150755663;
var MUL_HI = 1481765933 >>> 0;
var MUL_LO = 1284865837 >>> 0;
var BIT_53 = 9007199254740992;
var BIT_27 = 134217728;
var PCGRandom = class {
  constructor(seedHi, seedLo, incHi, incLo) {
    if (isNothing(seedLo) && isNothing(seedHi)) {
      seedLo = Math.random() * 4294967295 >>> 0;
      seedHi = 0;
    } else if (isNothing(seedLo)) {
      seedLo = seedHi;
      seedHi = 0;
    }
    if (isNothing(incLo) && isNothing(incHi)) {
      incLo = this._state ? this._state[3] : defaultIncLo;
      incHi = this._state ? this._state[2] : defaultIncHi;
    } else if (isNothing(incLo)) {
      incLo = incHi;
      incHi = 0;
    }
    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
    this._next();
    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
    this._next();
    return this;
  }
  /**
   * @returns A copy of the internal state of this random number generator as a JavaScript Array
   */
  getState() {
    return [this._state[0], this._state[1], this._state[2], this._state[3]];
  }
  /**
   * Restore state previously retrieved using getState()
   */
  setState(state) {
    this._state[0] = state[0];
    this._state[1] = state[1];
    this._state[2] = state[2];
    this._state[3] = state[3] | 1;
  }
  _next() {
    const oldHi = this._state[0] >>> 0;
    const oldLo = this._state[1] >>> 0;
    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
    let xsHi = oldHi >>> 18;
    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
    xsHi = (xsHi ^ oldHi) >>> 0;
    xsLo = (xsLo ^ oldLo) >>> 0;
    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
    const rot = oldHi >>> 27;
    const rot2 = (-rot >>> 0 & 31) >>> 0;
    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
  }
  /// Get a uniformly distributed 32 bit integer between [0, max).
  integer(max2) {
    if (!max2) {
      return this._next();
    }
    max2 = max2 >>> 0;
    if ((max2 & max2 - 1) === 0) {
      return this._next() & max2 - 1;
    }
    let num = 0;
    const skew = (-max2 >>> 0) % max2 >>> 0;
    for (num = this._next(); num < skew; num = this._next()) {
    }
    return num % max2;
  }
  /// Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with
  /// 53 bits of precision (every bit of the mantissa is randomized).
  number() {
    const hi = (this._next() & 67108863) * 1;
    const lo = (this._next() & 134217727) * 1;
    return (hi * BIT_27 + lo) / BIT_53;
  }
};
function mul64(out, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
  let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
  let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
  c0 = c0 << 16 >>> 0;
  lo = lo + c0 >>> 0;
  if (lo >>> 0 < c0 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  c1 = c1 << 16 >>> 0;
  lo = lo + c1 >>> 0;
  if (lo >>> 0 < c1 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  hi = hi + Math.imul(aLo, bHi) >>> 0;
  hi = hi + Math.imul(aHi, bLo) >>> 0;
  out[0] = hi;
  out[1] = lo;
}
function add64(out, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0;
  const lo = aLo + bLo >>> 0;
  if (lo >>> 0 < aLo >>> 0) {
    hi = hi + 1 | 0;
  }
  out[0] = hi;
  out[1] = lo;
}

// node_modules/@effect-ts/system/_mjs/Structural/HasHash/index.mjs
var hashSym = /* @__PURE__ */ Symbol();
function hasHash(u2) {
  return typeof u2 === "object" && u2 !== null && hashSym in u2;
}
var _current = 0;
function opt(n2) {
  return n2 & 3221225471 | n2 >>> 1 & 1073741824;
}
function hash(arg) {
  return opt(_hash(arg));
}
function hashUnknown(arg) {
  return opt(_hash(arg));
}
function hashArray(arr) {
  return opt(_hashArray(arr));
}
function combineHash(a2, b2) {
  return opt(_combineHash(a2, b2));
}
function hashIterator(it2) {
  return opt(_hashIterator(it2));
}
function hashPlainObject(o2) {
  return opt(_hashPlainObject(o2));
}
function hashString(str) {
  return opt(_hashString(str));
}
function isZero2(value) {
  return value === null || value === void 0 || value === false;
}
var RANDOM = /* @__PURE__ */ new PCGRandom(/* @__PURE__ */ Math.random() * 4294967296 >>> 0);
var CACHE = /* @__PURE__ */ new WeakMap();
function randomInt() {
  return RANDOM.integer(2147483647);
}
function _hash(arg) {
  if (isZero2(arg))
    return 0;
  if (typeof arg.valueOf === "function" && arg.valueOf !== Object.prototype.valueOf) {
    arg = arg.valueOf();
    if (isZero2(arg))
      return 0;
  }
  switch (typeof arg) {
    case "number":
      return _hashNumber(arg);
    case "string":
      return _hashString(arg);
    case "function":
      return _hashMiscRef(arg);
    case "object":
      return _hashObject(arg);
    case "boolean":
      return arg === true ? 1 : 0;
    case "symbol":
      return _hashString(String(arg));
    case "bigint":
      return _hashString(arg.toString(10));
    case "undefined": {
      return 0;
    }
  }
}
function _hashArray(arr) {
  let h2 = 6151;
  for (let i2 = 0; i2 < arr.length; i2++) {
    h2 = _combineHash(h2, _hash(arr[i2]));
  }
  return h2;
}
function _combineHash(a2, b2) {
  return a2 * 53 ^ b2;
}
function isDefined(value) {
  return value !== void 0;
}
function _hashObject(value) {
  if (hasHash(value)) {
    return value[hashSym];
  } else {
    let h2 = CACHE.get(value);
    if (isDefined(h2))
      return h2;
    h2 = _current++;
    CACHE.set(value, h2);
    return h2;
  }
}
function _hashMiscRef(o2) {
  let h2 = CACHE.get(o2);
  if (isDefined(h2))
    return h2;
  h2 = randomInt();
  CACHE.set(o2, h2);
  return h2;
}
function _hashIterator(it2) {
  let h2 = 6151;
  let current;
  while (!(current = it2.next()).done) {
    h2 = _combineHash(h2, hash(current.value));
  }
  return h2;
}
function _hashPlainObject(o2) {
  CACHE.set(o2, randomInt());
  const keys4 = Object.keys(o2).sort();
  let h2 = 12289;
  for (let i2 = 0; i2 < keys4.length; i2++) {
    h2 = _combineHash(h2, _hashString(keys4[i2]));
    h2 = _combineHash(h2, hash(o2[keys4[i2]]));
  }
  return h2;
}
function _hashNumber(n2) {
  if (n2 !== n2 || n2 === Infinity)
    return 0;
  let h2 = n2 | 0;
  if (h2 !== n2)
    h2 ^= n2 * 4294967295;
  while (n2 > 4294967295)
    h2 ^= n2 /= 4294967295;
  return n2;
}
function _hashString(str) {
  let h2 = 5381, i2 = str.length;
  while (i2)
    h2 = h2 * 33 ^ str.charCodeAt(--i2);
  return h2;
}

// node_modules/@effect-ts/system/_mjs/Structural/HasEquals/utils.mjs
var {
  keys
} = Object;
function sameValueZeroEqual(a2, b2) {
  return a2 === b2 || a2 !== a2 && b2 !== b2;
}
var hasOwnProperty = /* @__PURE__ */ Function.prototype.bind.call(Function.prototype.call, Object.prototype.hasOwnProperty);

// node_modules/@effect-ts/system/_mjs/Structural/HasEquals/index.mjs
var equalsSym = /* @__PURE__ */ Symbol();
function hasEquals(u2) {
  return hasHash(u2) && equalsSym in u2;
}
function equals(a2, b2) {
  if (!sameValueZeroEqual(hash(a2), hash(b2))) {
    return false;
  } else if (hasEquals(a2)) {
    return a2[equalsSym](b2);
  } else if (hasEquals(b2)) {
    return b2[equalsSym](a2);
  }
  return sameValueZeroEqual(a2, b2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Tuple/index.mjs
var TupleSym = /* @__PURE__ */ Symbol.for("@effect-ts/system/Collections/Immutable/Tuple");
function isTuple(self) {
  return typeof self === "object" && self != null && TupleSym in self;
}
var Tuple = class {
  constructor(tuple8) {
    this.tuple = tuple8;
  }
  [TupleSym]() {
    return TupleSym;
  }
  [Symbol.iterator]() {
    return this.tuple[Symbol.iterator]();
  }
  get [hashSym]() {
    return hashArray(this.tuple);
  }
  [equalsSym](that) {
    if (isTuple(that)) {
      return this.tuple.length === that.tuple.length && this.tuple.every((v2, i2) => equals(v2, that.tuple[i2]));
    }
    return false;
  }
  get(i2) {
    return this.tuple[i2];
  }
};
function tuple2(...args) {
  return new Tuple(args);
}
function get(i2) {
  return (self) => self.get(i2);
}
function get_(self, i2) {
  return self.get(i2);
}
function toNative(self) {
  return self.tuple;
}
function fromNative(self) {
  return new Tuple(self);
}
function update(i2, f2) {
  return (self) => update_(self, i2, f2);
}
function update_(self, i2, f2) {
  const len = self.tuple.length;
  const r2 = new Array(len);
  for (let k2 = 0; k2 < len; k2++) {
    if (k2 === i2) {
      r2[k2] = f2(self.tuple[k2]);
    } else {
      r2[k2] = self.tuple[k2];
    }
  }
  return new Tuple(r2);
}
function append(k2) {
  return (self) => append_(self, k2);
}
function append_(self, k2) {
  return new Tuple([...self.tuple, k2]);
}
function prepend(k2) {
  return (self) => prepend_(self, k2);
}
function prepend_(self, k2) {
  return new Tuple([k2, ...self.tuple]);
}
function concat(that) {
  return (self) => concat_(self, that);
}
function concat_(self, that) {
  return new Tuple([...self.tuple, ...that.tuple]);
}

// node_modules/@effect-ts/system/_mjs/Option/core.mjs
var _noneHash = /* @__PURE__ */ hashString("@effect-ts/system/Option/None");
var _someHash = /* @__PURE__ */ hashString("@effect-ts/system/Option/Some");
var None = class _None {
  constructor() {
    this._tag = "None";
  }
  [equalsSym](that) {
    return that instanceof _None;
  }
  get [hashSym]() {
    return _noneHash;
  }
};
var Some = class _Some {
  constructor(value) {
    this.value = value;
    this._tag = "Some";
  }
  [equalsSym](that) {
    return that instanceof _Some && equals(this.value, that.value);
  }
  get [hashSym]() {
    return combineHash(_someHash, hash(this.value));
  }
};
var none = /* @__PURE__ */ new None();
function emptyOf() {
  return none;
}
function some(a2) {
  return new Some(a2);
}
function ap_(fab, fa) {
  return isNone(fab) ? none : isNone(fa) ? none : some(fab.value(fa.value));
}
function ap(fa) {
  return (fab) => ap_(fab, fa);
}
function zip_(fa, fb) {
  return chain_(fa, (a2) => map_(fb, (b2) => tuple2(a2, b2)));
}
function zip(fb) {
  return (fa) => zip_(fa, fb);
}
function zipFirst(fb) {
  return (fa) => zipFirst_(fa, fb);
}
function zipFirst_(fa, fb) {
  return ap_(map_(fa, (a2) => () => a2), fb);
}
function zipSecond(fb) {
  return (fa) => zipSecond_(fa, fb);
}
function zipSecond_(fa, fb) {
  return ap_(map_(fa, () => (b2) => b2), fb);
}
function chain_(self, f2) {
  return isNone(self) ? none : f2(self.value);
}
function chain(f2) {
  return (self) => chain_(self, f2);
}
function tap(f2) {
  return (ma) => chain_(ma, (a2) => map_(f2(a2), () => a2));
}
function tap_(ma, f2) {
  return chain_(ma, (a2) => map_(f2(a2), () => a2));
}
function flatten(fa) {
  return chain_(fa, identity);
}
function duplicate(ma) {
  return isNone(ma) ? none : some(ma);
}
function exists(predicate) {
  return (ma) => isNone(ma) ? false : predicate(ma.value);
}
function exists_(ma, predicate) {
  return isNone(ma) ? false : predicate(ma.value);
}
function extend(f2) {
  return (self) => extend_(self, f2);
}
function extend_(self, f2) {
  return isNone(self) ? none : some(f2(self));
}
function fold(onNone, onSome) {
  return (ma) => fold_(ma, onNone, onSome);
}
function fold_(ma, onNone, onSome) {
  return isNone(ma) ? onNone() : onSome(ma.value);
}
function fromEither(ma) {
  return ma._tag === "Left" ? none : some(ma.right);
}
function fromNullable(a2) {
  return a2 == null ? none : some(a2);
}
function fromPredicate(predicate) {
  return (a2) => predicate(a2) ? some(a2) : none;
}
function fromPredicate_(a2, predicate) {
  return predicate(a2) ? some(a2) : none;
}
function getLeft(ma) {
  return ma._tag === "Right" ? none : some(ma.left);
}
function getOrElse(onNone) {
  return (o2) => getOrElse_(o2, onNone);
}
function getOrElseS(onNone) {
  return getOrElse(onNone);
}
function getOrElse_(ma, onNone) {
  return ma._tag === "None" ? onNone() : ma.value;
}
function getOrElseS_(ma, onNone) {
  return getOrElse_(ma, onNone);
}
function getRefinement(getOption) {
  return (a2) => isSome(getOption(a2));
}
function getRight(ma) {
  return ma._tag === "Left" ? none : some(ma.right);
}
function isNone(fa) {
  return fa._tag === "None";
}
function isSome(fa) {
  return fa._tag === "Some";
}
function map_(ma, f2) {
  return isNone(ma) ? none : some(f2(ma.value));
}
function map(f2) {
  return (fa) => map_(fa, f2);
}
function mapNullable(f2) {
  return (ma) => isNone(ma) ? none : fromNullable(f2(ma.value));
}
function toNullable(ma) {
  return isNone(ma) ? null : ma.value;
}
function toUndefined(ma) {
  return isNone(ma) ? void 0 : ma.value;
}
function tryCatch(f2) {
  try {
    return some(f2());
  } catch (e2) {
    return none;
  }
}
var PartialExceptionTypeId = /* @__PURE__ */ Symbol();
var PartialException = class {
  constructor() {
    this._typeId = PartialExceptionTypeId;
  }
};
function raisePartial() {
  throw new PartialException();
}
function partial(f2) {
  return (...args) => {
    try {
      return some(f2(raisePartial)(...args));
    } catch (e2) {
      if (e2 instanceof PartialException) {
        return none;
      }
      throw e2;
    }
  };
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Array/core.mjs
function chain_2(fa, f2) {
  let resLen = 0;
  const l2 = fa.length;
  const temp = new Array(l2);
  for (let i2 = 0; i2 < l2; i2++) {
    const e2 = fa[i2];
    const arr = f2(e2);
    resLen += arr.length;
    temp[i2] = arr;
  }
  const r2 = Array(resLen);
  let start = 0;
  for (let i2 = 0; i2 < l2; i2++) {
    const arr = temp[i2];
    const l3 = arr.length;
    for (let j2 = 0; j2 < l3; j2++) {
      r2[j2 + start] = arr[j2];
    }
    start += l3;
  }
  return r2;
}
function drop_(as6, n2) {
  return as6.slice(n2, as6.length);
}
function empty() {
  return [];
}
function head(as6) {
  return isEmpty(as6) ? none : some(as6[0]);
}
function isEmpty(as6) {
  return as6.length === 0;
}
function isNonEmpty(as6) {
  return as6.length > 0;
}
function makeBy_(n2, f2) {
  const r2 = [];
  for (let i2 = 0; i2 < n2; i2++) {
    r2.push(f2(i2));
  }
  return r2;
}
function map_2(fa, f2) {
  return fa.map(f2);
}
function range(start, end4) {
  return makeBy_(end4 - start + 1, (i2) => start + i2);
}
function reduce_(fa, b2, f2) {
  return reduceWithIndex_(fa, b2, (_2, b3, a2) => f2(b3, a2));
}
function reduceRight_(fa, b2, f2) {
  return reduceRightWithIndex_(fa, b2, (_2, a2, b3) => f2(a2, b3));
}
function reduceRightWithIndex_(fa, b2, f2) {
  return fa.reduceRight((b3, a2, i2) => f2(i2, a2, b3), b2);
}
function reduceWithIndex_(fa, b2, f2) {
  const l2 = fa.length;
  let r2 = b2;
  for (let i2 = 0; i2 < l2; i2++) {
    r2 = f2(i2, r2, fa[i2]);
  }
  return r2;
}
function reverse(as6) {
  return [...as6].reverse();
}
function takeRight_(as6, n2) {
  return n2 === 0 ? empty() : as6.slice(-n2);
}
function isOutOfBound(i2, as6) {
  return i2 < 0 || i2 >= as6.length;
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Array/classic.mjs
function updateAt_(as6, i2, a2) {
  return isOutOfBound(i2, as6) ? none : some(unsafeUpdateAt_(as6, i2, a2));
}
function unsafeUpdateAt_(as6, i2, a2) {
  if (as6[i2] === a2) {
    return as6;
  } else {
    const xs = [...as6];
    xs[i2] = a2;
    return xs;
  }
}
function separate(fa) {
  const left4 = [];
  const right5 = [];
  for (const e2 of fa) {
    if (e2._tag === "Left") {
      left4.push(e2.left);
    } else {
      right5.push(e2.right);
    }
  }
  return tuple2(left4, right5);
}

// node_modules/@effect-ts/system/_mjs/Either/core.mjs
var _leftHash = /* @__PURE__ */ hashString("@effect-ts/system/Either/Left");
var _rightHash = /* @__PURE__ */ hashString("@effect-ts/system/Either/Right");
var Left = class _Left {
  constructor(left4) {
    this.left = left4;
    this._tag = "Left";
  }
  [equalsSym](that) {
    return that instanceof _Left && equals(this.left, that.left);
  }
  get [hashSym]() {
    return combineHash(_leftHash, hash(this.left));
  }
};
var Right = class _Right {
  constructor(right5) {
    this.right = right5;
    this._tag = "Right";
  }
  [equalsSym](that) {
    return that instanceof _Right && equals(this.right, that.right);
  }
  get [hashSym]() {
    return combineHash(_rightHash, hash(this.right));
  }
};
function right(a2) {
  return new Right(a2);
}
function rightW(a2) {
  return new Right(a2);
}
function left(e2) {
  return new Left(e2);
}
function leftW(e2) {
  return new Left(e2);
}
function widenE() {
  return (
    /**
     * @ets_optimize identity
     */
    (self) => self
  );
}
function widenA() {
  return (
    /**
     * @ets_optimize identity
     */
    (self) => self
  );
}
function alt_(self, that) {
  return isLeft(self) ? that() : self;
}
function alt(that) {
  return (self) => alt_(self, that);
}
function ap_2(fab, fa) {
  return isLeft(fab) ? fab : isLeft(fa) ? fa : right(fab.right(fa.right));
}
function ap2(fa) {
  return (fab) => ap_2(fab, fa);
}
function zip_2(fa, fb) {
  return chain_3(fa, (a2) => map_3(fb, (b2) => tuple2(a2, b2)));
}
function zip2(fb) {
  return (fa) => zip_2(fa, fb);
}
function zipFirst2(fb) {
  return (fa) => zipFirst_2(fa, fb);
}
function zipFirst_2(fa, fb) {
  return ap_2(map_3(fa, (a2) => () => a2), fb);
}
function zipSecond2(fb) {
  return (fa) => zipSecond_2(fa, fb);
}
function zipSecond_2(fa, fb) {
  return ap_2(map_3(fa, () => (b2) => b2), fb);
}
function bimap_(fea, f2, g2) {
  return isLeft(fea) ? left(f2(fea.left)) : right(g2(fea.right));
}
function bimap(f2, g2) {
  return (fa) => bimap_(fa, f2, g2);
}
function chain_3(fa, f2) {
  return isLeft(fa) ? fa : f2(fa.right);
}
function chain2(f2) {
  return (ma) => chain_3(ma, f2);
}
function tap2(f2) {
  return (ma) => chain_3(ma, (a2) => map_3(f2(a2), () => a2));
}
function tap_2(ma, f2) {
  return chain_3(ma, (a2) => map_3(f2(a2), () => a2));
}
function duplicate2(ma) {
  return extend_2(ma, (x2) => x2);
}
function exists2(predicate) {
  return (ma) => isLeft(ma) ? false : predicate(ma.right);
}
function exists_2(ma, predicate) {
  return isLeft(ma) ? false : predicate(ma.right);
}
function extend_2(self, f2) {
  return isLeft(self) ? self : right(f2(self));
}
function extend2(f2) {
  return (self) => extend_2(self, f2);
}
function filterOrElse(predicate, onFalse) {
  return (ma) => chain_3(ma, (a2) => predicate(a2) ? right(a2) : left(onFalse(a2)));
}
function filterOrElse_(ma, predicate, onFalse) {
  return chain_3(ma, (a2) => predicate(a2) ? right(a2) : left(onFalse(a2)));
}
function flatten3(mma) {
  return chain_3(mma, (x2) => x2);
}
function fold2(onLeft2, onRight2) {
  return (ma) => isLeft(ma) ? onLeft2(ma.left) : onRight2(ma.right);
}
function fold_2(ma, onLeft2, onRight2) {
  return isLeft(ma) ? onLeft2(ma.left) : onRight2(ma.right);
}
function fromNullable2(e2) {
  return (a2) => a2 == null ? left(e2()) : right(a2);
}
function fromNullable_(a2, e2) {
  return a2 == null ? left(e2()) : right(a2);
}
function fromOption(onNone) {
  return (ma) => isNone(ma) ? left(onNone()) : right(ma.value);
}
function fromOption_(ma, onNone) {
  return isNone(ma) ? left(onNone()) : right(ma.value);
}
function fromPredicate2(predicate, onFalse) {
  return (a2) => predicate(a2) ? right(a2) : left(onFalse(a2));
}
function fromPredicate_2(a2, predicate, onFalse) {
  return predicate(a2) ? right(a2) : left(onFalse(a2));
}
function getOrElse2(onLeft2) {
  return (ma) => getOrElse_2(ma, onLeft2);
}
function getOrElse_2(self, onLeft2) {
  return isLeft(self) ? onLeft2(self.left) : self.right;
}
function isLeft(ma) {
  switch (ma._tag) {
    case "Left":
      return true;
    case "Right":
      return false;
  }
}
function isRight(ma) {
  return ma._tag === "Right" ? true : false;
}
function map_3(fa, f2) {
  return isLeft(fa) ? fa : right(f2(fa.right));
}
function map2(f2) {
  return (fa) => map_3(fa, f2);
}
function mapLeft_(fea, f2) {
  return isLeft(fea) ? left(f2(fea.left)) : fea;
}
function mapLeft(f2) {
  return (fa) => mapLeft_(fa, f2);
}
function merge(self) {
  return fold_2(self, (x2) => x2, (x2) => x2);
}
function orElse(onLeft2) {
  return (ma) => orElse_(ma, onLeft2);
}
function orElse_(ma, onLeft2) {
  return isLeft(ma) ? onLeft2(ma.left) : ma;
}
function orElseEither(onLeft2) {
  return (ma) => orElseEither_(ma, onLeft2);
}
function orElseEither_(ma, onLeft2) {
  return orElse_(map_3(ma, left), (e2) => map_3(onLeft2(e2), right));
}
function parseJSON_(s2, onError3) {
  return tryCatch2(() => JSON.parse(s2), onError3);
}
function parseJSON(onError3) {
  return (s2) => tryCatch2(() => JSON.parse(s2), onError3);
}
function stringifyJSON_(u2, onError3) {
  return tryCatch2(() => JSON.stringify(u2), onError3);
}
function stringifyJSON(onError3) {
  return (u2) => tryCatch2(() => JSON.stringify(u2), onError3);
}
function swap(ma) {
  return isLeft(ma) ? right(ma.left) : left(ma.right);
}
function toError(e2) {
  return e2 instanceof Error ? e2 : new Error(String(e2));
}
function tryCatch2(f2, onError3) {
  try {
    return right(f2());
  } catch (e2) {
    return left(onError3(e2));
  }
}
function compact(_2) {
  return _2;
}
function reduce_2(fa, b2, f2) {
  return isLeft(fa) ? b2 : f2(b2, fa.right);
}
function reduce(b2, f2) {
  return (fa) => reduce_2(fa, b2, f2);
}
function reduceRight(b2, f2) {
  return (fa) => reduceRight_2(fa, b2, f2);
}
function reduceRight_2(fa, b2, f2) {
  return isLeft(fa) ? b2 : f2(fa.right, b2);
}

// node_modules/@effect-ts/system/_mjs/Effect/commons.mjs
var _R = /* @__PURE__ */ Symbol();
var _E = /* @__PURE__ */ Symbol();
var _A = /* @__PURE__ */ Symbol();
var _U = /* @__PURE__ */ Symbol();
var _W = /* @__PURE__ */ Symbol();
var _L = /* @__PURE__ */ Symbol();
var _I = /* @__PURE__ */ Symbol();
var _O = /* @__PURE__ */ Symbol();
var _T = /* @__PURE__ */ Symbol();
var _C = /* @__PURE__ */ Symbol();
var _RIn = /* @__PURE__ */ Symbol();
var _ROut = /* @__PURE__ */ Symbol();
var _S1 = /* @__PURE__ */ Symbol();
var _S2 = /* @__PURE__ */ Symbol();

// node_modules/@effect-ts/system/_mjs/GlobalExceptions/ArrayIndexOutOfBoundsException.mjs
var ArrayIndexOutOfBoundsExceptionTypeId = /* @__PURE__ */ Symbol();
var ArrayIndexOutOfBoundsException = class {
  constructor(index) {
    this.index = index;
    this._typeId = ArrayIndexOutOfBoundsExceptionTypeId;
  }
};

// node_modules/@effect-ts/system/_mjs/GlobalExceptions/NoSuchElementException.mjs
var NoSuchElementExceptionTag = "NoSuchElementException";
var NoSuchElementException = class {
  constructor() {
    this._tag = NoSuchElementExceptionTag;
  }
};

// node_modules/@effect-ts/system/_mjs/Utils/index.mjs
var pattern = (n2) => (_2, d2) => (m2) => {
  return _2[m2[n2]] ? _2[m2[n2]](m2, m2) : d2(m2, m2);
};
var matchTag = /* @__PURE__ */ pattern("_tag");
function isEither(u2) {
  return typeof u2 === "object" && u2 != null && "_tag" in u2 && (u2["_tag"] === "Left" || u2["_tag"] === "Right");
}
function isOption(u2) {
  return typeof u2 === "object" && u2 != null && "_tag" in u2 && (u2["_tag"] === "Some" || u2["_tag"] === "None");
}
function isTag(u2) {
  return typeof u2 === "object" && u2 != null && "_tag" in u2 && u2["_tag"] === "Tag";
}

// node_modules/@effect-ts/system/_mjs/Either/gen.mjs
var GenEither = class {
  constructor(effect2) {
    this.effect = effect2;
  }
  *[Symbol.iterator]() {
    return yield this;
  }
};
function adapter(_2, __) {
  return isOption(_2) ? new GenEither(_2._tag === "Some" ? right(_2.value) : left(__ ? __() : new NoSuchElementException())) : new GenEither(_2);
}
function gen(f2) {
  const iterator = f2(adapter);
  const state = iterator.next();
  function run7(state2) {
    if (state2.done) {
      return right(state2.value);
    }
    return chain_3(state2.value["effect"], (val) => {
      const next2 = iterator.next(val);
      return run7(next2);
    });
  }
  return run7(state);
}

// node_modules/@effect-ts/system/_mjs/Stack/index.mjs
var Stack = class {
  constructor(value, previous) {
    this.value = value;
    this.previous = previous;
  }
};

// node_modules/@effect-ts/system/_mjs/IO/index.mjs
var Base = class {
};
var Succeed = class extends Base {
  constructor(a2) {
    super();
    this.a = a2;
    this._iotag = "Succeed";
  }
};
var Suspend = class extends Base {
  constructor(f2) {
    super();
    this.f = f2;
    this._iotag = "Suspend";
  }
};
var FlatMap = class extends Base {
  constructor(value, cont) {
    super();
    this.value = value;
    this.cont = cont;
    this._iotag = "FlatMap";
  }
};
function run(self) {
  let stack = void 0;
  let a2 = void 0;
  let curIO = self;
  while (curIO != null) {
    switch (curIO._iotag) {
      case "FlatMap": {
        switch (curIO.value._iotag) {
          case "Succeed": {
            curIO = curIO.cont(curIO.value.a);
            break;
          }
          default: {
            stack = new Stack(curIO.cont, stack);
            curIO = curIO.value;
          }
        }
        break;
      }
      case "Suspend": {
        curIO = curIO.f();
        break;
      }
      case "Succeed": {
        a2 = curIO.a;
        if (stack) {
          curIO = stack.value(a2);
          stack = stack.previous;
        } else {
          curIO = void 0;
        }
        break;
      }
    }
  }
  return a2;
}
function chain_4(self, f2) {
  return new FlatMap(self, f2);
}
function succeed(a2) {
  return new Succeed(a2);
}
function map_4(self, f2) {
  return chain_4(self, (a2) => succeed(f2(a2)));
}
function zipWith_(self, that, f2) {
  return chain_4(self, (a2) => map_4(that, (b2) => f2(a2, b2)));
}
function suspend(f2) {
  return new Suspend(f2);
}
function succeedWith(f2) {
  return suspend(() => succeed(f2()));
}
var GenIO = class {
  constructor(effect2) {
    this.effect = effect2;
  }
  *[Symbol.iterator]() {
    return yield this;
  }
};
function adapter2(_2) {
  return new GenIO(_2);
}
function run_(state, iterator) {
  if (state.done) {
    return succeed(state.value);
  }
  return chain_4(state.value["effect"], (val) => {
    const next2 = iterator.next(val);
    return run_(next2, iterator);
  });
}
function gen2(f2) {
  return suspend(() => {
    const iterator = f2(adapter2);
    const state = iterator.next();
    return run_(state, iterator);
  });
}

// node_modules/@effect-ts/system/_mjs/Iterable/index.mjs
function* genMap(iterator, mapping) {
  let n2 = -1;
  while (true) {
    const result4 = iterator.next();
    if (result4.done) {
      break;
    }
    n2 += 1;
    yield mapping(result4.value, n2);
  }
}
function* genChain(iterator, mapping) {
  while (true) {
    const result4 = iterator.next();
    if (result4.done) {
      break;
    }
    const ib = mapping(result4.value)[Symbol.iterator]();
    while (true) {
      const result5 = ib.next();
      if (result5.done) {
        break;
      }
      yield result5.value;
    }
  }
}
function map_5(i2, f2) {
  return {
    [Symbol.iterator]: () => genMap(i2[Symbol.iterator](), f2)
  };
}
function chain_5(i2, f2) {
  return {
    [Symbol.iterator]: () => genChain(i2[Symbol.iterator](), f2)
  };
}
function reduce_3(fa, b2, f2) {
  let res = b2;
  let n2 = -1;
  const iterator = fa[Symbol.iterator]();
  while (true) {
    const result4 = iterator.next();
    if (result4.done) {
      break;
    }
    n2 += 1;
    res = f2(res, result4.value, n2);
  }
  return res;
}
function reduceRight_3(fa, b2, f2) {
  return reduceRightWithIndex_(Array.from(fa), b2, (i2, a2, b3) => f2(a2, b3, i2));
}
function partitionMap(f2) {
  return (as6) => separate(Array.from(map_5(as6, f2)));
}
function corresponds(left4, right5, f2) {
  const leftIt = left4[Symbol.iterator]();
  const rightIt = right5[Symbol.iterator]();
  while (1) {
    const lnext = leftIt.next();
    const rnext = rightIt.next();
    if (lnext.done !== rnext.done) {
      return false;
    }
    if (lnext.done) {
      return true;
    }
    if (!f2(lnext.value, rnext.value)) {
      return false;
    }
  }
  throw new Error("Bug");
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/HashMap/Config/index.mjs
var SIZE = 5;
var BUCKET_SIZE = /* @__PURE__ */ Math.pow(2, SIZE);
var MASK = BUCKET_SIZE - 1;
var MAX_INDEX_NODE = BUCKET_SIZE / 2;
var MIN_ARRAY_NODE = BUCKET_SIZE / 4;

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/HashMap/Bitwise/index.mjs
function popcount(x2) {
  x2 -= x2 >> 1 & 1431655765;
  x2 = (x2 & 858993459) + (x2 >> 2 & 858993459);
  x2 = x2 + (x2 >> 4) & 252645135;
  x2 += x2 >> 8;
  x2 += x2 >> 16;
  return x2 & 127;
}
function hashFragment(shift, h2) {
  return h2 >>> shift & MASK;
}
function toBitmap(x2) {
  return 1 << x2;
}
function fromBitmap(bitmap, bit) {
  return popcount(bitmap & bit - 1);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/HashMap/Array/index.mjs
function arrayUpdate(mutate2, at2, v2, arr) {
  let out = arr;
  if (!mutate2) {
    const len = arr.length;
    out = new Array(len);
    for (let i2 = 0; i2 < len; ++i2)
      out[i2] = arr[i2];
  }
  out[at2] = v2;
  return out;
}
function arraySpliceOut(mutate2, at2, arr) {
  const newLen = arr.length - 1;
  let i2 = 0;
  let g2 = 0;
  let out = arr;
  if (mutate2) {
    i2 = g2 = at2;
  } else {
    out = new Array(newLen);
    while (i2 < at2)
      out[g2++] = arr[i2++];
  }
  ++i2;
  while (i2 <= newLen)
    out[g2++] = arr[i2++];
  if (mutate2) {
    out.length = newLen;
  }
  return out;
}
function arraySpliceIn(mutate2, at2, v2, arr) {
  const len = arr.length;
  if (mutate2) {
    let i3 = len;
    while (i3 >= at2)
      arr[i3--] = arr[i3];
    arr[at2] = v2;
    return arr;
  }
  let i2 = 0, g2 = 0;
  const out = new Array(len + 1);
  while (i2 < at2)
    out[g2++] = arr[i2++];
  out[at2] = v2;
  while (i2 < len)
    out[++g2] = arr[i2++];
  return out;
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/HashMap/Nodes/index.mjs
var Empty = class _Empty2 {
  constructor() {
    this._tag = "Empty";
  }
  modify(edit, _shift, f2, hash2, key, size7) {
    const v2 = f2(none);
    if (isNone(v2))
      return new _Empty2();
    ++size7.value;
    return new LeafNode(edit, hash2, key, v2);
  }
};
function isEmptyNode(a2) {
  return a2 instanceof Empty;
}
function isLeaf(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
function canEditNode(edit, node) {
  return isEmptyNode(node) ? false : edit === node.edit;
}
var LeafNode = class _LeafNode {
  constructor(edit, hash2, key, value) {
    this.edit = edit;
    this.hash = hash2;
    this.key = key;
    this.value = value;
    this._tag = "LeafNode";
  }
  modify(edit, shift, f2, hash2, key, size7) {
    if (equals(key, this.key)) {
      const v3 = f2(this.value);
      if (v3 === this.value)
        return this;
      else if (isNone(v3)) {
        --size7.value;
        return new Empty();
      }
      if (canEditNode(edit, this)) {
        this.value = v3;
        return this;
      }
      return new _LeafNode(edit, hash2, key, v3);
    }
    const v2 = f2(none);
    if (isNone(v2))
      return this;
    ++size7.value;
    return mergeLeaves(edit, shift, this.hash, this, hash2, new _LeafNode(edit, hash2, key, v2));
  }
};
var CollisionNode = class _CollisionNode {
  constructor(edit, hash2, children) {
    this.edit = edit;
    this.hash = hash2;
    this.children = children;
    this._tag = "CollisionNode";
  }
  modify(edit, shift, f2, hash2, key, size7) {
    if (hash2 === this.hash) {
      const canEdit = canEditNode(edit, this);
      const list2 = this.updateCollisionList(canEdit, edit, this.hash, this.children, f2, key, size7);
      if (list2 === this.children)
        return this;
      return list2.length > 1 ? new _CollisionNode(edit, this.hash, list2) : list2[0];
    }
    const v2 = f2(none);
    if (isNone(v2))
      return this;
    ++size7.value;
    return mergeLeaves(edit, shift, this.hash, this, hash2, new LeafNode(edit, hash2, key, v2));
  }
  updateCollisionList(mutate2, edit, hash2, list2, f2, key, size7) {
    const len = list2.length;
    for (let i2 = 0; i2 < len; ++i2) {
      const child = list2[i2];
      if ("key" in child && equals(key, child.key)) {
        const value = child.value;
        const newValue2 = f2(value);
        if (newValue2 === value)
          return list2;
        if (isNone(newValue2)) {
          --size7.value;
          return arraySpliceOut(mutate2, i2, list2);
        }
        return arrayUpdate(mutate2, i2, new LeafNode(edit, hash2, key, newValue2), list2);
      }
    }
    const newValue = f2(none);
    if (isNone(newValue))
      return list2;
    ++size7.value;
    return arrayUpdate(mutate2, len, new LeafNode(edit, hash2, key, newValue), list2);
  }
};
var IndexedNode = class _IndexedNode {
  constructor(edit, mask2, children) {
    this.edit = edit;
    this.mask = mask2;
    this.children = children;
    this._tag = "IndexedNode";
  }
  modify(edit, shift, f2, hash2, key, size7) {
    const mask2 = this.mask;
    const children = this.children;
    const frag = hashFragment(shift, hash2);
    const bit = toBitmap(frag);
    const indx = fromBitmap(mask2, bit);
    const exists5 = mask2 & bit;
    const canEdit = canEditNode(edit, this);
    if (!exists5) {
      const _newChild = new Empty().modify(edit, shift + SIZE, f2, hash2, key, size7);
      if (!_newChild)
        return this;
      return children.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask2, children) : new _IndexedNode(edit, mask2 | bit, arraySpliceIn(canEdit, indx, _newChild, children));
    }
    const current = exists5 ? children[indx] : new Empty();
    const child = current.modify(edit, shift + SIZE, f2, hash2, key, size7);
    if (current === child)
      return this;
    let bitmap = mask2;
    let newChildren;
    if (isEmptyNode(child)) {
      bitmap &= ~bit;
      if (!bitmap)
        return new Empty();
      if (children.length <= 2 && isLeaf(children[indx ^ 1]))
        return children[indx ^ 1];
      newChildren = arraySpliceOut(canEdit, indx, children);
    } else {
      newChildren = arrayUpdate(canEdit, indx, child, children);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return new _IndexedNode(edit, bitmap, newChildren);
  }
};
var ArrayNode = class _ArrayNode {
  constructor(edit, size7, children) {
    this.edit = edit;
    this.size = size7;
    this.children = children;
    this._tag = "ArrayNode";
  }
  modify(edit, shift, f2, hash2, key, size7) {
    let count2 = this.size;
    const children = this.children;
    const frag = hashFragment(shift, hash2);
    const child = children[frag];
    const newChild = (child || new Empty()).modify(edit, shift + SIZE, f2, hash2, key, size7);
    if (child === newChild)
      return this;
    const canEdit = canEditNode(edit, this);
    let newChildren;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ++count2;
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      --count2;
      if (count2 <= MIN_ARRAY_NODE) {
        return pack(edit, count2, frag, children);
      }
      newChildren = arrayUpdate(canEdit, frag, new Empty(), children);
    } else {
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    }
    if (canEdit) {
      this.size = count2;
      this.children = newChildren;
      return this;
    }
    return new _ArrayNode(edit, count2, newChildren);
  }
};
function pack(edit, count2, removed, elements) {
  const children = new Array(count2 - 1);
  let g2 = 0;
  let bitmap = 0;
  for (let i2 = 0, len = elements.length; i2 < len; ++i2) {
    if (i2 !== removed) {
      const elem3 = elements[i2];
      if (elem3 && !isEmptyNode(elem3)) {
        children[g2++] = elem3;
        bitmap |= 1 << i2;
      }
    }
  }
  return new IndexedNode(edit, bitmap, children);
}
function expand(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit = bitmap;
  let count2 = 0;
  for (let i2 = 0; bit; ++i2) {
    if (bit & 1)
      arr[i2] = subNodes[count2++];
    bit >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode(edit, count2 + 1, arr);
}
function mergeLeavesInner(edit, shift, h1, n1, h2, n2) {
  if (h1 === h2)
    return new CollisionNode(edit, h1, [n2, n1]);
  const subH1 = hashFragment(shift, h1);
  const subH2 = hashFragment(shift, h2);
  if (subH1 === subH2) {
    return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
  } else {
    const children = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children);
  }
}
function mergeLeaves(edit, shift, h1, n1, h2, n2) {
  let stack = void 0;
  let currentShift = shift;
  while (true) {
    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
    if (typeof res === "function") {
      stack = new Stack(res, stack);
      currentShift = currentShift + SIZE;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/HashMap/core.mjs
var HashMapHash = /* @__PURE__ */ hashString("HashMap");
var HashMap = class _HashMap {
  constructor(editable, edit, root, size7) {
    this.editable = editable;
    this.edit = edit;
    this.root = root;
    this.size = size7;
    this.tupleIterator = {
      [Symbol.iterator]: () => new HashMapIterator(this, ([k2, v2]) => tuple2(k2, v2))
    };
  }
  [Symbol.iterator]() {
    return new HashMapIterator(this, identity);
  }
  get [hashSym]() {
    let hash2 = HashMapHash;
    for (const item of this) {
      hash2 ^= combineHash(hashUnknown(item[0]), hashUnknown(item[1]));
    }
    return hash2;
  }
  [equalsSym](that) {
    if (that instanceof _HashMap) {
      if (that.size !== this.size) {
        return false;
      }
      for (const item of this) {
        const elem3 = getHash_(that, item[0], hash(item[0]));
        if (elem3._tag === "None") {
          return false;
        } else {
          if (!equals(item[1], elem3.value)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  }
};
var HashMapIterator = class _HashMapIterator {
  constructor(map15, f2) {
    this.map = map15;
    this.f = f2;
    this.v = visitLazy(this.map.root, this.f, void 0);
  }
  next() {
    if (isNone(this.v)) {
      return {
        done: true,
        value: void 0
      };
    }
    const v0 = this.v.value;
    this.v = applyCont(v0.cont);
    return {
      done: false,
      value: v0.value
    };
  }
  [Symbol.iterator]() {
    return new _HashMapIterator(this.map, this.f);
  }
};
function make() {
  return new HashMap(false, 0, new Empty(), 0);
}
function from(xs) {
  return reduce_3(xs, make(), (m2, p2) => set_(m2, ...p2));
}
function setTree_(map15, newRoot, newSize) {
  if (map15.editable) {
    map15.root = newRoot;
    map15.size = newSize;
    return map15;
  }
  return newRoot === map15.root ? map15 : new HashMap(map15.editable, map15.edit, newRoot, newSize);
}
function tryGetHash_(map15, key, hash2) {
  let node = map15.root;
  let shift = 0;
  while (true)
    switch (node._tag) {
      case "LeafNode": {
        return equals(key, node.key) ? node.value : none;
      }
      case "CollisionNode": {
        if (hash2 === node.hash) {
          const children = node.children;
          for (let i2 = 0, len = children.length; i2 < len; ++i2) {
            const child = children[i2];
            if ("key" in child && equals(key, child.key))
              return child.value;
          }
        }
        return none;
      }
      case "IndexedNode": {
        const frag = hashFragment(shift, hash2);
        const bit = toBitmap(frag);
        if (node.mask & bit) {
          node = node.children[fromBitmap(node.mask, bit)];
          shift += SIZE;
          break;
        }
        return none;
      }
      case "ArrayNode": {
        node = node.children[hashFragment(shift, hash2)];
        if (node) {
          shift += SIZE;
          break;
        }
        return none;
      }
      default:
        return none;
    }
}
function getHash_(map15, key, hash2) {
  return tryGetHash_(map15, key, hash2);
}
function unsafeGet_(map15, key) {
  const element = tryGetHash_(map15, key, hash(key));
  if (isNone(element)) {
    throw new NoSuchElementException();
  }
  return element.value;
}
function unsafeGet(key) {
  return (map15) => unsafeGet_(map15, key);
}
function get_2(map15, key) {
  return tryGetHash_(map15, key, hash(key));
}
function get2(key) {
  return (map15) => get_2(map15, key);
}
function hasHash_(map15, key, hash2) {
  return isSome(tryGetHash_(map15, key, hash2));
}
function has_(map15, key) {
  return isSome(tryGetHash_(map15, key, hash(key)));
}
function has(key) {
  return (map15) => has_(map15, key);
}
function isEmpty2(map15) {
  return map15 && !!isEmptyNode(map15.root);
}
function modifyHash_(map15, key, hash2, f2) {
  const size7 = {
    value: map15.size
  };
  const newRoot = map15.root.modify(map15.editable ? map15.edit : NaN, 0, f2, hash2, key, size7);
  return setTree_(map15, newRoot, size7.value);
}
function modify_(map15, key, f2) {
  return modifyHash_(map15, key, hash(key), f2);
}
function modify(key, f2) {
  return (map15) => modify_(map15, key, f2);
}
function set_(map15, key, value) {
  return modify_(map15, key, constant(some(value)));
}
function set(key, value) {
  return (map15) => set_(map15, key, value);
}
function remove_(map15, key) {
  return modify_(map15, key, constant(none));
}
function remove(key) {
  return (map15) => remove_(map15, key);
}
function beginMutation(map15) {
  return new HashMap(true, map15.edit + 1, map15.root, map15.size);
}
function endMutation(map15) {
  map15.editable = false;
  return map15;
}
function mutate(f2) {
  return (map15) => mutate_(map15, f2);
}
function mutate_(map15, f2) {
  const transient = beginMutation(map15);
  f2(transient);
  return endMutation(transient);
}
function applyCont(cont) {
  return cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none;
}
function visitLazyChildren(len, children, i2, f2, cont) {
  while (i2 < len) {
    const child = children[i2++];
    if (child && !isEmptyNode(child)) {
      return visitLazy(child, f2, [len, children, i2, f2, cont]);
    }
  }
  return applyCont(cont);
}
function visitLazy(node, f2, cont = void 0) {
  switch (node._tag) {
    case "LeafNode": {
      return isSome(node.value) ? some({
        value: f2(tuple(node.key, node.value.value)),
        cont
      }) : applyCont(cont);
    }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode": {
      const children = node.children;
      return visitLazyChildren(children.length, children, 0, f2, cont);
    }
    default: {
      return applyCont(cont);
    }
  }
}
function keys2(map15) {
  return new HashMapIterator(map15, ([k2]) => k2);
}
function values(map15) {
  return new HashMapIterator(map15, ([, v2]) => v2);
}
function update_2(map15, key, f2) {
  return modify_(map15, key, map(f2));
}
function update2(key, f2) {
  return (map15) => update_2(map15, key, f2);
}
function reduceWithIndex_2(map15, z2, f2) {
  const root = map15.root;
  if (root._tag === "LeafNode")
    return isSome(root.value) ? f2(z2, root.key, root.value.value) : z2;
  if (root._tag === "Empty") {
    return z2;
  }
  const toVisit = [root.children];
  let children;
  while (children = toVisit.pop()) {
    for (let i2 = 0, len = children.length; i2 < len; ) {
      const child = children[i2++];
      if (child && !isEmptyNode(child)) {
        if (child._tag === "LeafNode") {
          if (isSome(child.value)) {
            z2 = f2(z2, child.key, child.value.value);
          }
        } else
          toVisit.push(child.children);
      }
    }
  }
  return z2;
}
function reduceWithIndex(z2, f2) {
  return (map15) => reduceWithIndex_2(map15, z2, f2);
}
function reduce_4(map15, z2, f2) {
  return reduceWithIndex_2(map15, z2, (z3, _2, v2) => f2(z3, v2));
}
function reduce2(z2, f2) {
  return (map15) => reduce_4(map15, z2, f2);
}
function forEachWithIndex_(map15, f2) {
  reduceWithIndex_2(map15, void 0, (_2, key, value) => f2(key, value));
}
function forEachWithIndex(f2) {
  return (map15) => forEachWithIndex_(map15, f2);
}
function forEach_(map15, f2) {
  forEachWithIndex_(map15, (_2, value) => f2(value));
}
function forEach(f2) {
  return (map15) => forEach_(map15, f2);
}
function mapWithIndex_(map15, f2) {
  return reduceWithIndex_2(map15, make(), (z2, k2, v2) => set_(z2, k2, f2(k2, v2)));
}
function mapWithIndex(f2) {
  return (map15) => mapWithIndex_(map15, f2);
}
function map_6(map15, f2) {
  return reduceWithIndex_2(map15, make(), (z2, k2, v2) => set_(z2, k2, f2(v2)));
}
function map3(f2) {
  return (map15) => map_6(map15, f2);
}
function chain_6(map15, f2) {
  return reduceWithIndex_2(map15, make(), (z2, _2, v2) => mutate_(z2, (m2) => {
    forEachWithIndex_(f2(v2), (_k, _a12) => {
      set_(m2, _k, _a12);
    });
  }));
}
function chain3(f2) {
  return (map15) => chain_6(map15, f2);
}
function chainWithIndex_(map15, f2) {
  return reduceWithIndex_2(map15, make(), (z2, k2, v2) => mutate_(z2, (m2) => {
    forEachWithIndex_(f2(k2, v2), (_k, _a12) => {
      set_(m2, _k, _a12);
    });
  }));
}
function chainWithIndex(f2) {
  return (map15) => chainWithIndex_(map15, f2);
}
function compact2(fa) {
  return filterMapWithIndex_(fa, (_2, a2) => a2);
}
function filterMapWithIndex_(fa, f2) {
  const m2 = make();
  return mutate_(m2, (m3) => {
    for (const [k2, a2] of fa) {
      const o2 = f2(k2, a2);
      if (isSome(o2)) {
        set_(m3, k2, o2.value);
      }
    }
  });
}
function filterMapWithIndex(f2) {
  return (fa) => filterMapWithIndex_(fa, f2);
}
function filterMap_(fa, f2) {
  return filterMapWithIndex_(fa, (_2, a2) => f2(a2));
}
function filterMap(f2) {
  return (fa) => filterMap_(fa, f2);
}
function filterWithIndex_(fa, p2) {
  const m2 = make();
  return mutate_(m2, (m3) => {
    for (const [k2, a2] of fa) {
      if (p2(k2, a2)) {
        set_(m3, k2, a2);
      }
    }
  });
}
function filterWithIndex(p2) {
  return (fa) => filterWithIndex_(fa, p2);
}
function filter_(fa, p2) {
  return filterWithIndex_(fa, (_2, a2) => p2(a2));
}
function filter(p2) {
  return (fa) => filter_(fa, p2);
}
function size(map15) {
  return map15.size;
}
function removeMany_(self, ks) {
  return mutate_(self, (m2) => {
    for (const k2 of ks) {
      remove_(m2, k2);
    }
  });
}
function removeMany(ks) {
  return (self) => removeMany_(self, ks);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/HashSet/index.mjs
var HashSet = class _HashSet {
  constructor(keyMap) {
    this.keyMap = keyMap;
  }
  [Symbol.iterator]() {
    return keys2(this.keyMap);
  }
  get [hashSym]() {
    return hashIterator(this[Symbol.iterator]());
  }
  [equalsSym](that) {
    return that instanceof _HashSet && that.keyMap.size === this.keyMap.size && corresponds(this, that, equals);
  }
};
function make2() {
  return new HashSet(make());
}
function add_(set3, v2) {
  return set3.keyMap.editable ? (set_(set3.keyMap, v2, true), set3) : new HashSet(set_(set3.keyMap, v2, true));
}
function forEach_2(map15, f2) {
  forEachWithIndex_(map15.keyMap, (k2) => {
    f2(k2);
  });
}
function mutate_2(set3, transient) {
  const s2 = beginMutation2(set3);
  transient(s2);
  return endMutation2(s2);
}
function size2(set3) {
  return size(set3.keyMap);
}
function beginMutation2(set3) {
  return new HashSet(beginMutation(set3.keyMap));
}
function endMutation2(set3) {
  set3.keyMap.editable = false;
  return set3;
}
function union_(l2, r2) {
  const x2 = make2();
  return mutate_2(x2, (x3) => {
    forEach_2(l2, (a2) => {
      add_(x3, a2);
    });
    for (const a2 of r2) {
      add_(x3, a2);
    }
  });
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/List/core.mjs
var branchingFactor = 32;
var branchBits = 5;
var mask = 31;
function createPath(depth, value) {
  let current = value;
  for (let i2 = 0; i2 < depth; ++i2) {
    current = new Node(void 0, [current]);
  }
  return current;
}
function copyArray(source) {
  const array2 = [];
  for (let i2 = 0; i2 < source.length; ++i2) {
    array2[i2] = source[i2];
  }
  return array2;
}
function pushElements(source, target, offset, amount) {
  for (let i2 = offset; i2 < offset + amount; ++i2) {
    target.push(source[i2]);
  }
}
function copyIndices(source, sourceStart, target, targetStart, length) {
  for (let i2 = 0; i2 < length; ++i2) {
    target[targetStart + i2] = source[sourceStart + i2];
  }
}
function arrayPrepend(value, array2) {
  const newLength = array2.length + 1;
  const result4 = new Array(newLength);
  result4[0] = value;
  for (let i2 = 1; i2 < newLength; ++i2) {
    result4[i2] = array2[i2 - 1];
  }
  return result4;
}
function reverseArray(array2) {
  return array2.slice().reverse();
}
function arrayFirst(array2) {
  return array2[0];
}
function arrayLast(array2) {
  return array2[array2.length - 1];
}
var pathResult = {
  path: 0,
  index: 0,
  updatedOffset: 0
};
function getPath(index, offset, depth, sizes) {
  if (sizes === void 0 && offset !== 0) {
    pathResult.updatedOffset = 0;
    index = handleOffset(depth, offset, index);
  }
  let path9 = index >> depth * branchBits & mask;
  if (sizes !== void 0) {
    while (sizes[path9] <= index) {
      path9++;
    }
    const traversed = path9 === 0 ? 0 : sizes[path9 - 1];
    index -= traversed;
    pathResult.updatedOffset = offset;
  }
  pathResult.path = path9;
  pathResult.index = index;
  return pathResult;
}
var Node = class {
  constructor(sizes, array2) {
    this.sizes = sizes;
    this.array = array2;
  }
};
function cloneNode({
  array: array2,
  sizes
}) {
  return new Node(sizes === void 0 ? void 0 : copyArray(sizes), copyArray(array2));
}
var emptyAffix = [0];
var affixBits = 6;
var affixMask = 63;
function getSuffixSize(l2) {
  return l2.bits & affixMask;
}
function getPrefixSize(l2) {
  return l2.bits >> affixBits & affixMask;
}
function getDepth(l2) {
  return l2.bits >> affixBits * 2;
}
function setPrefix(size7, bits) {
  return size7 << affixBits | bits & ~(affixMask << affixBits);
}
function setSuffix(size7, bits) {
  return size7 | bits & ~affixMask;
}
function setDepth(depth, bits) {
  return depth << affixBits * 2 | bits & (affixMask | affixMask << affixBits);
}
function incrementPrefix(bits) {
  return bits + (1 << affixBits);
}
function incrementSuffix(bits) {
  return bits + 1;
}
function incrementDepth(bits) {
  return bits + (1 << affixBits * 2);
}
function decrementDepth(bits) {
  return bits - (1 << affixBits * 2);
}
var List = class _List {
  constructor(bits, offset, length, prefix, root, suffix) {
    this.bits = bits;
    this.offset = offset;
    this.length = length;
    this.prefix = prefix;
    this.root = root;
    this.suffix = suffix;
  }
  [Symbol.iterator]() {
    return new ForwardListIterator(this);
  }
  toJSON() {
    return toArray(this);
  }
  [equalsSym](that) {
    return that instanceof _List && equalsWith_(this, that, equals);
  }
  get [hashSym]() {
    return hashIterator(this[Symbol.iterator]());
  }
};
function cloneList(l2) {
  return new List(l2.bits, l2.offset, l2.length, l2.prefix, l2.root, l2.suffix);
}
var ListIterator = class {
  constructor(l2, direction) {
    this.l = l2;
    this.result = {
      done: false,
      value: void 0
    };
    this.idx = direction === 1 ? -1 : l2.length;
    this.prefixSize = getPrefixSize(l2);
    this.middleSize = l2.length - getSuffixSize(l2);
    if (l2.root !== void 0) {
      const depth = getDepth(l2);
      this.stack = new Array(depth + 1);
      this.indices = new Array(depth + 1);
      let currentNode = l2.root.array;
      for (let i2 = depth; 0 <= i2; --i2) {
        this.stack[i2] = currentNode;
        const idx = direction === 1 ? 0 : currentNode.length - 1;
        this.indices[i2] = idx;
        currentNode = currentNode[idx].array;
      }
      this.indices[0] -= direction;
    }
  }
};
var ForwardListIterator = class extends ListIterator {
  constructor(l2) {
    super(l2, 1);
  }
  nextInTree() {
    for (var i2 = 0; ++this.indices[i2] === this.stack[i2].length; ++i2) {
      this.indices[i2] = 0;
    }
    for (; 0 < i2; --i2) {
      this.stack[i2 - 1] = this.stack[i2][this.indices[i2]].array;
    }
  }
  next() {
    let newVal;
    const idx = ++this.idx;
    if (idx < this.prefixSize) {
      newVal = this.l.prefix[this.prefixSize - idx - 1];
    } else if (idx < this.middleSize) {
      this.nextInTree();
      newVal = this.stack[0][this.indices[0]];
    } else if (idx < this.l.length) {
      newVal = this.l.suffix[idx - this.middleSize];
    } else {
      this.result.done = true;
    }
    this.result.value = newVal;
    return this.result;
  }
};
function emptyPushable() {
  return new List(0, 0, 0, [], void 0, []);
}
function push_(l2, value) {
  const suffixSize = getSuffixSize(l2);
  if (l2.length === 0) {
    l2.bits = setPrefix(1, l2.bits);
    l2.prefix = [value];
  } else if (suffixSize < 32) {
    l2.bits = incrementSuffix(l2.bits);
    l2.suffix.push(value);
  } else if (l2.root === void 0) {
    l2.root = new Node(void 0, l2.suffix);
    l2.suffix = [value];
    l2.bits = setSuffix(1, l2.bits);
  } else {
    const newNode = new Node(void 0, l2.suffix);
    const index = l2.length - 1 - 32 + 1;
    let current = l2.root;
    let depth = getDepth(l2);
    l2.suffix = [value];
    l2.bits = setSuffix(1, l2.bits);
    if (index - 1 < branchingFactor ** (depth + 1)) {
      for (; depth >= 0; --depth) {
        const path9 = index >> depth * branchBits & mask;
        if (path9 < current.array.length) {
          current = current.array[path9];
        } else {
          current.array.push(createPath(depth - 1, newNode));
          break;
        }
      }
    } else {
      l2.bits = incrementDepth(l2.bits);
      l2.root = new Node(void 0, [l2.root, createPath(depth, newNode)]);
    }
  }
  l2.length++;
  return l2;
}
function list(...elements) {
  const l2 = emptyPushable();
  for (const element of elements) {
    push_(l2, element);
  }
  return l2;
}
function empty2() {
  return new List(0, 0, 0, emptyAffix, void 0, emptyAffix);
}
function of(a2) {
  return list(a2);
}
function from2(sequence3) {
  const l2 = emptyPushable();
  if (sequence3.length > 0 && (sequence3[0] !== void 0 || 0 in sequence3)) {
    for (let i2 = 0; i2 < sequence3.length; ++i2) {
      push_(l2, sequence3[i2]);
    }
  } else if (Symbol.iterator in sequence3) {
    const iterator = sequence3[Symbol.iterator]();
    let cur;
    while (!(cur = iterator.next()).done) {
      push_(l2, cur.value);
    }
  }
  return l2;
}
function range_(start, end4) {
  const list2 = emptyPushable();
  for (let i2 = start; i2 < end4; ++i2) {
    push_(list2, i2);
  }
  return list2;
}
function handleOffset(depth, offset, index) {
  index += offset;
  for (; depth >= 0; --depth) {
    index = index - (offset & mask << depth * branchBits);
    if ((index >> depth * branchBits & mask) !== 0) {
      break;
    }
  }
  return index;
}
function setSizes(node, height) {
  let sum3 = 0;
  const sizeTable = [];
  for (let i2 = 0; i2 < node.array.length; ++i2) {
    sum3 += sizeOfSubtree(node.array[i2], height - 1);
    sizeTable[i2] = sum3;
  }
  node.sizes = sizeTable;
  return node;
}
function sizeOfSubtree(node, height) {
  if (height !== 0) {
    if (node.sizes !== void 0) {
      return arrayLast(node.sizes);
    } else {
      const lastSize = sizeOfSubtree(arrayLast(node.array), height - 1);
      return (node.array.length - 1 << height * branchBits) + lastSize;
    }
  } else {
    return node.array.length;
  }
}
function affixPush(a2, array2, length) {
  if (array2.length === length) {
    array2.push(a2);
    return array2;
  } else {
    const newArray = [];
    copyIndices(array2, 0, newArray, 0, length);
    newArray.push(a2);
    return newArray;
  }
}
function prepend_2(l2, value) {
  const prefixSize = getPrefixSize(l2);
  if (prefixSize < 32) {
    return new List(incrementPrefix(l2.bits), l2.offset, l2.length + 1, affixPush(value, l2.prefix, prefixSize), l2.root, l2.suffix);
  } else {
    const newList = cloneList(l2);
    prependNodeToTree(newList, reverseArray(l2.prefix));
    const newPrefix = [value];
    newList.prefix = newPrefix;
    newList.length++;
    newList.bits = setPrefix(1, newList.bits);
    return newList;
  }
}
function copyLeft(l2, k2) {
  let currentNode = cloneNode(l2.root);
  l2.root = currentNode;
  for (let i2 = 1; i2 < k2; ++i2) {
    const index = 0;
    if (currentNode.sizes !== void 0) {
      for (let i3 = 0; i3 < currentNode.sizes.length; ++i3) {
        currentNode.sizes[i3] += 32;
      }
    }
    const newNode = cloneNode(currentNode.array[index]);
    currentNode.array[index] = newNode;
    currentNode = newNode;
  }
  return currentNode;
}
function nodePrepend(value, size7, node) {
  const array2 = arrayPrepend(value, node.array);
  let sizes = void 0;
  if (node.sizes !== void 0) {
    sizes = new Array(node.sizes.length + 1);
    sizes[0] = size7;
    for (let i2 = 0; i2 < node.sizes.length; ++i2) {
      sizes[i2 + 1] = node.sizes[i2] + size7;
    }
  }
  return new Node(sizes, array2);
}
function prependTopTree(l2, depth, node) {
  let newOffset2;
  if (l2.root.array.length < branchingFactor) {
    newOffset2 = 32 ** depth - 32;
    l2.root = new Node(void 0, arrayPrepend(createPath(depth - 1, node), l2.root.array));
  } else {
    l2.bits = incrementDepth(l2.bits);
    const sizes = l2.root.sizes === void 0 ? void 0 : [32, arrayLast(l2.root.sizes) + 32];
    newOffset2 = depth === 0 ? 0 : 32 ** (depth + 1) - 32;
    l2.root = new Node(sizes, [createPath(depth, node), l2.root]);
  }
  return newOffset2;
}
function prependNodeToTree(l2, array2) {
  if (l2.root === void 0) {
    if (getSuffixSize(l2) === 0) {
      l2.bits = setSuffix(array2.length, l2.bits);
      l2.suffix = array2;
    } else {
      l2.root = new Node(void 0, array2);
    }
    return l2;
  } else {
    const node = new Node(void 0, array2);
    const depth = getDepth(l2);
    let newOffset2 = 0;
    if (l2.root.sizes === void 0) {
      if (l2.offset !== 0) {
        newOffset2 = l2.offset - branchingFactor;
        l2.root = prependDense(l2.root, depth, l2.offset, node);
      } else {
        newOffset2 = prependTopTree(l2, depth, node);
      }
    } else {
      let copyableCount = 0;
      let nodesTraversed = 0;
      let currentNode = l2.root;
      while (currentNode.sizes !== void 0 && nodesTraversed < depth) {
        ++nodesTraversed;
        if (currentNode.array.length < 32) {
          copyableCount = nodesTraversed;
        }
        currentNode = currentNode.array[0];
      }
      if (l2.offset !== 0) {
        const copiedNode = copyLeft(l2, nodesTraversed);
        for (let i2 = 0; i2 < copiedNode.sizes.length; ++i2) {
          copiedNode.sizes[i2] += branchingFactor;
        }
        copiedNode.array[0] = prependDense(copiedNode.array[0], depth - nodesTraversed, l2.offset, node);
        l2.offset = l2.offset - branchingFactor;
        return l2;
      } else {
        if (copyableCount === 0) {
          l2.offset = prependTopTree(l2, depth, node);
        } else {
          let parent;
          let prependableNode;
          if (copyableCount > 1) {
            parent = copyLeft(l2, copyableCount - 1);
            prependableNode = parent.array[0];
          } else {
            parent = void 0;
            prependableNode = l2.root;
          }
          const path9 = createPath(depth - copyableCount, node);
          l2.offset = 32 ** (depth - copyableCount + 1) - 32;
          const prepended = nodePrepend(path9, 32, prependableNode);
          if (parent === void 0) {
            l2.root = prepended;
          } else {
            parent.array[0] = prepended;
          }
        }
        return l2;
      }
    }
    l2.offset = newOffset2;
    return l2;
  }
}
function prependDense(node, depth, offset, value) {
  const curOffset = offset >> depth * branchBits & mask;
  const path9 = (offset - 1 >> depth * branchBits & mask) - curOffset;
  if (path9 < 0) {
    return new Node(void 0, arrayPrepend(createPath(depth - 1, value), node.array));
  } else {
    const array2 = copyArray(node.array);
    array2[0] = prependDense(array2[0], depth - 1, offset, value);
    return new Node(void 0, array2);
  }
}
function append_3(l2, value) {
  const suffixSize = getSuffixSize(l2);
  if (suffixSize < 32) {
    return new List(incrementSuffix(l2.bits), l2.offset, l2.length + 1, l2.prefix, l2.root, affixPush(value, l2.suffix, suffixSize));
  }
  const newSuffix = [value];
  const newList = cloneList(l2);
  appendNodeToTree(newList, l2.suffix);
  newList.suffix = newSuffix;
  newList.length++;
  newList.bits = setSuffix(1, newList.bits);
  return newList;
}
function size3(l2) {
  return l2.length;
}
function unsafeFirst(l2) {
  return toUndefined(first(l2));
}
function first(l2) {
  const prefixSize = getPrefixSize(l2);
  return prefixSize !== 0 ? some(l2.prefix[prefixSize - 1]) : l2.length !== 0 ? some(l2.suffix[0]) : none;
}
function unsafeLast(l2) {
  return toUndefined(last(l2));
}
function last(l2) {
  const suffixSize = getSuffixSize(l2);
  return suffixSize !== 0 ? some(l2.suffix[suffixSize - 1]) : l2.length !== 0 ? some(l2.prefix[0]) : none;
}
function mapArray(f2, array2) {
  const result4 = new Array(array2.length);
  for (let i2 = 0; i2 < array2.length; ++i2) {
    result4[i2] = f2(array2[i2]);
  }
  return result4;
}
function mapNode(f2, node, depth) {
  if (depth !== 0) {
    const {
      array: array2
    } = node;
    const result4 = new Array(array2.length);
    for (let i2 = 0; i2 < array2.length; ++i2) {
      result4[i2] = mapNode(f2, array2[i2], depth - 1);
    }
    return new Node(node.sizes, result4);
  } else {
    return new Node(void 0, mapArray(f2, node.array));
  }
}
function mapPrefix(f2, prefix, length) {
  const newPrefix = new Array(length);
  for (let i2 = length - 1; 0 <= i2; --i2) {
    newPrefix[i2] = f2(prefix[i2]);
  }
  return newPrefix;
}
function mapAffix(f2, suffix, length) {
  const newSuffix = new Array(length);
  for (let i2 = 0; i2 < length; ++i2) {
    newSuffix[i2] = f2(suffix[i2]);
  }
  return newSuffix;
}
function map_7(l2, f2) {
  return new List(l2.bits, l2.offset, l2.length, mapPrefix(f2, l2.prefix, getPrefixSize(l2)), l2.root === void 0 ? void 0 : mapNode(f2, l2.root, getDepth(l2)), mapAffix(f2, l2.suffix, getSuffixSize(l2)));
}
function map4(f2) {
  return (l2) => new List(l2.bits, l2.offset, l2.length, mapPrefix(f2, l2.prefix, getPrefixSize(l2)), l2.root === void 0 ? void 0 : mapNode(f2, l2.root, getDepth(l2)), mapAffix(f2, l2.suffix, getSuffixSize(l2)));
}
function foldlSuffix(f2, acc, array2, length) {
  for (let i2 = 0; i2 < length; ++i2) {
    acc = f2(acc, array2[i2]);
  }
  return acc;
}
function foldlPrefix(f2, acc, array2, length) {
  for (let i2 = length - 1; 0 <= i2; --i2) {
    acc = f2(acc, array2[i2]);
  }
  return acc;
}
function foldlNode(f2, acc, node, depth) {
  const {
    array: array2
  } = node;
  if (depth === 0) {
    return foldlSuffix(f2, acc, array2, array2.length);
  }
  for (let i2 = 0; i2 < array2.length; ++i2) {
    acc = foldlNode(f2, acc, array2[i2], depth - 1);
  }
  return acc;
}
function reduce_5(l2, initial2, f2) {
  const suffixSize = getSuffixSize(l2);
  const prefixSize = getPrefixSize(l2);
  initial2 = foldlPrefix(f2, initial2, l2.prefix, prefixSize);
  if (l2.root !== void 0) {
    initial2 = foldlNode(f2, initial2, l2.root, getDepth(l2));
  }
  return foldlSuffix(f2, initial2, l2.suffix, suffixSize);
}
function filter_2(l2, predicate) {
  return reduce_5(l2, emptyPushable(), (acc, a2) => predicate(a2) ? push_(acc, a2) : acc);
}
function foldrSuffix(f2, initial2, array2, length) {
  let acc = initial2;
  for (let i2 = length - 1; 0 <= i2; --i2) {
    acc = f2(array2[i2], acc);
  }
  return acc;
}
function foldrPrefix(f2, initial2, array2, length) {
  let acc = initial2;
  for (let i2 = 0; i2 < length; ++i2) {
    acc = f2(array2[i2], acc);
  }
  return acc;
}
function foldrNode(f2, initial2, {
  array: array2
}, depth) {
  if (depth === 0) {
    return foldrSuffix(f2, initial2, array2, array2.length);
  }
  let acc = initial2;
  for (let i2 = array2.length - 1; 0 <= i2; --i2) {
    acc = foldrNode(f2, acc, array2[i2], depth - 1);
  }
  return acc;
}
function reduceRight_4(l2, initial2, f2) {
  const suffixSize = getSuffixSize(l2);
  const prefixSize = getPrefixSize(l2);
  let acc = foldrSuffix(f2, initial2, l2.suffix, suffixSize);
  if (l2.root !== void 0) {
    acc = foldrNode(f2, acc, l2.root, getDepth(l2));
  }
  return foldrPrefix(f2, acc, l2.prefix, prefixSize);
}
function foldlArrayCb(cb, state, array2, from4, to2) {
  for (var i2 = from4; i2 < to2 && cb(array2[i2], state); ++i2) {
  }
  return i2 === to2;
}
function foldrArrayCb(cb, state, array2, from4, to2) {
  for (var i2 = from4 - 1; to2 <= i2 && cb(array2[i2], state); --i2) {
  }
  return i2 === to2 - 1;
}
function foldlNodeCb(cb, state, node, depth) {
  const {
    array: array2
  } = node;
  if (depth === 0) {
    return foldlArrayCb(cb, state, array2, 0, array2.length);
  }
  const to2 = array2.length;
  for (let i2 = 0; i2 < to2; ++i2) {
    if (!foldlNodeCb(cb, state, array2[i2], depth - 1)) {
      return false;
    }
  }
  return true;
}
function foldlCb(cb, state, l2) {
  const prefixSize = getPrefixSize(l2);
  if (!foldrArrayCb(cb, state, l2.prefix, prefixSize, 0) || l2.root !== void 0 && !foldlNodeCb(cb, state, l2.root, getDepth(l2))) {
    return state;
  }
  const suffixSize = getSuffixSize(l2);
  foldlArrayCb(cb, state, l2.suffix, 0, suffixSize);
  return state;
}
function findCb(value, state) {
  if (state.predicate(value)) {
    state.result = some(value);
    return false;
  } else {
    return true;
  }
}
function find_(l2, predicate) {
  return foldlCb(findCb, {
    predicate,
    result: none
  }, l2).result;
}
function equalsCb(value2, state) {
  const {
    value
  } = state.iterator.next();
  return state.equals = state.f(value, value2);
}
function equalsWith_(l1, l2, f2) {
  if (l1 === l2) {
    return true;
  } else if (l1.length !== l2.length) {
    return false;
  } else {
    const s2 = {
      iterator: l2[Symbol.iterator](),
      equals: true,
      f: f2
    };
    return foldlCb(equalsCb, s2, l1).equals;
  }
}
var eMax = 2;
function createConcatPlan(array2) {
  const sizes = [];
  let sum3 = 0;
  for (let i3 = 0; i3 < array2.length; ++i3) {
    sum3 += array2[i3].array.length;
    sizes[i3] = array2[i3].array.length;
  }
  const optimalLength = Math.ceil(sum3 / branchingFactor);
  let n2 = array2.length;
  let i2 = 0;
  if (optimalLength + eMax >= n2) {
    return void 0;
  }
  while (optimalLength + eMax < n2) {
    while (sizes[i2] > branchingFactor - eMax / 2) {
      ++i2;
    }
    let remaining = sizes[i2];
    do {
      const size7 = Math.min(remaining + sizes[i2 + 1], branchingFactor);
      sizes[i2] = size7;
      remaining = remaining - (size7 - sizes[i2 + 1]);
      ++i2;
    } while (remaining > 0);
    for (let j2 = i2; j2 <= n2 - 1; ++j2) {
      sizes[j2] = sizes[j2 + 1];
    }
    --i2;
    --n2;
  }
  sizes.length = n2;
  return sizes;
}
function concatNodeMerge(left4, center, right5) {
  const array2 = [];
  if (left4 !== void 0) {
    for (let i2 = 0; i2 < left4.array.length - 1; ++i2) {
      array2.push(left4.array[i2]);
    }
  }
  for (let i2 = 0; i2 < center.array.length; ++i2) {
    array2.push(center.array[i2]);
  }
  if (right5 !== void 0) {
    for (let i2 = 1; i2 < right5.array.length; ++i2) {
      array2.push(right5.array[i2]);
    }
  }
  return array2;
}
function executeConcatPlan(merged, plan, height) {
  const result4 = [];
  let sourceIdx = 0;
  let offset = 0;
  for (let toMove of plan) {
    let source = merged[sourceIdx].array;
    if (toMove === source.length && offset === 0) {
      result4.push(merged[sourceIdx]);
      ++sourceIdx;
    } else {
      const node = new Node(void 0, []);
      while (toMove > 0) {
        const available = source.length - offset;
        const itemsToCopy = Math.min(toMove, available);
        pushElements(source, node.array, offset, itemsToCopy);
        if (toMove >= available) {
          ++sourceIdx;
          source = merged[sourceIdx].array;
          offset = 0;
        } else {
          offset += itemsToCopy;
        }
        toMove -= itemsToCopy;
      }
      if (height > 1) {
        setSizes(node, height - 1);
      }
      result4.push(node);
    }
  }
  return result4;
}
function rebalance(left4, center, right5, height, top) {
  const merged = concatNodeMerge(left4, center, right5);
  const plan = createConcatPlan(merged);
  const balanced = plan !== void 0 ? executeConcatPlan(merged, plan, height) : merged;
  if (balanced.length <= branchingFactor) {
    if (top === true) {
      return new Node(void 0, balanced);
    } else {
      return new Node(void 0, [setSizes(new Node(void 0, balanced), height)]);
    }
  } else {
    return new Node(void 0, [setSizes(new Node(void 0, balanced.slice(0, branchingFactor)), height), setSizes(new Node(void 0, balanced.slice(branchingFactor)), height)]);
  }
}
function concatSubTree(left4, lDepth, right5, rDepth, isTop) {
  if (lDepth > rDepth) {
    const c2 = concatSubTree(arrayLast(left4.array), lDepth - 1, right5, rDepth, false);
    return rebalance(left4, c2, void 0, lDepth, isTop);
  } else if (lDepth < rDepth) {
    const c2 = concatSubTree(left4, lDepth, arrayFirst(right5.array), rDepth - 1, false);
    return rebalance(void 0, c2, right5, rDepth, isTop);
  } else if (lDepth === 0) {
    return new Node(void 0, [left4, right5]);
  } else {
    const c2 = concatSubTree(arrayLast(left4.array), lDepth - 1, arrayFirst(right5.array), rDepth - 1, false);
    return rebalance(left4, c2, right5, lDepth, isTop);
  }
}
function getHeight(node) {
  if (node.array[0] instanceof Node) {
    return 1 + getHeight(node.array[0]);
  } else {
    return 0;
  }
}
function appendNodeToTree(l2, array2) {
  if (l2.root === void 0) {
    if (getPrefixSize(l2) === 0) {
      l2.bits = setPrefix(array2.length, l2.bits);
      l2.prefix = reverseArray(array2);
    } else {
      l2.root = new Node(void 0, array2);
    }
    return l2;
  }
  const depth = getDepth(l2);
  let index = handleOffset(depth, l2.offset, l2.length - 1 - getPrefixSize(l2));
  let nodesToCopy = 0;
  let nodesVisited = 0;
  let shift = depth * 5;
  let currentNode = l2.root;
  if (32 ** (depth + 1) < index) {
    shift = 0;
    nodesVisited = depth;
  }
  while (shift > 5) {
    let childIndex;
    if (currentNode.sizes === void 0) {
      childIndex = index >> shift & mask;
      index &= ~(mask << shift);
    } else {
      childIndex = currentNode.array.length - 1;
      index -= currentNode.sizes[childIndex - 1];
    }
    nodesVisited++;
    if (childIndex < mask) {
      nodesToCopy = nodesVisited;
    }
    currentNode = currentNode.array[childIndex];
    if (currentNode === void 0) {
      nodesToCopy = nodesVisited;
      shift = 5;
    }
    shift -= 5;
  }
  if (shift !== 0) {
    nodesVisited++;
    if (currentNode.array.length < branchingFactor) {
      nodesToCopy = nodesVisited;
    }
  }
  const node = new Node(void 0, array2);
  if (nodesToCopy === 0) {
    const newPath = nodesVisited === 0 ? node : createPath(nodesVisited, node);
    const newRoot = new Node(void 0, [l2.root, newPath]);
    l2.root = newRoot;
    l2.bits = incrementDepth(l2.bits);
  } else {
    const copiedNode = copyFirstK(l2, nodesToCopy, array2.length);
    copiedNode.array.push(createPath(depth - nodesToCopy, node));
  }
  return l2;
}
function copyFirstK(newList, k2, leafSize) {
  let currentNode = cloneNode(newList.root);
  newList.root = currentNode;
  for (let i2 = 1; i2 < k2; ++i2) {
    const index = currentNode.array.length - 1;
    if (currentNode.sizes !== void 0) {
      currentNode.sizes[index] += leafSize;
    }
    const newNode = cloneNode(currentNode.array[index]);
    currentNode.array[index] = newNode;
    currentNode = newNode;
  }
  if (currentNode.sizes !== void 0) {
    currentNode.sizes.push(arrayLast(currentNode.sizes) + leafSize);
  }
  return currentNode;
}
var concatBuffer = /* @__PURE__ */ new Array(3);
function concatAffixes(left4, right5) {
  let nr = 0;
  let arrIdx = 0;
  let i2 = 0;
  let length = getSuffixSize(left4);
  concatBuffer[nr] = [];
  for (i2 = 0; i2 < length; ++i2) {
    concatBuffer[nr][arrIdx++] = left4.suffix[i2];
  }
  length = getPrefixSize(right5);
  for (i2 = 0; i2 < length; ++i2) {
    if (arrIdx === 32) {
      arrIdx = 0;
      ++nr;
      concatBuffer[nr] = [];
    }
    concatBuffer[nr][arrIdx++] = right5.prefix[length - 1 - i2];
  }
  length = getSuffixSize(right5);
  for (i2 = 0; i2 < length; ++i2) {
    if (arrIdx === 32) {
      arrIdx = 0;
      ++nr;
      concatBuffer[nr] = [];
    }
    concatBuffer[nr][arrIdx++] = right5.suffix[i2];
  }
  return nr;
}
function concat_2(left4, right5) {
  if (left4.length === 0) {
    return right5;
  } else if (right5.length === 0) {
    return left4;
  }
  const newSize = left4.length + right5.length;
  const rightSuffixSize = getSuffixSize(right5);
  let newList = cloneList(left4);
  if (right5.root === void 0) {
    const nrOfAffixes = concatAffixes(left4, right5);
    for (let i2 = 0; i2 < nrOfAffixes; ++i2) {
      newList = appendNodeToTree(newList, concatBuffer[i2]);
      newList.length += concatBuffer[i2].length;
      concatBuffer[i2] = void 0;
    }
    newList.length = newSize;
    newList.suffix = concatBuffer[nrOfAffixes];
    newList.bits = setSuffix(concatBuffer[nrOfAffixes].length, newList.bits);
    concatBuffer[nrOfAffixes] = void 0;
    return newList;
  } else {
    const leftSuffixSize = getSuffixSize(left4);
    if (leftSuffixSize > 0) {
      newList = appendNodeToTree(newList, left4.suffix.slice(0, leftSuffixSize));
      newList.length += leftSuffixSize;
    }
    newList = appendNodeToTree(newList, right5.prefix.slice(0, getPrefixSize(right5)).reverse());
    const newNode = concatSubTree(newList.root, getDepth(newList), right5.root, getDepth(right5), true);
    const newDepth = getHeight(newNode);
    setSizes(newNode, newDepth);
    newList.root = newNode;
    newList.offset &= ~(mask << getDepth(left4) * branchBits);
    newList.length = newSize;
    newList.bits = setSuffix(rightSuffixSize, setDepth(newDepth, newList.bits));
    newList.suffix = right5.suffix;
    return newList;
  }
}
var newAffix;
function sliceNode(node, index, depth, pathLeft, pathRight, childLeft, childRight) {
  const array2 = node.array.slice(pathLeft, pathRight + 1);
  if (childLeft !== void 0) {
    array2[0] = childLeft;
  }
  if (childRight !== void 0) {
    array2[array2.length - 1] = childRight;
  }
  let sizes = node.sizes;
  if (sizes !== void 0) {
    sizes = sizes.slice(pathLeft, pathRight + 1);
    let slicedOffLeft = pathLeft !== 0 ? node.sizes[pathLeft - 1] : 0;
    if (childLeft !== void 0) {
      if (childLeft.sizes !== void 0) {
        const oldChild = node.array[pathLeft];
        slicedOffLeft += arrayLast(oldChild.sizes) - arrayLast(childLeft.sizes);
      } else {
        slicedOffLeft += (index - slicedOffLeft & ~31) + 32;
      }
    }
    for (let i2 = 0; i2 < sizes.length; ++i2) {
      sizes[i2] -= slicedOffLeft;
    }
    if (childRight !== void 0) {
      const slicedOffRight = sizeOfSubtree(node.array[pathRight], depth - 1) - sizeOfSubtree(childRight, depth - 1);
      sizes[sizes.length - 1] -= slicedOffRight;
    }
  }
  return new Node(sizes, array2);
}
var newOffset = 0;
function sliceLeft(tree, depth, index, offset, top) {
  let {
    index: newIndex,
    path: path9,
    updatedOffset
  } = getPath(index, offset, depth, tree.sizes);
  if (depth === 0) {
    newAffix = tree.array.slice(path9).reverse();
    return void 0;
  } else {
    const child = sliceLeft(tree.array[path9], depth - 1, newIndex, updatedOffset, false);
    if (child === void 0) {
      ++path9;
      if (path9 === tree.array.length) {
        return void 0;
      }
    }
    if (tree.sizes === void 0 && top === false) {
      newOffset |= 32 - (tree.array.length - path9) << depth * branchBits;
    }
    return sliceNode(tree, index, depth, path9, tree.array.length - 1, child, void 0);
  }
}
function sliceRight(node, depth, index, offset) {
  let {
    index: newIndex,
    path: path9
  } = getPath(index, offset, depth, node.sizes);
  if (depth === 0) {
    newAffix = node.array.slice(0, path9 + 1);
    return void 0;
  } else {
    const child = sliceRight(node.array[path9], depth - 1, newIndex, path9 === 0 ? offset : 0);
    if (child === void 0) {
      --path9;
      if (path9 === -1) {
        return void 0;
      }
    }
    const array2 = node.array.slice(0, path9 + 1);
    if (child !== void 0) {
      array2[array2.length - 1] = child;
    }
    let sizes = node.sizes;
    if (sizes !== void 0) {
      sizes = sizes.slice(0, path9 + 1);
      if (child !== void 0) {
        const slicedOff = sizeOfSubtree(node.array[path9], depth - 1) - sizeOfSubtree(child, depth - 1);
        sizes[sizes.length - 1] -= slicedOff;
      }
    }
    return new Node(sizes, array2);
  }
}
function sliceTreeList(from4, to2, tree, depth, offset, l2) {
  const sizes = tree.sizes;
  let {
    index: newFrom,
    path: pathLeft
  } = getPath(from4, offset, depth, sizes);
  let {
    index: newTo,
    path: pathRight
  } = getPath(to2, offset, depth, sizes);
  if (depth === 0) {
    l2.prefix = emptyAffix;
    l2.suffix = tree.array.slice(pathLeft, pathRight + 1);
    l2.root = void 0;
    l2.bits = setSuffix(pathRight - pathLeft + 1, 0);
    return l2;
  } else if (pathLeft === pathRight) {
    l2.bits = decrementDepth(l2.bits);
    return sliceTreeList(newFrom, newTo, tree.array[pathLeft], depth - 1, pathLeft === 0 ? offset : 0, l2);
  } else {
    const childRight = sliceRight(tree.array[pathRight], depth - 1, newTo, 0);
    l2.bits = setSuffix(newAffix.length, l2.bits);
    l2.suffix = newAffix;
    if (childRight === void 0) {
      --pathRight;
    }
    newOffset = 0;
    const childLeft = sliceLeft(tree.array[pathLeft], depth - 1, newFrom, pathLeft === 0 ? offset : 0, pathLeft === pathRight);
    l2.offset = newOffset;
    l2.bits = setPrefix(newAffix.length, l2.bits);
    l2.prefix = newAffix;
    if (childLeft === void 0) {
      ++pathLeft;
    }
    if (pathLeft >= pathRight) {
      if (pathLeft > pathRight) {
        l2.bits = setDepth(0, l2.bits);
        l2.root = void 0;
      } else {
        l2.bits = decrementDepth(l2.bits);
        const newRoot = childRight !== void 0 ? childRight : childLeft !== void 0 ? childLeft : tree.array[pathLeft];
        l2.root = new Node(newRoot.sizes, newRoot.array);
      }
    } else {
      l2.root = sliceNode(tree, from4, depth, pathLeft, pathRight, childLeft, childRight);
    }
    return l2;
  }
}
function slice_(l2, from4, to2) {
  let {
    bits,
    length
  } = l2;
  to2 = Math.min(length, to2);
  if (from4 < 0) {
    from4 = length + from4;
  }
  if (to2 < 0) {
    to2 = length + to2;
  }
  if (to2 <= from4 || to2 <= 0 || length <= from4) {
    return empty2();
  }
  if (from4 <= 0 && length <= to2) {
    return l2;
  }
  const newLength = to2 - from4;
  let prefixSize = getPrefixSize(l2);
  const suffixSize = getSuffixSize(l2);
  if (to2 <= prefixSize) {
    return new List(setPrefix(newLength, 0), 0, newLength, l2.prefix.slice(prefixSize - to2, prefixSize - from4), void 0, emptyAffix);
  }
  const suffixStart = length - suffixSize;
  if (suffixStart <= from4) {
    return new List(setSuffix(newLength, 0), 0, newLength, emptyAffix, void 0, l2.suffix.slice(from4 - suffixStart, to2 - suffixStart));
  }
  const newList = cloneList(l2);
  newList.length = newLength;
  if (prefixSize <= from4 && to2 <= suffixStart) {
    sliceTreeList(from4 - prefixSize + l2.offset, to2 - prefixSize + l2.offset - 1, l2.root, getDepth(l2), l2.offset, newList);
    return newList;
  }
  if (0 < from4) {
    if (from4 < prefixSize) {
      newList.prefix = l2.prefix.slice(0, prefixSize - from4);
      bits = setPrefix(prefixSize - from4, bits);
    } else {
      newOffset = 0;
      newList.root = sliceLeft(newList.root, getDepth(l2), from4 - prefixSize, l2.offset, true);
      newList.offset = newOffset;
      if (newList.root === void 0) {
        bits = setDepth(0, bits);
      }
      bits = setPrefix(newAffix.length, bits);
      prefixSize = newAffix.length;
      newList.prefix = newAffix;
    }
  }
  if (to2 < length) {
    if (length - to2 < suffixSize) {
      bits = setSuffix(suffixSize - (length - to2), bits);
      newList.suffix = l2.suffix.slice(0, suffixSize - (length - to2));
    } else {
      newList.root = sliceRight(newList.root, getDepth(l2), to2 - prefixSize - 1, newList.offset);
      if (newList.root === void 0) {
        bits = setDepth(0, bits);
        newList.offset = 0;
      }
      bits = setSuffix(newAffix.length, bits);
      newList.suffix = newAffix;
    }
  }
  newList.bits = bits;
  return newList;
}
function take_(l2, n2) {
  return slice_(l2, 0, n2);
}
function tail(l2) {
  return slice_(l2, 1, l2.length);
}
function arrayPush(array2, a2) {
  array2.push(a2);
  return array2;
}
function toArray(l2) {
  return reduce_5(l2, [], arrayPush);
}
function reverse2(l2) {
  return reduce_5(l2, empty2(), (newL, element) => prepend_2(newL, element));
}
function isEmpty3(l2) {
  return l2.length === 0;
}

// node_modules/@effect-ts/system/_mjs/Support/AtomicReference/index.mjs
var AtomicReference = class {
  constructor(initial2) {
    this.initial = initial2;
    this.current = initial2;
  }
  get get() {
    return this.current;
  }
  getAndSet(value) {
    const old = this.current;
    this.set(value);
    return old;
  }
  set(value) {
    this.current = value;
  }
  compareAndSet(old, value) {
    if (this.get === old) {
      this.set(value);
      return true;
    }
    return false;
  }
};

// node_modules/@effect-ts/system/_mjs/Support/AtomicNumber/index.mjs
var AtomicNumber = class extends AtomicReference {
  constructor(n2) {
    super(n2);
    this.incrementAndGet = this.incrementAndGet.bind(this);
    this.decrementAndGet = this.decrementAndGet.bind(this);
  }
  incrementAndGet() {
    this.set(this.get + 1);
    return this.get;
  }
  decrementAndGet() {
    this.set(this.get - 1);
    return this.get;
  }
  getAndIncrement() {
    const ret = this.get;
    this.set(this.get + 1);
    return ret;
  }
};

// node_modules/@effect-ts/system/_mjs/Fiber/id.mjs
function FiberID(startTimeMillis, seqNumber) {
  return {
    _tag: "FiberID",
    seqNumber,
    startTimeMillis
  };
}
var None2 = /* @__PURE__ */ FiberID(0, 0);
function equalsFiberID(x2, y2) {
  return x2.seqNumber === y2.seqNumber && x2.startTimeMillis === y2.startTimeMillis;
}
var _fiberCounter = /* @__PURE__ */ new AtomicNumber(0);
function newFiberId() {
  return FiberID((/* @__PURE__ */ new Date()).getTime(), _fiberCounter.getAndIncrement());
}
function prettyFiberId(_2) {
  return `#${_2.seqNumber} (started at: ${new Date(_2.startTimeMillis).toISOString()})`;
}

// node_modules/@effect-ts/system/_mjs/Cause/cause.mjs
var _a;
var _b;
var _c;
var _d;
var _e2;
var _f;
var _g;
var CauseSym = /* @__PURE__ */ Symbol();
function isCause(self) {
  return typeof self === "object" && self != null && CauseSym in self;
}
var _emptyHash = /* @__PURE__ */ opt(/* @__PURE__ */ randomInt());
var Empty2 = class {
  constructor() {
    this._tag = "Empty";
    this[_a] = CauseSym;
  }
  [(_a = CauseSym, equalsSym)](that) {
    return isCause(that) && run(this.equalsSafe(that));
  }
  get [hashSym]() {
    return _emptyHash;
  }
  equalsSafe(that) {
    const self = this;
    return gen2(function* (_2) {
      if (that._tag === "Empty") {
        return true;
      } else if (that._tag === "Then") {
        return (yield* _2(self.equalsSafe(that.left))) && (yield* _2(self.equalsSafe(that.right)));
      } else if (that._tag === "Both") {
        return (yield* _2(self.equalsSafe(that.left))) && (yield* _2(self.equalsSafe(that.right)));
      } else {
        return false;
      }
    });
  }
};
var empty3 = /* @__PURE__ */ new Empty2();
var Fail = class {
  constructor(value) {
    this.value = value;
    this._tag = "Fail";
    this[_b] = CauseSym;
  }
  [(_b = CauseSym, equalsSym)](that) {
    return isCause(that) && run(this.equalsSafe(that));
  }
  get [hashSym]() {
    return combineHash(hashString(this._tag), hash(this.value));
  }
  equalsSafe(that) {
    const self = this;
    return gen2(function* (_2) {
      switch (that._tag) {
        case "Fail": {
          return equals(self.value, that.value);
        }
        case "Then": {
          return yield* _2(sym(zero)(self, that));
        }
        case "Both": {
          return yield* _2(sym(zero)(self, that));
        }
        case "Traced": {
          return yield* _2(self.equalsSafe(that.cause));
        }
      }
      return false;
    });
  }
};
var Die = class {
  constructor(value) {
    this.value = value;
    this._tag = "Die";
    this[_c] = CauseSym;
  }
  [(_c = CauseSym, equalsSym)](that) {
    return isCause(that) && run(this.equalsSafe(that));
  }
  get [hashSym]() {
    return combineHash(hashString(this._tag), hash(this.value));
  }
  equalsSafe(that) {
    const self = this;
    return gen2(function* (_2) {
      switch (that._tag) {
        case "Die": {
          return equals(self.value, that.value);
        }
        case "Then": {
          return yield* _2(sym(zero)(self, that));
        }
        case "Both": {
          return yield* _2(sym(zero)(self, that));
        }
        case "Traced": {
          return yield* _2(self.equalsSafe(that.cause));
        }
      }
      return false;
    });
  }
};
var Interrupt = class {
  constructor(fiberId3) {
    this.fiberId = fiberId3;
    this._tag = "Interrupt";
    this[_d] = CauseSym;
  }
  [(_d = CauseSym, equalsSym)](that) {
    return isCause(that) && run(this.equalsSafe(that));
  }
  get [hashSym]() {
    return combineHash(hashString(this._tag), hash(this.fiberId));
  }
  equalsSafe(that) {
    const self = this;
    return gen2(function* (_2) {
      switch (that._tag) {
        case "Interrupt": {
          return equalsFiberID(self.fiberId, that.fiberId);
        }
        case "Then": {
          return yield* _2(sym(zero)(self, that));
        }
        case "Both": {
          return yield* _2(sym(zero)(self, that));
        }
        case "Traced": {
          return yield* _2(self.equalsSafe(that.cause));
        }
      }
      return false;
    });
  }
};
var Traced = class {
  constructor(cause2, trace3) {
    this.cause = cause2;
    this.trace = trace3;
    this._tag = "Traced";
    this[_e2] = CauseSym;
  }
  [(_e2 = CauseSym, equalsSym)](that) {
    return isCause(that) && run(this.equalsSafe(that));
  }
  get [hashSym]() {
    return this.cause[hashSym];
  }
  equalsSafe(that) {
    const self = this;
    return gen2(function* (_2) {
      if (that._tag === "Traced") {
        return yield* _2(self.cause.equalsSafe(that.cause));
      }
      return yield* _2(self.cause.equalsSafe(that));
    });
  }
};
var Then = class {
  constructor(left4, right5) {
    this.left = left4;
    this.right = right5;
    this._tag = "Then";
    this[_f] = CauseSym;
  }
  [(_f = CauseSym, equalsSym)](that) {
    return isCause(that) && run(this.equalsSafe(that));
  }
  get [hashSym]() {
    return hashCode(this);
  }
  equalsSafe(that) {
    const self = this;
    return gen2(function* (_2) {
      switch (that._tag) {
        case "Traced": {
          return yield* _2(self.equalsSafe(that.cause));
        }
      }
      return (yield* _2(self.eq(that))) || (yield* _2(sym(associativeThen)(self, that))) || (yield* _2(sym(distributiveThen)(self, that))) || (yield* _2(sym(zero)(self, that)));
    });
  }
  eq(that) {
    const self = this;
    if (that._tag === "Then") {
      return gen2(function* (_2) {
        return (yield* _2(self.left.equalsSafe(that.left))) && (yield* _2(self.right.equalsSafe(that.right)));
      });
    }
    return succeed(false);
  }
};
var Both = class {
  constructor(left4, right5) {
    this.left = left4;
    this.right = right5;
    this._tag = "Both";
    this[_g] = CauseSym;
  }
  [(_g = CauseSym, equalsSym)](that) {
    return isCause(that) && run(this.equalsSafe(that));
  }
  get [hashSym]() {
    return hashCode(this);
  }
  equalsSafe(that) {
    const self = this;
    return gen2(function* (_2) {
      switch (that._tag) {
        case "Traced": {
          return yield* _2(self.equalsSafe(that.cause));
        }
      }
      return (yield* _2(self.eq(that))) || (yield* _2(sym(associativeBoth)(self, that))) || (yield* _2(sym(distributiveBoth)(self, that))) || (yield* _2(commutativeBoth(self, that))) || (yield* _2(sym(zero)(self, that)));
    });
  }
  eq(that) {
    const self = this;
    if (that._tag === "Both") {
      return gen2(function* (_2) {
        return (yield* _2(self.left.equalsSafe(that.left))) && (yield* _2(self.right.equalsSafe(that.right)));
      });
    }
    return succeed(false);
  }
};
function fail2(value) {
  return new Fail(value);
}
function traced(cause2, trace3) {
  if (isEmpty3(trace3.executionTrace) && isEmpty3(trace3.stackTrace) && isNone(trace3.parentTrace)) {
    return cause2;
  }
  return new Traced(cause2, trace3);
}
function die(value) {
  return new Die(value);
}
function interrupt(fiberId3) {
  return new Interrupt(fiberId3);
}
function combineSeq(left4, right5) {
  return isEmpty4(left4) ? right5 : isEmpty4(right5) ? left4 : new Then(left4, right5);
}
function combinePar(left4, right5) {
  return isEmpty4(left4) ? right5 : isEmpty4(right5) ? left4 : new Both(left4, right5);
}
function isEmpty4(cause2) {
  if (cause2._tag === "Empty" || cause2._tag === "Traced" && cause2.cause._tag === "Empty") {
    return true;
  }
  let causes = void 0;
  let current = cause2;
  while (current) {
    switch (current._tag) {
      case "Die": {
        return false;
      }
      case "Fail": {
        return false;
      }
      case "Interrupt": {
        return false;
      }
      case "Then": {
        causes = new Stack(current.right, causes);
        current = current.left;
        break;
      }
      case "Both": {
        causes = new Stack(current.right, causes);
        current = current.left;
        break;
      }
      case "Traced": {
        current = current.cause;
        break;
      }
      default: {
        current = void 0;
      }
    }
    if (!current && causes) {
      current = causes.value;
      causes = causes.previous;
    }
  }
  return true;
}
function associativeThen(self, that) {
  return gen2(function* (_2) {
    if (self._tag === "Then" && self.left._tag === "Then" && that._tag === "Then" && that.right._tag === "Then") {
      const al = self.left.left;
      const bl = self.left.right;
      const cl = self.right;
      const ar = that.left;
      const br = that.right.left;
      const cr = that.right.right;
      return (yield* _2(al.equalsSafe(ar))) && (yield* _2(bl.equalsSafe(br))) && (yield* _2(cl.equalsSafe(cr)));
    }
    return false;
  });
}
function distributiveThen(self, that) {
  return gen2(function* (_2) {
    if (self._tag === "Then" && self.right._tag === "Both" && that._tag === "Both" && that.left._tag === "Then" && that.right._tag === "Then") {
      const al = self.left;
      const bl = self.right.left;
      const cl = self.right.right;
      const ar1 = that.left.left;
      const br = that.left.right;
      const ar2 = that.right.left;
      const cr = that.right.right;
      if ((yield* _2(ar1.equalsSafe(ar2))) && (yield* _2(al.equalsSafe(ar1))) && (yield* _2(bl.equalsSafe(br))) && (yield* _2(cl.equalsSafe(cr)))) {
        return true;
      }
    }
    if (self._tag === "Then" && self.left._tag === "Both" && that._tag === "Both" && that.left._tag === "Then" && that.right._tag === "Then") {
      const al = self.left.left;
      const bl = self.left.right;
      const cl = self.right;
      const ar = that.left.left;
      const cr1 = that.left.right;
      const br = that.right.left;
      const cr2 = that.right.right;
      if ((yield* _2(cr1.equalsSafe(cr2))) && (yield* _2(al.equalsSafe(ar))) && (yield* _2(bl.equalsSafe(br))) && (yield* _2(cl.equalsSafe(cr1)))) {
        return true;
      }
    }
    return false;
  });
}
function associativeBoth(self, that) {
  return gen2(function* (_2) {
    if (self._tag === "Both" && self.left._tag === "Both" && that._tag === "Both" && that.right._tag === "Both") {
      const al = self.left.left;
      const bl = self.left.right;
      const cl = self.right;
      const ar = that.left;
      const br = that.right.left;
      const cr = that.right.right;
      return (yield* _2(al.equalsSafe(ar))) && (yield* _2(bl.equalsSafe(br))) && (yield* _2(cl.equalsSafe(cr)));
    }
    return false;
  });
}
function distributiveBoth(self, that) {
  return gen2(function* (_2) {
    if (self._tag === "Both" && self.left._tag === "Then" && self.right._tag === "Then" && that._tag === "Then" && that.right._tag === "Both") {
      const al1 = self.left.left;
      const bl = self.left.right;
      const al2 = self.right.left;
      const cl = self.right.right;
      const ar = that.left;
      const br = that.right.left;
      const cr = that.right.right;
      if ((yield* _2(al1.equalsSafe(al2))) && (yield* _2(al1.equalsSafe(ar))) && (yield* _2(bl.equalsSafe(br))) && (yield* _2(cl.equalsSafe(cr)))) {
        return true;
      }
    }
    if (self._tag === "Both" && self.left._tag === "Then" && self.right._tag === "Then" && that._tag === "Then" && that.left._tag === "Both") {
      const al = self.left.left;
      const cl1 = self.left.right;
      const bl = self.right.left;
      const cl2 = self.right.right;
      const ar = that.left.left;
      const br = that.left.right;
      const cr = that.right;
      if ((yield* _2(cl1.equalsSafe(cl2))) && (yield* _2(al.equalsSafe(ar))) && (yield* _2(bl.equalsSafe(br))) && (yield* _2(cl1.equalsSafe(cr)))) {
        return true;
      }
    }
    return false;
  });
}
function commutativeBoth(self, that) {
  return gen2(function* (_2) {
    if (that._tag === "Both") {
      return (yield* _2(self.left.equalsSafe(that.right))) && (yield* _2(self.right.equalsSafe(that.left)));
    }
    return false;
  });
}
function zero(self, that) {
  if (self._tag === "Then" && self.right._tag === "Empty") {
    return self.left.equalsSafe(that);
  }
  if (self._tag === "Then" && self.left._tag === "Empty") {
    return self.right.equalsSafe(that);
  }
  if (self._tag === "Both" && self.right._tag === "Empty") {
    return self.left.equalsSafe(that);
  }
  if (self._tag === "Both" && self.left._tag === "Empty") {
    return self.right.equalsSafe(that);
  }
  return succeed(false);
}
function sym(f2) {
  return (l2, r2) => gen2(function* (_2) {
    return (yield* _2(f2(l2, r2))) || (yield* _2(f2(r2, l2)));
  });
}
function equals2(self, that) {
  return run(self.equalsSafe(that));
}
function stepLoop(cause2, stack, parallel2, sequential2) {
  while (1) {
    switch (cause2._tag) {
      case "Empty": {
        if (isEmpty3(stack)) {
          return tuple2(parallel2, sequential2);
        } else {
          cause2 = unsafeFirst(stack);
          stack = tail(stack);
        }
        break;
      }
      case "Traced": {
        cause2 = cause2.cause;
        break;
      }
      case "Both": {
        stack = prepend_2(stack, cause2.right);
        cause2 = cause2.left;
        break;
      }
      case "Then": {
        const left4 = cause2.left;
        const right5 = cause2.right;
        switch (left4._tag) {
          case "Traced": {
            cause2 = combineSeq(left4.cause, right5);
            break;
          }
          case "Empty": {
            cause2 = cause2.right;
            break;
          }
          case "Then": {
            cause2 = combineSeq(left4.left, combineSeq(left4.right, right5));
            break;
          }
          case "Both": {
            cause2 = combinePar(combineSeq(left4.left, right5), combineSeq(left4.right, right5));
            break;
          }
          default: {
            cause2 = left4;
            sequential2 = prepend_2(sequential2, right5);
          }
        }
        break;
      }
      default: {
        if (isEmpty3(stack)) {
          return tuple2(add_(parallel2, cause2), sequential2);
        } else {
          parallel2 = add_(parallel2, cause2);
          cause2 = unsafeFirst(stack);
          stack = tail(stack);
          break;
        }
      }
    }
  }
  throw new Error("Bug");
}
function step(self) {
  return stepLoop(self, empty2(), make2(), empty2());
}
function flattenLoop(causes, flattened) {
  while (1) {
    const [parallel2, sequential2] = reduce_5(causes, tuple(make2(), empty2()), ([parallel3, sequential3], cause2) => {
      const {
        tuple: [set3, seq]
      } = step(cause2);
      return tuple(union_(parallel3, set3), concat_2(sequential3, seq));
    });
    const updated = size2(parallel2) > 0 ? prepend_2(flattened, parallel2) : flattened;
    if (isEmpty3(sequential2)) {
      return reverse2(updated);
    } else {
      causes = sequential2;
      flattened = updated;
    }
  }
  throw new Error("Bug");
}
function flatten4(self) {
  return flattenLoop(of(self), empty2());
}
function hashCode(self) {
  const flat = flatten4(self);
  const size7 = size3(flat);
  let head6;
  if (size7 === 0) {
    return _emptyHash;
  } else if (size7 === 1 && (head6 = unsafeFirst(flat)) && size2(head6) === 1) {
    return unsafeFirst(from2(head6))[hashSym];
  } else {
    return hashIterator(flat[Symbol.iterator]());
  }
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/definition.mjs
var _a2;
var BufferSize = 64;
var ChunkTypeId = /* @__PURE__ */ Symbol();
var alloc = typeof Buffer !== "undefined" ? Buffer.alloc : (n2) => new Uint8Array(n2);
function isByte(u2) {
  return typeof u2 === "number" && Number.isInteger(u2) && u2 >= 0 && u2 <= 255;
}
var ChunkInternal = class {
  constructor() {
    this[_a2] = ChunkTypeId;
  }
  arrayLike() {
    if (this.arrayLikeCache) {
      return this.arrayLikeCache;
    }
    const arr = this.binary ? alloc(this.length) : new Array(this.length);
    this.copyToArray(0, arr);
    this.arrayLikeCache = arr;
    return arr;
  }
  array() {
    if (this.arrayCache) {
      return this.arrayCache;
    }
    const arr = new Array(this.length);
    this.copyToArray(0, arr);
    this.arrayCache = arr;
    return arr;
  }
  [(_a2 = ChunkTypeId, equalsSym)](that) {
    return isChunk(that) && corresponds_(this, that, equals);
  }
  get [hashSym]() {
    return hashIterator(this[Symbol.iterator]());
  }
  toString() {
    return `Chunk(${this.array().join(", ")})`;
  }
  toJSON() {
    return this.array();
  }
  buckets() {
    return {
      [Symbol.iterator]: () => this.arrayLikeIterator()
    };
  }
  reverseBuckets() {
    return {
      [Symbol.iterator]: () => this.reverseArrayLikeIterator()
    };
  }
  reverse() {
    const arr = this.arrayLike();
    return {
      [Symbol.iterator]: () => {
        let i2 = arr.length - 1;
        return {
          next: () => {
            if (i2 >= 0 && i2 < arr.length) {
              const k2 = arr[i2];
              i2--;
              return {
                value: k2,
                done: false
              };
            }
            return {
              value: arr.length,
              done: true
            };
          }
        };
      }
    };
  }
  materialize() {
    ;
    switch (this._typeId) {
      case EmptyTypeId: {
        return this;
      }
      case ArrTypeId: {
        return this;
      }
      default: {
        return array_(this.arrayLike());
      }
    }
  }
  append(a1) {
    const binary = this.binary && isByte(a1);
    const buffer2 = this.binary && binary ? alloc(BufferSize) : new Array(BufferSize);
    buffer2[0] = a1;
    return new AppendN(this, buffer2, 1, new AtomicNumber(1), this.binary && binary);
  }
  prepend(a1) {
    const binary = this.binary && isByte(a1);
    const buffer2 = this.binary && binary ? alloc(BufferSize) : new Array(BufferSize);
    buffer2[BufferSize - 1] = a1;
    return new PrependN(this, buffer2, 1, new AtomicNumber(1), this.binary && binary);
  }
  take(n2) {
    ;
    if (n2 <= 0) {
      return _Empty;
    } else if (n2 >= this.length) {
      return this;
    } else {
      switch (this._typeId) {
        case EmptyTypeId: {
          return _Empty;
        }
        case SliceTypeId: {
          if (n2 >= this.length) {
            return this;
          } else {
            return new Slice(this.chunk, this.offset, n2);
          }
        }
        case SingletonTypeId: {
          return this;
        }
        default: {
          return new Slice(this, 0, n2);
        }
      }
    }
  }
  concat(that) {
    ;
    ;
    if (this._typeId === EmptyTypeId) {
      return that;
    }
    if (that._typeId === EmptyTypeId) {
      return this;
    }
    if (this._typeId === AppendNTypeId) {
      const chunk2 = array_(this.buffer).take(this.bufferUsed);
      return this.start.concat(chunk2).concat(that);
    }
    if (that._typeId === PrependNTypeId) {
      const chunk2 = array_(takeRight_(that.buffer, that.bufferUsed));
      return this.concat(chunk2).concat(that.end);
    }
    const diff = that.depth - this.depth;
    if (Math.abs(diff) <= 1) {
      return new Concat(this, that);
    } else if (diff < -1) {
      if (this.left.depth >= this.right.depth) {
        const nr = this.right.concat(that);
        return new Concat(this.left, nr);
      } else {
        const nrr = this.right.right.concat(that);
        if (nrr.depth === this.depth - 3) {
          const nr = new Concat(this.right.left, nrr);
          return new Concat(this.left, nr);
        } else {
          const nl = new Concat(this.left, this.right.left);
          return new Concat(nl, nrr);
        }
      }
    } else {
      if (this.right.depth >= that.left.depth) {
        const nl = this.concat(that.left);
        return new Concat(nl, that.right);
      } else {
        const nll = this.concat(that.left.left);
        if (nll.depth === that.depth - 3) {
          const nl = new Concat(nll, that.left.right);
          return new Concat(nl, that.right);
        } else {
          const nr = new Concat(that.left.right, that.right);
          return new Concat(nll, nr);
        }
      }
    }
  }
};
var EmptyTypeId = /* @__PURE__ */ Symbol();
var Empty3 = class extends ChunkInternal {
  constructor() {
    super();
    this.depth = 0;
    this._typeId = EmptyTypeId;
    this.left = this;
    this.right = this;
    this.binary = true;
    this.length = 0;
  }
  get(n2) {
    throw new ArrayIndexOutOfBoundsException(n2);
  }
  materialize() {
    return array_([]);
  }
  copyToArray(_n, _array) {
  }
  [Symbol.iterator]() {
    return {
      next: () => ({
        value: 0,
        done: true
      })
    };
  }
  arrayLikeIterator() {
    return {
      next: () => ({
        value: 0,
        done: true
      })
    };
  }
  reverseArrayLikeIterator() {
    return {
      next: () => ({
        value: 0,
        done: true
      })
    };
  }
};
var _Empty = /* @__PURE__ */ new Empty3();
function concrete(_2) {
}
function concreteId(_2) {
  ;
  return _2;
}
var AppendNTypeId = /* @__PURE__ */ Symbol();
var AppendN = class _AppendN extends ChunkInternal {
  constructor(start, buffer2, bufferUsed, chain14, binary) {
    super();
    this.start = start;
    this.buffer = buffer2;
    this.bufferUsed = bufferUsed;
    this.chain = chain14;
    this.binary = binary;
    this._typeId = AppendNTypeId;
    this.depth = 0;
    this.left = _Empty;
    this.right = _Empty;
    this.length = this.start.length + this.bufferUsed;
  }
  get(n2) {
    if (n2 < this.start.length) {
      return this.start.get(n2);
    }
    const k2 = n2 - this.start.length;
    if (k2 >= this.buffer.length || k2 < 0) {
      throw new ArrayIndexOutOfBoundsException(n2);
    }
    return this.buffer[k2];
  }
  append(a1) {
    const binary = this.binary && isByte(a1);
    if (this.bufferUsed < this.buffer.length && this.chain.compareAndSet(this.bufferUsed, this.bufferUsed + 1)) {
      if (this.binary && !binary) {
        const buffer2 = new Array(BufferSize);
        for (let i2 = 0; i2 < BufferSize; i2++) {
          buffer2[i2] = this.buffer[i2];
        }
        buffer2[this.bufferUsed] = a1;
        return new _AppendN(this.start, buffer2, this.bufferUsed + 1, this.chain, this.binary && binary);
      }
      this.buffer[this.bufferUsed] = a1;
      return new _AppendN(this.start, this.buffer, this.bufferUsed + 1, this.chain, this.binary && binary);
    } else {
      const buffer2 = this.binary && binary ? alloc(BufferSize) : new Array(BufferSize);
      buffer2[0] = a1;
      const chunk2 = array_(this.buffer).take(this.bufferUsed);
      return new _AppendN(this.start.concat(chunk2), buffer2, 1, new AtomicNumber(1), this.binary && binary);
    }
  }
  copyToArray(n2, array2) {
    this.start.copyToArray(n2, array2);
    _copy(this.buffer, 0, array2, this.start.length + n2, this.bufferUsed);
  }
  [Symbol.iterator]() {
    const k2 = this.arrayLike();
    return k2[Symbol.iterator]();
  }
  arrayLikeIterator() {
    const array2 = this.arrayLike();
    let done7 = false;
    return {
      next: () => {
        if (!done7) {
          done7 = true;
          return {
            value: array2,
            done: false
          };
        } else {
          return {
            value: 1,
            done: true
          };
        }
      }
    };
  }
  reverseArrayLikeIterator() {
    const array2 = this.arrayLike();
    let done7 = false;
    return {
      next: () => {
        if (!done7) {
          done7 = true;
          return {
            value: array2,
            done: false
          };
        } else {
          return {
            value: 1,
            done: true
          };
        }
      }
    };
  }
};
var ArrTypeId = /* @__PURE__ */ Symbol();
var Arr = class extends ChunkInternal {
  constructor() {
    super(...arguments);
    this._typeId = ArrTypeId;
  }
};
var PlainArr = class extends Arr {
  constructor(_array) {
    super();
    this._array = _array;
    this.depth = 0;
    this.left = _Empty;
    this.right = _Empty;
    this.length = _array.length;
  }
  get binary() {
    if (typeof this.isBytes !== "undefined") {
      return this.isBytes;
    }
    this.isBytes = this._array.every(isByte);
    return this.isBytes;
  }
  get(n2) {
    if (n2 >= this.length || n2 < 0) {
      throw new ArrayIndexOutOfBoundsException(n2);
    }
    return this._array[n2];
  }
  arrayLike() {
    if (!this.binary) {
      return this._array;
    }
    if (this.arrayLikeCache) {
      return this.arrayLikeCache;
    }
    const arr = alloc(this.length);
    this.copyToArray(0, arr);
    this.arrayLikeCache = arr;
    return arr;
  }
  array() {
    return this._array;
  }
  materialize() {
    return this;
  }
  copyToArray(n2, array2) {
    _copy(this._array, 0, array2, n2, this.length);
  }
  [Symbol.iterator]() {
    return this._array[Symbol.iterator]();
  }
  arrayLikeIterator() {
    let done7 = false;
    return {
      next: () => {
        if (!done7) {
          done7 = true;
          return {
            value: this._array,
            done: false
          };
        } else {
          return {
            value: 1,
            done: true
          };
        }
      }
    };
  }
  reverseArrayLikeIterator() {
    let done7 = false;
    return {
      next: () => {
        if (!done7) {
          done7 = true;
          return {
            value: this._array,
            done: false
          };
        } else {
          return {
            value: 1,
            done: true
          };
        }
      }
    };
  }
};
var Uint8Arr = class extends Arr {
  constructor(_array) {
    super();
    this._array = _array;
    this.depth = 0;
    this.left = _Empty;
    this.right = _Empty;
    this.binary = true;
    this.length = _array.length;
  }
  arrayLike() {
    return this._array;
  }
  get(n2) {
    if (n2 >= this.length || n2 < 0) {
      throw new ArrayIndexOutOfBoundsException(n2);
    }
    return this._array[n2];
  }
  materialize() {
    return this;
  }
  copyToArray(n2, array2) {
    _copy(this._array, 0, array2, n2, this.length);
  }
  [Symbol.iterator]() {
    return this._array[Symbol.iterator]();
  }
  arrayLikeIterator() {
    let done7 = false;
    return {
      next: () => {
        if (!done7) {
          done7 = true;
          return {
            value: this._array,
            done: false
          };
        } else {
          return {
            value: 1,
            done: true
          };
        }
      }
    };
  }
  reverseArrayLikeIterator() {
    let done7 = false;
    return {
      next: () => {
        if (!done7) {
          done7 = true;
          return {
            value: this._array,
            done: false
          };
        } else {
          return {
            value: 1,
            done: true
          };
        }
      }
    };
  }
};
var SliceTypeId = /* @__PURE__ */ Symbol();
var Slice = class extends ChunkInternal {
  constructor(chunk2, offset, length) {
    super();
    this.chunk = chunk2;
    this.offset = offset;
    this.length = length;
    this.depth = 0;
    this.left = _Empty;
    this.right = _Empty;
    this._typeId = SliceTypeId;
    this.binary = this.chunk.binary;
  }
  get(n2) {
    return this.chunk.get(n2 + this.offset);
  }
  copyToArray(n2, array2) {
    let i2 = 0;
    let j2 = n2;
    while (i2 < this.length) {
      array2[j2] = this.get(i2);
      i2 += 1;
      j2 += 1;
    }
  }
  [Symbol.iterator]() {
    const k2 = this.arrayLike();
    return k2[Symbol.iterator]();
  }
  arrayLikeIterator() {
    const array2 = this.arrayLike();
    let done7 = false;
    return {
      next: () => {
        if (!done7) {
          done7 = true;
          return {
            value: array2,
            done: false
          };
        } else {
          return {
            value: 1,
            done: true
          };
        }
      }
    };
  }
  reverseArrayLikeIterator() {
    const array2 = this.arrayLike();
    let done7 = false;
    return {
      next: () => {
        if (!done7) {
          done7 = true;
          return {
            value: array2,
            done: false
          };
        } else {
          return {
            value: 1,
            done: true
          };
        }
      }
    };
  }
};
var SingletonTypeId = /* @__PURE__ */ Symbol();
var Singleton = class extends ChunkInternal {
  constructor(a2) {
    super();
    this.a = a2;
    this.depth = 0;
    this.left = _Empty;
    this.right = _Empty;
    this.length = 1;
    this._typeId = SingletonTypeId;
    this.binary = isByte(a2);
  }
  get(n2) {
    if (n2 === 0) {
      return this.a;
    }
    throw new ArrayIndexOutOfBoundsException(n2);
  }
  copyToArray(n2, array2) {
    array2[n2] = this.a;
  }
  [Symbol.iterator]() {
    const k2 = this.arrayLike();
    return k2[Symbol.iterator]();
  }
  arrayLikeIterator() {
    let done7 = false;
    return {
      next: () => {
        if (!done7) {
          done7 = true;
          return {
            value: this.arrayLike(),
            done: false
          };
        } else {
          return {
            value: 1,
            done: true
          };
        }
      }
    };
  }
  reverseArrayLikeIterator() {
    let done7 = false;
    return {
      next: () => {
        if (!done7) {
          done7 = true;
          return {
            value: this.arrayLike(),
            done: false
          };
        } else {
          return {
            value: 1,
            done: true
          };
        }
      }
    };
  }
};
var PrependNTypeId = /* @__PURE__ */ Symbol();
var PrependN = class _PrependN extends ChunkInternal {
  constructor(end4, buffer2, bufferUsed, chain14, binary) {
    super();
    this.end = end4;
    this.buffer = buffer2;
    this.bufferUsed = bufferUsed;
    this.chain = chain14;
    this.binary = binary;
    this.depth = 0;
    this.left = _Empty;
    this.right = _Empty;
    this._typeId = PrependNTypeId;
    this.length = this.end.length + this.bufferUsed;
  }
  get(n2) {
    if (n2 < this.bufferUsed) {
      const k2 = BufferSize - this.bufferUsed + n2;
      if (k2 >= this.buffer.length || k2 < 0) {
        throw new ArrayIndexOutOfBoundsException(n2);
      }
      return this.buffer[k2];
    }
    return this.end.get(n2 - this.bufferUsed);
  }
  copyToArray(n2, array2) {
    const length = Math.min(this.bufferUsed, Math.max(array2.length - n2, 0));
    _copy(this.buffer, BufferSize - this.bufferUsed, array2, n2, length);
    this.end.copyToArray(n2 + length, array2);
  }
  prepend(a1) {
    const binary = this.binary && isByte(a1);
    if (this.bufferUsed < this.buffer.length && this.chain.compareAndSet(this.bufferUsed, this.bufferUsed + 1)) {
      if (this.binary && !binary) {
        const buffer2 = new Array(BufferSize);
        for (let i2 = 0; i2 < BufferSize; i2++) {
          buffer2[i2] = this.buffer[i2];
        }
        buffer2[BufferSize - this.bufferUsed - 1] = a1;
        return new _PrependN(this.end, buffer2, this.bufferUsed + 1, this.chain, false);
      }
      this.buffer[BufferSize - this.bufferUsed - 1] = a1;
      return new _PrependN(this.end, this.buffer, this.bufferUsed + 1, this.chain, this.binary && binary);
    } else {
      const buffer2 = binary ? alloc(BufferSize) : new Array(BufferSize);
      buffer2[BufferSize - 1] = a1;
      const chunk2 = array_("subarray" in this.buffer ? this.buffer.subarray(this.buffer.length - this.bufferUsed) : this.buffer.slice(this.buffer.length - this.bufferUsed));
      return new _PrependN(chunk2.concat(this.end), buffer2, 1, new AtomicNumber(1), this.binary && binary);
    }
  }
  [Symbol.iterator]() {
    const k2 = this.arrayLike();
    return k2[Symbol.iterator]();
  }
  arrayLikeIterator() {
    let done7 = false;
    return {
      next: () => {
        if (!done7) {
          done7 = true;
          return {
            value: this.arrayLike(),
            done: false
          };
        } else {
          return {
            value: 1,
            done: true
          };
        }
      }
    };
  }
  reverseArrayLikeIterator() {
    let done7 = false;
    return {
      next: () => {
        if (!done7) {
          done7 = true;
          return {
            value: this.arrayLike(),
            done: false
          };
        } else {
          return {
            value: 1,
            done: true
          };
        }
      }
    };
  }
};
function _copy(src, srcPos, dest, destPos, len) {
  for (let i2 = srcPos; i2 < Math.min(src.length, srcPos + len); i2++) {
    dest[destPos + i2 - srcPos] = src[i2];
  }
  return dest;
}
var ConcatTypeId = /* @__PURE__ */ Symbol();
var Concat = class extends ChunkInternal {
  constructor(left4, right5) {
    super();
    this.left = left4;
    this.right = right5;
    this._typeId = ConcatTypeId;
    this.depth = 1 + Math.max(this.left.depth, this.right.depth);
    this.length = this.left.length + this.right.length;
    this.binary = this.left.binary && this.right.binary;
  }
  get(n2) {
    return n2 < this.left.length ? this.left.get(n2) : this.right.get(n2 - this.left.length);
  }
  copyToArray(n2, array2) {
    this.left.copyToArray(n2, array2);
    this.right.copyToArray(n2 + this.left.length, array2);
  }
  [Symbol.iterator]() {
    const k2 = this.arrayLike();
    return k2[Symbol.iterator]();
  }
  arrayLikeIterator() {
    let it2 = this.left.arrayLikeIterator();
    let i2 = 0;
    let n2 = it2.next();
    let j2 = 0;
    return {
      next: () => {
        j2++;
        if (i2 === 0 && n2.done) {
          it2 = this.right.arrayLikeIterator();
          const k2 = it2.next();
          if (k2.done) {
            return {
              value: j2,
              done: true
            };
          }
          i2++;
          n2 = it2.next();
          return k2;
        } else {
          if (n2.done) {
            return {
              value: j2,
              done: true
            };
          }
          const k2 = n2;
          n2 = it2.next();
          return k2;
        }
      }
    };
  }
  reverseArrayLikeIterator() {
    let it2 = this.right.arrayLikeIterator();
    let i2 = 0;
    let n2 = it2.next();
    let j2 = 0;
    return {
      next: () => {
        j2++;
        if (i2 === 0 && n2.done) {
          it2 = this.left.arrayLikeIterator();
          const k2 = it2.next();
          if (k2.done) {
            return {
              value: j2,
              done: true
            };
          }
          i2++;
          n2 = it2.next();
          return k2;
        } else {
          if (n2.done) {
            return {
              value: j2,
              done: true
            };
          }
          const k2 = n2;
          n2 = it2.next();
          return k2;
        }
      }
    };
  }
};
function isChunk(u2) {
  return typeof u2 === "object" && u2 != null && ChunkTypeId in u2;
}
function array_(array2) {
  if (isChunk(array2)) {
    ;
    return array2;
  }
  if (array2 instanceof Uint8Array) {
    return new Uint8Arr(array2);
  }
  return new PlainArr(Array.isArray(array2) ? array2 : Array.from(array2));
}
var from3 = array_;
function corresponds_(self, that, f2) {
  if (self.length !== that.length) {
    return false;
  }
  const leftIterator = self.arrayLikeIterator();
  const rightIterator = that.arrayLikeIterator();
  let i2 = 0;
  let j2 = 0;
  let equal = true;
  let done7 = false;
  let leftLength = 0;
  let rightLength = 0;
  let left4 = void 0;
  let right5 = void 0;
  let leftNext;
  let rightNext;
  while (equal && !done7) {
    if (i2 < leftLength && j2 < rightLength) {
      if (!f2(left4[i2], right5[j2])) {
        equal = false;
      }
      i2++;
      j2++;
    } else if (i2 === leftLength && (leftNext = leftIterator.next()) && !leftNext.done) {
      left4 = leftNext.value;
      leftLength = left4.length;
      i2 = 0;
    } else if (j2 === rightLength && (rightNext = rightIterator.next()) && !rightNext.done) {
      right5 = rightNext.value;
      rightLength = right5.length;
      j2 = 0;
    } else if (i2 === leftLength && j2 === rightLength) {
      done7 = true;
    } else {
      equal = false;
    }
  }
  return equal;
}
function corresponds2(that, f2) {
  return (self) => corresponds_(self, that, f2);
}
function toString(self) {
  return self.toString();
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/core.mjs
function single(a2) {
  return new Singleton(a2);
}
function empty4() {
  return _Empty;
}
function append2(a2) {
  return (self) => self.append(a2);
}
function append_4(self, a2) {
  return self.append(a2);
}
function prepend2(a2) {
  return (self) => self.prepend(a2);
}
function prepend_3(self, a2) {
  return self.prepend(a2);
}
function concat2(that) {
  return (self) => self.concat(that);
}
function concat_3(self, that) {
  return self.concat(that);
}
function toArrayLike(self) {
  return self.arrayLike();
}
function toArray2(self) {
  return self.array();
}
function get_3(self, n2) {
  return !Number.isInteger(n2) || n2 < 0 || n2 >= self.length ? none : some(self.get(n2));
}
function get3(n2) {
  return (self) => get_3(self, n2);
}
function unsafeGet_2(self, n2) {
  return self.get(n2);
}
function unsafeGet2(n2) {
  return (self) => unsafeGet_2(self, n2);
}
function equals_(self, that) {
  return corresponds_(self, that, equals);
}
function equals3(that) {
  return (self) => equals_(self, that);
}
function take_2(self, n2) {
  return self.take(n2);
}
function take(n2) {
  return (self) => self.take(n2);
}
function takeRight_2(self, n2) {
  return drop_2(self, size4(self) - n2);
}
function takeRight(n2) {
  return (self) => takeRight_2(self, n2);
}
function drop_2(self, n2) {
  ;
  if (n2 <= 0) {
    return self;
  } else if (n2 >= self.length) {
    return _Empty;
  } else {
    const len = self.length;
    switch (self._typeId) {
      case EmptyTypeId: {
        return _Empty;
      }
      case SliceTypeId: {
        return new Slice(self.chunk, self.offset + n2, self.length - n2);
      }
      case SingletonTypeId: {
        if (n2 > 0) {
          return _Empty;
        }
        return self;
      }
      default: {
        return new Slice(self, n2, len - n2);
      }
    }
  }
}
function drop(n2) {
  return (self) => drop_2(self, n2);
}
function dropRight_(self, n2) {
  ;
  return take_2(self, Math.max(0, self.length - n2));
}
function dropRight(n2) {
  return (self) => dropRight_(self, n2);
}
function size4(self) {
  return self.length;
}
function map_8(self, f2) {
  ;
  if (self._typeId === SingletonTypeId) {
    return new Singleton(f2(self.a));
  }
  let r2 = empty4();
  for (const k2 of self) {
    r2 = append_4(r2, f2(k2));
  }
  return r2;
}
function map5(f2) {
  return (self) => map_8(self, f2);
}
function mapWithIndex_2(self, f2) {
  ;
  if (self._typeId === SingletonTypeId) {
    return new Singleton(f2(0, self.a));
  }
  let r2 = empty4();
  let i2 = 0;
  for (const k2 of self) {
    r2 = append_4(r2, f2(i2, k2));
    i2 += 1;
  }
  return r2;
}
function mapWithIndex2(f2) {
  return (self) => mapWithIndex_2(self, f2);
}
function chain_7(self, f2) {
  ;
  if (self._typeId === SingletonTypeId) {
    return f2(self.a);
  }
  let r2 = empty4();
  for (const k2 of self) {
    r2 = concat_3(r2, f2(k2));
  }
  return r2;
}
function chain4(f2) {
  return (self) => chain_7(self, f2);
}
function flatten5(self) {
  return chain_7(self, identity);
}
function head2(self) {
  return get_3(self, 0);
}
function tail2(self) {
  return self.length > 0 ? some(drop_2(self, 1)) : none;
}
function last2(self) {
  return get_3(self, self.length - 1);
}
function unsafeHead(self) {
  return self.get(0);
}
function unsafeTail(self) {
  if (self.length === 0) {
    throw new ArrayIndexOutOfBoundsException(1);
  }
  return drop_2(self, 1);
}
function unsafeLast2(self) {
  return self.get(self.length - 1);
}
function isEmpty5(self) {
  return self.length === 0;
}
function isNonEmpty2(self) {
  return self.length !== 0;
}
function buckets(self) {
  return self.buckets();
}
function reverseBuckets(self) {
  return self.reverseBuckets();
}
function reverse3(self) {
  return self.reverse();
}
function materialize(self) {
  return self.materialize();
}
var unit = /* @__PURE__ */ single(void 0);
function make3(...iter) {
  let builder2 = empty4();
  for (const x2 of iter) {
    builder2 = append_4(builder2, x2);
  }
  return builder2;
}
function makeBy_2(n2, f2) {
  const b2 = builder();
  for (let i2 = 0; i2 < n2; i2++) {
    b2.append(f2(i2));
  }
  return b2.build();
}
function builder() {
  return new ChunkBuilder(empty4());
}
var ChunkBuilder = class {
  constructor(chunk2) {
    this.chunk = chunk2;
  }
  append(a2) {
    this.chunk = append_4(this.chunk, a2);
    return this;
  }
  build() {
    return this.chunk;
  }
};

// node_modules/@effect-ts/system/_mjs/XPure/core.mjs
var XPureBase = class {
  constructor() {
    this._tag = "XPure";
  }
};
var Succeed2 = class extends XPureBase {
  constructor(a2) {
    super();
    this.a = a2;
    this._xptag = "Succeed";
  }
};
var Suspend2 = class extends XPureBase {
  constructor(f2) {
    super();
    this.f = f2;
    this._xptag = "Suspend";
  }
};
var Fail2 = class extends XPureBase {
  constructor(e2) {
    super();
    this.e = e2;
    this._xptag = "Fail";
  }
};
var Modify = class extends XPureBase {
  constructor(run7) {
    super();
    this.run = run7;
    this._xptag = "Modify";
  }
};
var FlatMap2 = class extends XPureBase {
  constructor(value, cont) {
    super();
    this.value = value;
    this.cont = cont;
    this._xptag = "FlatMap";
  }
};
var Fold = class extends XPureBase {
  constructor(value, failure, success) {
    super();
    this.value = value;
    this.failure = failure;
    this.success = success;
    this._xptag = "Fold";
  }
};
var Access = class extends XPureBase {
  constructor(access6) {
    super();
    this.access = access6;
    this._xptag = "Access";
  }
};
var Provide = class extends XPureBase {
  constructor(r2, cont) {
    super();
    this.r = r2;
    this.cont = cont;
    this._xptag = "Provide";
  }
};
function chain_8(self, f2) {
  return new FlatMap2(self, f2);
}
function succeed2(a2) {
  return new Succeed2(a2);
}
function fail3(a2) {
  return new Fail2(a2);
}
function foldM_(self, failure, success) {
  return new Fold(self, failure, success);
}
function modify2(f2) {
  return new Modify(f2);
}
function set2(s2) {
  return modify2(() => tuple2(s2, void 0));
}
function provideAll_(self, r2) {
  return new Provide(r2, self);
}
function accessM(f2) {
  return new Access(f2);
}
function suspend2(f2) {
  return new Suspend2(f2);
}
function succeedWith2(f2) {
  return suspend2(() => succeed2(f2()));
}
var FoldFrame = class {
  constructor(failure, apply) {
    this.failure = failure;
    this.apply = apply;
    this._xptag = "FoldFrame";
  }
};
var ApplyFrame = class {
  constructor(apply) {
    this.apply = apply;
    this._xptag = "ApplyFrame";
  }
};
var Runtime = class {
  constructor() {
    this.stack = void 0;
  }
  pop() {
    var _a12;
    const nextInstr = this.stack;
    if (nextInstr) {
      this.stack = (_a12 = this.stack) === null || _a12 === void 0 ? void 0 : _a12.previous;
    }
    return nextInstr === null || nextInstr === void 0 ? void 0 : nextInstr.value;
  }
  push(cont) {
    this.stack = new Stack(cont, this.stack);
  }
  findNextErrorHandler() {
    let unwinding = true;
    while (unwinding) {
      const nextInstr = this.pop();
      if (nextInstr == null) {
        unwinding = false;
      } else {
        if (nextInstr._xptag === "FoldFrame") {
          unwinding = false;
          this.push(new ApplyFrame(nextInstr.failure));
        }
      }
    }
  }
  runAll(self, s2) {
    let s0 = s2;
    let a2 = void 0;
    let environments = void 0;
    let failed2 = false;
    let curXPure = self;
    let logs = empty4();
    while (curXPure != null) {
      ;
      const xp = curXPure;
      switch (xp._xptag) {
        case "FlatMap": {
          ;
          const nested = xp.value;
          const continuation = xp.cont;
          switch (nested._xptag) {
            case "Succeed": {
              curXPure = continuation(nested.a);
              break;
            }
            case "Modify": {
              const updated = nested.run(s0);
              s0 = updated.get(0);
              a2 = updated.get(1);
              curXPure = continuation(a2);
              break;
            }
            default: {
              curXPure = nested;
              this.push(new ApplyFrame(continuation));
            }
          }
          break;
        }
        case "Log": {
          logs = append_4(logs, xp.w);
          a2 = void 0;
          const nextInstr = this.pop();
          curXPure = nextInstr === null || nextInstr === void 0 ? void 0 : nextInstr.apply(a2);
          break;
        }
        case "Suspend": {
          curXPure = xp.f();
          break;
        }
        case "Succeed": {
          a2 = xp.a;
          const nextInstr = this.pop();
          if (nextInstr) {
            curXPure = nextInstr.apply(a2);
          } else {
            curXPure = void 0;
          }
          break;
        }
        case "Fail": {
          this.findNextErrorHandler();
          const nextInst = this.pop();
          if (nextInst) {
            curXPure = nextInst.apply(xp.e);
          } else {
            failed2 = true;
            a2 = xp.e;
            curXPure = void 0;
          }
          break;
        }
        case "Fold": {
          const state = s0;
          this.push(new FoldFrame((c2) => chain_8(set2(state), () => xp.failure(c2)), xp.success));
          curXPure = xp.value;
          break;
        }
        case "Access": {
          curXPure = xp.access((environments === null || environments === void 0 ? void 0 : environments.value) || {});
          break;
        }
        case "Get": {
          curXPure = xp.get(s0);
          break;
        }
        case "Provide": {
          environments = new Stack(xp.r, environments);
          curXPure = foldM_(xp.cont, (e2) => chain_8(succeedWith2(() => {
            environments = environments === null || environments === void 0 ? void 0 : environments.previous;
          }), () => fail3(e2)), (a3) => chain_8(succeedWith2(() => {
            environments = environments === null || environments === void 0 ? void 0 : environments.previous;
          }), () => succeed2(a3)));
          break;
        }
        case "Modify": {
          const updated = xp.run(s0);
          s0 = updated.get(0);
          a2 = updated.get(1);
          const nextInst = this.pop();
          if (nextInst) {
            curXPure = nextInst.apply(a2);
          } else {
            curXPure = void 0;
          }
          break;
        }
      }
    }
    if (failed2) {
      return tuple2(logs, left(a2));
    }
    return tuple2(logs, right(tuple2(s0, a2)));
  }
};
function run2(self) {
  return runState_(self, void 0).get(1);
}
function runState_(self, s2) {
  const result4 = new Runtime().runAll(self, s2).get(1);
  if (result4._tag === "Left") {
    throw result4.left;
  }
  return result4.right;
}
function runEither(self) {
  return map_3(new Runtime().runAll(self, void 0).get(1), (x2) => x2.get(1));
}

// node_modules/@effect-ts/system/_mjs/Sync/core.mjs
var chain_9 = chain_8;
var succeed3 = (a2) => succeed2(a2);
var fail4 = fail3;
var accessM2 = accessM;
var suspend3 = suspend2;
var run3 = run2;

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Dictionary/index.mjs
function keys3(r2) {
  return Object.keys(r2).sort();
}
function collect_(r2, f2) {
  const out = [];
  for (const key of keys3(r2)) {
    out.push(f2(key, r2[key]));
  }
  return out;
}
function mapWithIndex_3(fa, f2) {
  const out = {};
  const keys4 = Object.keys(fa);
  for (const key of keys4) {
    out[key] = f2(key, fa[key]);
  }
  return out;
}
function map_10(fa, f2) {
  return mapWithIndex_3(fa, (_2, a2) => f2(a2));
}

// node_modules/@effect-ts/system/_mjs/Has/index.mjs
var makeTag = (key = Symbol()) => ({
  _tag: "Tag",
  _T: void 0,
  key,
  has: (t2) => ({
    [key]: t2
  }),
  of: (t2) => t2,
  read: (r2) => r2[key],
  readOption: (r2) => typeof r2 === "object" && r2 !== null ? fromNullable(r2[key]) : none,
  refine: () => makeTag(key)
});
function tag(key) {
  return makeTag(key);
}
function mergeEnvironments(_2, r2, t2) {
  return {
    ...r2,
    ..._2.has(t2)
  };
}

// node_modules/@effect-ts/system/_mjs/Sync/has.mjs
function accessServiceM(s2) {
  return (f2) => accessM2((r2) => f2(r2[s2.key]));
}
function accessService(s2) {
  return (f2) => accessServiceM(s2)((a2) => succeed3(f2(a2)));
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/collect.mjs
function collect_2(self, f2) {
  ;
  switch (self._typeId) {
    case ArrTypeId: {
      const array2 = self.arrayLike();
      let dest = empty4();
      for (let i2 = 0; i2 < array2.length; i2++) {
        const rhs = f2(array2[i2]);
        if (isSome(rhs)) {
          dest = append_4(dest, rhs.value);
        }
      }
      return dest;
    }
    default: {
      return collect_2(self.materialize(), f2);
    }
  }
}
function collect(f2) {
  return (self) => collect_2(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/compact.mjs
function compact3(fa) {
  return collect_2(fa, (x2) => x2);
}

// node_modules/@effect-ts/system/_mjs/Sync/gen.mjs
var GenSync = class {
  constructor(effect2) {
    this.effect = effect2;
  }
  *[Symbol.iterator]() {
    return yield this;
  }
};
var adapter3 = (_2, __) => {
  if (isTag(_2)) {
    return new GenSync(accessService(_2)(identity));
  }
  if (isEither(_2)) {
    return new GenSync(_2._tag === "Left" ? fail4(_2.left) : succeed3(_2.right));
  }
  if (isOption(_2)) {
    return new GenSync(_2._tag === "None" ? fail4(__ ? __() : new NoSuchElementException()) : succeed3(_2.value));
  }
  return new GenSync(_2);
};
function gen3(f2) {
  return suspend3(() => {
    const iterator = f2(adapter3);
    const state = iterator.next();
    function run7(state2) {
      if (state2.done) {
        return succeed3(state2.value);
      }
      return chain_9(state2.value["effect"], (val) => {
        const next2 = iterator.next(val);
        return run7(next2);
      });
    }
    return run7(state);
  });
}

// node_modules/@effect-ts/system/_mjs/Fiber/tracing.mjs
var NoLocation = class {
  constructor() {
    this._tag = "NoLocation";
  }
};
var SourceLocation = class {
  constructor(location) {
    this.location = location;
    this._tag = "SourceLocation";
  }
};
function traceLocation(k2) {
  if (k2) {
    return new SourceLocation(k2);
  }
  return new NoLocation();
}
var Trace = class {
  constructor(fiberId3, executionTrace, stackTrace, parentTrace) {
    this.fiberId = fiberId3;
    this.executionTrace = executionTrace;
    this.stackTrace = stackTrace;
    this.parentTrace = parentTrace;
  }
};
function ancestryLengthSafe(trace3, i2) {
  const parent = trace3.parentTrace;
  if (parent._tag === "None") {
    return succeed3(i2);
  } else {
    return suspend3(() => ancestryLengthSafe(parent.value, i2 + 1));
  }
}
function ancestryLength(trace3) {
  return run3(ancestryLengthSafe(trace3, 0));
}
function parents(trace3) {
  const pushable = emptyPushable();
  let parent = toUndefined(trace3.parentTrace);
  while (parent != null) {
    push_(pushable, parent);
    parent = toUndefined(parent.parentTrace);
  }
  return pushable;
}
function truncatedParentTrace(trace3, maxAncestors) {
  if (ancestryLength(trace3) > maxAncestors) {
    return reduceRight_4(take_(parents(trace3), maxAncestors), none, (trace4, parent) => some(new Trace(trace4.fiberId, trace4.executionTrace, trace4.stackTrace, parent)));
  } else {
    return trace3.parentTrace;
  }
}
function prettyTrace(trace3) {
  return run3(prettyTraceSafe(trace3));
}
function prettyTraceSafe(trace3) {
  return gen3(function* ($2) {
    const execution = filter_2(trace3.executionTrace, (_2) => _2._tag === "SourceLocation");
    const stack = filter_2(trace3.stackTrace, (_2) => _2._tag === "SourceLocation");
    const execTrace = !isEmpty3(execution);
    const stackTrace = !isEmpty3(stack);
    const execPrint = execTrace ? [`Fiber: ${prettyFiberId(trace3.fiberId)} Execution trace:`, "", ...toArray(map_7(execution, (a2) => `  ${a2.location}`))] : [`Fiber: ${prettyFiberId(trace3.fiberId)} Execution trace: <empty trace>`];
    const stackPrint = stackTrace ? [`Fiber: ${prettyFiberId(trace3.fiberId)} was supposed to continue to:`, "", ...toArray(map_7(stack, (e2) => `  a future continuation at ${e2.location}`))] : [`Fiber: ${prettyFiberId(trace3.fiberId)} was supposed to continue to: <empty trace>`];
    const parent = trace3.parentTrace;
    const ancestry = parent._tag === "None" ? [`Fiber: ${prettyFiberId(trace3.fiberId)} was spawned by: <empty trace>`] : [`Fiber: ${prettyFiberId(trace3.fiberId)} was spawned by:`, yield* $2(prettyTraceSafe(parent.value))];
    return ["", ...stackPrint, "", ...execPrint, "", ...ancestry].join("\n");
  });
}

// node_modules/@effect-ts/system/_mjs/Cause/Pretty/index.mjs
function Failure(lines2) {
  return {
    _tag: "Failure",
    lines: lines2
  };
}
function Sequential(all4) {
  return {
    _tag: "Sequential",
    all: all4
  };
}
function Parallel(all4) {
  return {
    _tag: "Parallel",
    all: all4
  };
}
function headTail(a2) {
  const x2 = [...a2];
  const head6 = x2.shift();
  return [head6, x2];
}
function prefixBlock(values3, p1, p2) {
  return isNonEmpty(values3) ? (([head6, tail4]) => [`${p1}${head6}`, ...tail4.map((_2) => `${p2}${_2}`)])(headTail(values3)) : [];
}
function renderInterrupt(fiberId3, trace3, traceRenderer) {
  return Sequential([Failure([`An interrupt was produced by #${fiberId3.seqNumber}.`, "", ...renderTrace(trace3, traceRenderer)])]);
}
function renderError(error) {
  return lines(error.stack ? error.stack : String(error));
}
function renderDie(error, trace3, traceRenderer) {
  return Sequential([Failure(["An unchecked error was produced.", "", ...error, ...renderTrace(trace3, traceRenderer)])]);
}
function renderFail(error, trace3, traceRenderer) {
  return Sequential([Failure(["A checked error was not handled.", "", ...error, ...renderTrace(trace3, traceRenderer)])]);
}
function lines(s2) {
  return s2.split("\n").map((s3) => s3.replace("\r", ""));
}
function linearSegments(cause2, renderer) {
  return gen2(function* (_2) {
    switch (cause2._tag) {
      case "Then": {
        return [...yield* _2(linearSegments(cause2.left, renderer)), ...yield* _2(linearSegments(cause2.right, renderer))];
      }
      default: {
        return (yield* _2(causeToSequential(cause2, renderer))).all;
      }
    }
  });
}
function parallelSegments(cause2, renderer) {
  return gen2(function* (_2) {
    switch (cause2._tag) {
      case "Both": {
        return [...yield* _2(parallelSegments(cause2.left, renderer)), ...yield* _2(parallelSegments(cause2.right, renderer))];
      }
      default: {
        return [yield* _2(causeToSequential(cause2, renderer))];
      }
    }
  });
}
function renderToString(u2) {
  if (typeof u2 === "object" && u2 != null && "toString" in u2 && typeof u2["toString"] === "function" && u2["toString"] !== Object.prototype.toString) {
    return u2["toString"]();
  }
  return JSON.stringify(u2, null, 2);
}
function causeToSequential(cause2, renderer) {
  return gen2(function* (_2) {
    switch (cause2._tag) {
      case "Empty": {
        return Sequential([]);
      }
      case "Fail": {
        return renderFail(renderer.renderError(cause2.value), none, renderer.renderTrace);
      }
      case "Die": {
        return renderDie(renderer.renderUnknown(cause2.value), none, renderer.renderTrace);
      }
      case "Interrupt": {
        return renderInterrupt(cause2.fiberId, none, renderer.renderTrace);
      }
      case "Then": {
        return Sequential(yield* _2(linearSegments(cause2, renderer)));
      }
      case "Both": {
        return Sequential([Parallel(yield* _2(parallelSegments(cause2, renderer)))]);
      }
      case "Traced": {
        switch (cause2.cause._tag) {
          case "Fail": {
            return renderFail(renderer.renderError(cause2.cause.value), some(cause2.trace), renderer.renderTrace);
          }
          case "Die": {
            return renderDie(renderer.renderUnknown(cause2.cause.value), some(cause2.trace), renderer.renderTrace);
          }
          case "Interrupt": {
            return renderInterrupt(cause2.cause.fiberId, some(cause2.trace), renderer.renderTrace);
          }
          default: {
            return Sequential([Failure(["An error was rethrown with a new trace.", ...renderTrace(some(cause2.trace), renderer.renderTrace)]), ...(yield* _2(causeToSequential(cause2.cause, renderer))).all]);
          }
        }
      }
    }
  });
}
function renderTrace(o2, renderTrace2) {
  return o2._tag === "None" ? [] : lines(renderTrace2(o2.value));
}
function times(s2, n2) {
  let h2 = "";
  for (let i2 = 0; i2 < n2; i2 += 1) {
    h2 += s2;
  }
  return h2;
}
function format2(segment) {
  switch (segment._tag) {
    case "Failure": {
      return prefixBlock(segment.lines, "\u2500", " ");
    }
    case "Parallel": {
      return [times("\u2550\u2550\u2566", segment.all.length - 1) + "\u2550\u2550\u2557", ...reduceRight_(segment.all, [], (current, acc) => [...prefixBlock(acc, "  \u2551", "  \u2551"), ...prefixBlock(format2(current), "  ", "  ")])];
    }
    case "Sequential": {
      return chain_2(segment.all, (seg) => ["\u2551", ...prefixBlock(format2(seg), "\u2560", "\u2551"), "\u25BC"]);
    }
  }
}
function prettyLines(cause2, renderer) {
  return gen2(function* (_2) {
    const s2 = yield* _2(causeToSequential(cause2, renderer));
    if (s2.all.length === 1 && s2.all[0] && s2.all[0]._tag === "Failure") {
      return s2.all[0].lines;
    }
    return getOrElse_(updateAt_(format2(s2), 0, "\u2565"), () => []);
  });
}
function prettyM(cause2, renderer) {
  return gen2(function* (_2) {
    const lines2 = yield* _2(prettyLines(cause2, renderer));
    return `
${lines2.join("\n")}`;
  });
}
function defaultErrorToLines(error) {
  return error instanceof Error ? renderError(error) : lines(renderToString(error));
}
var defaultRenderer = {
  renderError: defaultErrorToLines,
  renderTrace: prettyTrace,
  renderUnknown: defaultErrorToLines
};
var pretty = (cause2, renderer = defaultRenderer) => run(prettyM(cause2, renderer));

// node_modules/@effect-ts/system/_mjs/Cause/errors.mjs
var _a3;
var _b2;
var _c2;
var _d2;
var _e3;
var _f2;
var FiberFailureSymbol = /* @__PURE__ */ Symbol.for("@matechs/core/symbols/errors/FiberFailure");
var FiberFailure = class extends Error {
  constructor(cause2) {
    super();
    this.cause = cause2;
    this[_a3] = "FiberFailure";
    this.pretty = pretty(this.cause);
    this.name = this[FiberFailureSymbol];
    delete this.stack;
  }
};
_a3 = FiberFailureSymbol;
var isFiberFailure = (u2) => u2 instanceof Error && u2[FiberFailureSymbol] === "FiberFailure";
var UntracedSymbol = /* @__PURE__ */ Symbol.for("@matechs/core/symbols/errors/Untraced");
var Untraced = class extends Error {
  constructor(message) {
    super(message);
    this[_b2] = "Untraced";
    delete this.stack;
    this.name = this[UntracedSymbol];
  }
};
_b2 = UntracedSymbol;
var isUntraced = (u2) => u2 instanceof Error && u2[UntracedSymbol] === "Untraced";
var RuntimeSymbol = /* @__PURE__ */ Symbol.for("@matechs/core/symbols/errors/Runtime");
var RuntimeError = class {
  constructor(message) {
    this.message = message;
    this[_c2] = "RuntimeError";
  }
};
_c2 = RuntimeSymbol;
var isRuntime = (u2) => u2 instanceof RuntimeError && u2[RuntimeSymbol] === "RuntimeError";
var InterruptedSymbol = /* @__PURE__ */ Symbol.for("@matechs/core/symbols/errors/Interrupted");
var InterruptedException = class extends Error {
  constructor(message) {
    super(message);
    this[_d2] = "InterruptedException";
    this.name = this[InterruptedSymbol];
  }
};
_d2 = InterruptedSymbol;
var isInterruptedException = (u2) => u2 instanceof Error && u2[InterruptedSymbol] === "InterruptedException";
var IllegalStateSymbol = /* @__PURE__ */ Symbol.for("@matechs/core/symbols/errors/IllegalState");
var IllegalStateException = class extends Error {
  constructor(message) {
    super(message);
    this[_e3] = "IllegalStateException";
    this.name = this[IllegalStateSymbol];
  }
};
_e3 = IllegalStateSymbol;
var isIllegalStateException = (u2) => u2 instanceof Error && u2[IllegalStateSymbol] === "IllegalStateException";
var IllegalArgumentSymbol = /* @__PURE__ */ Symbol.for("@matechs/core/symbols/errors/IllegalArgument");
var IllegalArgumentException = class extends Error {
  constructor(message) {
    super(message);
    this[_f2] = "IllegalArgumentException";
    this.name = this[IllegalArgumentSymbol];
  }
};
_f2 = IllegalArgumentSymbol;
var isIllegalArgumentException = (u2) => u2 instanceof Error && u2[IllegalArgumentSymbol] === "IllegalArgumentException";

// node_modules/@effect-ts/system/_mjs/Cause/core.mjs
function ap3(fa) {
  return chain6((f2) => map7(f2)(fa));
}
function as(e2) {
  return map7(() => e2);
}
function chain_10(cause2, f2) {
  return run(chainSafe_(cause2, f2));
}
function chain6(f2) {
  return (cause2) => chain_10(cause2, f2);
}
function chainSafe_(cause2, f2) {
  switch (cause2._tag) {
    case "Empty": {
      return succeed(empty3);
    }
    case "Fail": {
      return succeed(f2(cause2.value));
    }
    case "Die": {
      return succeed(cause2);
    }
    case "Interrupt": {
      return succeed(cause2);
    }
    case "Then": {
      return zipWith_(suspend(() => chainSafe_(cause2.left, f2)), suspend(() => chainSafe_(cause2.right, f2)), (l2, r2) => combineSeq(l2, r2));
    }
    case "Both": {
      return zipWith_(suspend(() => chainSafe_(cause2.left, f2)), suspend(() => chainSafe_(cause2.right, f2)), (l2, r2) => combinePar(l2, r2));
    }
    case "Traced": {
      return map_4(chainSafe_(cause2.cause, f2), (x2) => traced(x2, cause2.trace));
    }
  }
}
function map_11(cause2, f2) {
  return chain_10(cause2, (e2) => fail2(f2(e2)));
}
function map7(f2) {
  return (cause2) => map_11(cause2, f2);
}
function contains(that) {
  return (cause2) => run(containsSafe(that)(cause2));
}
function containsSafe(that) {
  return (cause2) => gen2(function* (_2) {
    if (yield* _2(cause2.equalsSafe(that))) {
      return true;
    }
    return yield* _2(reduceLeft(succeed(false))((_3, c2) => some(chain_4(_3, (b2) => b2 ? succeed(b2) : c2.equalsSafe(that))))(cause2));
  });
}
function defects(cause2) {
  return reduceLeft([])((a2, c2) => c2._tag === "Die" ? some([...a2, c2.value]) : none)(cause2);
}
function dieOption(cause2) {
  return find((c2) => c2._tag === "Die" ? some(c2.value) : none)(cause2);
}
function died(cause2) {
  return getOrElse_(map_(dieOption(cause2), () => true), () => false);
}
function failureOption(cause2) {
  return find((c2) => c2._tag === "Fail" ? some(c2.value) : none)(cause2);
}
function failed(cause2) {
  return getOrElse_(map_(failureOption(cause2), () => true), () => false);
}
function failureOrCause(cause2) {
  return getOrElse_(map_(failureOption(cause2), left), () => right(cause2));
}
function failures(cause2) {
  return reduceLeft([])((a2, c2) => c2._tag === "Fail" ? some([...a2, c2.value]) : none)(cause2);
}
function stripSomeDefects(f2) {
  return (cause2) => {
    return run(stripSomeDefectsSafe(cause2, f2));
  };
}
function stripSomeDefects_(cause2, f2) {
  return run(stripSomeDefectsSafe(cause2, f2));
}
function stripSomeDefectsSafe(cause2, f2) {
  switch (cause2._tag) {
    case "Empty": {
      return succeed(none);
    }
    case "Interrupt": {
      return succeed(some(cause2));
    }
    case "Fail": {
      return succeed(some(cause2));
    }
    case "Die": {
      return succeed(map_(f2(cause2.value), die));
    }
    case "Both": {
      return zipWith_(suspend(() => stripSomeDefectsSafe(cause2.left, f2)), suspend(() => stripSomeDefectsSafe(cause2.right, f2)), (l2, r2) => {
        if (l2._tag === "Some" && r2._tag === "Some") {
          return some(combinePar(l2.value, r2.value));
        } else if (l2._tag === "Some") {
          return l2;
        } else if (r2._tag === "Some") {
          return r2;
        } else {
          return none;
        }
      });
    }
    case "Then": {
      return zipWith_(suspend(() => stripSomeDefectsSafe(cause2.left, f2)), suspend(() => stripSomeDefectsSafe(cause2.right, f2)), (l2, r2) => {
        if (l2._tag === "Some" && r2._tag === "Some") {
          return some(combineSeq(l2.value, r2.value));
        } else if (l2._tag === "Some") {
          return l2;
        } else if (r2._tag === "Some") {
          return r2;
        } else {
          return none;
        }
      });
    }
    case "Traced": {
      return suspend(() => stripSomeDefectsSafe(cause2.cause, f2));
    }
  }
}
function find(f2) {
  return (cause2) => run(findSafe(f2)(cause2));
}
function findSafe(f2) {
  return (cause2) => {
    const apply = f2(cause2);
    if (apply._tag === "Some") {
      return succeed(apply);
    }
    switch (cause2._tag) {
      case "Then": {
        return chain_4(suspend(() => findSafe(f2)(cause2.left)), (isLeft2) => {
          if (isLeft2._tag === "Some") {
            return succeed(isLeft2);
          } else {
            return findSafe(f2)(cause2.right);
          }
        });
      }
      case "Traced": {
        return suspend(() => findSafe(f2)(cause2.cause));
      }
      case "Both": {
        return chain_4(suspend(() => findSafe(f2)(cause2.left)), (isLeft2) => {
          if (isLeft2._tag === "Some") {
            return succeed(isLeft2);
          } else {
            return findSafe(f2)(cause2.right);
          }
        });
      }
      default: {
        return succeed(apply);
      }
    }
  };
}
var flatten6 = /* @__PURE__ */ chain6(identity);
function fold4(empty8, failCase, dieCase, interruptCase, thenCase, bothCase, tracedCase) {
  return (cause2) => run(foldSafe(empty8, failCase, dieCase, interruptCase, thenCase, bothCase, tracedCase)(cause2));
}
function foldSafe(empty8, failCase, dieCase, interruptCase, thenCase, bothCase, tracedCase) {
  return (cause2) => {
    switch (cause2._tag) {
      case "Empty": {
        return succeedWith(empty8);
      }
      case "Fail": {
        return succeed(failCase(cause2.value));
      }
      case "Die": {
        return succeed(dieCase(cause2.value));
      }
      case "Interrupt": {
        return succeed(interruptCase(cause2.fiberId));
      }
      case "Traced": {
        return map_4(suspend(() => foldSafe(empty8, failCase, dieCase, interruptCase, thenCase, bothCase, tracedCase)(cause2.cause)), (x2) => tracedCase(x2, cause2.trace));
      }
      case "Both": {
        return zipWith_(suspend(() => foldSafe(empty8, failCase, dieCase, interruptCase, thenCase, bothCase, tracedCase)(cause2.left)), suspend(() => foldSafe(empty8, failCase, dieCase, interruptCase, thenCase, bothCase, tracedCase)(cause2.right)), (l2, r2) => bothCase(l2, r2));
      }
      case "Then": {
        return zipWith_(suspend(() => foldSafe(empty8, failCase, dieCase, interruptCase, thenCase, bothCase, tracedCase)(cause2.left)), suspend(() => foldSafe(empty8, failCase, dieCase, interruptCase, thenCase, bothCase, tracedCase)(cause2.right)), (l2, r2) => thenCase(l2, r2));
      }
    }
  };
}
function reduceLeft(z2) {
  return (f2) => {
    return (cause2) => {
      let causes = void 0;
      let current = cause2;
      let acc = z2;
      while (current) {
        const x2 = f2(acc, current);
        acc = x2._tag === "Some" ? x2.value : acc;
        switch (current._tag) {
          case "Then": {
            causes = new Stack(current.right, causes);
            current = current.left;
            break;
          }
          case "Both": {
            causes = new Stack(current.right, causes);
            current = current.left;
            break;
          }
          case "Traced": {
            current = current.cause;
            break;
          }
          default: {
            current = void 0;
            break;
          }
        }
        if (!current && causes) {
          current = causes.value;
          causes = causes.previous;
        }
      }
      return acc;
    };
  };
}
function interrupted(cause2) {
  return getOrElse_(map_(interruptOption(cause2), () => true), () => false);
}
function interruptOption(cause2) {
  return find((c2) => c2._tag === "Interrupt" ? some(c2.fiberId) : none)(cause2);
}
function interruptedOnly(cause2) {
  return getOrElse_(find((c2) => c2._tag === "Die" || c2._tag === "Fail" ? some(false) : none)(cause2), () => true);
}
function interruptors(cause2) {
  return Array.from(reduceLeft(/* @__PURE__ */ new Set())((s2, c2) => c2._tag === "Interrupt" ? some(s2.add(c2.fiberId)) : none)(cause2));
}
function keepDefectsSafe(cause2) {
  switch (cause2._tag) {
    case "Empty": {
      return succeed(none);
    }
    case "Fail": {
      return succeed(none);
    }
    case "Interrupt": {
      return succeed(none);
    }
    case "Die": {
      return succeed(some(cause2));
    }
    case "Traced": {
      return map_4(suspend(() => keepDefectsSafe(cause2.cause)), (x2) => map_(x2, (_2) => traced(_2, cause2.trace)));
    }
    case "Then": {
      return zipWith_(suspend(() => keepDefectsSafe(cause2.left)), suspend(() => keepDefectsSafe(cause2.right)), (l2, r2) => {
        if (l2._tag === "Some" && r2._tag === "Some") {
          return some(combineSeq(l2.value, r2.value));
        } else if (l2._tag === "Some") {
          return l2;
        } else if (r2._tag === "Some") {
          return r2;
        } else {
          return none;
        }
      });
    }
    case "Both": {
      return zipWith_(suspend(() => keepDefectsSafe(cause2.left)), suspend(() => keepDefectsSafe(cause2.right)), (l2, r2) => {
        if (l2._tag === "Some" && r2._tag === "Some") {
          return some(combinePar(l2.value, r2.value));
        } else if (l2._tag === "Some") {
          return l2;
        } else if (r2._tag === "Some") {
          return r2;
        } else {
          return none;
        }
      });
    }
  }
}
function keepDefects(cause2) {
  return run(keepDefectsSafe(cause2));
}
function sequenceCauseEither(c2) {
  return run(sequenceCauseEitherSafe(c2));
}
function sequenceCauseEitherSafe(c2) {
  switch (c2._tag) {
    case "Empty": {
      return succeed(left(empty3));
    }
    case "Interrupt": {
      return succeed(left(c2));
    }
    case "Fail": {
      return succeed(c2.value._tag === "Left" ? left(fail2(c2.value.left)) : right(c2.value.right));
    }
    case "Traced": {
      return map_4(suspend(() => sequenceCauseEitherSafe(c2.cause)), (x2) => mapLeft_(x2, (_2) => traced(_2, c2.trace)));
    }
    case "Die": {
      return succeed(left(c2));
    }
    case "Then": {
      return zipWith_(suspend(() => sequenceCauseEitherSafe(c2.left)), suspend(() => sequenceCauseEitherSafe(c2.right)), (l2, r2) => {
        if (l2._tag === "Left") {
          if (r2._tag === "Right") {
            return right(r2.right);
          } else {
            return left(combineSeq(l2.left, r2.left));
          }
        } else {
          return right(l2.right);
        }
      });
    }
    case "Both": {
      return zipWith_(suspend(() => sequenceCauseEitherSafe(c2.left)), suspend(() => sequenceCauseEitherSafe(c2.right)), (l2, r2) => {
        if (l2._tag === "Left") {
          if (r2._tag === "Right") {
            return right(r2.right);
          } else {
            return left(combinePar(l2.left, r2.left));
          }
        } else {
          return right(l2.right);
        }
      });
    }
  }
}
function sequenceCauseOptionSafe(c2) {
  switch (c2._tag) {
    case "Empty": {
      return succeed(some(empty3));
    }
    case "Interrupt": {
      return succeed(some(c2));
    }
    case "Traced": {
      return map_4(suspend(() => sequenceCauseOptionSafe(c2.cause)), (x2) => map_(x2, (_2) => traced(_2, c2.trace)));
    }
    case "Fail": {
      return succeed(map_(c2.value, fail2));
    }
    case "Die": {
      return succeed(some(c2));
    }
    case "Then": {
      return zipWith_(suspend(() => sequenceCauseOptionSafe(c2.left)), suspend(() => sequenceCauseOptionSafe(c2.right)), (l2, r2) => {
        if (l2._tag === "Some" && r2._tag === "Some") {
          return some(combineSeq(l2.value, r2.value));
        } else if (l2._tag === "Some") {
          return some(l2.value);
        } else if (r2._tag === "Some") {
          return some(r2.value);
        } else {
          return none;
        }
      });
    }
    case "Both": {
      return zipWith_(suspend(() => sequenceCauseOptionSafe(c2.left)), suspend(() => sequenceCauseOptionSafe(c2.right)), (l2, r2) => {
        if (l2._tag === "Some" && r2._tag === "Some") {
          return some(combinePar(l2.value, r2.value));
        } else if (l2._tag === "Some") {
          return some(l2.value);
        } else if (r2._tag === "Some") {
          return some(r2.value);
        } else {
          return none;
        }
      });
    }
  }
}
function sequenceCauseOption(c2) {
  return run(sequenceCauseOptionSafe(c2));
}
function squash(f2) {
  return (cause2) => getOrElse_(((o2) => o2._tag === "Some" ? o2 : head(defects(cause2)))(((o2) => o2._tag === "Some" ? o2 : interrupted(cause2) ? some(new InterruptedException("Interrupted by fibers: " + Array.from(interruptors(cause2)).map((_2) => _2.seqNumber.toString()).map((_2) => "#" + _2).join(", "))) : none)(map_(failureOption(cause2), f2))), () => new InterruptedException());
}
function stripFailures(cause2) {
  switch (cause2._tag) {
    case "Empty": {
      return empty3;
    }
    case "Fail": {
      return empty3;
    }
    case "Interrupt": {
      return cause2;
    }
    case "Die": {
      return cause2;
    }
    default: {
      return run(stripFailuresSafe(cause2));
    }
  }
}
function stripFailuresSafe(cause2) {
  switch (cause2._tag) {
    case "Empty": {
      return succeed(empty3);
    }
    case "Fail": {
      return succeed(empty3);
    }
    case "Interrupt": {
      return succeed(cause2);
    }
    case "Die": {
      return succeed(cause2);
    }
    case "Traced": {
      return map_4(suspend(() => stripFailuresSafe(cause2.cause)), (x2) => traced(x2, cause2.trace));
    }
    case "Both": {
      return zipWith_(suspend(() => stripFailuresSafe(cause2.left)), suspend(() => stripFailuresSafe(cause2.right)), (l2, r2) => combinePar(l2, r2));
    }
    case "Then": {
      return zipWith_(suspend(() => stripFailuresSafe(cause2.left)), suspend(() => stripFailuresSafe(cause2.right)), (l2, r2) => combineSeq(l2, r2));
    }
  }
}
function stripInterrupts(cause2) {
  switch (cause2._tag) {
    case "Empty": {
      return empty3;
    }
    case "Fail": {
      return cause2;
    }
    case "Interrupt": {
      return empty3;
    }
    case "Die": {
      return cause2;
    }
    default: {
      return run(stripInterruptsSafe(cause2));
    }
  }
}
function stripInterruptsSafe(cause2) {
  switch (cause2._tag) {
    case "Empty": {
      return succeed(empty3);
    }
    case "Fail": {
      return succeed(cause2);
    }
    case "Interrupt": {
      return succeed(empty3);
    }
    case "Die": {
      return succeed(cause2);
    }
    case "Traced": {
      return map_4(suspend(() => stripInterruptsSafe(cause2.cause)), (x2) => traced(x2, cause2.trace));
    }
    case "Both": {
      return zipWith_(suspend(() => stripInterruptsSafe(cause2.left)), suspend(() => stripInterruptsSafe(cause2.right)), (l2, r2) => combinePar(l2, r2));
    }
    case "Then": {
      return zipWith_(suspend(() => stripInterruptsSafe(cause2.left)), suspend(() => stripInterruptsSafe(cause2.right)), (l2, r2) => combineSeq(l2, r2));
    }
  }
}
function untraced(cause2) {
  switch (cause2._tag) {
    case "Die":
    case "Empty":
    case "Fail":
    case "Interrupt":
      return cause2;
    default:
      return run(untracedSafe(cause2));
  }
}
function untracedSafe(cause2) {
  switch (cause2._tag) {
    case "Traced": {
      return suspend(() => untracedSafe(cause2.cause));
    }
    case "Both": {
      return zipWith_(suspend(() => untracedSafe(cause2.left)), suspend(() => untracedSafe(cause2.right)), (l2, r2) => combinePar(l2, r2));
    }
    case "Then": {
      return zipWith_(suspend(() => untracedSafe(cause2.left)), suspend(() => untracedSafe(cause2.right)), (l2, r2) => combineSeq(l2, r2));
    }
    default: {
      return succeed(cause2);
    }
  }
}
var FCOStackFrameDoneTypeId = /* @__PURE__ */ Symbol();
var FCOStackFrameDone = class {
  constructor() {
    this._typeId = FCOStackFrameDoneTypeId;
  }
};
var FCOStackFrameTracedTypeId = /* @__PURE__ */ Symbol();
var FCOStackFrameTraced = class {
  constructor(cause2) {
    this.cause = cause2;
    this._typeId = FCOStackFrameTracedTypeId;
  }
};
var FCOStackFrameThenLeftTypeId = /* @__PURE__ */ Symbol();
var FCOStackFrameThenLeft = class {
  constructor(cause2) {
    this.cause = cause2;
    this._typeId = FCOStackFrameThenLeftTypeId;
  }
};
var FCOStackFrameThenRightTypeId = /* @__PURE__ */ Symbol();
var FCOStackFrameThenRight = class {
  constructor(cause2, leftResult) {
    this.cause = cause2;
    this.leftResult = leftResult;
    this._typeId = FCOStackFrameThenRightTypeId;
  }
};
var FCOStackFrameBothLeftTypeId = /* @__PURE__ */ Symbol();
var FCOStackFrameBothLeft = class {
  constructor(cause2) {
    this.cause = cause2;
    this._typeId = FCOStackFrameBothLeftTypeId;
  }
};
var FCOStackFrameBothRightTypeId = /* @__PURE__ */ Symbol();
var FCOStackFrameBothRight = class {
  constructor(cause2, leftResult) {
    this.cause = cause2;
    this.leftResult = leftResult;
    this._typeId = FCOStackFrameBothRightTypeId;
  }
};
function flipCauseOption(c2) {
  let stack = new Stack(new FCOStackFrameDone());
  let result4;
  recursion:
    while (stack) {
      pushing:
        while (true) {
          switch (c2._tag) {
            case "Empty":
              result4 = some(empty3);
              break pushing;
            case "Traced":
              stack = new Stack(new FCOStackFrameTraced(c2), stack);
              c2 = c2.cause;
              continue pushing;
            case "Interrupt":
              result4 = some(interrupt(c2.fiberId));
              break pushing;
            case "Die":
              result4 = some(c2);
              break pushing;
            case "Fail":
              result4 = fold_(c2.value, () => none, (r2) => some(fail2(r2)));
              break pushing;
            case "Then":
              stack = new Stack(new FCOStackFrameThenLeft(c2), stack);
              c2 = c2.left;
              continue pushing;
            case "Both":
              stack = new Stack(new FCOStackFrameBothLeft(c2), stack);
              c2 = c2.left;
              continue pushing;
          }
        }
      popping:
        while (true) {
          const top = stack.value;
          stack = stack.previous;
          switch (top._typeId) {
            case FCOStackFrameDoneTypeId:
              return result4;
            case FCOStackFrameTracedTypeId:
              result4 = map_(result4, (_2) => traced(_2, top.cause.trace));
              continue popping;
            case FCOStackFrameThenLeftTypeId:
              c2 = top.cause.right;
              stack = new Stack(new FCOStackFrameThenRight(top.cause, result4), stack);
              continue recursion;
            case FCOStackFrameThenRightTypeId: {
              const l2 = top.leftResult;
              if (isSome(l2) && isSome(result4)) {
                result4 = some(combineSeq(l2.value, result4.value));
              }
              if (isNone(l2) && isSome(result4)) {
                result4 = some(result4.value);
              }
              if (isSome(l2) && isNone(result4)) {
                result4 = some(l2.value);
              }
              result4 = none;
              continue popping;
            }
            case FCOStackFrameBothLeftTypeId:
              c2 = top.cause.right;
              stack = new Stack(new FCOStackFrameBothRight(top.cause, result4), stack);
              continue recursion;
            case FCOStackFrameBothRightTypeId: {
              const l2 = top.leftResult;
              if (isSome(l2) && isSome(result4)) {
                result4 = some(combinePar(l2.value, result4.value));
              }
              if (isNone(l2) && isSome(result4)) {
                result4 = some(result4.value);
              }
              if (isSome(l2) && isNone(result4)) {
                result4 = some(l2.value);
              }
              result4 = none;
              continue popping;
            }
          }
        }
    }
  throw new Error("Bug");
}

// node_modules/@effect-ts/system/_mjs/Exit/exit.mjs
var Success = class _Success {
  constructor(value) {
    this.value = value;
    this._tag = "Success";
  }
  get [hashSym]() {
    return hash(this.value);
  }
  [equalsSym](that) {
    return that instanceof _Success && equals(this.value, that.value);
  }
};
var Failure2 = class _Failure {
  constructor(cause2) {
    this.cause = cause2;
    this._tag = "Failure";
  }
  get [hashSym]() {
    return hash(this.cause);
  }
  [equalsSym](that) {
    return that instanceof _Failure && equals(this.cause, that.cause);
  }
};

// node_modules/@effect-ts/system/_mjs/Exit/core.mjs
function chain_11(exit, f2) {
  switch (exit._tag) {
    case "Failure": {
      return exit;
    }
    case "Success": {
      return f2(exit.value);
    }
  }
}
function chain7(f2) {
  return (exit) => chain_11(exit, f2);
}
function collectAll(...exits) {
  return map_(head(exits), (head6) => map8(reverse)(reduce_(drop_(exits, 1), map8((x2) => [x2])(head6), (acc, el) => zipWith2(el, (acc2, el2) => [el2, ...acc2], combineSeq)(acc))));
}
function zipWith_3(exit, that, f2, g2) {
  switch (exit._tag) {
    case "Failure": {
      switch (that._tag) {
        case "Success": {
          return exit;
        }
        case "Failure": {
          return halt(g2(exit.cause, that.cause));
        }
      }
    }
    case "Success": {
      switch (that._tag) {
        case "Success": {
          return succeed4(f2(exit.value, that.value));
        }
        case "Failure": {
          return that;
        }
      }
    }
  }
}
function zipWith2(that, f2, g2) {
  return (exit) => zipWith_3(exit, that, f2, g2);
}
function collectAllPar(...exits) {
  return map_(head(exits), (head6) => map8(reverse)(reduce_(drop_(exits, 1), map8((x2) => [x2])(head6), (acc, el) => zipWith2(el, (acc2, el2) => [el2, ...acc2], combinePar)(acc))));
}
function fail5(e2) {
  return halt(fail2(e2));
}
function failCause(cause2) {
  return new Failure2(cause2);
}
function flatten7(exit) {
  return chain7(identity)(exit);
}
function fold_4(exit, failed2, succeed12) {
  switch (exit._tag) {
    case "Success": {
      return succeed12(exit.value);
    }
    case "Failure": {
      return failed2(exit.cause);
    }
  }
}
function fold5(failed2, succeed12) {
  return (exit) => fold_4(exit, failed2, succeed12);
}
function halt(cause2) {
  return new Failure2(cause2);
}
function interrupt2(id) {
  return halt(interrupt(id));
}
function map_12(exit, f2) {
  return chain7((a2) => succeed4(f2(a2)))(exit);
}
function map8(f2) {
  return (exit) => map_12(exit, f2);
}
function mapError_2(exit, f2) {
  switch (exit._tag) {
    case "Failure": {
      return halt(map7(f2)(exit.cause));
    }
    case "Success": {
      return exit;
    }
  }
}
function succeed4(a2) {
  return new Success(a2);
}
function succeeded(exit) {
  switch (exit._tag) {
    case "Failure": {
      return false;
    }
    case "Success": {
      return true;
    }
  }
}
var unit2 = /* @__PURE__ */ succeed4(void 0);
function zipRight_(exit, that) {
  return zipWith2(that, (_2, b2) => b2, combineSeq)(exit);
}
function mapBoth_(self, f2, g2) {
  return map_12(mapError_2(self, f2), g2);
}

// node_modules/@effect-ts/system/_mjs/Effect/effect.mjs
var EffectURI = "Effect";
var Base2 = class {
};
function instruction(self) {
  return self;
}

// node_modules/@effect-ts/system/_mjs/Effect/primitives.mjs
var IFail = class extends Base2 {
  constructor(fill2, trace3) {
    super();
    this.fill = fill2;
    this.trace = trace3;
    this._tag = "Fail";
  }
};
var IFlatMap = class extends Base2 {
  constructor(val, f2, trace3) {
    super();
    this.val = val;
    this.f = f2;
    this.trace = trace3;
    this._tag = "FlatMap";
  }
};
var ISucceed = class extends Base2 {
  constructor(val, trace3) {
    super();
    this.val = val;
    this.trace = trace3;
    this._tag = "Succeed";
  }
};
var ITrace = class extends Base2 {
  constructor() {
    super();
    this._tag = "Trace";
  }
};
var ITracingStatus = class extends Base2 {
  constructor(effect2, flag) {
    super();
    this.effect = effect2;
    this.flag = flag;
    this._tag = "TracingStatus";
  }
};
var ICheckTracingStatus = class extends Base2 {
  constructor(f2) {
    super();
    this.f = f2;
    this._tag = "CheckTracingStatus";
  }
};
var IEffectPartial = class extends Base2 {
  constructor(effect2, onThrow, trace3) {
    super();
    this.effect = effect2;
    this.onThrow = onThrow;
    this.trace = trace3;
    this._tag = "EffectPartial";
  }
};
var IEffectTotal = class extends Base2 {
  constructor(effect2, trace3) {
    super();
    this.effect = effect2;
    this.trace = trace3;
    this._tag = "EffectTotal";
  }
};
var IEffectAsync = class extends Base2 {
  constructor(register, blockingOn, trace3) {
    super();
    this.register = register;
    this.blockingOn = blockingOn;
    this.trace = trace3;
    this._tag = "EffectAsync";
  }
};
var IFold = class extends Base2 {
  constructor(value, failure, apply, trace3) {
    super();
    this.value = value;
    this.failure = failure;
    this.apply = apply;
    this.trace = trace3;
    this._tag = "Fold";
  }
};
var IFork = class extends Base2 {
  constructor(value, scope3, reportFailure, trace3) {
    super();
    this.value = value;
    this.scope = scope3;
    this.reportFailure = reportFailure;
    this.trace = trace3;
    this._tag = "Fork";
  }
};
var IInterruptStatus = class extends Base2 {
  constructor(effect2, flag, trace3) {
    super();
    this.effect = effect2;
    this.flag = flag;
    this.trace = trace3;
    this._tag = "InterruptStatus";
  }
};
var ICheckInterrupt = class extends Base2 {
  constructor(f2, trace3) {
    super();
    this.f = f2;
    this.trace = trace3;
    this._tag = "CheckInterrupt";
  }
};
var IDescriptor = class extends Base2 {
  constructor(f2, trace3) {
    super();
    this.f = f2;
    this.trace = trace3;
    this._tag = "Descriptor";
  }
};
var IYield = class extends Base2 {
  constructor() {
    super();
    this._tag = "Yield";
  }
};
var IRead = class extends Base2 {
  constructor(f2, trace3) {
    super();
    this.f = f2;
    this.trace = trace3;
    this._tag = "Read";
  }
};
var IPlatform = class extends Base2 {
  constructor(f2, trace3) {
    super();
    this.f = f2;
    this.trace = trace3;
    this._tag = "Platform";
  }
};
var ITracer = class extends Base2 {
  constructor(f2, trace3) {
    super();
    this.f = f2;
    this.trace = trace3;
    this._tag = "Tracer";
  }
};
var IProvide = class extends Base2 {
  constructor(r2, next2, trace3) {
    super();
    this.r = r2;
    this.next = next2;
    this.trace = trace3;
    this._tag = "Provide";
  }
};
var ISuspend = class extends Base2 {
  constructor(factory, trace3) {
    super();
    this.factory = factory;
    this.trace = trace3;
    this._tag = "Suspend";
  }
};
var ISuspendPartial = class extends Base2 {
  constructor(factory, onThrow, trace3) {
    super();
    this.factory = factory;
    this.onThrow = onThrow;
    this.trace = trace3;
    this._tag = "SuspendPartial";
  }
};
var IFiberRefNew = class extends Base2 {
  constructor(initial2, onFork, onJoin) {
    super();
    this.initial = initial2;
    this.onFork = onFork;
    this.onJoin = onJoin;
    this._tag = "FiberRefNew";
  }
};
var IFiberRefModify = class extends Base2 {
  constructor(fiberRef, f2, trace3) {
    super();
    this.fiberRef = fiberRef;
    this.f = f2;
    this.trace = trace3;
    this._tag = "FiberRefModify";
  }
};
var IRaceWith = class extends Base2 {
  constructor(left4, right5, leftWins, rightWins, scope3, trace3) {
    super();
    this.left = left4;
    this.right = right5;
    this.leftWins = leftWins;
    this.rightWins = rightWins;
    this.scope = scope3;
    this.trace = trace3;
    this._tag = "RaceWith";
  }
};
var ISupervise = class extends Base2 {
  constructor(effect2, supervisor, trace3) {
    super();
    this.effect = effect2;
    this.supervisor = supervisor;
    this.trace = trace3;
    this._tag = "Supervise";
  }
};
var IGetForkScope = class extends Base2 {
  constructor(f2, trace3) {
    super();
    this.f = f2;
    this.trace = trace3;
    this._tag = "GetForkScope";
  }
};
var IOverrideForkScope = class extends Base2 {
  constructor(effect2, forkScope2, trace3) {
    super();
    this.effect = effect2;
    this.forkScope = forkScope2;
    this.trace = trace3;
    this._tag = "OverrideForkScope";
  }
};

// node_modules/@effect-ts/system/_mjs/Effect/core.mjs
function access3(f2, __trace) {
  return new IRead((_2) => new ISucceed(f2(_2)), __trace);
}
function accessM3(f2, __trace) {
  return new IRead(f2, __trace);
}
function chain8(f2, __trace) {
  return (val) => new IFlatMap(val, f2, __trace);
}
function chain_12(val, f2, __trace) {
  return new IFlatMap(val, f2, __trace);
}
function descriptorWith(f2, __trace) {
  return new IDescriptor(f2, __trace);
}
function checkInterruptible(f2, __trace) {
  return new ICheckInterrupt(f2, __trace);
}
var trace2 = /* @__PURE__ */ new ITrace();
function checkTraced(f2) {
  return new ICheckTracingStatus(f2);
}
function untraced2(self) {
  return new ITracingStatus(self, false);
}
function traced2(self) {
  return new ITracingStatus(self, true);
}
function effectAsyncOption(register, __trace) {
  return new IEffectAsync(register, [], __trace);
}
function effectAsyncOptionBlockingOn(register, blockingOn, __trace) {
  return new IEffectAsync(register, blockingOn, __trace);
}
function tryCatch4(effect2, onThrow, __trace) {
  return new IEffectPartial(effect2, onThrow, __trace);
}
function try_(effect2, __trace) {
  return new IEffectPartial(effect2, identity, __trace);
}
function succeedWith3(effect2, __trace) {
  return new IEffectTotal(effect2, __trace);
}
function foldCauseM(failure, success, __trace) {
  return (value) => new IFold(value, failure, success, __trace);
}
function foldCauseM_(value, failure, success, __trace) {
  return new IFold(value, failure, success, __trace);
}
function fork(value, __trace) {
  return new IFork(value, none, none, __trace);
}
function forkReport(reportFailure, __trace) {
  return (value) => new IFork(value, none, some(reportFailure), __trace);
}
function forkReport_(value, reportFailure, __trace) {
  return new IFork(value, none, some(reportFailure), __trace);
}
function halt2(cause2, __trace) {
  return new IFail(() => cause2, __trace);
}
function haltWith(cause2, __trace) {
  return new IFail(cause2, __trace);
}
function interruptStatus(flag, __trace) {
  return (effect2) => new IInterruptStatus(effect2, flag, __trace);
}
function interruptStatus_(effect2, flag, __trace) {
  return new IInterruptStatus(effect2, flag, __trace);
}
function tracingStatus(flag) {
  return (effect2) => new ITracingStatus(effect2, flag);
}
function tracingStatus_(effect2, flag) {
  return new ITracingStatus(effect2, flag);
}
function provideAll2(r2, __trace) {
  return (next2) => new IProvide(r2, next2, __trace);
}
function provideAll_3(next2, r2, __trace) {
  return new IProvide(r2, next2, __trace);
}
function result(value, __trace) {
  return new IFold(value, (cause2) => succeed5(halt(cause2)), (succ) => succeed5(succeed4(succ)), __trace);
}
function succeed5(a2, __trace) {
  return new ISucceed(a2, __trace);
}
function supervised(supervisor, __trace) {
  return (fa) => new ISupervise(fa, supervisor, __trace);
}
function supervised_(fa, supervisor, __trace) {
  return new ISupervise(fa, supervisor, __trace);
}
function suspend4(factory, __trace) {
  return new ISuspend(factory, __trace);
}
function tryCatchSuspend(factory, onThrow, __trace) {
  return new ISuspendPartial(factory, onThrow, __trace);
}
function tryOrElse_(self, that, success, __trace) {
  return new IFold(self, (cause2) => fold_(keepDefects(cause2), that, halt2), success, __trace);
}
function tryOrElse(that, success, __trace) {
  return (self) => tryOrElse_(self, that, success, __trace);
}
var unit3 = /* @__PURE__ */ new ISucceed(void 0);
var unitTraced = (__trace) => new ISucceed(void 0, __trace);
var yieldNow = /* @__PURE__ */ new IYield();
function checkPlatform(f2, __trace) {
  return new IPlatform(f2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/fail.mjs
function fail6(e2, __trace) {
  return haltWith((trace3) => traced(fail2(e2), trace3()), __trace);
}
function failWith(e2, __trace) {
  return haltWith((trace3) => traced(fail2(e2()), trace3()), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/fromEither.mjs
function fromEither2(f2, __trace) {
  return chain_12(succeedWith3(f2), fold2(fail6, succeed5), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/absolve.mjs
function absolve(v2, __trace) {
  return chain_12(v2, (e2) => fromEither2(() => e2), __trace);
}

// node_modules/@effect-ts/system/_mjs/Cause/do.mjs
var bind = (tag2, f2) => (mk) => chain6((k2) => map7((a2) => ({
  ...k2,
  [tag2]: a2
}))(f2(k2)))(mk);
var let_ = (tag2, f2) => (mk) => map7((k2) => ({
  ...k2,
  [tag2]: f2(k2)
}))(mk);
var do_ = /* @__PURE__ */ fail2({});

// node_modules/@effect-ts/system/_mjs/Effect/foldM.mjs
function foldM_2(value, failure, success, __trace) {
  return foldCauseM_(value, (cause2) => fold_2(failureOrCause(cause2), failure, halt2), success, __trace);
}
function foldM2(failure, success, __trace) {
  return (value) => foldM_2(value, failure, success, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/sandbox.mjs
function sandbox(fa, __trace) {
  return foldCauseM_(fa, fail6, succeed5, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/absorbWith.mjs
function absorbWith(f2, __trace) {
  return (fa) => absorbWith_(fa, f2, __trace);
}
function absorbWith_(fa, f2, __trace) {
  return foldM_2(sandbox(fa), (x2) => fail6(squash(f2)(x2)), succeed5, __trace);
}
function absorb(self, __trace) {
  return absorbWith_(self, identity, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/andThen.mjs
function andThen(fb, __trace) {
  return (fa) => andThen_(fa, fb, __trace);
}
function andThen_(fa, fb, __trace) {
  return chain_12(fa, (a2) => provideAll_3(fb, a2), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/map.mjs
function map_13(_2, f2, __trace) {
  return chain_12(_2, (a2) => succeed5(f2(a2)), __trace);
}
function map9(f2, __trace) {
  return (self) => map_13(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Effect/ap.mjs
function ap4(fa, __trace) {
  return (fab) => ap_3(fab, fa, __trace);
}
function ap_3(fab, fa, __trace) {
  return chain_12(fab, (ab) => map_13(fa, ab), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/as.mjs
function as_(self, b2, __trace) {
  return map_13(self, () => b2, __trace);
}
function as2(b2, __trace) {
  return (self) => as_(self, b2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/asService.mjs
function asService(has2, __trace) {
  return (fa) => asService_(fa, has2, __trace);
}
function asService_(fa, tag2, __trace) {
  return map_13(fa, tag2.has, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/asSome.mjs
function asSome(fa, __trace) {
  return map_13(fa, some, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/mapError.mjs
function mapError_3(self, f2, __trace) {
  return foldCauseM_(self, (c2) => halt2(map_11(c2, f2)), (a2) => succeed5(a2), __trace);
}
function mapError2(f2, __trace) {
  return (self) => mapError_3(self, f2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/asSomeError.mjs
function asSomeError(self, __trace) {
  return mapError_3(self, some, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/asUnit.mjs
function asUnit(self, __trace) {
  return chain_12(self, () => unit3, __trace);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/reduceRight.mjs
function reduceRight_5(self, s2, f2) {
  ;
  switch (self._typeId) {
    case SingletonTypeId: {
      return f2(self.a, s2);
    }
    case ArrTypeId: {
      const arr = self.arrayLike();
      const len = arr.length;
      let s1 = s2;
      let i2 = len - 1;
      while (i2 >= 0) {
        s1 = f2(arr[i2], s1);
        i2--;
      }
      return s1;
    }
    default: {
      const iterator = self.reverseArrayLikeIterator();
      let next2;
      let s1 = s2;
      while ((next2 = iterator.next()) && !next2.done) {
        const array2 = next2.value;
        const len = array2.length;
        let i2 = len - 1;
        while (i2 >= 0) {
          const a2 = array2[i2];
          s1 = f2(a2, s1);
          i2--;
        }
      }
      return s1;
    }
  }
}
function reduceRight2(s2, f2) {
  return (self) => reduceRight_5(self, s2, f2);
}

// node_modules/@effect-ts/system/_mjs/Exit/api.mjs
function foldM3(failed2, succeed12) {
  return (exit) => foldM_3(exit, failed2, succeed12);
}
function foldM_3(exit, failed2, succeed12) {
  switch (exit._tag) {
    case "Success": {
      return succeed12(exit.value);
    }
    case "Failure": {
      return failed2(exit.cause);
    }
  }
}
function forEach2(f2) {
  return (exit) => forEach_3(exit, f2);
}
function forEach_3(exit, f2) {
  switch (exit._tag) {
    case "Failure": {
      return succeed5(halt(exit.cause));
    }
    case "Success": {
      return result(f2(exit.value));
    }
  }
}

// node_modules/@effect-ts/system/_mjs/Effect/ExecutionStrategy.mjs
var Sequential2 = class {
  constructor() {
    this._tag = "Sequential";
  }
};
var Parallel2 = class {
  constructor() {
    this._tag = "Parallel";
  }
};
var ParallelN = class {
  constructor(n2) {
    this.n = n2;
    this._tag = "ParallelN";
  }
};
var sequential = /* @__PURE__ */ new Sequential2();
var parallel = /* @__PURE__ */ new Parallel2();
function parallelN(n2) {
  return new ParallelN(n2);
}

// node_modules/@effect-ts/system/_mjs/Ref/atomic.mjs
function getAndSet(self, a2) {
  return succeedWith3(() => {
    const v2 = self.value.get;
    self.value.set(a2);
    return v2;
  });
}
function modify3(self, f2) {
  return succeedWith3(() => {
    const v2 = self.value.get;
    const o2 = f2(v2);
    self.value.set(o2.get(1));
    return o2.get(0);
  });
}
function update3(self, f2) {
  return succeedWith3(() => {
    self.value.set(f2(self.value.get));
  });
}

// node_modules/@effect-ts/system/_mjs/Effect/do.mjs
function bind2(tag2, f2, __trace) {
  return (mk) => bind_(mk, tag2, f2, __trace);
}
function bind_(mk, tag2, f2, __trace) {
  return chain_12(mk, (k2) => map_13(f2(k2), (a2) => ({
    ...k2,
    [tag2]: a2
  })), __trace);
}
function let__(tag2, f2, __trace) {
  return (mk) => let_2(mk, tag2, f2);
}
function let_2(mk, tag2, f2, __trace) {
  return map_13(mk, (k2) => ({
    ...k2,
    [tag2]: f2(k2)
  }), __trace);
}
var do_2 = /* @__PURE__ */ succeed5({});

// node_modules/@effect-ts/system/_mjs/Effect/ifM.mjs
function ifM(onTrue, onFalse, __trace) {
  return (b2) => ifM_(b2, onTrue, onFalse, __trace);
}
function ifM_(b2, onTrue, onFalse, __trace) {
  return chain_12(b2, (x2) => x2 ? suspend4(onTrue, __trace) : suspend4(onFalse, __trace));
}
function _if(onTrue, onFalse, __trace) {
  return (b2) => if_(b2, onTrue, onFalse, __trace);
}
function if_(b2, onTrue, onFalse, __trace) {
  return ifM_(succeed5(b2), onTrue, onFalse, __trace);
}

// node_modules/@effect-ts/system/_mjs/Ref/XRef.mjs
var TypeId = /* @__PURE__ */ Symbol();
var Atomic = class {
  constructor(value) {
    this.value = value;
    this._tag = "Atomic";
    this._typeId = TypeId;
    this.fold = this.fold.bind(this);
    this.foldAll = this.foldAll.bind(this);
    this.set = this.set.bind(this);
  }
  fold(_ea, _eb, ca, bd) {
    return new Derived((f2) => f2(this, (s2) => bd(s2), (c2) => ca(c2)));
  }
  foldAll(_ea, _eb, _ec, ca, bd) {
    return new DerivedAll((f2) => f2(this, (s2) => bd(s2), (c2) => (s2) => ca(c2)(s2)));
  }
  get get() {
    return succeedWith3(() => this.value.get);
  }
  set(a2) {
    return succeedWith3(() => {
      this.value.set(a2);
    });
  }
};
var Derived = class _Derived {
  constructor(use2) {
    this.use = use2;
    this._tag = "Derived";
    this._typeId = TypeId;
    this.fold = this.fold.bind(this);
    this.foldAll = this.foldAll.bind(this);
    this.set = this.set.bind(this);
  }
  fold(ea, eb, ca, bd) {
    return this.use((value, getEither, setEither) => new _Derived((f2) => f2(value, (s2) => fold_2(getEither(s2), (e2) => left(eb(e2)), bd), (c2) => chain_3(ca(c2), (a2) => fold_2(setEither(a2), (e2) => left(ea(e2)), right)))));
  }
  foldAll(ea, eb, ec, ca, _bd) {
    return this.use((value, getEither, setEither) => new DerivedAll((f2) => f2(value, (s2) => fold_2(getEither(s2), (e2) => left(eb(e2)), right), (c2) => (s2) => chain_3(fold_2(getEither(s2), (e2) => left(ec(e2)), ca(c2)), (a2) => fold_2(setEither(a2), (e2) => left(ea(e2)), right)))));
  }
  get get() {
    return this.use((value, getEither) => chain_12(value.get, (s2) => fold_2(getEither(s2), fail6, succeed5)));
  }
  set(a2) {
    return this.use((value, _2, setEither) => fold_2(setEither(a2), fail6, value.set));
  }
};
var DerivedAll = class _DerivedAll {
  constructor(use2) {
    this.use = use2;
    this._tag = "DerivedAll";
    this._typeId = TypeId;
    this.fold = this.fold.bind(this);
    this.foldAll = this.foldAll.bind(this);
    this.set = this.set.bind(this);
  }
  fold(ea, eb, ca, bd) {
    return this.use((value, getEither, setEither) => new _DerivedAll((f2) => f2(value, (s2) => fold_2(getEither(s2), (e2) => left(eb(e2)), bd), (c2) => (s2) => chain_3(ca(c2), (a2) => fold_2(setEither(a2)(s2), (e2) => left(ea(e2)), right)))));
  }
  foldAll(ea, eb, ec, ca, bd) {
    return this.use((value, getEither, setEither) => new _DerivedAll((f2) => f2(value, (s2) => fold_2(getEither(s2), (e2) => left(eb(e2)), bd), (c2) => (s2) => chain_3(fold_2(getEither(s2), (e2) => left(ec(e2)), ca(c2)), (a2) => fold_2(setEither(a2)(s2), (e2) => left(ea(e2)), right)))));
  }
  get get() {
    return this.use((value, getEither) => chain_12(value.get, (a2) => fold_2(getEither(a2), fail6, succeed5)));
  }
  set(a2) {
    return this.use((value, _2, setEither) => absolve(modify3(value, (s2) => fold_2(setEither(a2)(s2), (e2) => tuple2(leftW(e2), s2), (s3) => tuple2(right(void 0), s3)))));
  }
};

// node_modules/@effect-ts/system/_mjs/Ref/api.mjs
function makeRef(a2) {
  return succeedWith3(() => new Atomic(new AtomicReference(a2)));
}
function unsafeMakeRef(a2) {
  return new Atomic(new AtomicReference(a2));
}
function modify_2(self, f2) {
  return matchTag({
    Atomic: (_2) => modify3(_2, f2),
    Derived: (self2) => self2.use((value, getEither, setEither) => absolve(modify3(value, (s2) => fold_2(getEither(s2), (e2) => tuple2(left(e2), s2), (a1) => (({
      tuple: [b2, a2]
    }) => fold_2(setEither(a2), (e2) => tuple2(left(e2), s2), (s3) => tuple2(right(b2), s3)))(f2(a1)))))),
    DerivedAll: (self2) => self2.use((value, getEither, setEither) => absolve(modify3(value, (s2) => fold_2(getEither(s2), (e2) => tuple2(left(e2), s2), (a1) => (({
      tuple: [b2, a2]
    }) => fold_2(setEither(a2)(s2), (e2) => tuple2(left(e2), s2), (s3) => tuple2(right(b2), s3)))(f2(a1))))))
  })(self);
}
function getAndSet2(a2) {
  return (self) => getAndSet_(self, a2);
}
function getAndSet_(self, a2) {
  return matchTag({
    Atomic: (_2) => getAndSet(_2, a2)
  }, (_2) => modify_2(_2, (v2) => tuple2(v2, a2)))(self);
}
function update_3(self, f2) {
  return matchTag({
    Atomic: (_2) => update3(_2, f2)
  }, (_2) => modify_2(_2, (v2) => tuple2(void 0, f2(v2))))(self);
}
function get4(self) {
  return self.get;
}
function set_2(self, a2) {
  return self.set(a2);
}

// node_modules/@effect-ts/system/_mjs/Effect/done.mjs
function done(exit, __trace) {
  switch (exit._tag) {
    case "Success": {
      return succeed5(exit.value, __trace);
    }
    case "Failure": {
      return halt2(exit.cause, __trace);
    }
  }
}

// node_modules/@effect-ts/system/_mjs/Effect/tap.mjs
function tap4(f2, __trace) {
  return (fa) => tap_4(fa, f2, __trace);
}
function tap_4(_2, f2, __trace) {
  return chain_12(_2, (a2) => map_13(f2(a2), () => a2), __trace);
}

// node_modules/@effect-ts/system/_mjs/Fiber/core.mjs
var Descriptor = class {
  constructor(id, status, interruptors2, interruptStatus3, scope3) {
    this.id = id;
    this.status = status;
    this.interruptors = interruptors2;
    this.interruptStatus = interruptStatus3;
    this.scope = scope3;
  }
};
var InterruptStatus = class {
  constructor(isInterruptible) {
    this.isInterruptible = isInterruptible;
  }
  get isUninteruptible() {
    return !this.isInterruptible;
  }
  get toBoolean() {
    return this.isInterruptible;
  }
};
var interruptible = /* @__PURE__ */ new InterruptStatus(true);
var uninterruptible = /* @__PURE__ */ new InterruptStatus(false);
var interruptStatus2 = (b2) => b2 ? interruptible : uninterruptible;
function join(fiber) {
  return tap_4(chain_12(fiber.await, done), () => fiber.inheritRefs);
}

// node_modules/@effect-ts/system/_mjs/Effect/cause.mjs
function cause(effect2, __trace) {
  return foldCauseM_(effect2, succeed5, () => succeed5(empty3), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/uncause.mjs
function uncause(effect2, __trace) {
  return chain_12(effect2, (a2) => isEmpty4(a2) ? unit3 : halt2(a2), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/zipWith.mjs
function zipWith3(b2, f2, __trace) {
  return (a2) => zipWith_4(a2, b2, f2, __trace);
}
function zipWith_4(a2, b2, f2, __trace) {
  return chain_12(a2, (ra) => map_13(b2, (rb) => f2(ra, rb)), __trace);
}

// node_modules/@effect-ts/system/_mjs/Scope/index.mjs
var Key = class {
  constructor(remove4) {
    this.remove = succeed5(false);
    if (remove4) {
      this.remove = remove4;
    }
  }
  setRemove(remove4) {
    this.remove = remove4;
  }
};
var Global = class {
  constructor() {
    this._tag = "Global";
    this.unsafeEnsureResult = right(new Key(succeedWith3(() => true)));
    this.ensureResult = succeedWith3(() => this.unsafeEnsureResult);
    this.deny = this.deny.bind(this);
    this.ensure = this.ensure.bind(this);
    this.extend = this.extend.bind(this);
    this.unsafeEnsure = this.unsafeEnsure.bind(this);
    this.unsafeExtend = this.unsafeExtend.bind(this);
  }
  get closed() {
    return succeed5(false);
  }
  deny(_key) {
    return succeed5(true);
  }
  get empty() {
    return succeed5(false);
  }
  ensure(_finalizer) {
    return this.ensureResult;
  }
  extend(that) {
    return succeedWith3(() => this.unsafeExtend(that));
  }
  get open() {
    return map_13(this.closed, (c2) => !c2);
  }
  get released() {
    return succeed5(false);
  }
  unsafeEnsure(_finalizer) {
    return this.unsafeEnsureResult;
  }
  unsafeExtend(that) {
    switch (that._tag) {
      case "Global":
        return true;
      case "Local":
        return that.unsafeAddRef();
    }
  }
  unsafeDeny() {
    return true;
  }
};
var OrderedFinalizer = class {
  constructor(order, finalizer2) {
    this.order = order;
    this.finalizer = finalizer2;
  }
};
var noCause = empty3;
var noCauseEffect = /* @__PURE__ */ succeed5(noCause);
var Local = class {
  constructor(finalizerCount, exitValue, references, finalizers) {
    this.finalizerCount = finalizerCount;
    this.exitValue = exitValue;
    this.references = references;
    this.finalizers = finalizers;
    this._tag = "Local";
  }
  get closed() {
    return succeedWith3(() => this.unsafeClosed);
  }
  get open() {
    return map_13(this.closed, (c2) => !c2);
  }
  deny(key) {
    return succeedWith3(() => this.unsafeDeny(key));
  }
  get empty() {
    return succeedWith3(() => this.finalizers.size === 0);
  }
  ensure(finalizer2) {
    return succeedWith3(() => this.unsafeEnsure(finalizer2));
  }
  extend(that) {
    return succeedWith3(() => this.unsafeExtend(that));
  }
  get released() {
    return succeedWith3(() => this.unsafeReleased());
  }
  unsafeExtend(that) {
    if (this === that) {
      return true;
    }
    switch (that._tag) {
      case "Global":
        return true;
      case "Local":
        if (!this.unsafeClosed && !that.unsafeClosed) {
          that.unsafeAddRef();
          this.unsafeEnsure((_2) => that.release);
          return true;
        } else {
          return false;
        }
    }
  }
  get release() {
    return suspend4(() => {
      const result4 = this.unsafeRelease();
      if (result4 != null) {
        return map_13(result4, () => true);
      } else {
        return succeed5(false);
      }
    });
  }
  unsafeReleased() {
    return this.references.get <= 0;
  }
  unsafeEnsure(finalizer2) {
    if (this.unsafeClosed) {
      return left(this.exitValue.get);
    }
    const key = new Key();
    key.setRemove(this.deny(key));
    this.finalizers.set(key, new OrderedFinalizer(this.finalizerCount.incrementAndGet(), finalizer2));
    return right(key);
  }
  unsafeAddRef() {
    if (this.unsafeClosed) {
      return false;
    }
    this.references.incrementAndGet();
    return true;
  }
  get unsafeClosed() {
    return this.exitValue.get != null;
  }
  unsafeDeny(key) {
    if (this.unsafeClosed) {
      return false;
    } else {
      return this.finalizers.delete(key);
    }
  }
  unsafeClose(a2) {
    this.exitValue.compareAndSet(null, a2);
    return this.unsafeRelease();
  }
  unsafeRelease() {
    if (this.references.decrementAndGet() === 0) {
      const totalSize = this.finalizers.size;
      if (totalSize === 0) {
        return null;
      }
      const array2 = Array.from(this.finalizers.values());
      const sorted = array2.sort((l2, r2) => l2 == null ? -1 : r2 == null ? 1 : l2.order - r2.order);
      const a2 = this.exitValue.get;
      return uncause(reduce_(sorted, noCauseEffect, (acc, o2) => o2 != null ? zipWith_4(acc, cause(o2.finalizer(a2)), (a3, b2) => combineSeq(a3, b2)) : acc));
    } else {
      return null;
    }
  }
  get unsafeEmpty() {
    return this.finalizers.size === 0;
  }
};
var globalScope = /* @__PURE__ */ new Global();
var Open = class {
  constructor(close, scope3) {
    this.close = close;
    this.scope = scope3;
  }
};
function unsafeMakeScope() {
  const exitValue = new AtomicReference(null);
  const finalizers = /* @__PURE__ */ new Map();
  const scope3 = new Local(new AtomicNumber(Number.MIN_SAFE_INTEGER), exitValue, new AtomicNumber(1), finalizers);
  return new Open((a2) => {
    return suspend4(() => {
      const result4 = scope3.unsafeClose(a2);
      if (result4 != null) {
        return map_13(result4, () => true);
      } else {
        return succeed5(false);
      }
    });
  }, scope3);
}

// node_modules/@effect-ts/system/_mjs/Effect/core-scope.mjs
var forkScope = /* @__PURE__ */ new IGetForkScope(succeed5);
var ForkScopeRestore = class {
  constructor(scope3) {
    this.scope = scope3;
    this.restore = (fa, __trace) => new IOverrideForkScope(fa, some(this.scope), __trace);
  }
};
function forkScopeMask_(newScope, f2, __trace) {
  return forkScopeWith((scope3) => new IOverrideForkScope(f2(new ForkScopeRestore(scope3)), some(newScope)), __trace);
}
function forkScopeMask(f2, __trace) {
  return (newScope) => forkScopeMask_(newScope, f2, __trace);
}
function raceWithScope_(left4, right5, leftWins, rightWins, scope3, __trace) {
  return new IRaceWith(left4, right5, leftWins, rightWins, some(scope3), __trace);
}
function raceWithScope(right5, leftWins, rightWins, scope3, __trace) {
  return (left4) => raceWithScope_(left4, right5, leftWins, rightWins, scope3, __trace);
}
function raceWith_(left4, right5, leftWins, rightWins, __trace) {
  return new IRaceWith(left4, right5, leftWins, rightWins, none, __trace);
}
function raceWith(right5, leftWins, rightWins, __trace) {
  return (left4) => raceWith_(left4, right5, leftWins, rightWins, __trace);
}
function transplant(f2, __trace) {
  return forkScopeWith((scope3) => f2((e2, __trace2) => new IOverrideForkScope(e2, some(scope3), __trace2)), __trace);
}
function forkDaemon(value, __trace) {
  return new IFork(value, some(globalScope), none, __trace);
}
function forkDaemonReport(reportFailure, __trace) {
  return (value) => forkDaemonReport_(value, reportFailure, __trace);
}
function forkDaemonReport_(value, reportFailure, __trace) {
  return new IFork(value, some(globalScope), some(reportFailure), __trace);
}
function forkIn(scope3, __trace) {
  return (value) => forkIn_(value, scope3, __trace);
}
function forkIn_(value, scope3, __trace) {
  return new IFork(value, some(scope3), none, __trace);
}
function forkInReport(scope3, reportFailure, __trace) {
  return (value) => new IFork(value, some(scope3), some(reportFailure), __trace);
}
function forkInReport_(value, scope3, reportFailure, __trace) {
  return new IFork(value, some(scope3), some(reportFailure), __trace);
}
function forkScopeWith(f2, __trace) {
  return new IGetForkScope(f2, __trace);
}
function overrideForkScope(scope3, __trace) {
  return (self) => new IOverrideForkScope(self, some(scope3), __trace);
}
function overrideForkScope_(self, scope3, __trace) {
  return new IOverrideForkScope(self, some(scope3), __trace);
}
function resetForkScope(self, __trace) {
  return new IOverrideForkScope(self, none, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/zipWithPar.mjs
function zipWithPar_(a2, b2, f2, __trace) {
  const g2 = (b3, a3) => f2(a3, b3);
  return transplant((graft) => descriptorWith((d2) => raceWith_(graft(a2), graft(b2), (ex, fi) => coordinateZipPar(d2.id, f2, true, ex, fi), (ex, fi) => coordinateZipPar(d2.id, g2, false, ex, fi), __trace)));
}
function coordinateZipPar(fiberId3, f2, leftWinner, winner, loser) {
  switch (winner._tag) {
    case "Success": {
      return map_13(join(loser), (y2) => f2(winner.value, y2));
    }
    case "Failure": {
      return chain_12(loser.interruptAs(fiberId3), (e2) => {
        switch (e2._tag) {
          case "Success": {
            return halt2(winner.cause);
          }
          case "Failure": {
            return leftWinner ? halt2(combinePar(winner.cause, e2.cause)) : halt2(combinePar(e2.cause, winner.cause));
          }
        }
      });
    }
  }
}
function zipWithPar(b2, f2, __trace) {
  return (a2) => zipWithPar_(a2, b2, f2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/zips.mjs
function zipLeft_(a2, b2, __trace) {
  return chain_12(a2, (r2) => as_(b2, r2));
}
function zipLeft2(b2, __trace) {
  return (a2) => zipLeft_(a2, b2, __trace);
}
function zipLeftPar_(a2, b2, __trace) {
  return zipWithPar_(a2, b2, (a3) => a3, __trace);
}
function zipLeftPar(b2, __trace) {
  return (a2) => zipLeftPar_(a2, b2, __trace);
}
function zipRight_2(a2, b2, __trace) {
  return chain_12(a2, () => b2, __trace);
}
function zipRight2(b2, __trace) {
  return (a2) => zipRight_2(a2, b2, __trace);
}
function zipRightPar_(a2, b2, __trace) {
  return zipWithPar_(a2, b2, (_2, a3) => a3, __trace);
}
function zipRightPar(b2, __trace) {
  return (a2) => zipRightPar_(a2, b2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/fiberId.mjs
var fiberId = /* @__PURE__ */ descriptorWith((d2) => succeed5(d2.id));

// node_modules/@effect-ts/system/_mjs/Effect/interruption.mjs
var uninterruptible2 = /* @__PURE__ */ interruptStatus(uninterruptible);
var InterruptStatusRestoreImpl = class {
  constructor(flag) {
    this.flag = flag;
    this.restore = this.restore.bind(this);
    this.force = this.force.bind(this);
  }
  restore(effect2, __trace) {
    return interruptStatus_(effect2, this.flag, __trace);
  }
  force(effect2, __trace) {
    if (this.flag.isUninteruptible) {
      return interruptible2(disconnect(uninterruptible2(effect2)), __trace);
    }
    return interruptStatus_(effect2, this.flag, __trace);
  }
};
function uninterruptibleMask(f2, __trace) {
  return checkInterruptible((flag) => uninterruptible2(f2(new InterruptStatusRestoreImpl(flag))), __trace);
}
function onInterrupt_(self, cleanup, __trace) {
  return uninterruptibleMask(({
    restore: restore2
  }) => foldCauseM_(restore2(self), (cause2) => interrupted(cause2) ? chain_12(cleanup(interruptors(cause2)), () => halt2(cause2)) : halt2(cause2), succeed5, __trace));
}
function onInterruptExtended_(self, cleanup, __trace) {
  return uninterruptibleMask(({
    restore: restore2
  }) => foldCauseM_(restore2(self), (cause2) => interrupted(cause2) ? foldCauseM_(cleanup(interruptors(cause2)), (_2) => halt2(_2), () => halt2(cause2)) : halt2(cause2), succeed5, __trace));
}
function onInterrupt(cleanup, __trace) {
  return (self) => onInterrupt_(self, cleanup, __trace);
}
function disconnect(effect2, __trace) {
  return uninterruptibleMask(({
    restore: restore2
  }) => chain_12(fiberId, (id) => chain_12(forkDaemon(restore2(effect2)), (fiber) => onInterrupt_(restore2(join(fiber)), () => forkDaemon(fiber.interruptAs(id))))), __trace);
}
function interruptibleMask(f2, __trace) {
  return checkInterruptible((flag) => interruptible2(f2(new InterruptStatusRestoreImpl(flag))), __trace);
}
function interruptAs(fiberId3, __trace) {
  return haltWith((trace3) => traced(interrupt(fiberId3), trace3()), __trace);
}
var interrupt3 = /* @__PURE__ */ chain_12(fiberId, interruptAs);
function interruptible2(effect2, __trace) {
  return interruptStatus_(effect2, interruptible, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/bracketExit.mjs
function bracketExit(use2, release4, __trace) {
  return (acquire) => bracketExit_(acquire, use2, release4, __trace);
}
function bracketExit_(acquire, use2, release4, __trace) {
  return uninterruptibleMask(({
    restore: restore2
  }) => chain_12(acquire, (a2) => chain_12(result(suspend4(() => restore2(use2(a2)))), (e2) => foldCauseM_(suspend4(() => release4(a2, e2)), (cause2) => halt2(fold_4(e2, (_2) => combineSeq(_2, cause2), (_2) => cause2)), (_2) => done(e2))), __trace));
}

// node_modules/@effect-ts/system/_mjs/Effect/environment.mjs
function environment2(__trace) {
  return access3((_2) => _2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/flatten.mjs
function flatten8(effect2, __trace) {
  return chain_12(effect2, identity, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/mapErrorCause.mjs
function mapErrorCause_(self, f2, __trace) {
  return foldCauseM_(self, (c2) => halt2(f2(c2)), succeed5, __trace);
}
function mapErrorCause2(f2, __trace) {
  return (self) => foldCauseM_(self, (c2) => halt2(f2(c2)), succeed5, __trace);
}

// node_modules/@effect-ts/system/_mjs/Support/OneShot/index.mjs
var OneShot = class {
  constructor() {
    this.internal = void 0;
  }
  set(a2) {
    if (this.internal) {
      throw new Error("OneShot already set");
    }
    if (a2 == null) {
      throw new Error("Cannot set null to OneShot");
    }
    this.internal = a2;
  }
  get() {
    if (this.internal) {
      return this.internal;
    }
    throw new Error("Value not set in OneShot");
  }
  isSet() {
    return this.internal != null;
  }
};

// node_modules/@effect-ts/system/_mjs/Effect/effectMaybeAsyncInterrupt.mjs
function effectMaybeAsyncInterrupt(register, __trace) {
  return effectMaybeAsyncInterruptBlockingOn(register, [], __trace);
}
function effectMaybeAsyncInterruptBlockingOn(register, blockingOn, __trace) {
  return chain_12(succeedWith3(() => [new AtomicReference(false), new OneShot()]), ([started, cancel]) => onInterrupt_(flatten8(effectAsyncOptionBlockingOn((k2) => {
    started.set(true);
    const ret = new AtomicReference(none);
    try {
      const res = register((io) => k2(succeed5(io)));
      switch (res._tag) {
        case "Right": {
          ret.set(some(succeed5(res.right)));
          break;
        }
        case "Left": {
          cancel.set(res.left);
          break;
        }
      }
    } finally {
      if (!cancel.isSet()) {
        cancel.set(unit3);
      }
    }
    return ret.get;
  }, blockingOn, __trace)), () => suspend4(() => started.get ? cancel.get() : unit3)));
}

// node_modules/@effect-ts/system/_mjs/Effect/effectAsyncInterrupt.mjs
function effectAsyncInterrupt(register, __trace) {
  return effectAsyncInterruptBlockingOn(register, [], __trace);
}
function effectAsyncInterruptBlockingOn(register, blockingOn, __trace) {
  return effectMaybeAsyncInterruptBlockingOn((cb) => left(register(cb)), blockingOn, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/never.mjs
var never = /* @__PURE__ */ suspend4(() => effectAsyncInterrupt(() => {
  const interval = setInterval(() => {
  }, 6e4);
  return succeedWith3(() => {
    clearInterval(interval);
  });
}));

// node_modules/@effect-ts/system/_mjs/Effect/provideSome.mjs
function provideSome_(effect2, f2, __trace) {
  return accessM3((r0) => provideAll_3(effect2, f2(r0)), __trace);
}
function provideSome2(f2, __trace) {
  return (effect2) => provideSome_(effect2, f2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/zip.mjs
function zip5(b2, __trace) {
  return (a2) => zip_4(a2, b2, __trace);
}
function zip_4(a2, b2, __trace) {
  return chain_12(a2, (ra) => map_13(b2, (rb) => tuple2(ra, rb)), __trace);
}

// node_modules/@effect-ts/system/_mjs/Managed/managed.mjs
var ManagedURI = "@matechs/core/Eff/ManagedURI";
var ManagedImpl = class {
  constructor(effect2) {
    this.effect = effect2;
  }
};
function managedApply(effect2) {
  return new ManagedImpl(effect2);
}

// node_modules/@effect-ts/system/_mjs/Managed/ReleaseMap/finalizer.mjs
var noopFinalizer = () => unit3;

// node_modules/@effect-ts/system/_mjs/Managed/fromEffect.mjs
function fromEffect(effect2, __trace) {
  return managedApply(map_13(provideSome_(effect2, (_2) => _2.get(0), __trace), (a2) => tuple2(noopFinalizer, a2)));
}
function fromEffectUninterruptible(effect2, __trace) {
  return fromEffect(uninterruptible2(effect2), __trace);
}

// node_modules/@effect-ts/system/_mjs/Ref/makeManagedRef.mjs
function makeManagedRef(a2) {
  return fromEffect(makeRef(a2));
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Map/core.mjs
var empty5 = /* @__PURE__ */ new Map();
function insert_(self, k2, v2) {
  const m2 = copy(self);
  m2.set(k2, v2);
  return m2;
}
function insert(k2, v2) {
  return (self) => insert_(self, k2, v2);
}
function remove_2(self, k2) {
  const m2 = copy(self);
  m2.delete(k2);
  return m2;
}
function remove2(k2) {
  return (self) => remove_2(self, k2);
}
function lookup_(m2, k2) {
  return fromNullable(m2.get(k2));
}
function lookup(k2) {
  return (m2) => lookup_(m2, k2);
}
function copy(self) {
  const m2 = /* @__PURE__ */ new Map();
  self.forEach((v2, k2) => {
    m2.set(k2, v2);
  });
  return m2;
}

// node_modules/@effect-ts/system/_mjs/Managed/ReleaseMap/Exited.mjs
var Exited = class {
  constructor(nextKey, exit) {
    this.nextKey = nextKey;
    this.exit = exit;
    this._tag = "Exited";
  }
};

// node_modules/@effect-ts/system/_mjs/Managed/ReleaseMap/next.mjs
function next(l2) {
  return l2 + 1;
}

// node_modules/@effect-ts/system/_mjs/Managed/ReleaseMap/Running.mjs
var Running = class {
  constructor(nextKey, _finalizers) {
    this.nextKey = nextKey;
    this._finalizers = _finalizers;
    this._tag = "Running";
  }
  finalizers() {
    return this._finalizers;
  }
};

// node_modules/@effect-ts/system/_mjs/Managed/ReleaseMap/addIfOpen.mjs
function addIfOpen(finalizer2) {
  return (_2) => flatten8(modify_2(_2.ref, (s2) => {
    switch (s2._tag) {
      case "Exited": {
        return tuple2(map_13(finalizer2(s2.exit), () => none), new Exited(next(s2.nextKey), s2.exit));
      }
      case "Running": {
        return tuple2(succeed5(some(s2.nextKey)), new Running(next(s2.nextKey), insert(s2.nextKey, finalizer2)(s2.finalizers())));
      }
    }
  }));
}

// node_modules/@effect-ts/system/_mjs/Managed/ReleaseMap/release.mjs
function release(key, exit) {
  return (_2) => flatten8(modify_2(_2.ref, (s2) => {
    switch (s2._tag) {
      case "Exited": {
        return tuple2(unit3, s2);
      }
      case "Running": {
        return tuple2(fold_(lookup(key)(s2.finalizers()), () => unit3, (f2) => f2(exit)), new Running(s2.nextKey, remove2(key)(s2.finalizers())));
      }
    }
  }));
}

// node_modules/@effect-ts/system/_mjs/Managed/ReleaseMap/add.mjs
function add(finalizer2) {
  return (_2) => map_13(addIfOpen(finalizer2)(_2), fold(() => () => unit3, (k2) => (e2) => release(k2, e2)(_2)));
}

// node_modules/@effect-ts/system/_mjs/Managed/makeExit.mjs
function makeExit(release4, __trace) {
  return (acquire) => makeExit_(acquire, release4, __trace);
}
function makeExit_(acquire, release4, __trace) {
  return managedApply(uninterruptible2(map_13(bind_(bind_(bind_(do_2, "r", () => environment2()), "a", (s2) => provideAll_3(acquire, s2.r.get(0)), __trace), "rm", (s2) => add((ex) => provideAll_3(release4(s2.a, ex), s2.r.get(0), __trace))(s2.r.get(1))), (s2) => tuple2(s2.rm, s2.a))));
}

// node_modules/@effect-ts/system/_mjs/Managed/ReleaseMap/ReleaseMap.mjs
var ReleaseMap = class {
  constructor(ref) {
    this.ref = ref;
  }
};

// node_modules/@effect-ts/system/_mjs/Managed/ReleaseMap/makeReleaseMap.mjs
var makeReleaseMap = /* @__PURE__ */ map_13(/* @__PURE__ */ makeRef(/* @__PURE__ */ new Running(0, /* @__PURE__ */ new Map())), (s2) => new ReleaseMap(s2));

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/filter.mjs
function filter_3(self, f2) {
  ;
  switch (self._typeId) {
    case ArrTypeId: {
      const arr = self.arrayLike();
      const len = arr.length;
      let i2 = 0;
      let builder2 = empty4();
      while (i2 < len) {
        const elem3 = arr[i2];
        if (f2(elem3)) {
          builder2 = append_4(builder2, elem3);
        }
        i2++;
      }
      return builder2;
    }
    default: {
      const iterator = self.arrayLikeIterator();
      let next2;
      let builder2 = empty4();
      while ((next2 = iterator.next()) && !next2.done) {
        const array2 = next2.value;
        const len = array2.length;
        let i2 = 0;
        while (i2 < len) {
          const a2 = array2[i2];
          if (f2(a2)) {
            builder2 = append_4(builder2, a2);
          }
          i2++;
        }
      }
      return builder2;
    }
  }
}
function filter2(f2) {
  return (self) => filter_3(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/forEach.mjs
function forEach_4(self, f2) {
  ;
  switch (self._typeId) {
    case ArrTypeId: {
      const arr = self.arrayLike();
      const len = arr.length;
      let i2 = 0;
      while (i2 < len) {
        f2(arr[i2]);
        i2++;
      }
      return;
    }
    default: {
      const iterator = self.arrayLikeIterator();
      let next2;
      while ((next2 = iterator.next()) && !next2.done) {
        const array2 = next2.value;
        const len = array2.length;
        let i2 = 0;
        while (i2 < len) {
          const a2 = array2[i2];
          f2(a2);
          i2++;
        }
      }
      return;
    }
  }
}
function forEach3(f2) {
  return (self) => forEach_4(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/indexWhereFrom.mjs
function indexWhereFrom_(self, from4, f2) {
  const iterator = self.arrayLikeIterator();
  let next2;
  let i2 = 0;
  while ((next2 = iterator.next()) && !next2.done) {
    const array2 = next2.value;
    const len = array2.length;
    if (i2 + len - 1 >= from4) {
      let j2 = 0;
      while (j2 < len) {
        const a2 = array2[j2];
        if (i2 >= from4 && f2(a2)) {
          return i2;
        }
        j2++;
        i2++;
      }
    } else {
      i2 += len;
    }
  }
  return -1;
}
function indexWhereFrom(from4, f2) {
  return (self) => indexWhereFrom_(self, from4, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/indexWhere.mjs
function indexWhere_(self, f2) {
  return indexWhereFrom_(self, 0, f2);
}
function indexWhere(f2) {
  return (self) => indexWhere_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/splitAt.mjs
function splitAt_(self, n2) {
  return tuple2(take_2(self, n2), drop_2(self, n2));
}
function splitAt(n2) {
  return (self) => splitAt_(self, n2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/zipWith.mjs
function zipWith_5(self, that, f2) {
  const length = Math.min(self.length, that.length);
  if (length === 0) {
    return empty4();
  }
  const leftIterator = self.arrayLikeIterator();
  const rightIterator = that.arrayLikeIterator();
  let i2 = 0;
  let j2 = 0;
  let k2 = 0;
  let leftLength = 0;
  let rightLength = 0;
  let left4 = void 0;
  let right5 = void 0;
  let leftNext;
  let rightNext;
  let builder2 = empty4();
  while (i2 < length) {
    if (j2 < leftLength && k2 < rightLength) {
      builder2 = append_4(builder2, f2(left4[j2], right5[k2]));
      i2++;
      j2++;
      k2++;
    } else if (j2 === leftLength && (leftNext = leftIterator.next()) && !leftNext.done) {
      left4 = leftNext.value;
      leftLength = left4.length;
      j2 = 0;
    } else if (k2 === rightLength && (rightNext = rightIterator.next()) && !rightNext.done) {
      right5 = rightNext.value;
      rightLength = right5.length;
      k2 = 0;
    }
  }
  return builder2;
}
function zipWith4(that, f2) {
  return (self) => zipWith_5(self, that, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/zip.mjs
function zip_5(self, that) {
  return zipWith_5(self, that, tuple2);
}
function zip6(that) {
  return (self) => zip_5(self, that);
}

// node_modules/@effect-ts/system/_mjs/Effect/bracket.mjs
function bracket(use2, release4, __trace) {
  return (acquire) => bracket_(acquire, use2, release4, __trace);
}
function bracket_(acquire, use2, release4, __trace) {
  return bracketExit_(acquire, use2, release4, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/die.mjs
function die3(e2, __trace) {
  return haltWith((trace3) => traced(die(e2), trace3()), __trace);
}
function dieWith(e2, __trace) {
  return haltWith((trace3) => traced(die(e2()), trace3()), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/effectAsync.mjs
function effectAsync(register, __trace) {
  return effectAsyncBlockingOn(register, [], __trace);
}
function effectAsyncBlockingOn(register, blockingOn, __trace) {
  return effectAsyncOptionBlockingOn((cb) => {
    register(cb);
    return none;
  }, blockingOn, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/reduce.mjs
function reduce_6(i2, zero2, f2, __trace) {
  return suspend4(() => reduce_3(i2, succeed5(zero2), (acc, el) => chain_12(acc, (a2) => f2(a2, el))), __trace);
}
function reduce3(zero2, f2, __trace) {
  return (i2) => reduce_6(i2, zero2, f2, __trace);
}
function reduceRight_6(i2, zero2, f2, __trace) {
  return suspend4(() => reduceRight_3(i2, succeed5(zero2), (el, acc) => chain_12(acc, (a2) => f2(el, a2))), __trace);
}
function reduceRight3(zero2, f2, __trace) {
  return (i2) => reduceRight_6(i2, zero2, f2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/zipPar.mjs
function zipPar_(a2, b2, __trace) {
  return zipWithPar_(a2, b2, tuple2, __trace);
}
function zipPar2(b2, __trace) {
  return (a2) => zipPar_(a2, b2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Fiber/interrupt.mjs
function interrupt4(fiber) {
  return chain_12(fiberId, (id) => fiber.interruptAs(id));
}

// node_modules/@effect-ts/system/_mjs/Support/DoublyLinkedList/index.mjs
var LinkedListNode = class {
  constructor(value) {
    this.value = value;
    this.removed = false;
    this.right = void 0;
    this.left = void 0;
  }
};
var DoublyLinkedList = class {
  constructor() {
    this.length = 0;
    this.headN = void 0;
    this.tailN = void 0;
  }
  get head() {
    return this.headN === void 0 ? void 0 : this.headN.value;
  }
  get isEmpty() {
    return this.length === 0;
  }
  get tail() {
    return this.tailN === void 0 ? void 0 : this.tailN.value;
  }
  forEach(f2) {
    let current = this.headN;
    while (current !== void 0) {
      f2(current.value);
      current = current.right;
    }
  }
  add(val) {
    const node = new LinkedListNode(val);
    if (this.length === 0) {
      this.headN = node;
    }
    if (this.tailN === void 0) {
      this.tailN = node;
    } else {
      this.tailN.right = node;
      node.left = this.tailN;
      this.tailN = node;
    }
    this.length += 1;
    return node;
  }
  empty() {
    this.length = 0;
    this.headN = this.tailN = void 0;
  }
  pop() {
    const h2 = this.tailN;
    if (h2 !== void 0) {
      this.remove(h2);
      return h2.value;
    }
    return void 0;
  }
  remove(n2) {
    if (n2.removed) {
      return;
    }
    n2.removed = true;
    if (n2.left !== void 0 && n2.right !== void 0) {
      n2.left.right = n2.right;
      n2.right.left = n2.left;
    } else if (n2.left !== void 0) {
      this.tailN = n2.left;
      n2.left.right = void 0;
    } else if (n2.right !== void 0) {
      this.headN = n2.right;
      n2.right.left = void 0;
    } else {
      this.tailN = void 0;
      this.headN = void 0;
    }
    if (this.length > 0) {
      this.length -= 1;
    }
  }
  shift() {
    const h2 = this.headN;
    if (h2 !== void 0) {
      this.remove(h2);
      return h2.value;
    }
    return void 0;
  }
};

// node_modules/@effect-ts/system/_mjs/Support/MutableQueue/index.mjs
var EmptyQueue = /* @__PURE__ */ Symbol.for("@effect-ts/system/MutableQueue/Empty");
var Unbounded = class {
  constructor() {
    this.queue = new DoublyLinkedList();
  }
  get size() {
    return this.queue.length;
  }
  get isEmpty() {
    return this.size === 0;
  }
  get isFull() {
    return false;
  }
  get capacity() {
    return Number.MAX_SAFE_INTEGER;
  }
  offer(a2) {
    this.queue.add(a2);
    return true;
  }
  offerAll(as6) {
    for (const a2 of as6) {
      this.offer(a2);
    }
    return empty4();
  }
  poll(a2) {
    if (this.isEmpty) {
      return a2;
    }
    return this.queue.shift();
  }
  pollUpTo(n2) {
    let result4 = empty4();
    let count2 = 0;
    while (count2 < n2) {
      const elem3 = this.poll(EmptyQueue);
      if (elem3 === EmptyQueue) {
        break;
      }
      result4 = append_4(result4, elem3);
      count2 += 1;
    }
    return result4;
  }
};
var Bounded = class {
  constructor(n2) {
    this.queue = new DoublyLinkedList();
    this.n = n2;
  }
  get size() {
    return this.queue.length;
  }
  get isEmpty() {
    return this.size === 0;
  }
  get isFull() {
    return this.size === this.capacity;
  }
  get capacity() {
    return this.n;
  }
  offer(a2) {
    if (this.isFull) {
      return false;
    }
    this.queue.add(a2);
    return true;
  }
  offerAll(as6) {
    const it2 = as6[Symbol.iterator]();
    let next2;
    let rem = empty4();
    let offerig = true;
    while (offerig && (next2 = it2.next()) && !next2.done) {
      offerig = this.offer(next2.value);
    }
    while (next2 && !next2.done) {
      rem = append_4(rem, next2.value);
      next2 = it2.next();
    }
    return rem;
  }
  poll(a2) {
    if (this.isEmpty) {
      return a2;
    }
    return this.queue.shift();
  }
  pollUpTo(n2) {
    let result4 = empty4();
    let count2 = 0;
    while (count2 < n2) {
      const elem3 = this.poll(EmptyQueue);
      if (elem3 === EmptyQueue) {
        break;
      }
      result4 = append_4(result4, elem3);
      count2 += 1;
    }
    return result4;
  }
};

// node_modules/@effect-ts/system/_mjs/Effect/whenM.mjs
function whenM_(self, predicate, __trace) {
  return chain_12(predicate, (a2) => a2 ? asUnit(self, __trace) : unit3);
}
function whenM(predicate, __trace) {
  return (self) => whenM_(self, predicate, __trace);
}

// node_modules/@effect-ts/system/_mjs/Promise/state.mjs
var Done = class {
  constructor(value) {
    this.value = value;
    this._tag = "Done";
  }
};
var Pending = class {
  constructor(joiners) {
    this.joiners = joiners;
    this._tag = "Pending";
  }
};

// node_modules/@effect-ts/system/_mjs/Promise/completeWith.mjs
function completeWith(io) {
  return (promise2) => succeedWith3(() => {
    const state = promise2.state.get;
    switch (state._tag) {
      case "Done": {
        return false;
      }
      case "Pending": {
        promise2.state.set(new Done(io));
        state.joiners.forEach((f2) => {
          f2(io);
        });
        return true;
      }
    }
  });
}

// node_modules/@effect-ts/system/_mjs/Promise/interruptAs.mjs
function interruptAs2(id) {
  return (promise2) => completeWith(interruptAs(id))(promise2);
}

// node_modules/@effect-ts/system/_mjs/Promise/promise.mjs
var Promise2 = class {
  constructor(state, blockingOn) {
    this.state = state;
    this.blockingOn = blockingOn;
  }
};

// node_modules/@effect-ts/system/_mjs/Promise/unsafeMake.mjs
function unsafeMake(fiberId3) {
  return new Promise2(new AtomicReference(new Pending([])), [fiberId3]);
}

// node_modules/@effect-ts/system/_mjs/Promise/makeAs.mjs
function makeAs(fiberId3) {
  return succeedWith3(() => unsafeMake(fiberId3));
}

// node_modules/@effect-ts/system/_mjs/Promise/make.mjs
function make4() {
  return chain_12(fiberId, (id) => makeAs(id));
}

// node_modules/@effect-ts/system/_mjs/Promise/succeed.mjs
function succeed6(a2) {
  return (promise2) => completeWith(succeed5(a2))(promise2);
}
function succeed_(promise2, a2) {
  return completeWith(succeed5(a2))(promise2);
}

// node_modules/@effect-ts/system/_mjs/Promise/unsafeDone.mjs
function unsafeDone(io) {
  return (promise2) => {
    const state = promise2.state.get;
    if (state._tag === "Pending") {
      promise2.state.set(new Done(io));
      Array.from(state.joiners).reverse().forEach((f2) => {
        f2(io);
      });
    }
  };
}

// node_modules/@effect-ts/system/_mjs/Promise/interruptJoiner.mjs
function interruptJoiner(joiner) {
  return (promise2) => succeedWith3(() => {
    const state = promise2.state.get;
    if (state._tag === "Pending") {
      promise2.state.set(new Pending(state.joiners.filter((j2) => j2 !== joiner)));
    }
  });
}

// node_modules/@effect-ts/system/_mjs/Promise/await.mjs
function wait(promise2) {
  return effectMaybeAsyncInterruptBlockingOn((k2) => {
    const state = promise2.state.get;
    switch (state._tag) {
      case "Done": {
        return right(state.value);
      }
      case "Pending": {
        promise2.state.set(new Pending([k2, ...state.joiners]));
        return left(interruptJoiner(k2)(promise2));
      }
    }
  }, promise2.blockingOn);
}

// node_modules/@effect-ts/system/_mjs/Queue/xqueue.mjs
var XQueueInternal = class {
};

// node_modules/@effect-ts/system/_mjs/Queue/core.mjs
var DroppingStrategy = class {
  handleSurplus(_as, _queue, _takers, _isShutdown) {
    return succeed5(false);
  }
  unsafeOnQueueEmptySpace(_queue) {
  }
  get shutdown() {
    return unit3;
  }
  get surplusSize() {
    return 0;
  }
};
var SlidingStrategy = class {
  handleSurplus(as6, queue, takers, _isShutdown) {
    return succeedWith3(() => {
      this.unsafeSlidingOffer(queue, as6);
      unsafeCompleteTakers(this, queue, takers);
      return true;
    });
  }
  unsafeOnQueueEmptySpace(_queue) {
  }
  get shutdown() {
    return unit3;
  }
  get surplusSize() {
    return 0;
  }
  unsafeSlidingOffer(queue, as6) {
    let bs = as6;
    while (size4(bs) > 0) {
      if (queue.capacity === 0) {
        return;
      }
      queue.poll(EmptyQueue);
      if (queue.offer(unsafeGet_2(bs, 0))) {
        bs = drop_2(bs, 1);
      }
    }
  }
};
function unsafeCompletePromise(p2, a2) {
  return unsafeDone(succeed5(a2))(p2);
}
function unsafeCompleteTakers(strategy, queue, takers) {
  let keepPolling = true;
  while (keepPolling && !queue.isEmpty) {
    const taker = takers.poll(EmptyQueue);
    if (taker !== EmptyQueue) {
      const element = queue.poll(EmptyQueue);
      if (element !== EmptyQueue) {
        unsafeCompletePromise(taker, element);
        strategy.unsafeOnQueueEmptySpace(queue, takers);
      } else {
        unsafeOfferAll(takers, prepend_3(unsafePollAll(takers), taker));
      }
      keepPolling = true;
    } else {
      keepPolling = false;
    }
  }
}
function unsafeRemove(q2, a2) {
  unsafeOfferAll(q2, filter_3(unsafePollAll(q2), (b2) => a2 !== b2));
}
function unsafePollN(q2, max2) {
  return q2.pollUpTo(max2);
}
function unsafeOfferAll(q2, as6) {
  return q2.offerAll(as6);
}
function unsafePollAll(q2) {
  let as6 = empty4();
  while (!q2.isEmpty) {
    const elem3 = q2.poll(EmptyQueue);
    if (elem3 !== EmptyQueue) {
      as6 = append_4(as6, elem3);
    }
  }
  return as6;
}
function isShutdown(self) {
  ;
  return self.isShutdown;
}
function offer_(self, a2) {
  ;
  return self.offer(a2);
}
function shutdown(self) {
  ;
  return self.shutdown;
}
function size5(self) {
  ;
  return self.size;
}
function take2(self) {
  ;
  return self.take;
}

// node_modules/@effect-ts/system/_mjs/Support/AtomicBoolean/index.mjs
var AtomicBoolean = class extends AtomicReference {
  constructor(b2) {
    super(b2);
  }
};

// node_modules/@effect-ts/system/_mjs/Effect/catchAll.mjs
function catchAll_2(effect2, f2, __trace) {
  return foldM_2(effect2, f2, succeed5, __trace);
}
function catchAll2(f2, __trace) {
  return (effect2) => catchAll_2(effect2, f2, __trace);
}
function _catch(tag2, k2, f2, __trace) {
  return (self) => catchAll_2(self, (e2) => {
    if (tag2 in e2 && e2[tag2] === k2) {
      return f2(e2);
    }
    return fail6(e2);
  }, __trace);
}
function catch_(self, tag2, k2, f2, __trace) {
  return catchAll_2(self, (e2) => {
    if (tag2 in e2 && e2[tag2] === k2) {
      return f2(e2);
    }
    return fail6(e2);
  }, __trace);
}
function catchTag(k2, f2, __trace) {
  return (self) => catchTag_(self, k2, f2, __trace);
}
function catchTag_(self, k2, f2, __trace) {
  return catchAll_2(self, (e2) => {
    if ("_tag" in e2 && e2["_tag"] === k2) {
      return f2(e2);
    }
    return fail6(e2);
  }, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/ensuring.mjs
function ensuring(finalizer2, __trace) {
  return (effect2) => ensuring_(effect2, finalizer2, __trace);
}
function ensuring_(effect2, finalizer2, __trace) {
  return uninterruptibleMask(({
    restore: restore2
  }) => foldCauseM_(restore2(effect2), (cause1) => foldCauseM_(finalizer2, (cause2) => halt2(combineSeq(cause1, cause2)), (_2) => halt2(cause1)), (value) => foldCauseM_(finalizer2, (cause1) => halt2(cause1), (_2) => succeed5(value)), __trace));
}

// node_modules/@effect-ts/system/_mjs/Promise/fail.mjs
function fail_(promise2, e2) {
  return completeWith(fail6(e2))(promise2);
}
function fail7(e2) {
  return (promise2) => fail_(promise2, e2);
}

// node_modules/@effect-ts/system/_mjs/Promise/halt.mjs
function halt_(promise2, e2) {
  return completeWith(halt2(e2))(promise2);
}
function halt3(e2) {
  return (promise2) => halt_(promise2, e2);
}

// node_modules/@effect-ts/system/_mjs/Effect/tapCause.mjs
function tapCause(f2, __trace) {
  return (effect2) => tapCause_(effect2, f2, __trace);
}
function tapCause_(effect2, f2, __trace) {
  return foldCauseM_(effect2, (c2) => chain_12(f2(c2), () => halt2(c2)), succeed5, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/toManaged.mjs
function toManaged(self) {
  return fromEffect(self);
}
function toManagedRelease_(self, release4) {
  return makeExit_(self, release4);
}
function toManagedRelease(release4) {
  return (self) => makeExit_(self, release4);
}

// node_modules/@effect-ts/system/_mjs/Effect/excl-forEach.mjs
function forEach_5(as6, f2, __trace) {
  return suspend4(() => {
    const acc = [];
    return map_13(forEachUnit_(as6, (a2) => map_13(f2(a2), (b2) => {
      acc.push(b2);
    })), () => from3(acc));
  }, __trace);
}
function forEachWithIndex_2(as6, f2, __trace) {
  return suspend4(() => {
    let index = 0;
    const acc = [];
    return map_13(forEachUnit_(as6, (a2) => map_13(f2(a2, index), (b2) => {
      acc.push(b2);
      index++;
    })), () => from3(acc));
  }, __trace);
}
function forEach4(f2, __trace) {
  return (as6) => forEach_5(as6, f2, __trace);
}
function forEachWithIndex2(f2, __trace) {
  return (as6) => forEachWithIndex_2(as6, f2, __trace);
}
function forEachUnitLoop(iterator, f2) {
  const next2 = iterator.next();
  return next2.done ? unit3 : chain_12(f2(next2.value), () => forEachUnitLoop(iterator, f2));
}
function forEachUnit_(as6, f2, __trace) {
  return suspend4(() => forEachUnitLoop(as6[Symbol.iterator](), f2), __trace);
}
function forEachUnit(f2, __trace) {
  return (as6) => forEachUnit_(as6, f2, __trace);
}
function forEachUnitPar_(as6, f2, __trace) {
  const collection = from2(as6);
  const size7 = size3(collection);
  if (isEmpty3(collection)) {
    return unit3;
  }
  return suspend4(() => asUnit(tap_4(tap_4(let_2(bind_(let_2(let_2(let_2(bind_(bind_(bind_(bind_(do_2, "parentId", () => fiberId), "causes", () => makeRef(empty3)), "result", () => make4()), "status", () => makeRef(tuple2(0, 0, false))), "startTask", ({
    status
  }) => modify_2(status, ({
    tuple: [started, done7, failing]
  }) => {
    if (failing) {
      return tuple2(false, tuple2(started, done7, failing));
    }
    return tuple2(true, tuple2(started + 1, done7, failing));
  })), "startFailure", ({
    result: result4,
    status
  }) => zipRight_2(update_3(status, ({
    tuple: [started, done7, _2]
  }) => tuple2(started, done7, true)), fail7(void 0)(result4))), "task", ({
    causes,
    parentId,
    result: result4,
    startFailure,
    startTask,
    status
  }) => (a2) => uninterruptible2(ifM_(startTask, () => ensuring_(tapCause_(interruptible2(suspend4(() => f2(a2))), (c2) => zipRight_2(update_3(causes, (_2) => combinePar(_2, c2)), startFailure)), (() => {
    const isComplete = modify_2(status, ({
      tuple: [started, done7, failing]
    }) => {
      const newDone = done7 + 1;
      return tuple2((failing ? started : size7) === newDone, tuple2(started, newDone, failing));
    });
    return whenM_(succeed6(void 0)(result4), isComplete);
  })()), () => update_3(causes, (_2) => combinePar(_2, interrupt(parentId)))))), "fibers", ({
    task
  }) => transplant((graft) => forEach_5(collection, (a2) => fork(graft(task(a2)))))), "interrupter", ({
    fibers,
    parentId,
    result: result4
  }) => forkManaged(catchAll_2(wait(result4), () => chain_12(forEach_5(fibers, (_2) => fork(_2.interruptAs(parentId))), fiberJoinAll)))), ({
    causes,
    fibers,
    interrupter,
    result: result4
  }) => managedUse_(interrupter, () => whenM_(zipRight_2(fail7(void 0)(result4), chain_12(causes.get, halt2)), map_13(forEach_5(fibers, (_2) => _2.await), (_2) => indexWhere_(_2, (ex) => !succeeded(ex)) !== -1)))), ({
    fibers
  }) => forEach_5(fibers, (_2) => _2.inheritRefs))), __trace);
}
function forkManaged(self, __trace) {
  return managedFork(toManaged(self), __trace);
}
function forEachUnitPar(f2, __trace) {
  return (as6) => forEachUnitPar_(as6, f2, __trace);
}
function forEachPar_(as6, f2, __trace) {
  return suspend4(() => chain_12(succeedWith3(() => []), (array2) => map_13(forEachUnitPar_(map_5(as6, (a2, n2) => [a2, n2]), ([a2, n2]) => chain_12(suspend4(() => f2(a2)), (b2) => succeedWith3(() => {
    array2[n2] = b2;
  }))), () => from3(array2))), __trace);
}
function forEachParWithIndex_(as6, f2, __trace) {
  return suspend4(() => chain_12(succeedWith3(() => []), (array2) => map_13(forEachUnitPar_(map_5(as6, (a2, n2) => [a2, n2]), ([a2, n2]) => chain_12(suspend4(() => f2(a2, n2)), (b2) => succeedWith3(() => {
    array2[n2] = b2;
  }))), () => from3(array2))), __trace);
}
function forEachPar(f2, __trace) {
  return (as6) => forEachPar_(as6, f2, __trace);
}
function forEachParWithIndex(f2, __trace) {
  return (as6) => forEachParWithIndex_(as6, f2, __trace);
}
function forEachUnitParN_(as6, n2, f2, __trace) {
  const as_5 = from2(as6);
  const size7 = size3(as_5);
  function worker(q2, ref) {
    return whenM_(chain_12(chain_12(take2(q2), f2), () => worker(q2, ref)), modify_2(ref, (n3) => tuple2(n3 > 0, n3 - 1)));
  }
  return suspend4(() => bracket_(makeBoundedQueue(n2), (q2) => tap_4(bind_(tap_4(bind_(do_2, "ref", () => makeRef(size7)), () => fork(forEachUnit_(as6, (x2) => offer_(q2, x2)))), "fibers", ({
    ref
  }) => collectAll2(map_7(range_(0, n2), () => fork(worker(q2, ref))))), ({
    fibers
  }) => forEach_5(fibers, (_2) => _2.await)), (q2) => shutdown(q2)), __trace);
}
function forEachUnitParN(n2, f2, __trace) {
  return (as6) => forEachUnitParN_(as6, n2, f2, __trace);
}
function forEachParN_(as6, n2, f2, __trace) {
  function worker(q2, pairs, ref) {
    return whenM_(chain_12(chain_12(take2(q2), ({
      tuple: [p2, a2]
    }) => foldCauseM_(suspend4(() => f2(a2)), (c2) => forEach_5(pairs, (_2) => halt3(c2)(_2.get(0))), (b2) => succeed6(b2)(p2))), () => worker(q2, pairs, ref)), modify_2(ref, (n3) => tuple2(n3 > 0, n3 - 1)));
  }
  return suspend4(() => bracket_(makeBoundedQueue(n2), (q2) => chain_12(tap_4(tap_4(bind_(bind_(do_2, "pairs", () => forEach_5(as6, (a2) => map_13(make4(), (p2) => tuple2(p2, a2)))), "ref", ({
    pairs
  }) => makeRef(size4(pairs))), ({
    pairs
  }) => fork(forEach_5(pairs, (pair) => offer_(q2, pair)))), ({
    pairs,
    ref
  }) => collectAllUnit(map4(() => fork(worker(q2, pairs, ref)))(range_(0, n2)))), ({
    pairs
  }) => forEach_5(pairs, (_2) => wait(_2.get(0)))), shutdown), __trace);
}
function forEachParWithIndexN_(as6, n2, f2, __trace) {
  function worker(q2, pairs, ref) {
    return whenM_(chain_12(chain_12(take2(q2), ({
      tuple: [p2, a2, i2]
    }) => foldCauseM_(suspend4(() => f2(a2, i2)), (c2) => forEach_5(pairs, (_2) => halt3(c2)(_2.get(0))), (b2) => succeed6(b2)(p2))), () => worker(q2, pairs, ref)), modify_2(ref, (n3) => tuple2(n3 > 0, n3 - 1)));
  }
  return suspend4(() => bracket_(makeBoundedQueue(n2), (q2) => chain_12(tap_4(tap_4(bind_(bind_(do_2, "pairs", () => forEachWithIndex_2(as6, (a2, i2) => map_13(make4(), (p2) => tuple2(p2, a2, i2)))), "ref", ({
    pairs
  }) => makeRef(size4(pairs))), ({
    pairs
  }) => fork(forEach_5(pairs, (pair) => offer_(q2, pair)))), ({
    pairs,
    ref
  }) => collectAllUnit(map4(() => fork(worker(q2, pairs, ref)))(range_(0, n2)))), ({
    pairs
  }) => forEach_5(pairs, (_2) => wait(_2.get(0)))), shutdown), __trace);
}
function forEachParN(n2, f2, __trace) {
  return (as6) => forEachParN_(as6, n2, f2, __trace);
}
function forEachParWithIndexN(n2, f2, __trace) {
  return (as6) => forEachParWithIndexN_(as6, n2, f2, __trace);
}
function forEachExec_(as6, es, f2, __trace) {
  switch (es._tag) {
    case "Sequential": {
      return forEach_5(as6, f2, __trace);
    }
    case "Parallel": {
      return forEachPar_(as6, f2, __trace);
    }
    case "ParallelN": {
      return forEachParN_(as6, es.n, f2, __trace);
    }
  }
}
function forEachExec(es, f2, __trace) {
  return (as6) => forEachExec_(as6, es, f2, __trace);
}
function collectAll2(as6, __trace) {
  return forEach_5(as6, identity, __trace);
}
function collectAllPar2(as6, __trace) {
  return forEachPar_(as6, identity, __trace);
}
function collectAllParN(n2, __trace) {
  return (as6) => forEachParN_(as6, n2, identity, __trace);
}
function collectAllParN_(as6, n2, __trace) {
  return forEachParN_(as6, n2, identity, __trace);
}
function collectAllUnit(as6, __trace) {
  return forEachUnit_(as6, identity, __trace);
}
function collectAllUnitPar(as6, __trace) {
  return forEachUnitPar_(as6, identity, __trace);
}
function collectAllUnitParN(n2, __trace) {
  return (as6) => forEachUnitParN_(as6, n2, identity, __trace);
}
function collectAllUnitParN_(as6, n2, __trace) {
  return forEachUnitParN_(as6, n2, identity, __trace);
}
function collectAllWith_(as6, pf, __trace) {
  return map_13(collectAll2(as6, __trace), collect(pf));
}
function collectAllWith(pf, __trace) {
  return (as6) => collectAllWith_(as6, pf, __trace);
}
function collectAllWithPar_(as6, pf, __trace) {
  return map_13(collectAllPar2(as6, __trace), collect(pf));
}
function collectAllWithPar(pf, __trace) {
  return (as6) => collectAllWithPar_(as6, pf, __trace);
}
function collectAllWithParN_(as6, n2, pf, __trace) {
  return map_13(collectAllParN_(as6, n2, __trace), collect(pf));
}
function collectAllWithParN(n2, pf, __trace) {
  return (as6) => collectAllWithParN_(as6, n2, pf, __trace);
}
function collectAllSuccesses(as6, __trace) {
  return collectAllWith_(map_5(as6, (x2) => result(x2)), (e2) => e2._tag === "Success" ? some(e2.value) : none, __trace);
}
function collectAllSuccessesPar(as6, __trace) {
  return collectAllWithPar_(map_5(as6, (x2) => result(x2)), (e2) => e2._tag === "Success" ? some(e2.value) : none, __trace);
}
function collectAllSuccessesParN_(as6, n2, __trace) {
  return collectAllWithParN_(map_5(as6, (x2) => result(x2)), n2, (e2) => e2._tag === "Success" ? some(e2.value) : none, __trace);
}
function collectAllSuccessesParN(n2, __trace) {
  return (as6) => collectAllSuccessesParN_(as6, n2, __trace);
}
function fiberJoinAll(as6, __trace) {
  return tap_4(chain_12(fiberWaitAll(as6), done), () => forEach_5(as6, (f2) => f2.inheritRefs), __trace);
}
function fiberWaitAll(as6, __trace) {
  return result(forEachPar_(as6, (f2) => chain_12(f2.await, done)), __trace);
}
function releaseMapReleaseAll(exit, execStrategy, __trace) {
  return (_2) => flatten8(modify_2(_2.ref, (s2) => {
    switch (s2._tag) {
      case "Exited": {
        return tuple2(unit3, s2);
      }
      case "Running": {
        switch (execStrategy._tag) {
          case "Sequential": {
            return tuple2(chain_12(forEach_5(Array.from(s2.finalizers()).reverse(), ([_3, f2]) => result(f2(exit)), __trace), (e2) => done(getOrElse_(collectAll(...e2), () => succeed4([])))), new Exited(s2.nextKey, exit));
          }
          case "Parallel": {
            return tuple2(chain_12(forEachPar_(Array.from(s2.finalizers()).reverse(), ([_3, f2]) => result(f2(exit)), __trace), (e2) => done(getOrElse_(collectAllPar(...e2), () => succeed4([])))), new Exited(s2.nextKey, exit));
          }
          case "ParallelN": {
            return tuple2(chain_12(forEachParN_(Array.from(s2.finalizers()).reverse(), execStrategy.n, ([_3, f2]) => result(f2(exit)), __trace), (e2) => done(getOrElse_(collectAllPar(...e2), () => succeed4([])))), new Exited(s2.nextKey, exit));
          }
        }
      }
    }
  }));
}
function managedFork(self, __trace) {
  return managedApply(uninterruptibleMask(({
    restore: restore2
  }) => map_13(bind_(bind_(bind_(let_2(let_2(bind_(do_2, "tp", () => environment2()), "r", ({
    tp
  }) => tp.get(0)), "outerReleaseMap", ({
    tp
  }) => tp.get(1)), "innerReleaseMap", () => makeReleaseMap), "fiber", ({
    innerReleaseMap,
    r: r2
  }) => restore2(provideAll_3(forkDaemon(map_13(self.effect, (_2) => _2.get(1))), tuple2(r2, innerReleaseMap), __trace))), "releaseMapEntry", ({
    fiber,
    innerReleaseMap,
    outerReleaseMap
  }) => add((e2) => chain_12(interrupt4(fiber), () => releaseMapReleaseAll(e2, sequential)(innerReleaseMap), __trace))(outerReleaseMap)), ({
    fiber,
    releaseMapEntry
  }) => tuple2(releaseMapEntry, fiber))));
}
function managedUse_(self, f2, __trace) {
  return bracketExit_(makeReleaseMap, (rm4) => chain_12(provideSome_(self.effect, (r2) => tuple2(r2, rm4)), (a2) => f2(a2.get(1)), __trace), (rm4, ex) => releaseMapReleaseAll(ex, sequential, __trace)(rm4));
}
var BackPressureStrategy = class {
  constructor() {
    this.putters = new Unbounded();
  }
  handleSurplus(as6, queue, takers, isShutdown2) {
    return suspend4((_2, fiberId3) => {
      const p2 = unsafeMake(fiberId3);
      return onInterrupt_(suspend4(() => {
        this.unsafeOffer(as6, p2);
        this.unsafeOnQueueEmptySpace(queue, takers);
        unsafeCompleteTakers(this, queue, takers);
        if (isShutdown2.get) {
          return interrupt3;
        } else {
          return wait(p2);
        }
      }), () => succeedWith3(() => this.unsafeRemove(p2)));
    });
  }
  unsafeRemove(p2) {
    unsafeOfferAll(this.putters, filter_3(unsafePollAll(this.putters), ([_2, __]) => __ !== p2));
  }
  unsafeOffer(as6, p2) {
    let bs = as6;
    while (size4(bs) > 0) {
      const head6 = unsafeGet_2(bs, 0);
      bs = drop_2(bs, 1);
      if (size4(bs) === 0) {
        this.putters.offer(tuple2(head6, p2, true));
        return;
      } else {
        this.putters.offer(tuple2(head6, p2, false));
      }
    }
  }
  unsafeOnQueueEmptySpace(queue, takers) {
    let keepPolling = true;
    while (keepPolling && !queue.isFull) {
      const putter = this.putters.poll(EmptyQueue);
      if (putter !== EmptyQueue) {
        const offered = queue.offer(putter.get(0));
        if (offered && putter.get(2)) {
          unsafeCompletePromise(putter.get(1), true);
        } else if (!offered) {
          unsafeOfferAll(this.putters, prepend_3(unsafePollAll(this.putters), putter));
        }
        unsafeCompleteTakers(this, queue, takers);
      } else {
        keepPolling = false;
      }
    }
  }
  get shutdown() {
    return asUnit(tap_4(bind_(bind_(do_2, "fiberId", () => fiberId), "putters", () => succeedWith3(() => unsafePollAll(this.putters))), (s2) => forEachPar_(s2.putters, ({
      tuple: [_2, p2, lastItem]
    }) => lastItem ? interruptAs2(s2.fiberId)(p2) : unit3)));
  }
  get surplusSize() {
    return this.putters.size;
  }
};
function makeBoundedQueue(capacity, __trace) {
  return chain_12(succeedWith3(() => new Bounded(capacity)), (x2) => createQueue_(x2, new BackPressureStrategy()), __trace);
}
function unsafeCreateQueue(queue, takers, shutdownHook, shutdownFlag, strategy) {
  return new UnsafeCreate(queue, takers, shutdownHook, shutdownFlag, strategy);
}
var UnsafeCreate = class extends XQueueInternal {
  constructor(queue, takers, shutdownHook, shutdownFlag, strategy) {
    super();
    this.queue = queue;
    this.takers = takers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
    this.awaitShutdown = wait(this.shutdownHook);
    this.capacity = this.queue.capacity;
    this.isShutdown = succeedWith3(() => this.shutdownFlag.get);
    this.shutdown = uninterruptible2(suspend4((_2, fiberId3) => {
      this.shutdownFlag.set(true);
      return whenM_(chain_12(forEachPar_(unsafePollAll(this.takers), interruptAs2(fiberId3)), () => this.strategy.shutdown), succeed6(void 0)(this.shutdownHook));
    }));
    this.size = suspend4(() => {
      if (this.shutdownFlag.get) {
        return interrupt3;
      } else {
        return succeed5(this.queue.size - this.takers.size + this.strategy.surplusSize);
      }
    });
    this.take = suspend4((_2, fiberId3) => {
      if (this.shutdownFlag.get) {
        return interrupt3;
      }
      const item = this.queue.poll(EmptyQueue);
      if (item !== EmptyQueue) {
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return succeed5(item);
      } else {
        const p2 = unsafeMake(fiberId3);
        return onInterrupt_(suspend4(() => {
          this.takers.offer(p2);
          unsafeCompleteTakers(this.strategy, this.queue, this.takers);
          if (this.shutdownFlag.get) {
            return interrupt3;
          } else {
            return wait(p2);
          }
        }), () => succeedWith3(() => unsafeRemove(this.takers, p2)));
      }
    });
    this.takeAll = suspend4(() => {
      if (this.shutdownFlag.get) {
        return interrupt3;
      } else {
        return succeedWith3(() => {
          const as6 = unsafePollAll(this.queue);
          this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
          return as6;
        });
      }
    });
  }
  offer(a2) {
    return suspend4(() => {
      if (this.shutdownFlag.get) {
        return interrupt3;
      } else {
        const noRemaining = (() => {
          if (this.queue.isEmpty) {
            const taker = this.takers.poll(EmptyQueue);
            if (taker === EmptyQueue) {
              return false;
            } else {
              unsafeCompletePromise(taker, a2);
              return true;
            }
          } else {
            return false;
          }
        })();
        if (noRemaining) {
          return succeed5(true);
        }
        const succeeded2 = this.queue.offer(a2);
        unsafeCompleteTakers(this.strategy, this.queue, this.takers);
        if (succeeded2) {
          return succeed5(true);
        } else {
          return this.strategy.handleSurplus(single(a2), this.queue, this.takers, this.shutdownFlag);
        }
      }
    });
  }
  offerAll(as6) {
    const arr = from3(as6);
    return suspend4(() => {
      if (this.shutdownFlag.get) {
        return interrupt3;
      } else {
        const pTakers = this.queue.isEmpty ? unsafePollN(this.takers, size4(arr)) : empty4();
        const {
          tuple: [forTakers, remaining]
        } = splitAt_(arr, size4(pTakers));
        forEach_4(zip_5(pTakers, forTakers), ({
          tuple: [taker, item]
        }) => {
          unsafeCompletePromise(taker, item);
        });
        if (size4(remaining) === 0) {
          return succeed5(true);
        }
        const surplus = unsafeOfferAll(this.queue, remaining);
        unsafeCompleteTakers(this.strategy, this.queue, this.takers);
        if (size4(surplus) === 0) {
          return succeed5(true);
        } else {
          return this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);
        }
      }
    });
  }
  takeUpTo(n2) {
    return suspend4(() => {
      if (this.shutdownFlag.get) {
        return interrupt3;
      } else {
        return succeedWith3(() => {
          const as6 = unsafePollN(this.queue, n2);
          this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
          return as6;
        });
      }
    });
  }
};
function createQueue_(queue, strategy, __trace) {
  return map_13(make4(), (p2) => unsafeCreateQueue(queue, new Unbounded(), p2, new AtomicBoolean(false), strategy), __trace);
}
function createQueue(strategy, __trace) {
  return (queue) => createQueue_(queue, strategy, __trace);
}

// node_modules/@effect-ts/system/_mjs/Managed/use.mjs
function use(f2, __trace) {
  return (self) => managedUse_(self, f2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Managed/core.mjs
function chain9(f2, __trace) {
  return (self) => chain_13(self, f2, __trace);
}
function chain_13(self, f2, __trace) {
  return managedApply(chain_12(self.effect, ({
    tuple: [releaseSelf, a2]
  }) => map_13(f2(a2).effect, ({
    tuple: [releaseThat, b2]
  }) => tuple2((e2) => chain_12(result(releaseThat(e2)), (e1) => chain_12(result(releaseSelf(e2)), (e22) => done(zipRight_(e1, e22), __trace))), b2), __trace)));
}
function succeedWith4(effect2, __trace) {
  return fromEffect(succeedWith3(effect2, __trace));
}
function ensuring_2(self, f2, __trace) {
  return onExit_(self, () => f2, __trace);
}
function ensuring2(f2, __trace) {
  return (self) => ensuring_2(self, f2, __trace);
}
function fail8(e2, __trace) {
  return fromEffect(fail6(e2, __trace));
}
function failWith2(e2, __trace) {
  return fromEffect(failWith(e2, __trace));
}
function finalizerRef(initial2, __trace) {
  return makeExit_(makeRef(initial2), (ref, exit) => chain_12(ref.get, (f2) => f2(exit)), __trace);
}
function foldCauseM2(f2, g2, __trace) {
  return (self) => foldCauseM_2(self, f2, g2, __trace);
}
function foldCauseM_2(self, f2, g2, __trace) {
  return managedApply(foldCauseM_(self.effect, (c2) => f2(c2).effect, ({
    tuple: [_2, a2]
  }) => g2(a2).effect, __trace));
}
function make5(release4, __trace) {
  return (acquire) => make_(acquire, release4, __trace);
}
function make_(acquire, release4, __trace) {
  return makeExit_(acquire, release4, __trace);
}
function makeInterruptible(release4, __trace) {
  return (acquire) => makeInterruptible_(acquire, release4, __trace);
}
function makeInterruptible_(acquire, release4, __trace) {
  return onExitFirst_(fromEffect(acquire, __trace), forEach2(release4), __trace);
}
function makeManagedReleaseMap(es, __trace) {
  return makeExit_(makeReleaseMap, (rm4, e2) => releaseMapReleaseAll(e2, es)(rm4), __trace);
}
function makeReserve(reservation, __trace) {
  return managedApply(uninterruptibleMask(({
    restore: restore2
  }) => map_13(bind_(bind_(bind_(let_2(let_2(bind_(do_2, "tp", () => environment2()), "r", (s2) => s2.tp.get(0)), "releaseMap", (s2) => s2.tp.get(1)), "reserved", (s2) => provideAll_3(reservation, s2.r)), "releaseKey", (s2) => addIfOpen((x2) => provideAll_3(s2.reserved.release(x2), s2.r, __trace))(s2.releaseMap)), "finalizerAndA", (s2) => {
    const k2 = s2.releaseKey;
    switch (k2._tag) {
      case "None": {
        return interrupt3;
      }
      case "Some": {
        return map_13(restore2(provideSome_(s2.reserved.acquire, ({
          tuple: [r2]
        }) => r2, __trace)), (a2) => tuple2((e2) => release(k2.value, e2)(s2.releaseMap), a2));
      }
    }
  }), (s2) => s2.finalizerAndA)));
}
function map10(f2, __trace) {
  return (self) => map_14(self, f2, __trace);
}
function map_14(self, f2, __trace) {
  return managedApply(map_13(self.effect, ({
    tuple: [fin, a2]
  }) => tuple2(fin, f2(a2)), __trace));
}
function mapM_(self, f2, __trace) {
  return managedApply(chain_12(self.effect, ({
    tuple: [fin, a2]
  }) => provideSome_(map_13(f2(a2), (b2) => tuple2(fin, b2), __trace), ({
    tuple: [r2]
  }) => r2)));
}
function mapM(f2, __trace) {
  return (self) => mapM_(self, f2, __trace);
}
function onExit_(self, cleanup, __trace) {
  return managedApply(uninterruptibleMask(({
    restore: restore2
  }) => map_13(bind_(bind_(bind_(bind_(let_2(let_2(bind_(do_2, "tp", () => environment2()), "r", (s2) => s2.tp.get(0)), "outerReleaseMap", (s2) => s2.tp.get(1)), "innerReleaseMap", () => makeReleaseMap), "exitEA", (s2) => provideAll_3(result(restore2(map_13(self.effect, ({
    tuple: [_2, a2]
  }) => a2))), tuple2(s2.r, s2.innerReleaseMap))), "releaseMapEntry", (s2) => add((e2) => flatten8(zipWith_4(result(releaseMapReleaseAll(e2, sequential)(s2.innerReleaseMap)), result(provideAll_3(cleanup(s2.exitEA), s2.r)), (l2, r2) => done(zipRight_(l2, r2)), __trace)))(s2.outerReleaseMap)), "a", (s2) => done(s2.exitEA)), (s2) => tuple2(s2.releaseMapEntry, s2.a))));
}
function onExit(cleanup, __trace) {
  return (self) => onExit_(self, cleanup, __trace);
}
function onExitFirst(cleanup, __trace) {
  return (self) => onExitFirst_(self, cleanup, __trace);
}
function onExitFirst_(self, cleanup, __trace) {
  return managedApply(uninterruptibleMask(({
    restore: restore2
  }) => map_13(bind_(bind_(bind_(bind_(let_2(let_2(bind_(do_2, "tp", () => environment2()), "r", (s2) => s2.tp.get(0)), "outerReleaseMap", (s2) => s2.tp.get(1)), "innerReleaseMap", () => makeReleaseMap), "exitEA", (s2) => provideAll_3(result(restore2(map_13(self.effect, ({
    tuple: [_2, a2]
  }) => a2))), tuple2(s2.r, s2.innerReleaseMap))), "releaseMapEntry", (s2) => add((e2) => flatten8(zipWith_4(result(provideAll_3(cleanup(s2.exitEA), s2.r, __trace)), result(releaseMapReleaseAll(e2, sequential)(s2.innerReleaseMap)), (l2, r2) => done(zipRight_(l2, r2)))))(s2.outerReleaseMap)), "a", (s2) => done(s2.exitEA)), (s2) => tuple2(s2.releaseMapEntry, s2.a))));
}
function provideSome_2(self, f2, __trace) {
  return managedApply(accessM3(({
    tuple: [r0, rm4]
  }) => provideAll_3(self.effect, tuple2(f2(r0), rm4), __trace)));
}
function provideSome3(f2, __trace) {
  return (self) => provideSome_2(self, f2, __trace);
}
function provideAll3(r2, __trace) {
  return (self) => provideAll_4(self, r2);
}
function provideAll_4(self, r2, __trace) {
  return provideSome_2(self, () => r2, __trace);
}
var Reservation = class {
  constructor(acquire, release4) {
    this.acquire = acquire;
    this.release = release4;
  }
};
Reservation.of = (acquire, release4) => new Reservation(acquire, release4);
function makeReservation_(acquire, release4) {
  return Reservation.of(acquire, release4);
}
function makeReservation(release4) {
  return (acquire) => Reservation.of(acquire, release4);
}
function reserve(reservation, __trace) {
  return makeReserve(succeed5(reservation), __trace);
}
function tap_5(self, f2, __trace) {
  return chain_13(self, (a2) => map_14(f2(a2), () => a2), __trace);
}
function tap5(f2, __trace) {
  return (self) => tap_5(self, f2, __trace);
}
function useNow(self, __trace) {
  return managedUse_(self, succeed5, __trace);
}
function useForever(self, __trace) {
  return managedUse_(self, () => never, __trace);
}
function zip_6(self, that, __trace) {
  return zipWith_6(self, that, (a2, a22) => [a2, a22], __trace);
}
function zip7(that, __trace) {
  return (self) => zip_6(self, that, __trace);
}
function zipWith5(that, f2, __trace) {
  return (self) => zipWith_6(self, that, f2, __trace);
}
function zipWith_6(self, that, f2, __trace) {
  return chain_13(self, (a2) => map_14(that, (a22) => f2(a2, a22)), __trace);
}
function zipWithPar2(that, f2, __trace) {
  return (self) => zipWithPar_2(self, that, f2, __trace);
}
function zipWithPar_2(self, that, f2, __trace) {
  return mapM_(makeManagedReleaseMap(parallel), (parallelReleaseMap) => {
    const innerMap = provideSome_(makeManagedReleaseMap(sequential).effect, (r2) => tuple2(r2, parallelReleaseMap));
    return chain_12(zip_4(innerMap, innerMap, __trace), ({
      tuple: [{
        tuple: [_2, l2]
      }, {
        tuple: [__, r2]
      }]
    }) => zipWithPar_(provideSome_(self.effect, (_3) => tuple2(_3, l2)), provideSome_(that.effect, (_3) => tuple2(_3, r2)), ({
      tuple: [_3, a2]
    }, {
      tuple: [__2, a22]
    }) => f2(a2, a22), __trace));
  });
}
function managedReserve(self) {
  return map_13(makeReleaseMap, (releaseMap2) => Reservation.of(map_13(provideSome_(self.effect, (_2) => tuple2(_2, releaseMap2)), get(1)), (_2) => releaseMapReleaseAll(_2, sequential)(releaseMap2)));
}

// node_modules/@effect-ts/system/_mjs/Fiber/api.mjs
function interruptAllAs(id) {
  return (fs3) => reduce_3(fs3, unit3, (io, f2) => asUnit(chain_12(io, () => f2.interruptAs(id))));
}
function interruptAll(fs3) {
  return chain_12(fiberId, (id) => interruptAllAs(id)(fs3));
}
function waitAll(as6) {
  return result(forEachPar_(as6, (f2) => chain_12(f2.await, done)));
}
function collectAll3(fibers) {
  return {
    getRef: (ref) => reduce_6(fibers, ref.initial, (a2, fiber) => map_13(fiber.getRef(ref), (a22) => ref.join(a2, a22))),
    inheritRefs: forEachUnit_(fibers, (f2) => f2.inheritRefs),
    interruptAs: (fiberId3) => map_13(forEach_5(fibers, (f2) => f2.interruptAs(fiberId3)), reduceRight2(succeed4(empty4()), (a2, b2) => zipWith_3(a2, b2, (_a12, _b5) => prepend_3(_b5, _a12), combinePar))),
    poll: map_13(forEach_5(fibers, (f2) => f2.poll), reduceRight2(some(succeed4(empty4())), (a2, b2) => fold_(a2, () => none, (ra) => fold_(b2, () => none, (rb) => some(zipWith_3(ra, rb, (_a12, _b5) => prepend_3(_b5, _a12), combinePar)))))),
    await: waitAll(fibers)
  };
}

// node_modules/@effect-ts/system/_mjs/FiberRef/fiberRef.mjs
var TypeId2 = /* @__PURE__ */ Symbol();
var Runtime2 = class {
  constructor(initial2, fork2 = identity, join10 = (_2, a2) => a2) {
    this.initial = initial2;
    this.fork = fork2;
    this.join = join10;
    this._tag = "Runtime";
    this._typeId = TypeId2;
  }
  fold(_ea, _eb, ca, bd) {
    return new Derived2((f2) => f2(this, bd, ca));
  }
  foldAll(_ea, _eb, _ec, ca, bd) {
    return new DerivedAll2((f2) => f2(this, (s2) => bd(s2), (c2) => (s2) => ca(c2)(s2)));
  }
  modify(f2) {
    return new IFiberRefModify(this, f2);
  }
  get get() {
    return this.modify((v2) => tuple2(v2, v2));
  }
  locally(a2, use2) {
    return chain_12(this.get, (oldValue) => bracket_(this.set(a2), () => use2, () => this.set(oldValue)));
  }
  set(value) {
    return this.modify(() => tuple2(void 0, value));
  }
};
var Derived2 = class _Derived {
  constructor(use2) {
    this.use = use2;
    this._tag = "Derived";
    this._typeId = TypeId2;
  }
  fold(ea, eb, ca, bd) {
    return this.use((value, getEither, setEither) => new _Derived((f2) => f2(value, (s2) => fold_2(getEither(s2), (e2) => left(eb(e2)), bd), (c2) => chain_3(ca(c2), (a2) => fold_2(setEither(a2), (e2) => left(ea(e2)), right)))));
  }
  foldAll(ea, eb, ec, ca, _bd) {
    return this.use((value, getEither, setEither) => new DerivedAll2((f2) => f2(value, (s2) => fold_2(getEither(s2), (e2) => left(eb(e2)), right), (c2) => (s2) => chain_3(fold_2(getEither(s2), (e2) => left(ec(e2)), ca(c2)), (a2) => fold_2(setEither(a2), (e2) => left(ea(e2)), right)))));
  }
  get get() {
    return this.use((value, getEither) => chain_12(value.get, (s2) => fold_2(getEither(s2), fail6, succeed5)));
  }
  locally(a2, use2) {
    return this.use((value, _getEither, setEither) => chain_12(value.get, (old) => fold_2(setEither(a2), (e2) => fail6(e2), (s2) => bracket_(value.set(s2), () => use2, () => value.set(old)))));
  }
  set(a2) {
    return this.use((value, _getEither, setEither) => fold_2(setEither(a2), fail6, (s2) => value.set(s2)));
  }
};
var DerivedAll2 = class _DerivedAll {
  constructor(use2) {
    this.use = use2;
    this._tag = "DerivedAll";
    this._typeId = TypeId2;
  }
  fold(ea, eb, ca, bd) {
    return this.use((value, getEither, setEither) => new _DerivedAll((f2) => f2(value, (s2) => fold_2(getEither(s2), (e2) => left(eb(e2)), bd), (c2) => (s2) => chain_3(ca(c2), (a2) => fold_2(setEither(a2)(s2), (e2) => left(ea(e2)), right)))));
  }
  foldAll(ea, eb, ec, ca, bd) {
    return this.use((value, getEither, setEither) => new _DerivedAll((f2) => f2(value, (s2) => fold_2(getEither(s2), (e2) => left(eb(e2)), bd), (c2) => (s2) => chain_3(fold_2(getEither(s2), (e2) => left(ec(e2)), ca(c2)), (a2) => fold_2(setEither(a2)(s2), (e2) => left(ea(e2)), right)))));
  }
  get get() {
    return this.use((value, getEither) => chain_12(value.get, (s2) => fold_2(getEither(s2), fail6, succeed5)));
  }
  locally(a2, use2) {
    return this.use((value, _getEither, setEither) => chain_12(value.get, (old) => fold_2(setEither(a2)(old), (e2) => fail6(e2), (s2) => bracket_(value.set(s2), () => use2, () => value.set(old)))));
  }
  set(a2) {
    return this.use((value, _getEither, setEither) => absolve(value.modify((s2) => fold_2(setEither(a2)(s2), (e2) => tuple2(leftW(e2), s2), (s3) => tuple2(right(void 0), s3)))));
  }
};

// node_modules/@effect-ts/system/_mjs/FiberRef/modify.mjs
function modify_3(fiberRef, f2) {
  return matchTag({
    Runtime: (self) => self.modify(f2),
    Derived: (self) => self.use((value, getEither, setEither) => absolve(value.modify((s2) => fold_2(getEither(s2), (e2) => tuple2(left(e2), s2), (a1) => (({
      tuple: [b2, a2]
    }) => fold_2(setEither(a2), (e2) => tuple2(left(e2), s2), (s3) => tuple2(right(b2), s3)))(f2(a1)))))),
    DerivedAll: (self) => self.use((value, getEither, setEither) => absolve(value.modify((s2) => fold_2(getEither(s2), (e2) => tuple2(left(e2), s2), (a1) => (({
      tuple: [b2, a2]
    }) => fold_2(setEither(a2)(s2), (e2) => tuple2(left(e2), s2), (s3) => tuple2(right(b2), s3)))(f2(a1))))))
  })(fiberRef);
}

// node_modules/@effect-ts/system/_mjs/FiberRef/update.mjs
function update_4(self, f2) {
  return modify_3(self, (v2) => tuple2(void 0, f2(v2)));
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/RedBlackTree/index.mjs
var Node2 = class {
  constructor(color, key, value, left4, right5, count2) {
    this.color = color;
    this.key = key;
    this.value = value;
    this.left = left4;
    this.right = right5;
    this.count = count2;
  }
};
function cloneNode2(node) {
  return new Node2(node.color, node.key, node.value, node.left, node.right, node.count);
}
function swapNode(n2, v2) {
  n2.key = v2.key;
  n2.value = v2.value;
  n2.left = v2.left;
  n2.right = v2.right;
  n2.color = v2.color;
  n2.count = v2.count;
}
function repaintNode(node, color) {
  return new Node2(color, node.key, node.value, node.left, node.right, node.count);
}
function recountNode(node) {
  var _a12, _b5, _c4, _d4;
  node.count = 1 + ((_b5 = (_a12 = node.left) === null || _a12 === void 0 ? void 0 : _a12.count) !== null && _b5 !== void 0 ? _b5 : 0) + ((_d4 = (_c4 = node.right) === null || _c4 === void 0 ? void 0 : _c4.count) !== null && _d4 !== void 0 ? _d4 : 0);
}
var RedBlackTree = class _RedBlackTree {
  constructor(ord, root) {
    this.ord = ord;
    this.root = root;
  }
  [Symbol.iterator]() {
    const stack = [];
    let n2 = this.root;
    while (n2) {
      stack.push(n2);
      n2 = n2.left;
    }
    return new RedBlackTreeIterator(this, stack, "Forward");
  }
  get [hashSym]() {
    return hashIterator(this[Symbol.iterator]());
  }
  [equalsSym](that) {
    return that instanceof _RedBlackTree && size6(this) === size6(that) && corresponds(this, that, equals);
  }
};
function make6(ord) {
  return new RedBlackTree(ord, void 0);
}
function size6(self) {
  var _a12, _b5;
  return (_b5 = (_a12 = self.root) === null || _a12 === void 0 ? void 0 : _a12.count) !== null && _b5 !== void 0 ? _b5 : 0;
}
function insert_2(self, key, value) {
  const cmp = self.ord.compare;
  let n2 = self.root;
  const n_stack = [];
  const d_stack = [];
  while (n2) {
    const d2 = cmp(key, n2.key);
    n_stack.push(n2);
    d_stack.push(d2);
    if (d2 <= 0) {
      n2 = n2.left;
    } else {
      n2 = n2.right;
    }
  }
  n_stack.push(new Node2("Red", key, value, void 0, void 0, 1));
  for (let s2 = n_stack.length - 2; s2 >= 0; --s2) {
    const n22 = n_stack[s2];
    if (d_stack[s2] <= 0) {
      n_stack[s2] = new Node2(n22.color, n22.key, n22.value, n_stack[s2 + 1], n22.right, n22.count + 1);
    } else {
      n_stack[s2] = new Node2(n22.color, n22.key, n22.value, n22.left, n_stack[s2 + 1], n22.count + 1);
    }
  }
  for (let s2 = n_stack.length - 1; s2 > 1; --s2) {
    const p2 = n_stack[s2 - 1];
    const n3 = n_stack[s2];
    if (p2.color === "Black" || n3.color === "Black") {
      break;
    }
    const pp = n_stack[s2 - 2];
    if (pp.left === p2) {
      if (p2.left === n3) {
        const y2 = pp.right;
        if (y2 && y2.color === "Red") {
          p2.color = "Black";
          pp.right = repaintNode(y2, "Black");
          pp.color = "Red";
          s2 -= 1;
        } else {
          pp.color = "Red";
          pp.left = p2.right;
          p2.color = "Black";
          p2.right = pp;
          n_stack[s2 - 2] = p2;
          n_stack[s2 - 1] = n3;
          recountNode(pp);
          recountNode(p2);
          if (s2 >= 3) {
            const ppp = n_stack[s2 - 3];
            if (ppp.left === pp) {
              ppp.left = p2;
            } else {
              ppp.right = p2;
            }
          }
          break;
        }
      } else {
        const y2 = pp.right;
        if (y2 && y2.color === "Red") {
          p2.color = "Black";
          pp.right = repaintNode(y2, "Black");
          pp.color = "Red";
          s2 -= 1;
        } else {
          p2.right = n3.left;
          pp.color = "Red";
          pp.left = n3.right;
          n3.color = "Black";
          n3.left = p2;
          n3.right = pp;
          n_stack[s2 - 2] = n3;
          n_stack[s2 - 1] = p2;
          recountNode(pp);
          recountNode(p2);
          recountNode(n3);
          if (s2 >= 3) {
            const ppp = n_stack[s2 - 3];
            if (ppp.left === pp) {
              ppp.left = n3;
            } else {
              ppp.right = n3;
            }
          }
          break;
        }
      }
    } else {
      if (p2.right === n3) {
        const y2 = pp.left;
        if (y2 && y2.color === "Red") {
          p2.color = "Black";
          pp.left = repaintNode(y2, "Black");
          pp.color = "Red";
          s2 -= 1;
        } else {
          pp.color = "Red";
          pp.right = p2.left;
          p2.color = "Black";
          p2.left = pp;
          n_stack[s2 - 2] = p2;
          n_stack[s2 - 1] = n3;
          recountNode(pp);
          recountNode(p2);
          if (s2 >= 3) {
            const ppp = n_stack[s2 - 3];
            if (ppp.right === pp) {
              ppp.right = p2;
            } else {
              ppp.left = p2;
            }
          }
          break;
        }
      } else {
        const y2 = pp.left;
        if (y2 && y2.color === "Red") {
          p2.color = "Black";
          pp.left = repaintNode(y2, "Black");
          pp.color = "Red";
          s2 -= 1;
        } else {
          p2.left = n3.right;
          pp.color = "Red";
          pp.right = n3.left;
          n3.color = "Black";
          n3.right = p2;
          n3.left = pp;
          n_stack[s2 - 2] = n3;
          n_stack[s2 - 1] = p2;
          recountNode(pp);
          recountNode(p2);
          recountNode(n3);
          if (s2 >= 3) {
            const ppp = n_stack[s2 - 3];
            if (ppp.right === pp) {
              ppp.right = n3;
            } else {
              ppp.left = n3;
            }
          }
          break;
        }
      }
    }
  }
  n_stack[0].color = "Black";
  return new RedBlackTree(self.ord, n_stack[0]);
}
function fixDoubleBlack(stack) {
  let n2, p2, s2, z2;
  for (let i2 = stack.length - 1; i2 >= 0; --i2) {
    n2 = stack[i2];
    if (i2 === 0) {
      n2.color = "Black";
      return;
    }
    p2 = stack[i2 - 1];
    if (p2.left === n2) {
      s2 = p2.right;
      if (s2 && s2.right && s2.right.color === "Red") {
        s2 = p2.right = cloneNode2(s2);
        z2 = s2.right = cloneNode2(s2.right);
        p2.right = s2.left;
        s2.left = p2;
        s2.right = z2;
        s2.color = p2.color;
        n2.color = "Black";
        p2.color = "Black";
        z2.color = "Black";
        recountNode(p2);
        recountNode(s2);
        if (i2 > 1) {
          const pp = stack[i2 - 2];
          if (pp.left === p2) {
            pp.left = s2;
          } else {
            pp.right = s2;
          }
        }
        stack[i2 - 1] = s2;
        return;
      } else if (s2 && s2.left && s2.left.color === "Red") {
        s2 = p2.right = cloneNode2(s2);
        z2 = s2.left = cloneNode2(s2.left);
        p2.right = z2.left;
        s2.left = z2.right;
        z2.left = p2;
        z2.right = s2;
        z2.color = p2.color;
        p2.color = "Black";
        s2.color = "Black";
        n2.color = "Black";
        recountNode(p2);
        recountNode(s2);
        recountNode(z2);
        if (i2 > 1) {
          const pp = stack[i2 - 2];
          if (pp.left === p2) {
            pp.left = z2;
          } else {
            pp.right = z2;
          }
        }
        stack[i2 - 1] = z2;
        return;
      }
      if (s2 && s2.color === "Black") {
        if (p2.color === "Red") {
          p2.color = "Black";
          p2.right = repaintNode(s2, "Red");
          return;
        } else {
          p2.right = repaintNode(s2, "Red");
          continue;
        }
      } else if (s2) {
        s2 = cloneNode2(s2);
        p2.right = s2.left;
        s2.left = p2;
        s2.color = p2.color;
        p2.color = "Red";
        recountNode(p2);
        recountNode(s2);
        if (i2 > 1) {
          const pp = stack[i2 - 2];
          if (pp.left === p2) {
            pp.left = s2;
          } else {
            pp.right = s2;
          }
        }
        stack[i2 - 1] = s2;
        stack[i2] = p2;
        if (i2 + 1 < stack.length) {
          stack[i2 + 1] = n2;
        } else {
          stack.push(n2);
        }
        i2 = i2 + 2;
      }
    } else {
      s2 = p2.left;
      if (s2 && s2.left && s2.left.color === "Red") {
        s2 = p2.left = cloneNode2(s2);
        z2 = s2.left = cloneNode2(s2.left);
        p2.left = s2.right;
        s2.right = p2;
        s2.left = z2;
        s2.color = p2.color;
        n2.color = "Black";
        p2.color = "Black";
        z2.color = "Black";
        recountNode(p2);
        recountNode(s2);
        if (i2 > 1) {
          const pp = stack[i2 - 2];
          if (pp.right === p2) {
            pp.right = s2;
          } else {
            pp.left = s2;
          }
        }
        stack[i2 - 1] = s2;
        return;
      } else if (s2 && s2.right && s2.right.color === "Red") {
        s2 = p2.left = cloneNode2(s2);
        z2 = s2.right = cloneNode2(s2.right);
        p2.left = z2.right;
        s2.right = z2.left;
        z2.right = p2;
        z2.left = s2;
        z2.color = p2.color;
        p2.color = "Black";
        s2.color = "Black";
        n2.color = "Black";
        recountNode(p2);
        recountNode(s2);
        recountNode(z2);
        if (i2 > 1) {
          const pp = stack[i2 - 2];
          if (pp.right === p2) {
            pp.right = z2;
          } else {
            pp.left = z2;
          }
        }
        stack[i2 - 1] = z2;
        return;
      }
      if (s2 && s2.color === "Black") {
        if (p2.color === "Red") {
          p2.color = "Black";
          p2.left = repaintNode(s2, "Red");
          return;
        } else {
          p2.left = repaintNode(s2, "Red");
          continue;
        }
      } else if (s2) {
        s2 = cloneNode2(s2);
        p2.left = s2.right;
        s2.right = p2;
        s2.color = p2.color;
        p2.color = "Red";
        recountNode(p2);
        recountNode(s2);
        if (i2 > 1) {
          const pp = stack[i2 - 2];
          if (pp.right === p2) {
            pp.right = s2;
          } else {
            pp.left = s2;
          }
        }
        stack[i2 - 1] = s2;
        stack[i2] = p2;
        if (i2 + 1 < stack.length) {
          stack[i2 + 1] = n2;
        } else {
          stack.push(n2);
        }
        i2 = i2 + 2;
      }
    }
  }
}
var RedBlackTreeIterator = class _RedBlackTreeIterator {
  constructor(self, stack, direction) {
    this.self = self;
    this.stack = stack;
    this.direction = direction;
    this.count = 0;
  }
  /**
   * Clones the iterator
   */
  clone() {
    return new _RedBlackTreeIterator(this.self, this.stack.slice(), this.direction);
  }
  /**
   * Reverse the traversal direction
   */
  reversed() {
    return new _RedBlackTreeIterator(this.self, this.stack.slice(), this.direction === "Forward" ? "Backward" : "Forward");
  }
  /**
   * Iterator next
   */
  next() {
    const entry = this.entry;
    this.count++;
    if (this.direction === "Forward") {
      this.moveNext();
    } else {
      this.movePrev();
    }
    return fold_(entry, () => ({
      done: true,
      value: this.count
    }), (kv) => ({
      done: false,
      value: kv
    }));
  }
  /**
   * Returns the key
   */
  get key() {
    if (this.stack.length > 0) {
      return some(this.stack[this.stack.length - 1].key);
    }
    return none;
  }
  /**
   * Returns the value
   */
  get value() {
    if (this.stack.length > 0) {
      return some(this.stack[this.stack.length - 1].value);
    }
    return none;
  }
  /**
   * Returns the key
   */
  get entry() {
    if (this.stack.length > 0) {
      return some(tuple(this.stack[this.stack.length - 1].key, this.stack[this.stack.length - 1].value));
    }
    return none;
  }
  /**
   * Returns the position of this iterator in the sorted list
   */
  get index() {
    let idx = 0;
    const stack = this.stack;
    if (stack.length === 0) {
      const r2 = this.self.root;
      if (r2) {
        return r2.count;
      }
      return 0;
    } else if (stack[stack.length - 1].left) {
      idx = stack[stack.length - 1].left.count;
    }
    for (let s2 = stack.length - 2; s2 >= 0; --s2) {
      if (stack[s2 + 1] === stack[s2].right) {
        ++idx;
        if (stack[s2].left) {
          idx += stack[s2].left.count;
        }
      }
    }
    return idx;
  }
  /**
   * Advances iterator to next element in list
   */
  moveNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n2 = stack[stack.length - 1];
    if (n2.right) {
      n2 = n2.right;
      while (n2) {
        stack.push(n2);
        n2 = n2.left;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].right === n2) {
        n2 = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  /**
   * Checks if there is a next element
   */
  get hasNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].right) {
      return true;
    }
    for (let s2 = stack.length - 1; s2 > 0; --s2) {
      if (stack[s2 - 1].left === stack[s2]) {
        return true;
      }
    }
    return false;
  }
  /**
   * Advances iterator to previous element in list
   */
  movePrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n2 = stack[stack.length - 1];
    if (n2 && n2.left) {
      n2 = n2.left;
      while (n2) {
        stack.push(n2);
        n2 = n2.right;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].left === n2) {
        n2 = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  /**
   * Checks if there is a previous element
   */
  get hasPrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].left) {
      return true;
    }
    for (let s2 = stack.length - 1; s2 > 0; --s2) {
      if (stack[s2 - 1].right === stack[s2]) {
        return true;
      }
    }
    return false;
  }
};
function keys_(self, direction = "Forward") {
  const begin = self[Symbol.iterator]();
  let count2 = 0;
  return {
    [Symbol.iterator]: () => keys_(self, direction),
    next: () => {
      count2++;
      const entry = begin.key;
      if (direction === "Forward") {
        begin.moveNext();
      } else {
        begin.movePrev();
      }
      return fold_(entry, () => ({
        value: count2,
        done: true
      }), (entry2) => ({
        value: entry2,
        done: false
      }));
    }
  };
}
function findFirst_(tree, key) {
  const cmp = tree.ord.compare;
  let n2 = tree.root;
  while (n2) {
    const d2 = cmp(key, n2.key);
    if (equals(key, n2.key)) {
      return some(n2.value);
    }
    if (d2 <= 0) {
      n2 = n2.left;
    } else {
      n2 = n2.right;
    }
  }
  return none;
}
function has_2(tree, key) {
  return findFirst_(tree, key)._tag === "Some";
}
function removeFirst_(self, key) {
  const cmp = self.ord.compare;
  let node = self.root;
  const stack = [];
  while (node) {
    const d2 = cmp(key, node.key);
    stack.push(node);
    if (equals(key, node.key)) {
      node = void 0;
    } else if (d2 <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  if (stack.length === 0) {
    return self;
  }
  const cstack = new Array(stack.length);
  let n2 = stack[stack.length - 1];
  cstack[cstack.length - 1] = new Node2(n2.color, n2.key, n2.value, n2.left, n2.right, n2.count);
  for (let i2 = stack.length - 2; i2 >= 0; --i2) {
    n2 = stack[i2];
    if (n2.left === stack[i2 + 1]) {
      cstack[i2] = new Node2(n2.color, n2.key, n2.value, cstack[i2 + 1], n2.right, n2.count);
    } else {
      cstack[i2] = new Node2(n2.color, n2.key, n2.value, n2.left, cstack[i2 + 1], n2.count);
    }
  }
  n2 = cstack[cstack.length - 1];
  if (n2.left && n2.right) {
    const split2 = cstack.length;
    n2 = n2.left;
    while (n2.right) {
      cstack.push(n2);
      n2 = n2.right;
    }
    const v2 = cstack[split2 - 1];
    cstack.push(new Node2(n2.color, v2.key, v2.value, n2.left, n2.right, n2.count));
    cstack[split2 - 1].key = n2.key;
    cstack[split2 - 1].value = n2.value;
    for (let i2 = cstack.length - 2; i2 >= split2; --i2) {
      n2 = cstack[i2];
      cstack[i2] = new Node2(n2.color, n2.key, n2.value, n2.left, cstack[i2 + 1], n2.count);
    }
    cstack[split2 - 1].left = cstack[split2];
  }
  n2 = cstack[cstack.length - 1];
  if (n2.color === "Red") {
    const p2 = cstack[cstack.length - 2];
    if (p2.left === n2) {
      p2.left = null;
    } else if (p2.right === n2) {
      p2.right = null;
    }
    cstack.pop();
    for (let i2 = 0; i2 < cstack.length; ++i2) {
      cstack[i2]._count--;
    }
    return new RedBlackTree(self.ord, cstack[0]);
  } else {
    if (n2.left || n2.right) {
      if (n2.left) {
        swapNode(n2, n2.left);
      } else if (n2.right) {
        swapNode(n2, n2.right);
      }
      n2.color = "Black";
      for (let i2 = 0; i2 < cstack.length - 1; ++i2) {
        cstack[i2]._count--;
      }
      return new RedBlackTree(self.ord, cstack[0]);
    } else if (cstack.length === 1) {
      return new RedBlackTree(self.ord, void 0);
    } else {
      for (let i2 = 0; i2 < cstack.length; ++i2) {
        cstack[i2]._count--;
      }
      const parent = cstack[cstack.length - 2];
      fixDoubleBlack(cstack);
      if (parent.left === n2) {
        parent.left = null;
      } else {
        parent.right = null;
      }
    }
  }
  return new RedBlackTree(self.ord, cstack[0]);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/SortedSet/index.mjs
var SortedSet = class {
  constructor(keyTree) {
    this.keyTree = keyTree;
  }
  [Symbol.iterator]() {
    return keys_(this.keyTree);
  }
  get [hashSym]() {
    return this.keyTree[hashSym];
  }
  [equalsSym](that) {
    return this.keyTree[equalsSym](that);
  }
};
function make7(K2) {
  return new SortedSet(make6(K2));
}
function add_2(set3, v2) {
  return has_2(set3.keyTree, v2) ? set3 : new SortedSet(insert_2(set3.keyTree, v2, true));
}
function remove_3(set3, v2) {
  return new SortedSet(removeFirst_(set3.keyTree, v2));
}
function values2(set3) {
  return keys_(set3.keyTree);
}
function filter_4(set3, predicate) {
  let r2 = make7(set3.keyTree.ord);
  const values_ = values2(set3);
  let e2;
  while (!(e2 = values_.next()).done) {
    const value = e2.value;
    if (predicate(value)) {
      r2 = add_2(r2, value);
    }
  }
  return r2;
}

// node_modules/@effect-ts/system/_mjs/Equal/operations.mjs
function makeEqual(f2) {
  return {
    equals: f2
  };
}
function strict() {
  return makeEqual((x2, y2) => x2 === y2);
}

// node_modules/@effect-ts/system/_mjs/Ord/operations.mjs
function makeOrd(compare2) {
  return {
    compare: compare2
  };
}

// node_modules/@effect-ts/system/_mjs/Ord/common.mjs
var compare = (x2, y2) => {
  return x2 < y2 ? -1 : x2 > y2 ? 1 : 0;
};
var number = /* @__PURE__ */ makeOrd(compare);

// node_modules/@effect-ts/system/_mjs/Ordering/operations.mjs
function combine(x2, y2) {
  return x2 !== 0 ? x2 : y2;
}

// node_modules/@effect-ts/system/_mjs/Fiber/runtimeOrd.mjs
var runtimeOrd = () => makeOrd((x2, y2) => combine(number.compare(x2.id.startTimeMillis, y2.id.startTimeMillis), number.compare(x2.id.seqNumber, y2.id.seqNumber)));

// node_modules/@effect-ts/system/_mjs/Supervisor/index.mjs
var Supervisor = class _Supervisor {
  constructor(value, unsafeOnStart, unsafeOnEnd) {
    this.value = value;
    this.unsafeOnStart = unsafeOnStart;
    this.unsafeOnEnd = unsafeOnEnd;
  }
  /**
   * Returns a new supervisor that performs the function of this supervisor,
   * and the function of the specified supervisor, producing a tuple of the
   * outputs produced by both supervisors.
   *
   * The composite supervisor indicates that it has fully handled the
   * supervision event if only both component supervisors indicate they have
   * handled the supervision event.
   */
  and(that) {
    return new _Supervisor(zip_4(this.value, that.value), (environment5, effect2, parent, fiber) => propagationAnd(this.unsafeOnStart(environment5, effect2, parent, fiber), that.unsafeOnStart(environment5, effect2, parent, fiber)), (value, fiber) => propagationAnd(this.unsafeOnEnd(value, fiber), that.unsafeOnEnd(value, fiber)));
  }
  /**
   * Returns a new supervisor that performs the function of this supervisor,
   * and the function of the specified supervisor, producing a tuple of the
   * outputs produced by both supervisors.
   *
   * The composite supervisor indicates that it has fully handled the
   * supervision event if either component supervisors indicate they have
   * handled the supervision event.
   */
  or(that) {
    return new _Supervisor(zip_4(this.value, that.value), (environment5, effect2, parent, fiber) => propagationOr(this.unsafeOnStart(environment5, effect2, parent, fiber), that.unsafeOnStart(environment5, effect2, parent, fiber)), (value, fiber) => propagationOr(this.unsafeOnEnd(value, fiber), that.unsafeOnEnd(value, fiber)));
  }
};
var Stop = class {
  constructor() {
    this._tag = "Stop";
  }
};
var Continue = class {
  constructor() {
    this._tag = "Continue";
  }
};
var propagationAnd = (self, that) => self._tag === "Continue" && that._tag === "Continue" ? _continue : _stop;
var propagationOr = (self, that) => self._tag === "Continue" || that._tag === "Continue" ? _continue : _stop;
var _stop = /* @__PURE__ */ new Stop();
var _continue = /* @__PURE__ */ new Continue();
var mainFibers = /* @__PURE__ */ new Set();
function unsafeTrackMain() {
  const interval = new AtomicReference(void 0);
  return new Supervisor(succeedWith3(() => mainFibers), (_2, __, ___, fiber) => {
    if (mainFibers.has(fiber)) {
      if (typeof interval.get === "undefined") {
        interval.set(setInterval(() => {
        }, 6e4));
      }
    }
    return _continue;
  }, (_2, fiber) => {
    mainFibers.delete(fiber);
    if (mainFibers.size === 0) {
      const ci = interval.get;
      if (ci) {
        clearInterval(ci);
      }
    }
    return _continue;
  });
}
var trackMainFibers = /* @__PURE__ */ unsafeTrackMain();
var track = /* @__PURE__ */ suspend4(() => fibersIn(new AtomicReference(make7(runtimeOrd()))));
function fibersIn(ref) {
  return succeedWith3(() => new Supervisor(succeedWith3(() => ref.get), (_2, __, ___, fiber) => {
    ref.set(add_2(ref.get, fiber));
    return _continue;
  }, (_2, fiber) => {
    ref.set(remove_3(ref.get, fiber));
    return _continue;
  }));
}
var none2 = /* @__PURE__ */ new Supervisor(unit3, () => _continue, () => _continue);

// node_modules/@effect-ts/system/_mjs/Support/RingBuffer/index.mjs
var RingBuffer = class {
  constructor(size7, ignoreFn) {
    this.size = size7;
    this.ignoreFn = ignoreFn;
    this.values = new DoublyLinkedList();
    this.ignored = 0;
  }
  push(value) {
    if (this.values.length - this.ignored >= this.size) {
      this.values.shift();
    }
    this.values.add(value);
    if (this.ignoreFn && this.ignoreFn(value)) {
      this.ignored++;
    }
    return this.values;
  }
  pop() {
    const popped = this.values.pop();
    if (popped && this.ignoreFn && this.ignoreFn(popped)) {
      this.ignored--;
    }
    return this.values;
  }
  get list() {
    const l2 = emptyPushable();
    this.values.forEach((t2) => {
      push_(l2, t2);
    });
    return l2;
  }
  get listReverse() {
    return reverse2(this.list);
  }
};

// node_modules/@effect-ts/system/_mjs/Support/Scheduler/index.mjs
var isRunning = false;
var tasks = /* @__PURE__ */ new DoublyLinkedList();
var defaultScheduler = (thunk) => {
  tasks.add(thunk);
  if (!isRunning) {
    isRunning = true;
    Promise.resolve().then(() => {
      while (tasks.length > 0) {
        tasks.shift()();
      }
      isRunning = false;
    });
  }
};

// node_modules/@effect-ts/system/_mjs/Fiber/status.mjs
var Done2 = class _Done {
  constructor() {
    this._tag = "Done";
  }
  get [hashSym]() {
    return hashString(this._tag);
  }
  [equalsSym](that) {
    return that instanceof _Done;
  }
};
var Finishing = class _Finishing {
  constructor(interrupting2) {
    this.interrupting = interrupting2;
    this._tag = "Finishing";
  }
  get [hashSym]() {
    return combineHash(hashString(this._tag), hash(this.interrupting));
  }
  [equalsSym](that) {
    return that instanceof _Finishing && this.interrupting === that.interrupting;
  }
};
var Running2 = class _Running {
  constructor(interrupting2) {
    this.interrupting = interrupting2;
    this._tag = "Running";
  }
  get [hashSym]() {
    return combineHash(hashString(this._tag), hash(this.interrupting));
  }
  [equalsSym](that) {
    return that instanceof _Running && this.interrupting === that.interrupting;
  }
};
var Suspended = class _Suspended {
  constructor(previous, interruptible3, epoch, blockingOn) {
    this.previous = previous;
    this.interruptible = interruptible3;
    this.epoch = epoch;
    this.blockingOn = blockingOn;
    this._tag = "Suspended";
  }
  get [hashSym]() {
    return combineHash(combineHash(hashString(this._tag), hashPlainObject({
      previous: this.previous,
      interruptible: this.interruptible,
      epoch: this.epoch
    })), hashArray(this.blockingOn));
  }
  [equalsSym](that) {
    return that instanceof _Suspended && equals(this.previous, that.previous) && this.interruptible === that.interruptible && this.epoch === that.epoch && this.eqArr(this.blockingOn, that.blockingOn);
  }
  eqArr(a2, b2) {
    if (a2.length !== b2.length) {
      return false;
    }
    return a2.every((v2, i2) => equals(v2, b2[i2]));
  }
};
function withInterruptingSafe(b2) {
  return (s2) => {
    return gen3(function* (_2) {
      switch (s2._tag) {
        case "Done": {
          return s2;
        }
        case "Finishing": {
          return new Finishing(b2);
        }
        case "Running": {
          return new Running2(b2);
        }
        case "Suspended": {
          return new Suspended(yield* _2(withInterruptingSafe(b2)(s2.previous)), s2.interruptible, s2.epoch, s2.blockingOn);
        }
      }
    });
  };
}
function withInterrupting(b2) {
  return (s2) => run3(withInterruptingSafe(b2)(s2));
}
function toFinishing(s2) {
  return run3(toFinishingSafe(s2));
}
function toFinishingSafe(s2) {
  return gen3(function* (_2) {
    switch (s2._tag) {
      case "Done": {
        return s2;
      }
      case "Finishing": {
        return s2;
      }
      case "Running": {
        return s2;
      }
      case "Suspended": {
        return yield* _2(toFinishingSafe(s2.previous));
      }
    }
  });
}

// node_modules/@effect-ts/system/_mjs/Fiber/state.mjs
var FiberStateExecuting = class {
  constructor(status, observers, interrupted3) {
    this.status = status;
    this.observers = observers;
    this.interrupted = interrupted3;
    this._tag = "Executing";
  }
};
var FiberStateDone = class {
  constructor(value) {
    this.value = value;
    this._tag = "Done";
    this.interrupted = empty3;
    this.status = new Done2();
  }
};
function initial() {
  return new FiberStateExecuting(new Running2(false), [], empty3);
}
function interrupting(state) {
  let current = state.status;
  while (current) {
    switch (current._tag) {
      case "Running": {
        return current.interrupting;
      }
      case "Finishing": {
        return current.interrupting;
      }
      case "Done": {
        return false;
      }
      case "Suspended": {
        current = current.previous;
      }
    }
  }
  throw new Error("BUG: should never end up here");
}

// node_modules/@effect-ts/system/_mjs/Fiber/context.mjs
var Stack2 = class {
  constructor(value, previous) {
    this.value = value;
    this.previous = previous;
  }
};
var InterruptExit = class {
  constructor(apply, trace3) {
    this.apply = apply;
    this.trace = trace3;
    this._tag = "InterruptExit";
  }
};
var TracingExit = class {
  constructor(apply, trace3) {
    this.apply = apply;
    this.trace = trace3;
    this._tag = "TracingExit";
  }
};
var HandlerFrame = class {
  constructor(apply, trace3) {
    this.apply = apply;
    this.trace = trace3;
    this._tag = "HandlerFrame";
  }
};
var ApplyFrame2 = class {
  constructor(apply, trace3) {
    this.apply = apply;
    this.trace = trace3;
    this._tag = "ApplyFrame";
  }
};
var currentFiber = /* @__PURE__ */ new AtomicReference(null);
var noop = /* @__PURE__ */ some(constVoid);
var FiberContext = class _FiberContext {
  constructor(fiberId3, startEnv, startIStatus, fiberRefLocals, supervisor0, openScope, maxOp, reportFailure, platform, parentTrace, initialTracingStatus) {
    this.fiberId = fiberId3;
    this.startEnv = startEnv;
    this.startIStatus = startIStatus;
    this.fiberRefLocals = fiberRefLocals;
    this.supervisor0 = supervisor0;
    this.openScope = openScope;
    this.maxOp = maxOp;
    this.reportFailure = reportFailure;
    this.platform = platform;
    this.parentTrace = parentTrace;
    this.initialTracingStatus = initialTracingStatus;
    this._tag = "RuntimeFiber";
    this.state = new AtomicReference(initial());
    this.asyncEpoch = 0 | 0;
    this.stack = void 0;
    this.environments = new Stack2(this.startEnv);
    this.interruptStatus = new Stack2(this.startIStatus.toBoolean);
    this.supervisors = new Stack2(this.supervisor0);
    this.forkScopeOverride = void 0;
    this.scopeKey = void 0;
    this.traceStatusEnabled = this.platform.value.traceExecution || this.platform.value.traceStack;
    this.traceStatusStack = this.traceStatusEnabled ? new Stack2(this.initialTracingStatus) : void 0;
    this.executionTraces = this.traceStatusEnabled ? new RingBuffer(this.platform.value.executionTraceLength) : void 0;
    this.stackTraces = this.traceStatusEnabled ? new RingBuffer(this.platform.value.stackTraceLength, (x2) => x2._tag === "NoLocation") : void 0;
    this.interruptExit = new InterruptExit((v2) => {
      if (this.isInterruptible) {
        this.popInterruptStatus();
        return succeed5(v2);
      } else {
        return succeedWith3(() => {
          this.popInterruptStatus();
          return v2;
        });
      }
    });
    this.tracingExit = new TracingExit((v2) => {
      this.popTracingStatus();
      return new ISucceed(v2);
    });
    this.evaluateNow = this.evaluateNow.bind(this);
  }
  get [hashSym]() {
    return hash(this.id);
  }
  [equalsSym](that) {
    return that instanceof _FiberContext && equals(this.id, that.id);
  }
  get poll() {
    return succeedWith3(() => this.poll0());
  }
  addTrace(trace3) {
    if (this.inTracingRegion && trace3) {
      this.executionTraces.push(new SourceLocation(trace3));
    }
  }
  addTraceValue(trace3) {
    if (this.inTracingRegion && trace3._tag === "SourceLocation") {
      this.executionTraces.push(trace3);
    }
  }
  getRef(fiberRef) {
    return succeedWith3(() => this.fiberRefLocals.get(fiberRef) || fiberRef.initial);
  }
  poll0() {
    const state = this.state.get;
    switch (state._tag) {
      case "Executing": {
        return none;
      }
      case "Done": {
        return some(state.value);
      }
    }
  }
  popTracingStatus() {
    var _a12;
    this.traceStatusStack = (_a12 = this.traceStatusStack) === null || _a12 === void 0 ? void 0 : _a12.previous;
  }
  pushTracingStatus(flag) {
    this.traceStatusStack = new Stack2(flag, this.traceStatusStack);
  }
  get isInterruptible() {
    return this.interruptStatus ? this.interruptStatus.value : true;
  }
  get isInterrupted() {
    return !isEmpty4(this.state.get.interrupted);
  }
  get isInterrupting() {
    return interrupting(this.state.get);
  }
  get shouldInterrupt() {
    return this.isInterrupted && this.isInterruptible && !this.isInterrupting;
  }
  get isStackEmpty() {
    return !this.stack;
  }
  get id() {
    return this.fiberId;
  }
  pushContinuation(k2) {
    if (this.platform.value.traceStack && this.inTracingRegion) {
      this.stackTraces.push(traceLocation(k2.trace));
    }
    this.stack = new Stack2(k2, this.stack);
  }
  popStackTrace() {
    this.stackTraces.pop();
  }
  popContinuation() {
    var _a12, _b5;
    const current = (_a12 = this.stack) === null || _a12 === void 0 ? void 0 : _a12.value;
    this.stack = (_b5 = this.stack) === null || _b5 === void 0 ? void 0 : _b5.previous;
    return current;
  }
  pushEnv(k2) {
    this.environments = new Stack2(k2, this.environments);
  }
  popEnv() {
    var _a12, _b5;
    const current = (_a12 = this.environments) === null || _a12 === void 0 ? void 0 : _a12.value;
    this.environments = (_b5 = this.environments) === null || _b5 === void 0 ? void 0 : _b5.previous;
    return current;
  }
  pushInterruptStatus(flag) {
    this.interruptStatus = new Stack2(flag, this.interruptStatus);
  }
  popInterruptStatus() {
    var _a12, _b5;
    const current = (_a12 = this.interruptStatus) === null || _a12 === void 0 ? void 0 : _a12.value;
    this.interruptStatus = (_b5 = this.interruptStatus) === null || _b5 === void 0 ? void 0 : _b5.previous;
    return current;
  }
  runAsync(k2) {
    const v2 = this.register0((xx) => k2(flatten7(xx)));
    if (v2) {
      k2(v2);
    }
  }
  /**
   * Unwinds the stack, looking for the first error handler, and exiting
   * interruptible / uninterruptible regions.
   */
  unwindStack() {
    let unwinding = true;
    let discardedFolds = false;
    while (unwinding && !this.isStackEmpty) {
      const frame = this.popContinuation();
      switch (frame._tag) {
        case "InterruptExit": {
          this.popInterruptStatus();
          break;
        }
        case "TracingExit": {
          this.popTracingStatus();
          break;
        }
        case "Fold": {
          if (this.platform.value.traceStack && this.inTracingRegion) {
            this.popStackTrace();
          }
          if (!this.shouldInterrupt) {
            this.pushContinuation(new HandlerFrame(frame.failure, frame.trace));
            unwinding = false;
          } else {
            discardedFolds = true;
          }
          break;
        }
        default: {
          if (this.platform.value.traceStack && this.inTracingRegion) {
            this.popStackTrace();
          }
        }
      }
    }
    return discardedFolds;
  }
  register0(k2) {
    const oldState = this.state.get;
    switch (oldState._tag) {
      case "Done": {
        return oldState.value;
      }
      case "Executing": {
        const observers = [k2, ...oldState.observers];
        this.state.set(new FiberStateExecuting(oldState.status, observers, oldState.interrupted));
        return null;
      }
    }
  }
  nextInstr(value) {
    if (!this.isStackEmpty) {
      const k2 = this.popContinuation();
      if (this.inTracingRegion && this.platform.value.traceExecution) {
        this.addTrace(k2.trace);
      }
      if (this.platform.value.traceStack && k2._tag !== "InterruptExit" && k2._tag !== "TracingExit") {
        this.popStackTrace();
      }
      return k2.apply(value);
    } else {
      return this.done(succeed4(value));
    }
  }
  notifyObservers(v2, observers) {
    const result4 = succeed4(v2);
    observers.slice(0).reverse().forEach((k2) => k2(result4));
  }
  observe0(k2) {
    const x2 = this.register0(k2);
    if (x2 != null) {
      return some(succeed5(x2));
    }
    return none;
  }
  get await() {
    return effectMaybeAsyncInterruptBlockingOn((k2) => {
      const cb = (x2) => k2(done(x2));
      return fold_(this.observe0(cb), () => left(succeedWith3(() => this.interruptObserver(cb))), right);
    }, [this.fiberId]);
  }
  interruptObserver(k2) {
    const oldState = this.state.get;
    if (oldState._tag === "Executing") {
      const observers = oldState.observers.filter((o2) => o2 !== k2);
      this.state.set(new FiberStateExecuting(oldState.status, observers, oldState.interrupted));
    }
  }
  interruptAs(fiberId3) {
    const interruptedCause = interrupt(fiberId3);
    return suspend4(() => {
      const oldState = this.state.get;
      if (oldState._tag === "Executing" && oldState.status._tag === "Suspended" && oldState.status.interruptible && !interrupting(oldState)) {
        const newCause = combineSeq(oldState.interrupted, interruptedCause);
        this.state.set(new FiberStateExecuting(withInterrupting(true)(oldState.status), oldState.observers, newCause));
        this.evaluateLater(interruptAs(fiberId3));
      } else if (oldState._tag === "Executing") {
        const newCause = combineSeq(oldState.interrupted, interruptedCause);
        this.state.set(new FiberStateExecuting(oldState.status, oldState.observers, newCause));
      }
      return this.await;
    });
  }
  done(v2) {
    const oldState = this.state.get;
    switch (oldState._tag) {
      case "Done": {
        return void 0;
      }
      case "Executing": {
        if (this.openScope.scope.unsafeClosed) {
          this.state.set(new FiberStateDone(v2));
          this.reportUnhandled(v2);
          this.notifyObservers(v2, oldState.observers);
          return void 0;
        } else {
          this.state.set(new FiberStateExecuting(toFinishing(oldState.status), oldState.observers, oldState.interrupted));
          this.setInterrupting(true);
          return chain_12(this.openScope.close(v2), () => done(v2));
        }
      }
    }
  }
  reportUnhandled(exit) {
    if (exit._tag === "Failure") {
      this.reportFailure(exit.cause);
    }
  }
  setInterrupting(value) {
    const oldState = this.state.get;
    switch (oldState._tag) {
      case "Executing": {
        this.state.set(new FiberStateExecuting(withInterrupting(value)(oldState.status), oldState.observers, oldState.interrupted));
        return;
      }
      case "Done": {
        return;
      }
    }
  }
  enterAsync(epoch, blockingOn) {
    const oldState = this.state.get;
    switch (oldState._tag) {
      case "Done": {
        throw new RuntimeError(`Unexpected fiber completion ${this.fiberId}`);
      }
      case "Executing": {
        const newState = new FiberStateExecuting(new Suspended(oldState.status, this.isInterruptible, epoch, blockingOn), oldState.observers, oldState.interrupted);
        this.state.set(newState);
        if (this.shouldInterrupt) {
          this.exitAsync(epoch);
          return halt2(this.state.get.interrupted);
        } else {
          return void 0;
        }
      }
    }
  }
  exitAsync(epoch) {
    const oldState = this.state.get;
    switch (oldState._tag) {
      case "Done": {
        return false;
      }
      case "Executing": {
        if (oldState.status._tag === "Suspended" && epoch === oldState.status.epoch) {
          this.state.set(new FiberStateExecuting(oldState.status.previous, oldState.observers, oldState.interrupted));
          return true;
        } else {
          return false;
        }
      }
    }
  }
  resumeAsync(epoch) {
    return (_2) => {
      if (this.exitAsync(epoch)) {
        this.evaluateLater(_2);
      }
    };
  }
  evaluateLater(i0) {
    defaultScheduler(() => this.evaluateNow(i0));
  }
  get scope() {
    return this.openScope.scope;
  }
  get status() {
    return succeed5(this.state.get.status);
  }
  fork(i0, forkScope2, reportFailure) {
    var _a12, _b5;
    const childFiberRefLocals = /* @__PURE__ */ new Map();
    this.fiberRefLocals.forEach((v2, k2) => {
      childFiberRefLocals.set(k2, k2.fork(v2));
    });
    const parentScope = getOrElse_(forkScope2._tag === "Some" ? forkScope2 : ((_a12 = this.forkScopeOverride) === null || _a12 === void 0 ? void 0 : _a12.value) || none, () => this.scope);
    const currentEnv = ((_b5 = this.environments) === null || _b5 === void 0 ? void 0 : _b5.value) || {};
    const currentSup = this.supervisors.value;
    const childId = newFiberId();
    const childScope = unsafeMakeScope();
    const ancestry = this.inTracingRegion && (this.platform.value.traceExecution || this.platform.value.traceStack) ? some(this.cutAncestryTrace(this.captureTrace())) : none;
    const childContext = new _FiberContext(childId, currentEnv, interruptStatus2(this.isInterruptible), childFiberRefLocals, currentSup, childScope, this.maxOp, getOrElse_(reportFailure, () => this.reportFailure), this.platform, ancestry, this.inTracingRegion);
    if (currentSup !== none2) {
      currentSup.unsafeOnStart(currentEnv, i0, some(this), childContext);
      childContext.onDone((exit) => {
        currentSup.unsafeOnEnd(flatten7(exit), childContext);
      });
    }
    const toExecute = this.parentScopeOp(parentScope, childContext, i0);
    childContext.evaluateLater(toExecute);
    return childContext;
  }
  parentScopeOp(parentScope, childContext, i0) {
    if (parentScope !== globalScope) {
      const exitOrKey = parentScope.unsafeEnsure((exit) => suspend4(() => {
        const _interruptors = exit._tag === "Failure" ? interruptors(exit.cause) : [];
        const head6 = _interruptors[0];
        if (head6) {
          return childContext.interruptAs(head6);
        } else {
          return childContext.interruptAs(this.fiberId);
        }
      }));
      return fold_2(exitOrKey, (exit) => {
        switch (exit._tag) {
          case "Failure": {
            return interruptAs(getOrElse_(head(Array.from(interruptors(exit.cause))), () => this.fiberId));
          }
          case "Success": {
            return interruptAs(this.fiberId);
          }
        }
      }, (key) => {
        childContext.scopeKey = key;
        childContext.onDone(() => {
          parentScope.unsafeDeny(key);
        });
        return i0;
      });
    } else {
      return i0;
    }
  }
  onDone(k2) {
    const oldState = this.state.get;
    switch (oldState._tag) {
      case "Done": {
        k2(succeed4(oldState.value));
        return;
      }
      case "Executing": {
        this.state.set(new FiberStateExecuting(oldState.status, [k2, ...oldState.observers], oldState.interrupted));
      }
    }
  }
  getDescriptor() {
    return new Descriptor(this.fiberId, this.state.get.status, interruptors(this.state.get.interrupted), interruptStatus2(this.isInterruptible), this.scope);
  }
  complete(winner, loser, cont, winnerExit, ab, cb) {
    if (ab.compareAndSet(true, false)) {
      switch (winnerExit._tag) {
        case "Failure": {
          cb(cont(winnerExit, loser));
          break;
        }
        case "Success": {
          cb(chain_12(winner.inheritRefs, () => cont(winnerExit, loser)));
          break;
        }
      }
    }
  }
  get inheritRefs() {
    return suspend4(() => {
      const locals = this.fiberRefLocals;
      if (locals.size === 0) {
        return unit3;
      } else {
        return forEachUnit_(locals, ([fiberRef, value]) => update_4(fiberRef, (old) => fiberRef.join(old, value)));
      }
    });
  }
  get inTracingRegion() {
    return this.traceStatusStack ? this.traceStatusStack.value : this.initialTracingStatus;
  }
  raceWithImpl(race2) {
    const raceIndicator = new AtomicReference(true);
    const left4 = this.fork(race2.left, race2.scope, noop);
    const right5 = this.fork(race2.right, race2.scope, noop);
    return effectAsyncBlockingOn((cb) => {
      const leftRegister = left4.register0((exit) => {
        switch (exit._tag) {
          case "Failure": {
            this.complete(left4, right5, race2.leftWins, exit, raceIndicator, cb);
            break;
          }
          case "Success": {
            this.complete(left4, right5, race2.leftWins, exit.value, raceIndicator, cb);
            break;
          }
        }
      });
      if (leftRegister != null) {
        this.complete(left4, right5, race2.leftWins, leftRegister, raceIndicator, cb);
      } else {
        const rightRegister = right5.register0((exit) => {
          switch (exit._tag) {
            case "Failure": {
              this.complete(right5, left4, race2.rightWins, exit, raceIndicator, cb);
              break;
            }
            case "Success": {
              this.complete(right5, left4, race2.rightWins, exit.value, raceIndicator, cb);
              break;
            }
          }
        });
        if (rightRegister != null) {
          this.complete(right5, left4, race2.rightWins, rightRegister, raceIndicator, cb);
        }
      }
    }, [left4.fiberId, right5.fiberId], race2.trace);
  }
  captureTrace() {
    const exec = this.executionTraces ? this.executionTraces.listReverse : empty2();
    const stack = this.stackTraces ? this.stackTraces.listReverse : empty2();
    return new Trace(this.id, exec, stack, this.parentTrace);
  }
  cutAncestryTrace(trace3) {
    const maxExecLength = this.platform.value.ancestorExecutionTraceLength;
    const maxStackLength = this.platform.value.ancestorStackTraceLength;
    const maxAncestors = this.platform.value.ancestryLength - 1;
    const truncated = truncatedParentTrace(trace3, maxAncestors);
    return new Trace(trace3.fiberId, take_(trace3.executionTrace, maxExecLength), take_(trace3.stackTrace, maxStackLength), truncated);
  }
  evaluateNow(i0) {
    var _a12, _b5;
    try {
      let current = i0;
      currentFiber.set(this);
      while (current != null) {
        try {
          let opCount = 0;
          while (current != null) {
            if (!this.shouldInterrupt) {
              if (opCount === this.maxOp) {
                this.evaluateLater(current);
                current = void 0;
              } else {
                switch (current._tag) {
                  case "FlatMap": {
                    this.pushContinuation(new ApplyFrame2(current.f, current.trace));
                    current = current.val;
                    break;
                  }
                  case "XPure": {
                    const result4 = runEither(provideAll_(current, ((_a12 = this.environments) === null || _a12 === void 0 ? void 0 : _a12.value) || {}));
                    current = result4._tag === "Left" ? new IFail((t2) => traced(fail2(result4.left), t2())) : new ISucceed(result4.right);
                    break;
                  }
                  case "TracingStatus": {
                    if (this.traceStatusStack) {
                      this.pushTracingStatus(current.flag);
                      this.stack = new Stack2(this.tracingExit, this.stack);
                    }
                    current = current.effect;
                    break;
                  }
                  case "CheckTracingStatus": {
                    current = current.f(this.inTracingRegion);
                    break;
                  }
                  case "Trace": {
                    current = this.nextInstr(this.captureTrace());
                    break;
                  }
                  case "Tracer": {
                    current = current.f((trace3) => {
                      if (trace3 && this.platform.value.traceExecution && this.inTracingRegion) {
                        this.addTrace(trace3);
                      }
                    });
                    break;
                  }
                  case "Succeed": {
                    if (current.trace && this.platform.value.traceEffects && this.inTracingRegion) {
                      this.addTrace(current.trace);
                    }
                    current = this.nextInstr(current.val);
                    break;
                  }
                  case "EffectTotal": {
                    if (current.trace && this.platform.value.traceEffects && this.inTracingRegion) {
                      this.addTrace(current.trace);
                    }
                    current = this.nextInstr(current.effect());
                    break;
                  }
                  case "Fail": {
                    if (current.trace && this.platform.value.traceEffects && this.inTracingRegion) {
                      this.addTrace(current.trace);
                    }
                    const fullCause = current.fill(() => this.captureTrace());
                    const discardedFolds = this.unwindStack();
                    const maybeRedactedCause = discardedFolds ? (
                      // We threw away some error handlers while unwinding the stack because
                      // we got interrupted during this instruction. So it's not safe to return
                      // typed failures from cause0, because they might not be typed correctly.
                      // Instead, we strip the typed failures, and return the remainders and
                      // the interruption.
                      stripFailures(fullCause)
                    ) : fullCause;
                    if (this.isStackEmpty) {
                      const cause2 = () => {
                        const interrupted3 = this.state.get.interrupted;
                        const causeAndInterrupt = !contains(interrupted3)(maybeRedactedCause) ? combineSeq(maybeRedactedCause, interrupted3) : maybeRedactedCause;
                        return causeAndInterrupt;
                      };
                      this.setInterrupting(true);
                      current = this.done(halt(cause2()));
                    } else {
                      this.setInterrupting(false);
                      current = this.nextInstr(maybeRedactedCause);
                    }
                    break;
                  }
                  case "Platform": {
                    if (current.trace && this.inTracingRegion && this.platform.value.traceExecution) {
                      this.addTrace(current.trace);
                    }
                    current = current.f(this.platform);
                    break;
                  }
                  case "Fold": {
                    this.pushContinuation(current);
                    current = current.value;
                    break;
                  }
                  case "InterruptStatus": {
                    if (current.trace && this.inTracingRegion && this.platform.value.traceExecution) {
                      this.addTrace(current.trace);
                    }
                    this.pushInterruptStatus(current.flag.toBoolean);
                    this.stack = new Stack2(this.interruptExit, this.stack);
                    current = current.effect;
                    break;
                  }
                  case "CheckInterrupt": {
                    if (current.trace && this.inTracingRegion && this.platform.value.traceExecution) {
                      this.addTrace(current.trace);
                    }
                    current = current.f(interruptStatus2(this.isInterruptible));
                    break;
                  }
                  case "EffectPartial": {
                    const c2 = current;
                    try {
                      if (c2.trace && this.inTracingRegion && this.platform.value.traceEffects) {
                        this.addTrace(c2.trace);
                      }
                      current = this.nextInstr(c2.effect());
                    } catch (e2) {
                      current = fail6(c2.onThrow(e2));
                    }
                    break;
                  }
                  case "EffectAsync": {
                    const epoch = this.asyncEpoch;
                    this.asyncEpoch = epoch + 1;
                    const c2 = current;
                    current = this.enterAsync(epoch, c2.blockingOn);
                    if (!current) {
                      const k2 = c2.register;
                      if (c2.trace && this.platform.value.traceEffects && this.inTracingRegion) {
                        this.addTrace(c2.trace);
                      }
                      const h2 = k2(this.resumeAsync(epoch));
                      switch (h2._tag) {
                        case "None": {
                          current = void 0;
                          break;
                        }
                        case "Some": {
                          if (this.exitAsync(epoch)) {
                            current = h2.value;
                          } else {
                            current = void 0;
                          }
                        }
                      }
                    }
                    break;
                  }
                  case "Fork": {
                    if (current.trace && this.platform.value.traceExecution && this.inTracingRegion) {
                      this.addTrace(current.trace);
                    }
                    current = this.nextInstr(this.fork(current.value, current.scope, current.reportFailure));
                    break;
                  }
                  case "Descriptor": {
                    if (current.trace && this.platform.value.traceExecution && this.inTracingRegion) {
                      this.addTrace(current.trace);
                    }
                    current = current.f(this.getDescriptor());
                    break;
                  }
                  case "Yield": {
                    current = void 0;
                    this.evaluateLater(unit3);
                    break;
                  }
                  case "Read": {
                    if (current.trace && this.platform.value.traceExecution && this.inTracingRegion) {
                      this.addTrace(current.trace);
                    }
                    current = current.f(this.environments ? this.environments.value : {});
                    break;
                  }
                  case "Provide": {
                    if (current.trace && this.platform.value.traceExecution && this.inTracingRegion) {
                      this.addTrace(current.trace);
                    }
                    const c2 = current;
                    current = bracket_(succeedWith3(() => {
                      this.pushEnv(c2.r);
                    }), () => c2.next, () => succeedWith3(() => {
                      this.popEnv();
                    }));
                    break;
                  }
                  case "Suspend": {
                    if (current.trace && this.platform.value.traceExecution && this.inTracingRegion) {
                      this.addTrace(current.trace);
                    }
                    current = current.factory(this.platform, this.fiberId);
                    break;
                  }
                  case "SuspendPartial": {
                    const c2 = current;
                    try {
                      if (current.trace && this.platform.value.traceExecution && this.inTracingRegion) {
                        this.addTrace(current.trace);
                      }
                      current = c2.factory(this.platform, this.fiberId);
                    } catch (e2) {
                      current = fail6(c2.onThrow(e2));
                    }
                    break;
                  }
                  case "FiberRefNew": {
                    const fiberRef = new Runtime2(current.initial, current.onFork, current.onJoin);
                    this.fiberRefLocals.set(fiberRef, current.initial);
                    current = this.nextInstr(fiberRef);
                    break;
                  }
                  case "FiberRefModify": {
                    const c2 = current;
                    const oldValue = fromNullable(this.fiberRefLocals.get(c2.fiberRef));
                    if (current.trace && this.platform.value.traceExecution && this.inTracingRegion) {
                      this.addTrace(current.trace);
                    }
                    const {
                      tuple: [result4, newValue]
                    } = current.f(getOrElse_(oldValue, () => c2.fiberRef.initial));
                    this.fiberRefLocals.set(c2.fiberRef, newValue);
                    current = this.nextInstr(result4);
                    break;
                  }
                  case "RaceWith": {
                    current = this.raceWithImpl(current);
                    break;
                  }
                  case "Supervise": {
                    if (current.trace && this.platform.value.traceExecution && this.inTracingRegion) {
                      this.addTrace(current.trace);
                    }
                    const c2 = current;
                    const lastSupervisor = this.supervisors.value;
                    const newSupervisor = c2.supervisor.and(lastSupervisor);
                    const push = succeedWith3(() => {
                      this.supervisors = new Stack2(newSupervisor, this.supervisors);
                    });
                    const pop = succeedWith3(() => {
                      this.supervisors = this.supervisors.previous;
                    });
                    current = bracket_(push, () => c2.effect, () => pop);
                    break;
                  }
                  case "GetForkScope": {
                    const c2 = current;
                    if (current.trace && this.platform.value.traceExecution && this.inTracingRegion) {
                      this.addTrace(current.trace);
                    }
                    current = c2.f(getOrElse_(((_b5 = this.forkScopeOverride) === null || _b5 === void 0 ? void 0 : _b5.value) || none, () => this.scope));
                    break;
                  }
                  case "OverrideForkScope": {
                    const c2 = current;
                    if (current.trace && this.platform.value.traceExecution && this.inTracingRegion) {
                      this.addTrace(current.trace);
                    }
                    const push = succeedWith3(() => {
                      this.forkScopeOverride = new Stack2(c2.forkScope, this.forkScopeOverride);
                    });
                    const pop = succeedWith3(() => {
                      var _a13;
                      this.forkScopeOverride = (_a13 = this.forkScopeOverride) === null || _a13 === void 0 ? void 0 : _a13.previous;
                    });
                    current = bracket_(push, () => c2.effect, () => pop);
                    break;
                  }
                  default: {
                    throw new RuntimeError(`operation not supported: ${JSON.stringify(current)}`);
                  }
                }
              }
            } else {
              current = halt2(this.state.get.interrupted);
              this.setInterrupting(true);
            }
            opCount += 1;
          }
        } catch (e2) {
          this.setInterrupting(true);
          current = die3(e2);
        }
      }
    } finally {
      currentFiber.set(null);
    }
  }
};

// node_modules/@effect-ts/system/_mjs/FiberRef/set.mjs
function set_3(fiberRef, a2) {
  return fiberRef.set(a2);
}

// node_modules/@effect-ts/system/_mjs/Fiber/fiberName.mjs
var fiberName = /* @__PURE__ */ new Runtime2(none, identity, identity);

// node_modules/@effect-ts/system/_mjs/Fiber/platform.mjs
var Platform = class {
  constructor(value) {
    this.value = value;
  }
};

// node_modules/@effect-ts/system/_mjs/Effect/ensuringChildren.mjs
function ensuringChildren(children, __trace) {
  return (fa) => ensuringChildren_(fa, children, __trace);
}
function ensuringChildren_(fa, children, __trace) {
  return chain_12(track, (s2) => ensuring_(supervised_(fa, s2), chain_12(s2.value, children), __trace));
}
function ensuringChild_(fa, f2, __trace) {
  return ensuringChildren_(fa, (x2) => f2(collectAll3(x2)), __trace);
}
function ensuringChild(f2, __trace) {
  return (fa) => ensuringChild_(fa, f2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/awaitAllChildren.mjs
function awaitAllChildren(fa, __trace) {
  return ensuringChildren_(fa, waitAll, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/bimap.mjs
function bimap4(f2, g2, __trace) {
  return (self) => bimap_3(self, f2, g2, __trace);
}
function bimap_3(self, f2, g2, __trace) {
  return foldM_2(self, (e2) => fail6(f2(e2)), (a2) => succeed5(g2(a2)), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/bindAll.mjs
function bindAll(r2, __trace) {
  return (s2) => bindAll_(s2, r2, __trace);
}
function bindAll_(s2, r2, __trace) {
  return chain_12(s2, (k2) => map_13(forEach_5(collect_(r2(k2), (k3, v2) => [k3, v2]), ([_2, e2]) => map_13(e2, (a2) => [_2, a2])), (values3) => {
    const res = {};
    for (const [k3, v2] of values3) {
      res[k3] = v2;
    }
    return Object.assign(res, k2);
  }), __trace);
}
function bindAllPar(r2, __trace) {
  return (s2) => bindAllPar_(s2, r2, __trace);
}
function bindAllPar_(s2, r2, __trace) {
  return chain_12(s2, (k2) => map_13(forEachPar_(collect_(r2(k2), (k3, v2) => [k3, v2]), ([_2, e2]) => map_13(e2, (a2) => [_2, a2])), (values3) => {
    const res = {};
    for (const [k3, v2] of values3) {
      res[k3] = v2;
    }
    return Object.assign(res, k2);
  }), __trace);
}
function bindAllParN(n2, r2, __trace) {
  return (s2) => bindAllParN_(s2, n2, r2, __trace);
}
function bindAllParN_(s2, n2, r2, __trace) {
  return chain_12(s2, (k2) => map_13(forEachParN_(collect_(r2(k2), (k3, v2) => [k3, v2]), n2, ([_2, e2]) => map_13(e2, (a2) => [_2, a2])), (values3) => {
    const res = {};
    for (const [k3, v2] of values3) {
      res[k3] = v2;
    }
    return Object.assign(res, k2);
  }), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/bracketFiber.mjs
function bracketFiber_(effect2, use2, __trace) {
  return bracket_(forkDaemon(effect2), (f2) => chain_12(fiberId, f2.interruptAs), use2, __trace);
}
function bracketFiber(use2, __trace) {
  return (effect2) => bracketFiber_(effect2, use2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/bracketOnError.mjs
function bracketOnError(use2, release4, __trace) {
  return (acquire) => bracketOnError_(acquire, use2, release4, __trace);
}
function bracketOnError_(acquire, use2, release4, __trace) {
  return bracketExit_(acquire, use2, (a2, e2) => e2._tag === "Success" ? unit3 : release4(a2, e2), __trace);
}

// node_modules/@effect-ts/system/_mjs/Tracing/Global/index.mjs
var _tracing = false;
function isTracingEnabled() {
  return _tracing;
}

// node_modules/@effect-ts/system/_mjs/Tracing/index.mjs
var currentTraceCall;
function accessCallTrace() {
  if (!isTracingEnabled() || !currentTraceCall) {
    return void 0;
  }
  const callTrace = currentTraceCall;
  currentTraceCall = void 0;
  return callTrace;
}

// node_modules/@effect-ts/system/_mjs/Effect/has.mjs
function accessServicesM(s2) {
  return (f2, __trace) => accessM3((r2) => f2(map_10(s2, (v2) => r2[v2.key])), __trace);
}
function accessServicesTM(...s2) {
  return (f2, __trace) => accessM3((r2) => f2(...map_2(s2, (v2) => r2[v2.key])), __trace);
}
function accessServicesT(...s2) {
  return (f2, __trace) => access3((r2) => f2(...map_2(s2, (v2) => r2[v2.key])), __trace);
}
function accessServices(s2) {
  return (f2, __trace) => access3((r2) => f2(map_10(s2, (v2) => r2[v2.key])), __trace);
}
function accessServiceM2(s2) {
  return (f2, __trace) => accessM3((r2) => f2(r2[s2.key]), __trace);
}
function accessService2(s2) {
  return (f2, __trace) => accessServiceM2(s2)((a2) => succeed5(f2(a2)), __trace);
}
function service(s2, __trace) {
  return accessServiceM2(s2)(succeed5, __trace);
}
function services(...s2) {
  return access3((r2) => s2.map((tag2) => tag2.read(r2)), accessCallTrace());
}
function provideServiceM(_2) {
  return (service4, __trace) => (ma) => accessM3((r2) => chain_12(service4, (t2) => provideAll_3(ma, mergeEnvironments(_2, r2, t2), __trace)));
}
function provideServiceM_(ma, _2, service4, __trace) {
  return accessM3((r2) => chain_12(service4, (t2) => provideAll_3(ma, mergeEnvironments(_2, r2, t2), __trace)));
}
function provideService(_2) {
  return (service4, __trace) => (ma) => provideServiceM(_2)(succeed5(service4), __trace)(ma);
}
function provideService_(ma, _2, service4, __trace) {
  return provideServiceM(_2)(succeed5(service4), __trace)(ma);
}
function replaceServiceM(_2, f2, __trace) {
  return (ma) => accessServiceM2(_2)((t2) => provideServiceM(_2)(f2(t2), __trace)(ma));
}
function replaceServiceM_(ma, _2, f2, __trace) {
  return accessServiceM2(_2)((t2) => provideServiceM(_2)(f2(t2), __trace)(ma));
}
function replaceService(_2, f2, __trace) {
  return (ma) => replaceService_(ma, _2, f2, __trace);
}
function replaceService_(ma, _2, f2, __trace) {
  return accessServiceM2(_2)((t2) => provideServiceM(_2)(succeedWith3(() => f2(t2)), __trace)(ma));
}

// node_modules/@effect-ts/system/_mjs/Clock/id.mjs
var ClockId = /* @__PURE__ */ Symbol.for("@effect-ts/system/Clock");

// node_modules/@effect-ts/system/_mjs/Clock/index.mjs
var Clock = class {
  constructor() {
    this.serviceId = ClockId;
  }
};
var HasClock = /* @__PURE__ */ tag(ClockId);
var LiveClock = class extends Clock {
  constructor() {
    super(...arguments);
    this.currentTime = succeedWith3(() => (/* @__PURE__ */ new Date()).getTime());
    this.sleep = (ms, trace3) => effectAsyncInterrupt((cb) => {
      const timeout4 = setTimeout(() => {
        cb(unit3);
      }, ms);
      return succeedWith3(() => {
        clearTimeout(timeout4);
      });
    }, trace3);
  }
};
var currentTime = /* @__PURE__ */ accessServiceM2(HasClock)((_2) => _2.currentTime);
function sleep(ms, __trace) {
  return accessServiceM2(HasClock)((_2) => _2.sleep(ms, __trace));
}
var TestClock = class extends Clock {
  constructor() {
    super(...arguments);
    this.time = (/* @__PURE__ */ new Date()).getTime();
    this.currentTime = succeedWith3(() => this.time);
    this.sleep = () => unit3;
    this.advance = (ms) => succeedWith3(() => {
      this.time = this.time + ms;
    });
  }
};
TestClock.advance = (ms) => accessServiceM2(HasTestClock)((_2) => _2.advance(ms));
var HasTestClock = /* @__PURE__ */ tag(ClockId);

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/filterEffect.mjs
function filterEffect_(self, f2) {
  return suspend4(() => {
    const iterator = self.arrayLikeIterator();
    let next2;
    let dest = succeed5(empty4());
    while ((next2 = iterator.next()) && !next2.done) {
      const array2 = next2.value;
      const len = array2.length;
      let i2 = 0;
      while (i2 < len) {
        const a2 = array2[i2];
        dest = zipWith_4(dest, f2(a2), (d2, b2) => b2 ? append_4(d2, a2) : d2);
        i2++;
      }
    }
    return dest;
  });
}
function filterEffect(f2) {
  return (self) => filterEffect_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/mapEffect.mjs
function mapEffect_(self, f2) {
  return forEach_5(self, f2);
}
function mapEffect(f2) {
  return (self) => mapEffect_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Effect/filter.mjs
function filter3(f2, __trace) {
  return (as6) => filter_5(as6, f2, __trace);
}
function filter_5(as6, f2, __trace) {
  return suspend4(() => reduce_3(as6, succeedWith3(() => []), (io, a2) => zipWith_4(io, suspend4(() => f2(a2)), (as_5, p2) => {
    if (p2) {
      as_5.push(a2);
    }
    return as_5;
  })), __trace);
}
function filterPar_(as6, f2, __trace) {
  return map_13(forEachPar_(as6, (a2) => map_13(f2(a2), (b2) => b2 ? some(a2) : none), __trace), compact3);
}
function filterPar(f2, __trace) {
  return (as6) => filterPar_(as6, f2, __trace);
}
function filterParN_(as6, n2, f2, __trace) {
  return map_13(forEachParN_(as6, n2, (a2) => map_13(f2(a2), (b2) => b2 ? some(a2) : none), __trace), compact3);
}
function filterParN(n2, f2, __trace) {
  return (as6) => filterParN_(as6, n2, f2, __trace);
}
function filterNot(f2, __trace) {
  return (as6) => filterNot_(as6, f2, __trace);
}
function filterNot_(as6, f2, __trace) {
  return filter_5(as6, (x2) => map_13(f2(x2), (b2) => !b2), __trace);
}
function filterNotPar_(as6, f2, __trace) {
  return filterPar_(as6, (x2) => map_13(f2(x2), (b2) => !b2), __trace);
}
function filterNotPar(f2, __trace) {
  return (as6) => filterNotPar_(as6, f2, __trace);
}
function filterNotParN_(as6, n2, f2, __trace) {
  return filterParN_(as6, n2, (x2) => map_13(f2(x2), (b2) => !b2), __trace);
}
function filterNotParN(n2, f2, __trace) {
  return (as6) => filterNotParN_(as6, n2, f2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Schedule/Driver/index.mjs
var Driver = class {
  constructor(next2, last4, reset) {
    this.next = next2;
    this.last = last4;
    this.reset = reset;
  }
};

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/NonEmptyArray/index.mjs
function head3(nea) {
  return nea[0];
}
function tail3(nea) {
  return nea.slice(1);
}
var map_15 = map_2;

// node_modules/@effect-ts/system/_mjs/Random/index.mjs
var RandomId = /* @__PURE__ */ Symbol.for("@effect-ts/system/Random");
var Random = class {
  constructor() {
    this.serviceId = RandomId;
  }
};
var LiveRandom = class extends Random {
  constructor(seed) {
    super();
    this.next = succeedWith3(() => this.PRNG.number());
    this.nextBoolean = chain_12(this.next, (n2) => succeedWith3(() => n2 > 0.5));
    this.nextInt = succeedWith3(() => this.PRNG.integer(0));
    this.nextRange = (low, high) => chain_12(this.next, (n2) => succeedWith3(() => (high - low) * n2 + low));
    this.nextIntBetween = (low, high) => succeedWith3(() => this.PRNG.integer(1 + high - low) + low);
    this.PRNG = new PCGRandom(seed);
  }
};
var defaultRandom = /* @__PURE__ */ new LiveRandom(/* @__PURE__ */ Math.random() * 4294967296 >>> 0);
var HasRandom = /* @__PURE__ */ tag(RandomId);

// node_modules/@effect-ts/system/_mjs/Effect/sleep.mjs
function sleep2(ms, __trace) {
  return sleep(ms, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/delay.mjs
function delay(ms, __trace) {
  return (effect2) => delay_(effect2, ms, __trace);
}
function delay_(effect2, ms, __trace) {
  return chain_12(sleep2(ms, __trace), () => effect2);
}

// node_modules/@effect-ts/system/_mjs/Effect/orElse.mjs
function orElse_2(self, that, __trace) {
  return tryOrElse_(self, that, succeed5, __trace);
}
function orElse2(that, __trace) {
  return (self) => orElse_2(self, that, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/race.mjs
function race_(self, that, __trace) {
  return descriptorWith((descriptor3) => {
    const parentFiberId = descriptor3.id;
    const maybeDisconnect = (io) => uninterruptibleMask((interruptible3) => interruptible3.force(io));
    return raceWith_(maybeDisconnect(self), maybeDisconnect(that), (exit, right5) => foldM_3(exit, (cause2) => mapErrorCause_(join(right5), (_2) => combinePar(cause2, _2)), (a2) => as_(right5.interruptAs(parentFiberId), a2)), (exit, left4) => foldM_3(exit, (cause2) => mapErrorCause_(join(left4), (_2) => combinePar(_2, cause2)), (a2) => as_(left4.interruptAs(parentFiberId), a2)), __trace);
  });
}
function race(that, __trace) {
  return (self) => race_(self, that, __trace);
}
function raceEither_(self, that, __trace) {
  return race_(map_13(self, left), map_13(that, right), __trace);
}
function raceEither(that, __trace) {
  return (self) => raceEither_(self, that, __trace);
}
function raceFirst_(self, that, __trace) {
  return chain_12(race_(result(self), result(that), __trace), (a2) => done(a2));
}
function raceFirst(that, __trace) {
  return (self) => raceFirst_(self, that, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/tapBoth.mjs
function tapBoth(f2, g2, __trace) {
  return (self) => tapBoth_(self, f2, g2, __trace);
}
function tapBoth_(self, f2, g2, __trace) {
  return foldCauseM_(self, (c2) => fold_2(failureOrCause(c2), (e2) => chain_12(f2(e2), () => halt2(c2)), (_2) => halt2(c2)), (a2) => map_13(g2(a2), () => a2), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/tapError.mjs
function tapError_(self, f2, __trace) {
  return foldCauseM_(self, (c2) => fold_2(failureOrCause(c2), (e2) => chain_12(f2(e2), () => halt2(c2)), (_2) => halt2(c2)), succeed5, __trace);
}
function tapError(f2, __trace) {
  return (self) => tapError_(self, f2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Schedule/Decision/index.mjs
var Done3 = class {
  constructor(out) {
    this.out = out;
    this._tag = "Done";
  }
};
var Continue2 = class {
  constructor(out, interval, next2) {
    this.out = out;
    this.interval = interval;
    this.next = next2;
    this._tag = "Continue";
  }
};
function makeDone(o2) {
  return new Done3(o2);
}
function makeContinue(out, interval, next2) {
  return new Continue2(out, interval, next2);
}
function toDone(self) {
  switch (self._tag) {
    case "Done": {
      return self;
    }
    case "Continue": {
      return new Done3(self.out);
    }
  }
}
function done2(a2) {
  return () => succeed5(new Done3(a2));
}

// node_modules/@effect-ts/system/_mjs/Schedule/schedule.mjs
var Schedule = class {
  constructor(step2) {
    this.step = step2;
    this["&&"] = (that) => intersection_(this, that);
    this["***"] = (that) => bothInOut_(this, that);
    this["*>"] = (that) => map_16(this["&&"](that), (_2) => _2.get(1));
    this["+++"] = (that) => chooseMerge_(this, that);
    this["++"] = (that) => andThen_2(this, that);
    this["<*"] = (that) => map_16(this["&&"](that), (_2) => _2.get(0));
    this["<*>"] = (that) => zip_8(this, that);
    this["<<<"] = (that) => compose_(that, this);
    this[">>>"] = (that) => compose_(this, that);
    this["||"] = (that) => union_2(this, that);
    this["|||"] = (that) => chooseMerge_(this, that);
    this["<||>"] = (that) => andThenEither_(this, that);
  }
};
function driver(self) {
  return map_13(makeRef([none, self.step]), (ref) => {
    const reset = ref.set([none, self.step]);
    const last4 = chain_12(ref.get, ([o2, _2]) => fold_(o2, () => fail6(new NoSuchElementException()), (b2) => succeed5(b2)));
    const next2 = (i2) => map_13(bind_(bind_(bind_(bind_(do_2, "step", () => map_13(ref.get, ([_2, o2]) => o2)), "now", () => currentTime), "dec", ({
      now,
      step: step2
    }) => step2(now, i2)), "v", ({
      dec,
      now
    }) => {
      switch (dec._tag) {
        case "Done": {
          return chain_12(ref.set([some(dec.out), done2(dec.out)]), () => fail6(none));
        }
        case "Continue": {
          return map_13(chain_12(map_13(ref.set([some(dec.out), dec.next]), () => dec.interval - now), (s2) => s2 > 0 ? sleep2(s2) : unit3), () => dec.out);
        }
      }
    }), ({
      v: v2
    }) => v2);
    return new Driver(next2, last4, reset);
  });
}
function addDelay_(self, f2) {
  return addDelayM_(self, (b2) => succeed5(f2(b2)));
}
function addDelayM_(self, f2) {
  return modifyDelayM_(self, (o2, d2) => map_13(f2(o2), (i2) => i2 + d2));
}
function andThen_2(self, that) {
  return map_16(andThenEither_(self, that), (a2) => a2._tag === "Left" ? a2.left : a2.right);
}
function bothLoop(self, that) {
  return (now, t2) => {
    const {
      tuple: [in1, in2]
    } = t2;
    return zipWith_4(self(now, in1), that(now, in2), (d1, d2) => {
      switch (d1._tag) {
        case "Done": {
          switch (d2._tag) {
            case "Done": {
              return makeDone(tuple2(d1.out, d2.out));
            }
            case "Continue": {
              return makeDone(tuple2(d1.out, d2.out));
            }
          }
        }
        case "Continue": {
          switch (d2._tag) {
            case "Done": {
              return makeDone(tuple2(d1.out, d2.out));
            }
            case "Continue": {
              return makeContinue(tuple2(d1.out, d2.out), Math.min(d1.interval, d2.interval), bothLoop(d1.next, d2.next));
            }
          }
        }
      }
    });
  };
}
function bothInOut_(self, that) {
  return new Schedule(bothLoop(self.step, that.step));
}
function intersection_(self, that) {
  return intersectWith_(self, that, (l2, r2) => Math.max(l2, r2));
}
function andThenEitherLoop(self, that, onLeft2) {
  return (now, i2) => {
    if (onLeft2) {
      return chain_12(self(now, i2), (d2) => {
        switch (d2._tag) {
          case "Continue": {
            return succeed5(makeContinue(left(d2.out), d2.interval, andThenEitherLoop(d2.next, that, true)));
          }
          case "Done": {
            return andThenEitherLoop(self, that, false)(now, i2);
          }
        }
      });
    } else {
      return map_13(that(now, i2), (d2) => {
        switch (d2._tag) {
          case "Done": {
            return makeDone(right(d2.out));
          }
          case "Continue": {
            return makeContinue(right(d2.out), d2.interval, andThenEitherLoop(self, d2.next, false));
          }
        }
      });
    }
  };
}
function andThenEither_(self, that) {
  return new Schedule(andThenEitherLoop(self.step, that.step, true));
}
function chooseLoop(self, that) {
  return (now, either5) => fold_2(either5, (i2) => map_13(self(now, i2), (d2) => {
    switch (d2._tag) {
      case "Done": {
        return makeDone(left(d2.out));
      }
      case "Continue": {
        return makeContinue(left(d2.out), d2.interval, chooseLoop(d2.next, that));
      }
    }
  }), (i2) => map_13(that(now, i2), (d2) => {
    switch (d2._tag) {
      case "Done": {
        return makeDone(right(d2.out));
      }
      case "Continue": {
        return makeContinue(right(d2.out), d2.interval, chooseLoop(self, d2.next));
      }
    }
  }));
}
function choose_(self, that) {
  return new Schedule(chooseLoop(self.step, that.step));
}
function chooseMerge_(self, that) {
  return map_16(choose_(self, that), merge);
}
function composeLoop(self, that) {
  return (now, i2) => chain_12(self(now, i2), (d2) => {
    switch (d2._tag) {
      case "Done": {
        return map_13(that(now, d2.out), toDone);
      }
      case "Continue": {
        return map_13(that(now, d2.out), (d22) => {
          switch (d22._tag) {
            case "Done": {
              return makeDone(d22.out);
            }
            case "Continue": {
              return makeContinue(d22.out, Math.max(d2.interval, d22.interval), composeLoop(d2.next, d22.next));
            }
          }
        });
      }
    }
  });
}
function compose_(self, that) {
  return new Schedule(composeLoop(self.step, that.step));
}
function intersectWithLoop(self, that, f2) {
  return (now, i2) => {
    const left4 = self(now, i2);
    const right5 = that(now, i2);
    return zipWith_4(left4, right5, (l2, r2) => {
      switch (l2._tag) {
        case "Done": {
          switch (r2._tag) {
            case "Done": {
              return makeDone(tuple2(l2.out, r2.out));
            }
            case "Continue": {
              return makeDone(tuple2(l2.out, r2.out));
            }
          }
        }
        case "Continue": {
          switch (r2._tag) {
            case "Done": {
              return makeDone(tuple2(l2.out, r2.out));
            }
            case "Continue": {
              return makeContinue(tuple2(l2.out, r2.out), f2(l2.interval, r2.interval), intersectWithLoop(l2.next, r2.next, f2));
            }
          }
        }
      }
    });
  };
}
function union_2(self, that) {
  return unionWith_(self, that, (d1, d2) => Math.min(d1, d2));
}
function unionWithLoop(self, that, f2) {
  return (now, inp) => {
    const left4 = self(now, inp);
    const right5 = that(now, inp);
    return zipWith_4(left4, right5, (l2, r2) => {
      switch (l2._tag) {
        case "Done": {
          switch (r2._tag) {
            case "Done": {
              return makeDone(tuple2(l2.out, r2.out));
            }
            case "Continue": {
              return makeContinue(tuple2(l2.out, r2.out), r2.interval, unionWithLoop(() => succeed5(l2), r2.next, f2));
            }
          }
        }
        case "Continue": {
          switch (r2._tag) {
            case "Done": {
              return makeContinue(tuple2(l2.out, r2.out), l2.interval, unionWithLoop(l2.next, () => succeed5(r2), f2));
            }
            case "Continue": {
              return makeContinue(tuple2(l2.out, r2.out), f2(l2.interval, r2.interval), unionWithLoop(l2.next, r2.next, f2));
            }
          }
        }
      }
    });
  };
}
function unionWith_(self, that, f2) {
  return new Schedule(unionWithLoop(self.step, that.step, f2));
}
function fixed(interval) {
  function loop6(startMillis, n2) {
    return (now, _2) => succeed5(fold_(startMillis, () => makeContinue(n2 + 1, now + interval, loop6(some({
      startMillis: now,
      lastRun: now + interval
    }), n2 + 1)), ({
      lastRun,
      startMillis: startMillis2
    }) => {
      const runningBehind = now > lastRun + interval;
      const boundary = interval === 0 ? interval : interval - (now - startMillis2) % interval;
      const sleepTime = boundary === 0 ? interval : boundary;
      const nextRun = runningBehind ? now : now + sleepTime;
      return makeContinue(n2 + 1, nextRun, loop6(some({
        startMillis: startMillis2,
        lastRun: nextRun
      }), n2 + 1));
    }));
  }
  return new Schedule(loop6(none, 0));
}
var forever = /* @__PURE__ */ unfold_(0, (n2) => n2 + 1);
function intersectWith_(self, that, f2) {
  return new Schedule(intersectWithLoop(self.step, that.step, f2));
}
function mapMLoop(f2, self) {
  return (now, i2) => chain_12(self(now, i2), (d2) => {
    switch (d2._tag) {
      case "Done": {
        return map_13(f2(d2.out), (o2) => makeDone(o2));
      }
      case "Continue": {
        return map_13(f2(d2.out), (o2) => makeContinue(o2, d2.interval, mapMLoop(f2, d2.next)));
      }
    }
  });
}
function map_16(self, f2) {
  return mapM_2(self, (o2) => succeed5(f2(o2)));
}
function mapM_2(self, f2) {
  return new Schedule(mapMLoop(f2, self.step));
}
function modifyDelayMLoop(f2, self) {
  return (now, i2) => chain_12(self(now, i2), (d2) => {
    switch (d2._tag) {
      case "Done": {
        return succeed5(makeDone(d2.out));
      }
      case "Continue": {
        const delay2 = d2.interval - now;
        return map_13(f2(d2.out, delay2), (n2) => makeContinue(d2.out, d2.interval + n2, modifyDelayMLoop(f2, d2.next)));
      }
    }
  });
}
function modifyDelayM_(self, f2) {
  return new Schedule(modifyDelayMLoop(f2, self.step));
}
function spaced(duration) {
  return addDelay_(forever, () => duration);
}
function unfoldLoop(a2, f2) {
  return (now, _2) => succeed5(makeContinue(a2, now, unfoldLoop(f2(a2), f2)));
}
function unfold_(a2, f2) {
  return new Schedule((now) => succeedWith3(() => makeContinue(a2, now, unfoldLoop(f2(a2), f2))));
}
function zip_8(self, that) {
  return intersectWith_(self, that, (d2, d22) => Math.max(d2, d22));
}

// node_modules/@effect-ts/system/_mjs/Effect/orDieWith.mjs
function orDieWith(f2, __trace) {
  return (effect2) => orDieWith_(effect2, f2, __trace);
}
function orDieWith_(effect2, f2, __trace) {
  return foldM_2(effect2, (e2) => die3(f2(e2)), succeed5, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/orDie.mjs
function orDie(effect2, __trace) {
  return orDieWith_(effect2, (e2) => e2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/repeat.mjs
function repeatOrElseEither_(self, schedule2, orElse6, __trace) {
  return chain8((driver2) => {
    function loop6(a2) {
      return foldM2(() => map_13(orDie(driver2.last), right), (b2) => foldM2((e2) => map_13(orElse6(e2, some(b2)), left), (a3) => loop6(a3))(self))(driver2.next(a2));
    }
    return foldM2((e2) => map_13(orElse6(e2, none), left), (a2) => loop6(a2), __trace)(self);
  })(driver(schedule2));
}
function repeatOrElseEither(schedule2, orElse6, __trace) {
  return (self) => repeatOrElseEither_(self, schedule2, orElse6, __trace);
}
function repeatOrElse_(self, schedule2, orElse6, __trace) {
  return map_13(repeatOrElseEither_(self, schedule2, orElse6, __trace), merge);
}
function repeatOrElse(schedule2, orElse6, __trace) {
  return (self) => repeatOrElse_(self, schedule2, orElse6, __trace);
}
function repeat_(self, schedule2, __trace) {
  return repeatOrElse_(self, schedule2, (e2) => fail6(e2), __trace);
}
function repeat(schedule2, __trace) {
  return (self) => repeat_(self, schedule2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Queue/api.mjs
function makeSliding(capacity) {
  return chain_12(succeedWith3(() => new Bounded(capacity)), createQueue(new SlidingStrategy()));
}
function makeUnbounded() {
  return chain_12(succeedWith3(() => new Unbounded()), createQueue(new DroppingStrategy()));
}
function makeDropping(capacity) {
  return chain_12(succeedWith3(() => new Bounded(capacity)), createQueue(new DroppingStrategy()));
}
function takeRemainderLoop(self, n2) {
  ;
  if (n2 <= 0) {
    return succeed5(empty4());
  } else {
    return chain_12(self.take, (a2) => map_13(takeRemainderLoop(self, n2 - 1), (_2) => append_4(_2, a2)));
  }
}
function takeBetween_(self, min2, max2) {
  ;
  if (max2 < min2) {
    return succeed5(empty4());
  } else {
    return chain_12(self.takeUpTo(max2), (bs) => {
      const remaining = min2 - size4(bs);
      if (remaining === 1) {
        return map_13(self.take, (b2) => append_4(bs, b2));
      } else if (remaining > 1) {
        return map_13(takeRemainderLoop(self, remaining), (list2) => concat_3(bs, list2));
      } else {
        return succeed5(bs);
      }
    });
  }
}
function dimapM_(self, f2, g2) {
  ;
  return new DimapM(self, f2, g2);
}
var DimapM = class extends XQueueInternal {
  constructor(self, f2, g2) {
    super();
    this.self = self;
    this.f = f2;
    this.g = g2;
    this.awaitShutdown = this.self.awaitShutdown;
    this.capacity = this.self.capacity;
    this.isShutdown = this.self.isShutdown;
    this.shutdown = this.self.shutdown;
    this.size = this.self.size;
    this.take = chain_12(this.self.take, this.g);
    this.takeAll = chain_12(this.self.takeAll, (a2) => mapEffect_(a2, this.g));
  }
  offer(a2) {
    return chain_12(this.f(a2), (a3) => this.self.offer(a3));
  }
  offerAll(as6) {
    return chain_12(forEach_5(as6, this.f), (as7) => this.self.offerAll(as7));
  }
  takeUpTo(n2) {
    return chain_12(this.self.takeUpTo(n2), (bs) => mapEffect_(bs, this.g));
  }
};
function map_17(self, f2) {
  return mapM_3(self, (_2) => succeed5(f2(_2)));
}
function mapM_3(self, f2) {
  return dimapM_(self, (a2) => succeed5(a2), f2);
}

// node_modules/@effect-ts/system/_mjs/Support/ImmutableQueue/index.mjs
var ImmutableQueue = class _ImmutableQueue {
  constructor(backing) {
    this.backing = backing;
  }
  push(a2) {
    return new _ImmutableQueue(append_3(this.backing, a2));
  }
  prepend(a2) {
    return new _ImmutableQueue(prepend_2(this.backing, a2));
  }
  get size() {
    return this.backing.length;
  }
  dequeue() {
    if (!isEmpty3(this.backing)) {
      return some(tuple2(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        unsafeFirst(this.backing),
        new _ImmutableQueue(tail(this.backing))
      ));
    } else {
      return none;
    }
  }
  find(f2) {
    return find_(this.backing, f2);
  }
  filter(f2) {
    return new _ImmutableQueue(filter_2(this.backing, f2));
  }
  static single(a2) {
    return new _ImmutableQueue(of(a2));
  }
  [Symbol.iterator]() {
    return toArray(this.backing).values();
  }
};

// node_modules/@effect-ts/system/_mjs/Semaphore/state.mjs
var assertNonNegative = (n2) => n2 < 0 ? die3(`Unexpected negative value ${n2} passed to acquireN or releaseN.`) : unit3;
var Acquisition = class {
  constructor(waitAcquire, release4) {
    this.waitAcquire = waitAcquire;
    this.release = release4;
  }
};

// node_modules/@effect-ts/system/_mjs/Semaphore/semaphore.mjs
var Semaphore = class {
  constructor(state) {
    this.state = state;
    this.loop = this.loop.bind(this);
    this.restore = this.restore.bind(this);
    this.releaseN = this.releaseN.bind(this);
    this.restore = this.restore.bind(this);
  }
  get available() {
    return map_13(this.state.get, fold2(() => 0, identity));
  }
  loop(n2, state, acc) {
    while (1) {
      switch (state._tag) {
        case "Right": {
          return tuple2(acc, right(n2 + state.right));
        }
        case "Left": {
          const d2 = state.left.dequeue();
          if (isNone(d2)) {
            return tuple2(acc, right(n2));
          } else {
            const {
              tuple: [{
                tuple: [p2, m2]
              }, q2]
            } = d2.value;
            if (n2 > m2) {
              n2 = n2 - m2;
              state = left(q2);
              acc = zipLeft_(acc, succeed_(p2, void 0));
            } else if (n2 === m2) {
              return tuple2(zipLeft_(acc, succeed_(p2, void 0)), left(q2));
            } else {
              return tuple2(acc, left(q2.prepend(tuple2(p2, m2 - n2))));
            }
          }
          break;
        }
      }
    }
    throw new Error("Bug: we should never get here");
  }
  releaseN(toRelease) {
    return uninterruptible2(flatten8(chain_12(assertNonNegative(toRelease), () => modify_2(this.state, (s2) => this.loop(toRelease, s2, unit3)))));
  }
  restore(p2, n2) {
    return flatten8(modify_2(this.state, fold2((q2) => fold_(q2.find(({
      tuple: [a2]
    }) => a2 === p2), () => tuple2(this.releaseN(n2), left(q2)), (x2) => tuple2(this.releaseN(n2 - x2[1]), left(q2.filter(({
      tuple: [a2]
    }) => a2 !== p2)))), (m2) => tuple2(unit3, right(n2 + m2)))));
  }
  prepare(n2) {
    if (n2 === 0) {
      return succeed5(new Acquisition(unit3, unit3));
    } else {
      return chain_12(make4(), (p2) => modify_2(this.state, fold2((q2) => tuple2(new Acquisition(wait(p2), this.restore(p2, n2)), left(q2.push(tuple2(p2, n2)))), (m2) => {
        if (m2 >= n2) {
          return tuple2(new Acquisition(unit3, this.releaseN(n2)), right(m2 - n2));
        }
        return tuple2(new Acquisition(wait(p2), this.restore(p2, n2)), left(new ImmutableQueue(of(tuple2(p2, n2 - m2)))));
      })));
    }
  }
};
function withPermits_(e2, s2, n2) {
  return bracket_(s2.prepare(n2), (a2) => chain_12(a2.waitAcquire, () => e2), (a2) => a2.release);
}
function withPermit_(self, s2) {
  return withPermits_(self, s2, 1);
}
function makeSemaphore(permits) {
  return map_13(makeRef(right(permits)), (state) => new Semaphore(state));
}

// node_modules/@effect-ts/system/_mjs/RefM/XRefM.mjs
var AtomicM = class {
  constructor(ref, semaphore) {
    this.ref = ref;
    this.semaphore = semaphore;
    this._tag = "AtomicM";
    this.foldM = this.foldM.bind(this);
    this.foldAllM = this.foldAllM.bind(this);
    this.set = this.set.bind(this);
  }
  foldM(_ea, _eb, ca, bd) {
    return new DerivedM((f2) => f2(this, (s2) => bd(s2), (a2) => ca(a2)));
  }
  foldAllM(_ea, _eb, _ec, ca, bd) {
    return new DerivedAllM((f2) => f2(this, (s2) => bd(s2), (a2) => (s2) => ca(a2)(s2)));
  }
  get get() {
    return this.ref.get;
  }
  set(a2) {
    return withPermit_(this.ref.set(a2), this.semaphore);
  }
};
var DerivedM = class _DerivedM {
  constructor(use2) {
    this.use = use2;
    this._tag = "DerivedM";
    this.foldM = this.foldM.bind(this);
    this.foldAllM = this.foldAllM.bind(this);
    this.set = this.set.bind(this);
  }
  foldM(ea, eb, ca, bd) {
    return this.use((value, getEither, setEither) => new _DerivedM((f2) => f2(value, (s2) => foldM_2(getEither(s2), (e2) => fail6(eb(e2)), (a2) => bd(a2)), (a2) => chain_12(ca(a2), (a3) => mapError_3(setEither(a3), ea)))));
  }
  foldAllM(ea, eb, ec, ca, bd) {
    return this.use((value, getEither, setEither) => new DerivedAllM((f2) => f2(value, (s2) => foldM_2(getEither(s2), (e2) => fail6(eb(e2)), (a2) => bd(a2)), (c2) => (s2) => chain_12(foldM_2(getEither(s2), (e2) => fail6(ec(e2)), ca(c2)), (a2) => mapError_3(setEither(a2), ea)))));
  }
  get get() {
    return this.use((value, getEither) => chain_12(value.get, (a2) => getEither(a2)));
  }
  set(a2) {
    return this.use((value, _2, setEither) => withPermit_(chain_12(setEither(a2), (a3) => value.set(a3)), value.semaphore));
  }
};
var DerivedAllM = class _DerivedAllM {
  constructor(use2) {
    this.use = use2;
    this._tag = "DerivedAllM";
    this.foldM = this.foldM.bind(this);
    this.foldAllM = this.foldAllM.bind(this);
    this.set = this.set.bind(this);
  }
  foldM(ea, eb, ca, bd) {
    return this.use((value, getEither, setEither) => new _DerivedAllM((f2) => f2(value, (s2) => foldM_2(getEither(s2), (e2) => fail6(eb(e2)), (a2) => bd(a2)), (a2) => (s2) => chain_12(ca(a2), (a3) => mapError_3(setEither(a3)(s2), ea)))));
  }
  foldAllM(ea, eb, ec, ca, bd) {
    return this.use((value, getEither, setEither) => new _DerivedAllM((f2) => f2(value, (s2) => foldM_2(getEither(s2), (e2) => fail6(eb(e2)), (a2) => bd(a2)), (c2) => (s2) => chain_12(foldM_2(getEither(s2), (e2) => fail6(ec(e2)), ca(c2)), (a2) => mapError_3(setEither(a2)(s2), ea)))));
  }
  get get() {
    return this.use((value, getEither) => chain_12(value.get, (a2) => getEither(a2)));
  }
  set(a2) {
    return this.use((value, _2, setEither) => withPermit_(chain_12(chain_12(value.get, setEither(a2)), (a3) => value.set(a3)), value.semaphore));
  }
};
var concrete3 = (_2) => _2;

// node_modules/@effect-ts/system/_mjs/RefM/api.mjs
function makeRefM(a2) {
  return map_13(bind_(bind_(do_2, "ref", () => makeRef(a2)), "semaphore", () => makeSemaphore(1)), ({
    ref,
    semaphore
  }) => new AtomicM(ref, semaphore));
}
function modify_4(self, f2) {
  return matchTag({
    AtomicM: (atomic) => withPermit_(chain_12(chain_12(atomic.ref.get, f2), ({
      tuple: [b2, a2]
    }) => as_(atomic.ref.set(a2), b2)), atomic.semaphore),
    DerivedM: (derived) => derived.use((value, getEither, setEither) => withPermit_(chain_12(value.ref.get, (a2) => chain_12(chain_12(getEither(a2), f2), ({
      tuple: [b2, a3]
    }) => as_(chain_12(setEither(a3), (a4) => value.ref.set(a4)), b2))), value.semaphore)),
    DerivedAllM: (derivedAll) => derivedAll.use((value, getEither, setEither) => withPermit_(chain_12(value.ref.get, (s2) => chain_12(chain_12(getEither(s2), f2), ({
      tuple: [b2, a2]
    }) => as_(chain_12(setEither(a2)(s2), (a3) => value.ref.set(a3)), b2))), value.semaphore))
  })(concrete3(self));
}
function modify4(f2) {
  return (self) => modify_4(self, f2);
}
function updateSomeAndGet_(self, f2) {
  return modify_4(self, (v2) => map_13(getOrElse_(f2(v2), () => succeed5(v2)), (r2) => tuple2(r2, r2)));
}
function updateSomeAndGet2(f2) {
  return (self) => updateSomeAndGet_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Promise/done.mjs
function done3(e2) {
  return (promise2) => completeWith(done(e2))(promise2);
}

// node_modules/@effect-ts/system/_mjs/Effect/to.mjs
function to(p2, __trace) {
  return (effect2) => to_(effect2, p2, __trace);
}
function to_(effect2, p2, __trace) {
  return uninterruptibleMask(({
    restore: restore2
  }) => chain_12(result(restore2(effect2)), (x2) => done3(x2)(p2)), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/cachedInvalidate.mjs
function cachedInvalidate(ttl, __trace) {
  return (fa) => cachedInvalidate_(fa, ttl);
}
function cachedInvalidate_(fa, ttl, __trace) {
  return map_13(bind_(bind_(do_2, "r", () => environment2()), "cache", () => makeRefM(none)), ({
    cache,
    r: r2
  }) => tuple2(provideAll_3(get5(fa, ttl, cache), r2), invalidate(cache)), __trace);
}
function invalidate(cache) {
  return cache.set(none);
}
function compute(fa, ttl, start) {
  return map_13(tap_4(bind_(do_2, "p", () => make4()), ({
    p: p2
  }) => to_(fa, p2)), ({
    p: p2
  }) => some(tuple2(start + ttl, p2)));
}
function get5(fa, ttl, cache) {
  return uninterruptibleMask(({
    restore: restore2
  }) => chain_12(currentTime, (time) => chain_12(updateSomeAndGet2((o2) => fold_(o2, () => some(compute(fa, ttl, time)), ({
    tuple: [end4]
  }) => end4 - time <= 0 ? some(compute(fa, ttl, time)) : none))(cache), (a2) => a2._tag === "None" ? die3("bug") : restore2(wait(a2.value.get(1))))));
}

// node_modules/@effect-ts/system/_mjs/Effect/cached.mjs
function cached(ttl, __trace) {
  return (fa) => cached_(fa, ttl);
}
function cached_(fa, ttl, __trace) {
  return map_13(cachedInvalidate_(fa, ttl, __trace), ({
    tuple: [cachedEffect, _2]
  }) => cachedEffect);
}

// node_modules/@effect-ts/system/_mjs/Effect/catchAllCause.mjs
function catchAllCause_(effect2, f2, __trace) {
  return foldCauseM_(effect2, f2, succeed5, __trace);
}
function catchAllCause(f2, __trace) {
  return (effect2) => catchAllCause_(effect2, f2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/unrefine.mjs
function unrefine(pf, __trace) {
  return (fa) => unrefine_(fa, pf, __trace);
}
function unrefine_(fa, pf, __trace) {
  return unrefineWith_(fa, pf, identity, __trace);
}
function unrefineWith(pf, f2, __trace) {
  return (fa) => unrefineWith_(fa, pf, f2, __trace);
}
function unrefineWith_(fa, pf, f2, __trace) {
  return catchAllCause_(fa, (cause2) => fold_(find((c2) => c2._tag === "Die" ? pf(c2.value) : none)(cause2), () => halt2(map7(f2)(cause2)), fail6), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/catchSomeDefect.mjs
function catchSomeDefect_(fa, f2, __trace) {
  return catchAll_2(unrefineWith_(fa, f2, fail6), (s2) => s2, __trace);
}
function catchSomeDefect(f2, __trace) {
  return (effect2) => catchSomeDefect_(effect2, f2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/catchAllDefect.mjs
function catchAllDefect_(fa, f2, __trace) {
  return catchSomeDefect_(fa, (u2) => some(f2(u2)), __trace);
}
function catchAllDefect(f2, __trace) {
  return (effect2) => catchAllDefect_(effect2, f2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/catchSome.mjs
function catchSome(f2, __trace) {
  return (fa) => catchSome_(fa, f2, __trace);
}
function catchSome_(fa, f2, __trace) {
  return foldCauseM_(fa, (cause2) => fold_2(failureOrCause(cause2), (x2) => getOrElse_(f2(x2), () => halt2(cause2)), halt2), succeed5, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/catchSomeCause_.mjs
function catchSomeCause_(effect2, f2, __trace) {
  return foldCauseM_(effect2, (c2) => fold_(f2(c2), () => halt2(c2), (a2) => a2), succeed5, __trace);
}
function catchSomeCause(f2, __trace) {
  return (effect2) => catchSomeCause_(effect2, f2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/flip.mjs
function flip(self, __trace) {
  return foldM_2(self, succeed5, fail6, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/flipWith.mjs
function flipWith(f2, __trace) {
  return (self) => flipWith_(self, f2, __trace);
}
function flipWith_(self, f2, __trace) {
  return flip(f2(flip(self)), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/chainError.mjs
function chainError(f2, __trace) {
  return (self) => chainError_(self, f2, __trace);
}
function chainError_(self, f2, __trace) {
  return flipWith_(self, (x2) => chain_12(x2, f2, __trace));
}

// node_modules/@effect-ts/system/_mjs/Effect/optional.mjs
function optional(self, __trace) {
  return foldM_2(self, fold(() => succeed5(none), fail6), (a2) => succeed5(some(a2)), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/collect.mjs
function collect2(f2, __trace) {
  return (self) => collect_3(self, f2, __trace);
}
function collect_3(self, f2, __trace) {
  return map_13(forEach_5(self, (a2) => optional(f2(a2)), __trace), compact3);
}
function collectPar(f2, __trace) {
  return (self) => collectPar_(self, f2, __trace);
}
function collectPar_(self, f2, __trace) {
  return map_13(forEachPar_(self, (a2) => optional(f2(a2)), __trace), compact3);
}
function collectParN_(self, n2, f2, __trace) {
  return map_13(forEachParN_(self, n2, (a2) => optional(f2(a2)), __trace), compact3);
}
function collectParN(n2, f2, __trace) {
  return (self) => collectParN_(self, n2, f2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/compose.mjs
function compose(that, __trace) {
  return (self) => compose_2(self, that, __trace);
}
function compose_2(self, that, __trace) {
  return chain_12(self, (r2) => provideAll_3(that, r2), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/cond.mjs
function cond(onTrue, onFalse, __trace) {
  return (b2) => cond_(b2, onTrue, onFalse, __trace);
}
function cond_(b2, onTrue, onFalse, __trace) {
  return condM_(b2, succeedWith3(onTrue), succeedWith3(onFalse), __trace);
}
function condM_(b2, onTrue, onFalse, __trace) {
  return suspend4(() => b2 ? onTrue : chain_12(onFalse, (x2) => fail6(x2)), __trace);
}
function condM(onTrue, onFalse, __trace) {
  return (b2) => condM_(b2, onTrue, onFalse, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/continueOrFail.mjs
function continueOrFailM_(fa, f2, pf, __trace) {
  return chain_12(fa, (a2) => getOrElse_(pf(a2), () => failWith(f2)), __trace);
}
function continueOrFailM(f2, pf, __trace) {
  return (fa) => continueOrFailM_(fa, f2, pf, __trace);
}
function continueOrFail_(fa, f2, pf, __trace) {
  return continueOrFailM_(fa, f2, (x2) => map_(pf(x2), succeed5), __trace);
}
function continueOrFail(f2, pf, __trace) {
  return (fa) => continueOrFail_(fa, f2, pf, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/derive.mjs
function deriveLifted(H2) {
  return (functions, constants, values3) => {
    const ret = {};
    for (const k2 of functions) {
      ret[k2] = (...args) => accessServiceM2(H2)((h2) => h2[k2](...args));
    }
    for (const k2 of constants) {
      ret[k2] = accessServiceM2(H2)((h2) => h2[k2]);
    }
    for (const k2 of values3) {
      ret[k2] = accessService2(H2)((h2) => h2[k2]);
    }
    return ret;
  };
}
function deriveAccessM(H2) {
  return (generics) => {
    const ret = {};
    for (const k2 of generics) {
      ret[k2] = (f2, trace3) => accessServiceM2(H2)((h2) => f2(h2[k2]), trace3);
    }
    return ret;
  };
}
function deriveAccess(H2) {
  return (generics) => {
    const ret = {};
    for (const k2 of generics) {
      ret[k2] = (f2, trace3) => accessService2(H2)((h2) => f2(h2[k2]), trace3);
    }
    return ret;
  };
}

// node_modules/@effect-ts/system/_mjs/Effect/descriptor.mjs
var descriptor2 = /* @__PURE__ */ descriptorWith(succeed5);

// node_modules/@effect-ts/system/_mjs/Effect/dieMessage.mjs
function dieMessage(message, __trace) {
  return dieWith(() => new RuntimeError(message), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/dropWhile.mjs
function dropWhile(p2, __trace) {
  return (as6) => dropWhile_(as6, p2, __trace);
}
function dropWhile_(as6, p2, __trace) {
  return suspend4(() => {
    let dropping = succeed5(true);
    const r2 = [];
    for (const a2 of as6) {
      dropping = chain_12(dropping, (d2) => {
        if (d2) {
          return p2(a2);
        } else {
          r2.push(a2);
          return succeed5(false);
        }
      });
    }
    return map_13(dropping, () => r2, __trace);
  });
}

// node_modules/@effect-ts/system/_mjs/Effect/runtime.mjs
var empty6 = () => {
};
var defaultEnv = {
  [HasClock.key]: /* @__PURE__ */ new LiveClock(),
  [HasRandom.key]: defaultRandom
};
var prettyReporter = (e2) => {
  console.error(pretty(e2, defaultRenderer));
};
var defaultPlatform = /* @__PURE__ */ new Platform({
  executionTraceLength: 25,
  stackTraceLength: 25,
  traceExecution: /* @__PURE__ */ isTracingEnabled(),
  traceStack: /* @__PURE__ */ isTracingEnabled(),
  traceEffects: /* @__PURE__ */ isTracingEnabled(),
  initialTracingStatus: /* @__PURE__ */ isTracingEnabled(),
  ancestorExecutionTraceLength: 25,
  ancestorStackTraceLength: 25,
  ancestryLength: 25,
  renderer: defaultRenderer,
  reportFailure: constVoid,
  maxOp: 2048,
  supervisor: trackMainFibers
});
var CustomRuntime = class _CustomRuntime {
  constructor(env, platform) {
    this.env = env;
    this.platform = platform;
    this.traceExecution = this.traceExecution.bind(this);
    this.executionTraceLength = this.executionTraceLength.bind(this);
    this.traceStack = this.traceStack.bind(this);
    this.stackTraceLength = this.stackTraceLength.bind(this);
    this.traceEffect = this.traceEffect.bind(this);
    this.initialTracingStatus = this.initialTracingStatus.bind(this);
    this.ancestorExecutionTraceLength = this.ancestorExecutionTraceLength.bind(this);
    this.ancestorStackTraceLength = this.ancestorStackTraceLength.bind(this);
    this.ancestryLength = this.ancestryLength.bind(this);
    this.fiberContext = this.fiberContext.bind(this);
    this.run = this.run.bind(this);
    this.runCancel = this.runCancel.bind(this);
    this.runPromise = this.runPromise.bind(this);
    this.runPromiseExit = this.runPromiseExit.bind(this);
    this.traceRenderer = this.traceRenderer.bind(this);
    this.runFiber = this.runFiber.bind(this);
  }
  fiberContext(effect2) {
    const initialIS = interruptible;
    const fiberId3 = newFiberId();
    const scope3 = unsafeMakeScope();
    const supervisor = none2;
    const context3 = new FiberContext(fiberId3, this.env, initialIS, /* @__PURE__ */ new Map(), supervisor, scope3, this.platform.value.maxOp, this.platform.value.reportFailure, this.platform, none, this.platform.value.initialTracingStatus);
    if (supervisor !== none2) {
      supervisor.unsafeOnStart(this.env, effect2, none, context3);
      context3.onDone((exit) => supervisor.unsafeOnEnd(flatten7(exit), context3));
    }
    context3.evaluateLater(effect2);
    return context3;
  }
  supervised(supervisor) {
    return new _CustomRuntime(this.env, new Platform({
      ...this.platform.value,
      supervisor
    }));
  }
  runFiber(self) {
    const context3 = this.fiberContext(self);
    return context3;
  }
  /**
   * Runs effect until completion, calling cb with the eventual exit state
   */
  run(self, cb) {
    const context3 = this.fiberContext(self);
    context3.runAsync(cb || empty6);
  }
  /**
   * Runs effect until completion returing a cancel effecr that when executed
   * triggers cancellation of the process
   */
  runCancel(self, cb) {
    const context3 = this.fiberContext(self);
    context3.runAsync(cb || empty6);
    return context3.interruptAs(context3.id);
  }
  /**
   * Run effect as a Promise, throwing a the first error or exception
   */
  runPromise(self) {
    const context3 = this.fiberContext(self);
    return new Promise((res, rej) => {
      context3.runAsync((exit) => {
        switch (exit._tag) {
          case "Success": {
            res(exit.value);
            break;
          }
          case "Failure": {
            rej(squash(identity)(exit.cause));
            break;
          }
        }
      });
    });
  }
  /**
   * Run effect as a Promise of the Exit state
   * in case of error.
   */
  runPromiseExit(self) {
    const context3 = this.fiberContext(self);
    return new Promise((res) => {
      context3.runAsync((exit) => {
        res(exit);
      });
    });
  }
  withEnvironment(f2) {
    return new _CustomRuntime(f2(this.env), this.platform);
  }
  traceRenderer(renderer) {
    return new _CustomRuntime(this.env, new Platform({
      ...this.platform.value,
      renderer
    }));
  }
  traceExecution(b2) {
    return new _CustomRuntime(this.env, new Platform({
      ...this.platform.value,
      traceExecution: b2
    }));
  }
  executionTraceLength(n2) {
    return new _CustomRuntime(this.env, new Platform({
      ...this.platform.value,
      executionTraceLength: n2
    }));
  }
  traceStack(b2) {
    return new _CustomRuntime(this.env, new Platform({
      ...this.platform.value,
      traceStack: b2
    }));
  }
  stackTraceLength(n2) {
    return new _CustomRuntime(this.env, new Platform({
      ...this.platform.value,
      stackTraceLength: n2
    }));
  }
  traceEffect(b2) {
    return new _CustomRuntime(this.env, new Platform({
      ...this.platform.value,
      traceEffects: b2
    }));
  }
  initialTracingStatus(b2) {
    return new _CustomRuntime(this.env, new Platform({
      ...this.platform.value,
      initialTracingStatus: b2
    }));
  }
  ancestorExecutionTraceLength(n2) {
    return new _CustomRuntime(this.env, new Platform({
      ...this.platform.value,
      ancestorExecutionTraceLength: n2
    }));
  }
  ancestorStackTraceLength(n2) {
    return new _CustomRuntime(this.env, new Platform({
      ...this.platform.value,
      ancestorStackTraceLength: n2
    }));
  }
  ancestryLength(n2) {
    return new _CustomRuntime(this.env, new Platform({
      ...this.platform.value,
      ancestryLength: n2
    }));
  }
  reportFailure(reportFailure) {
    return new _CustomRuntime(this.env, new Platform({
      ...this.platform.value,
      reportFailure
    }));
  }
  maxOp(maxOp) {
    return new _CustomRuntime(this.env, new Platform({
      ...this.platform.value,
      maxOp
    }));
  }
};
function makeCustomRuntime(env, platform) {
  return new CustomRuntime(env, platform);
}
var defaultRuntime = /* @__PURE__ */ makeCustomRuntime(defaultEnv, defaultPlatform);
var {
  run: run4,
  runCancel,
  runFiber,
  runPromise,
  runPromiseExit
} = defaultRuntime;
function runtime() {
  return accessM3((r0) => new IPlatform((platform) => succeedWith3(() => {
    return makeCustomRuntime(r0, platform);
  })));
}
function withRuntimeM(f2) {
  return chain_12(runtime(), f2);
}
function withRuntime(f2) {
  return chain_12(runtime(), (r2) => succeed5(f2(r2)));
}

// node_modules/@effect-ts/system/_mjs/Effect/effectAsyncM.mjs
function effectAsyncM(register, __trace) {
  return map_13(bind_(bind_(bind_(do_2, "p", () => make4()), "r", () => runtime()), "a", ({
    p: p2,
    r: r2
  }) => uninterruptibleMask(({
    restore: restore2
  }) => zipRight_2(fork(restore2(catchAllCause_(register((k2) => {
    r2.run(to_(k2, p2));
  }), (c2) => halt3(c2)(p2))), __trace), restore2(wait(p2))))), ({
    a: a2
  }) => a2);
}

// node_modules/@effect-ts/system/_mjs/Effect/either.mjs
function either2(self, __trace) {
  return foldM_2(self, (e2) => succeed5(left(e2)), (a2) => succeed5(right(a2)), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/eventually.mjs
function eventually(fa, __trace) {
  return orElse_2(fa, () => zipRight_2(yieldNow, eventually(fa)), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/filterOr.mjs
function filterOrDie(p2, dieWith5, __trace) {
  return (fa) => filterOrDie_(fa, p2, dieWith5, __trace);
}
function filterOrDie_(fa, p2, dieWith5, __trace) {
  return filterOrElse_2(fa, p2, (x2) => die3(dieWith5(x2)), __trace);
}
function filterOrFail(p2, failWith5, __trace) {
  return (fa) => filterOrFail_(fa, p2, failWith5, __trace);
}
function filterOrFail_(fa, p2, failWith5, __trace) {
  return filterOrElse_2(fa, p2, (x2) => fail6(failWith5(x2)), __trace);
}
function filterOrElse2(p2, or, __trace) {
  return (fa) => filterOrElse_2(fa, p2, or, __trace);
}
function filterOrElse_2(fa, p2, or, __trace) {
  return chain_12(fa, (a2) => p2(a2) ? succeed5(a2, __trace) : suspend4(() => or(a2), __trace));
}
function filterOrDieMessage(p2, message, __trace) {
  return (fa) => filterOrDieMessage_(fa, p2, message, __trace);
}
function filterOrDieMessage_(fa, p2, message, __trace) {
  return filterOrDie_(fa, p2, (a2) => new RuntimeError(message(a2)), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/first.mjs
function first2(__trace) {
  return access3((_2) => _2.get(0), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/firstSuccessOf.mjs
function firstSuccessOf(effects, __trace) {
  const first5 = head3(effects);
  const rest = tail3(effects);
  return suspend4(() => reduce_(rest, first5, (b2, a2) => orElse_2(b2, () => a2)), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/flattenErrorOption.mjs
function flattenErrorOption(def, __trace) {
  return (self) => flattenErrorOption_(self, def, __trace);
}
function flattenErrorOption_(self, def, __trace) {
  return mapError_3(self, fold(def, identity), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/fold.mjs
function fold_5(value, failure, success, __trace) {
  return foldM_2(value, (e2) => succeed5(failure(e2)), (a2) => succeed5(success(a2)), __trace);
}
function fold6(failure, success, __trace) {
  return (value) => fold_5(value, failure, success, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/foldCause.mjs
function foldCause_(value, failure, success, __trace) {
  return foldCauseM_(value, (c2) => succeed5(failure(c2)), (x2) => succeed5(success(x2)), __trace);
}
function foldCause(failure, success, __trace) {
  return (value) => foldCause_(value, failure, success, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/forever.mjs
function forever2(effect2, __trace) {
  return chain_12(effect2, () => zipRight_2(yieldNow, forever2(effect2)), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/forkAll.mjs
function forkAll(effects, __trace) {
  return map_13(forEach_5(effects, fork, __trace), collectAll3);
}
function forkAllUnit(effects, __trace) {
  return forEachUnit_(effects, fork, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/forkAs.mjs
function forkAs(name, __trace) {
  return (self) => forkAs_(self, name, __trace);
}
function forkAs_(self, name, __trace) {
  return uninterruptibleMask(({
    restore: restore2
  }) => fork(zipRight_2(set_3(fiberName, some(name)), restore2(self)), __trace));
}

// node_modules/@effect-ts/system/_mjs/Effect/onExit.mjs
function onExit_2(self, cleanup, __trace) {
  return bracketExit_(unit3, () => self, (_2, e2) => cleanup(e2), __trace);
}
function onExit2(cleanup, __trace) {
  return (self) => onExit_2(self, cleanup, __trace);
}
function onError(cleanup, __trace) {
  return (self) => onError_(self, cleanup, __trace);
}
function onError_(self, cleanup, __trace) {
  return onExit_2(self, (e2) => {
    switch (e2._tag) {
      case "Failure": {
        return cleanup(e2.cause);
      }
      case "Success": {
        return unit3;
      }
    }
  }, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/forkWithErrorHandler.mjs
function forkWithErrorHandler(handler, __trace) {
  return (self) => forkWithErrorHandler_(self, handler, __trace);
}
function forkWithErrorHandler_(self, handler, __trace) {
  return fork(onError_(self, (x2) => fold2(handler, halt2)(failureOrCause(x2))), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/fromFiber.mjs
function fromFiber(fiber, __trace) {
  return chain_12(succeedWith3(fiber), join, __trace);
}
function fromFiberM(fiber, __trace) {
  return chain_12(fiber, join, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/fromNodeCb.mjs
function fromNodeCb(f2, __trace) {
  return function() {
    const args = Array.prototype.slice.call(arguments);
    return effectAsync((cb) => {
      const cbResolver = (e2, r2) => e2 != null ? cb(fail6(e2)) : cb(succeed5(r2));
      f2.apply(null, args.concat(cbResolver));
    }, __trace);
  };
}

// node_modules/@effect-ts/system/_mjs/Effect/fromOption.mjs
function fromOption3(o2, __trace) {
  return o2._tag === "None" ? fail6(none, __trace) : succeed5(o2.value, __trace);
}
function fromNullable3(o2, __trace) {
  return fromOption3(fromNullable(o2), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/fromPredicate.mjs
function fromPredicate3(predicate, onFalse) {
  return (a2) => suspend4(() => predicate(a2) ? succeed5(a2) : fail6(onFalse(a2)));
}

// node_modules/@effect-ts/system/_mjs/Effect/getOrFail.mjs
function getOrFail(v2, __trace) {
  return fold_(v2, () => fail6(new NoSuchElementException(), __trace), (x2) => succeed5(x2, __trace));
}
function getOrFailUnit(v2, __trace) {
  return fold_(v2, () => fail6(void 0, __trace), (a2) => succeed5(a2, __trace));
}

// node_modules/@effect-ts/system/_mjs/Effect/gen.mjs
var GenEffect = class {
  constructor(effect2, trace3) {
    this.effect = effect2;
    this.trace = trace3;
  }
  *[Symbol.iterator]() {
    return yield this;
  }
};
function adapter4(_2, __, ___) {
  if (isEither(_2)) {
    return new GenEffect(fromEither2(() => _2), __);
  }
  if (isOption(_2)) {
    if (__ && typeof __ === "function") {
      return new GenEffect(_2._tag === "None" ? fail6(__()) : succeed5(_2.value), ___);
    }
    return new GenEffect(getOrFail(_2), __);
  }
  if (isTag(_2)) {
    return new GenEffect(service(_2), __);
  }
  return new GenEffect(_2, __);
}
function genM(f2, __trace) {
  return suspend4(() => {
    const iterator = f2(adapter4);
    const state = iterator.next();
    function run7(rm4, state2) {
      if (state2.done) {
        return succeed5(state2.value);
      }
      return chain_12(suspend4(() => state2.value.trace ? state2.value["effect"] instanceof ManagedImpl ? map_13(provideSome_(state2.value["effect"]["effect"], (r0) => tuple2(r0, rm4)), (_2) => _2.get(1)) : state2.value["effect"] : state2.value["effect"] instanceof ManagedImpl ? map_13(provideSome_(state2.value["effect"]["effect"], (r0) => tuple2(r0, rm4)), (_2) => _2.get(1)) : state2.value["effect"], state2.value.trace), (val) => {
        const next2 = iterator.next(val);
        return run7(rm4, next2);
      });
    }
    return chain_12(makeReleaseMap, (rm4) => bracketExit_(unit3, () => run7(rm4, state), (_2, e2) => releaseMapReleaseAll(e2, sequential)(rm4)));
  }, __trace);
}
function gen4(f2, __trace) {
  return suspend4(() => {
    const iterator = f2(adapter4);
    const state = iterator.next();
    function run7(state2) {
      if (state2.done) {
        return succeed5(state2.value);
      }
      return chain_12(suspend4(() => state2.value["effect"], state2.value.trace), (val) => run7(iterator.next(val)));
    }
    return run7(state);
  }, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/get.mjs
function get6(self, __trace) {
  return foldCauseM_(self, (x2) => halt2(map_11(x2, some)), fold(() => fail6(none), succeed5), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/head.mjs
function head4(self, __trace) {
  return foldCauseM_(self, (x2) => halt2(map_11(x2, some)), (x2) => {
    const it2 = x2[Symbol.iterator]();
    const next2 = it2.next();
    return next2.done ? fail6(none) : succeed5(next2.value);
  }, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/ignore.mjs
function ignore(self, __trace) {
  return fold_5(self, constVoid, constVoid, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/in.mjs
function _in(scope3, __trace) {
  return (self) => in_(self, scope3, __trace);
}
function in_(self, scope3, __trace) {
  return uninterruptibleMask(({
    restore: restore2
  }) => chain_12(forkDaemon(restore2(self), __trace), (fiber) => chain_12(scope3.extend(fiber.scope), () => onInterrupt_(restore2(join(fiber)), (x2) => fold_(head(Array.from(x2)), () => interrupt4(fiber), (id) => fiber.interruptAs(id))))));
}

// node_modules/@effect-ts/system/_mjs/Async/core.mjs
var Async = class {
};
var ISucceed2 = class extends Async {
  constructor(a2) {
    super();
    this.a = a2;
    this._asyncTag = "Succeed";
  }
};
var IFail2 = class extends Async {
  constructor(e2) {
    super();
    this.e = e2;
    this._asyncTag = "Fail";
  }
};
var FoldFrame2 = class {
  constructor(failure, apply) {
    this.failure = failure;
    this.apply = apply;
    this._asyncTag = "FoldFrame";
  }
};
var ApplyFrame3 = class {
  constructor(apply) {
    this.apply = apply;
    this._asyncTag = "ApplyFrame";
  }
};
var InterruptionState = class {
  constructor() {
    this.isInterrupted = false;
    this.listeners = /* @__PURE__ */ new Set();
  }
  // listen to an interruption event
  listen(f2) {
    this.listeners.add(f2);
    return () => {
      this.listeners.delete(f2);
    };
  }
  get interrupted() {
    return this.isInterrupted;
  }
  interrupt() {
    if (!this.isInterrupted) {
      this.isInterrupted = true;
      this.listeners.forEach((i2) => {
        i2();
      });
    }
  }
};
var failExit = (e2) => ({
  _tag: "Failure",
  e: e2
});
var interruptExit = {
  _tag: "Interrupt"
};
var successExit = (a2) => ({
  _tag: "Success",
  a: a2
});
var CancelablePromise = class {
  constructor(promiseFactory, is) {
    this.promiseFactory = promiseFactory;
    this.is = is;
    this.rejection = void 0;
    this.current = void 0;
    this.promise = () => {
      if (this.current) {
        throw new Error("Bug: promise() have been called twice");
      } else if (this.is.interrupted) {
        throw new Error("Bug: trying to create a promise already interrupted");
      } else {
        const onInterrupt2 = [];
        const removeListener = this.is.listen(() => {
          onInterrupt2.forEach((f2) => {
            f2();
          });
          this.interrupt();
        });
        const p2 = new Promise((res, rej) => {
          this.rejection = rej;
          this.promiseFactory((f2) => {
            onInterrupt2.push(f2);
          }).then((a2) => {
            removeListener();
            if (!this.is.interrupted) {
              res(a2);
            }
          }).catch((e2) => {
            removeListener();
            if (!this.is.interrupted) {
              rej(e2);
            }
          });
        });
        this.current = p2;
        return p2;
      }
    };
    this.interrupt = () => {
      var _a12;
      (_a12 = this.rejection) === null || _a12 === void 0 ? void 0 : _a12.call(this, interruptExit);
    };
  }
};
var Tracer = class {
  constructor() {
    this.running = /* @__PURE__ */ new Set();
    this.traced = this.traced.bind(this);
    this.wait = this.wait.bind(this);
    this.clear = this.clear.bind(this);
  }
  // tracks a lazy promise lifetime
  traced(promise2) {
    return async () => {
      const p2 = promise2();
      this.running.add(p2);
      try {
        const a2 = await p2;
        this.running.delete(p2);
        return Promise.resolve(a2);
      } catch (e2) {
        this.running.delete(p2);
        return Promise.reject(e2);
      }
    };
  }
  // awaits for all the running promises to complete
  async wait() {
    const t2 = await Promise.all(Array.from(this.running).map((p2) => p2.then((a2) => successExit(a2)).catch((e2) => Promise.resolve(e2))));
    return await new Promise((r2) => {
      setTimeout(() => {
        r2(t2);
      }, 0);
    });
  }
  // clears itself
  clear() {
    this.running.clear();
  }
};
var tracingContext = /* @__PURE__ */ new Tracer();
function runPromiseExitEnv(self, ri, is = new InterruptionState()) {
  return tracingContext.traced(async () => {
    let stack = void 0;
    let a2 = null;
    let r2 = ri;
    let failed2 = false;
    let curAsync = self;
    let cnt = 0;
    let interruptedLocal = false;
    function isInterruted() {
      return interruptedLocal || is.interrupted;
    }
    function pop() {
      const nextInstr = stack;
      if (nextInstr) {
        stack = stack === null || stack === void 0 ? void 0 : stack.previous;
      }
      return nextInstr === null || nextInstr === void 0 ? void 0 : nextInstr.value;
    }
    function push(cont) {
      stack = new Stack(cont, stack);
    }
    function findNextErrorHandler() {
      let unwinding = true;
      while (unwinding) {
        const nextInstr = pop();
        if (nextInstr == null) {
          unwinding = false;
        } else {
          if (nextInstr._asyncTag === "FoldFrame") {
            unwinding = false;
            push(new ApplyFrame3(nextInstr.failure));
          }
        }
      }
    }
    while (curAsync != null && !isInterruted()) {
      if (cnt > 1e4) {
        await new Promise((r3) => {
          setTimeout(() => {
            r3(void 0);
          }, 0);
        });
        cnt = 0;
      }
      cnt += 1;
      const xp = curAsync;
      switch (xp._asyncTag) {
        case "FlatMap": {
          const nested = xp.value;
          const continuation = xp.cont;
          switch (nested._asyncTag) {
            case "Succeed": {
              curAsync = continuation(nested.a);
              break;
            }
            default: {
              curAsync = nested;
              push(new ApplyFrame3(continuation));
            }
          }
          break;
        }
        case "Suspend": {
          curAsync = xp.f();
          break;
        }
        case "Succeed": {
          a2 = xp.a;
          const nextInstr = pop();
          if (nextInstr) {
            curAsync = nextInstr.apply(a2);
          } else {
            curAsync = void 0;
          }
          break;
        }
        case "Fail": {
          findNextErrorHandler();
          const nextInst = pop();
          if (nextInst) {
            curAsync = nextInst.apply(xp.e);
          } else {
            failed2 = true;
            a2 = xp.e;
            curAsync = void 0;
          }
          break;
        }
        case "Fold": {
          curAsync = xp.value;
          push(new FoldFrame2(xp.failure, xp.success));
          break;
        }
        case "Done": {
          switch (xp.exit._tag) {
            case "Failure": {
              curAsync = new IFail2(xp.exit.e);
              break;
            }
            case "Interrupt": {
              interruptedLocal = true;
              curAsync = void 0;
              break;
            }
            case "Success": {
              curAsync = new ISucceed2(xp.exit.a);
              break;
            }
          }
          break;
        }
        case "Access": {
          curAsync = xp.access(r2);
          break;
        }
        case "Provide": {
          r2 = xp.r;
          curAsync = xp.cont;
          break;
        }
        case "Promise": {
          try {
            curAsync = new ISucceed2(await new CancelablePromise((s2) => xp.promise(s2).catch((e2) => Promise.reject(failExit(xp.onError(e2)))), is).promise());
          } catch (e2) {
            const e_ = e2;
            switch (e_._tag) {
              case "Failure": {
                curAsync = new IFail2(e_.e);
                break;
              }
              case "Interrupt": {
                interruptedLocal = true;
                curAsync = void 0;
                break;
              }
            }
          }
          break;
        }
      }
    }
    if (is.interrupted) {
      return interruptExit;
    }
    if (failed2) {
      return failExit(a2);
    }
    return successExit(a2);
  })();
}
function runAsyncEnv(task, r2, cb) {
  const is = new InterruptionState();
  runPromiseExitEnv(task, r2, is).then(cb);
  return () => {
    is.interrupt();
  };
}

// node_modules/@effect-ts/system/_mjs/Effect/interop.mjs
function fromAsync(async2, __trace) {
  return accessM3((r2) => effectAsyncInterrupt((cb) => {
    const cancel = runAsyncEnv(async2, r2, (exit) => {
      switch (exit._tag) {
        case "Success": {
          cb(succeed5(exit.a));
          break;
        }
        case "Interrupt": {
          cb(interrupt3);
          break;
        }
        case "Failure": {
          cb(fail6(exit.e));
          break;
        }
      }
    });
    return succeedWith3(() => {
      cancel();
    });
  }, __trace));
}
function fromIO(io, __trace) {
  return succeedWith3(() => run(io), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/interruptAllChildren.mjs
function interruptAllChildren(self, __trace) {
  return ensuringChildren_(self, interruptAll, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/isFailure.mjs
function isFailure(self, __trace) {
  return fold_5(self, () => true, () => false, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/isSuccess.mjs
function isSuccess(self, __trace) {
  return fold_5(self, () => false, () => true, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/iterate.mjs
function iterate(initial2, cont) {
  return (body, __trace) => {
    return suspend4(() => {
      if (cont(initial2)) {
        return chain_12(body(initial2), (z2) => iterate(z2, cont)(body));
      }
      return succeed5(initial2);
    }, __trace);
  };
}

// node_modules/@effect-ts/system/_mjs/Effect/join.mjs
function join2(that, __trace) {
  return (self) => {
    return join_(self, that, __trace);
  };
}
function join_(self, that, __trace) {
  return accessM3((_2) => fold_2(_2, (r2) => provideAll_3(self, r2), (r1) => provideAll_3(that, r1)), __trace);
}
function joinEither_(self, that, __trace) {
  return accessM3((_2) => fold_2(_2, (r2) => map_13(provideAll_3(self, r2), left), (r1) => map_13(provideAll_3(that, r1), right)), __trace);
}
function joinEither(that, __trace) {
  return (self) => joinEither_(self, that, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/leftOrFail.mjs
function leftOrFail_(self, orFail, __trace) {
  return chain_12(self, fold2(succeed5, (x2) => failWith(() => orFail(x2))), __trace);
}
function leftOrFail(orFail, __trace) {
  return (self) => leftOrFail_(self, orFail, __trace);
}
function leftOrFailException(self, __trace) {
  return leftOrFail_(self, () => new NoSuchElementException(), __trace);
}
function left2(self) {
  return foldM_2(self, (e2) => fail6(some(e2)), fold2(succeed5, () => fail6(none)));
}

// node_modules/@effect-ts/system/_mjs/Effect/loop.mjs
function loop(initial2, cont, inc) {
  return (body, __trace) => {
    return map_13(loopInternal_(initial2, cont, inc, body, __trace), (x2) => Array.from(reverse2(x2)));
  };
}
function loopInternal_(initial2, cont, inc, body, __trace) {
  return suspend4(() => {
    if (cont(initial2)) {
      return chain_12(body(initial2), (a2) => map_13(loopInternal_(inc(initial2), cont, inc, body), (as6) => {
        push_(as6, a2);
        return as6;
      }));
    }
    return succeedWith3(() => emptyPushable());
  }, __trace);
}
function loopUnit(initial2, cont, inc) {
  return (body, __trace) => {
    return suspend4(() => {
      if (cont(initial2)) {
        return chain_12(body(initial2), () => loopUnit(inc(initial2), cont, inc)(body));
      }
      return unit3;
    }, __trace);
  };
}

// node_modules/@effect-ts/system/_mjs/Effect/mapBoth.mjs
function mapBoth_2(self, f2, g2, __trace) {
  return foldM_2(self, (e2) => fail6(f2(e2)), (a2) => succeed5(g2(a2)), __trace);
}
function mapBoth(f2, g2, __trace) {
  return (self) => mapBoth_2(self, f2, g2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/tuple.mjs
function tuple3(...t2) {
  return map_13(collectAll2(t2, accessCallTrace()), (x2) => tuple2(...x2));
}
function tuplePar(...t2) {
  return map_13(collectAllPar2(t2, accessCallTrace()), (x2) => tuple2(...x2));
}
function tupleParN(n2) {
  return (
    /**
     * @ets_trace call
     */
    (...t2) => map_13(collectAllParN_(t2, n2, accessCallTrace()), (x2) => tuple2(...x2))
  );
}

// node_modules/@effect-ts/system/_mjs/Effect/mapN.mjs
function mapN(f2, __trace) {
  return (t2) => mapN_(t2, f2, __trace);
}
function mapN_(t2, f2, __trace) {
  return map_13(tuple3(...t2.tuple), (x2) => f2(...x2.tuple), __trace);
}
function mapNPar(f2, __trace) {
  return (t2) => mapNPar_(t2, f2, __trace);
}
function mapNPar_(t2, f2, __trace) {
  return map_13(tuplePar(...t2.tuple), (x2) => f2(...x2.tuple), __trace);
}
function mapNParN(n2, f2, __trace) {
  return (t2) => mapNParN_(t2, n2, f2, __trace);
}
function mapNParN_(t2, n2, f2, __trace) {
  return map_13(tupleParN(n2)(...t2.tuple), (x2) => f2(...x2.tuple), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/mapTryCatch.mjs
function mapTryCatch_(self, f2, onThrow, __trace) {
  return chain_12(self, (a2) => tryCatch4(() => f2(a2), onThrow, __trace));
}
function mapTryCatch(f2, onThrow, __trace) {
  return (self) => mapTryCatch_(self, f2, onThrow, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/memoize.mjs
function memoize(f2, __trace) {
  return map_13(makeRefM(/* @__PURE__ */ new Map()), (ref) => (a2) => map_13(bind_(bind_(do_2, "promise", () => modify4((m2) => {
    const memo = m2.get(a2);
    if (memo) {
      return succeed5(tuple2(memo, m2));
    }
    return map_13(tap_4(bind_(do_2, "promise", () => make4()), ({
      promise: promise2
    }) => fork(to_(f2(a2), promise2))), ({
      promise: promise2
    }) => tuple2(promise2, m2.set(a2, promise2)));
  })(ref)), "b", ({
    promise: promise2
  }) => wait(promise2)), ({
    b: b2
  }) => b2), __trace);
}
function memoizeEq(compare2) {
  return (f2) => map_13(makeRefM(/* @__PURE__ */ new Map()), (ref) => (a2) => map_13(bind_(bind_(do_2, "promise", () => modify4((m2) => {
    for (const [k2, v2] of m2) {
      if (compare2(k2)(a2)) {
        return succeed5(tuple2(v2, m2));
      }
    }
    return map_13(tap_4(bind_(do_2, "promise", () => make4()), ({
      promise: promise2
    }) => fork(to_(f2(a2), promise2))), ({
      promise: promise2
    }) => tuple2(promise2, m2.set(a2, promise2)));
  })(ref)), "b", ({
    promise: promise2
  }) => wait(promise2)), ({
    b: b2
  }) => b2));
}

// node_modules/@effect-ts/system/_mjs/Effect/merge.mjs
function merge2(self, __trace) {
  return foldM_2(self, succeed5, succeed5, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/mergeAll.mjs
function mergeAll(zero2, f2, __trace) {
  return (as6) => mergeAll_(as6, zero2, f2, __trace);
}
function mergeAll_(as6, zero2, f2, __trace) {
  return suspend4(() => reduce_3(as6, succeed5(zero2), (b2, a2) => zipWith_4(b2, a2, f2)), __trace);
}
function mergeAllPar(zero2, f2, __trace) {
  return (as6) => mergeAllPar_(as6, zero2, f2, __trace);
}
function mergeAllPar_(as6, zero2, f2, __trace) {
  return suspend4(() => reduce_3(as6, succeed5(zero2), (b2, a2) => zipWithPar_(b2, a2, f2)), __trace);
}
function mergeAllParN(n2, zero2, f2, __trace) {
  return (as6) => mergeAllParN_(as6, n2, zero2, f2, __trace);
}
function mergeAllParN_(as6, n2, zero2, f2, __trace) {
  return chain_12(makeRef(zero2), (acc) => chain_12(forEachUnitParN_(as6, n2, chain8((a2) => update_3(acc, (b2) => f2(b2, a2))), __trace), () => acc.get));
}

// node_modules/@effect-ts/system/_mjs/Effect/none.mjs
var none3 = /* @__PURE__ */ succeed5(none);

// node_modules/@effect-ts/system/_mjs/Effect/once.mjs
function once(self, __trace) {
  return map_13(makeRef(true), (r2) => whenM_(self, getAndSet2(false)(r2)), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/onFirst.mjs
function onFirst(self, __trace) {
  return zip_4(self, environment2(), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/onLeft.mjs
function onLeft(__trace) {
  return (self) => joinEither_(self, environment2(), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/onRight.mjs
function onRight(__trace) {
  return (self) => joinEither_(environment2(), self, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/onSecond.mjs
function onSecond(self, __trace) {
  return zip_4(environment2(), self, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/onTermination.mjs
function onTermination_(self, cleanup, __trace) {
  return bracketExit_(unit3, () => self, (_2, eb) => {
    switch (eb._tag) {
      case "Success": {
        return unit3;
      }
      case "Failure": {
        return fold_2(failureOrCause(eb.cause), () => unit3, cleanup);
      }
    }
  }, __trace);
}
function onTermination(cleanup, __trace) {
  return (self) => onTermination_(self, cleanup, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/option.mjs
function option(self, __trace) {
  return foldM_2(self, () => succeed5(none), (a2) => succeed5(some(a2)), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/orDieKeep.mjs
function orDieKeep(effect2, __trace) {
  return foldCauseM_(effect2, (ce2) => halt2(chain6((e2) => die(e2))(ce2)), succeed5, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/orElseEither.mjs
function orElseEither3(that, __trace) {
  return (self) => orElseEither_3(self, that, __trace);
}
function orElseEither_3(self, that, __trace) {
  return tryOrElse_(self, () => map_13(that(), right), (x2) => succeed5(left(x2)), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/orElseFail.mjs
function orElseFail2(e2, __trace) {
  return (self) => orElseFail_(self, e2, __trace);
}
function orElseFail_(self, e2, __trace) {
  return orElse_2(self, () => fail6(e2), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/orElseOptional.mjs
function orElseOptional(that, __trace) {
  return (self) => orElseOptional_(self, that, __trace);
}
function orElseOptional_(self, that, __trace) {
  return catchAll_2(self, fold(that, (x2) => fail6(some(x2))), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/orElseSucceed.mjs
function orElseSucceed(a2, __trace) {
  return (self) => orElseSucceed_(self, a2, __trace);
}
function orElseSucceed_(self, a2, __trace) {
  return orElse_2(self, () => succeed5(a2), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/parallelErrors.mjs
function parallelErrors(self, __trace) {
  return foldCauseM_(self, (cause2) => {
    const f2 = failures(cause2);
    if (f2.length === 0) {
      return halt2(cause2);
    } else {
      return fail6(f2);
    }
  }, succeed5, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/partition.mjs
function partition(f2, __trace) {
  return (as6) => partition_(as6, f2, __trace);
}
function partition_(as6, f2, __trace) {
  return map_13(forEach_5(as6, (a2) => either2(f2(a2)), __trace), partitionMap(identity));
}
function partitionPar(f2, __trace) {
  return (as6) => partitionPar_(as6, f2, __trace);
}
function partitionPar_(as6, f2, __trace) {
  return map_13(forEachPar_(as6, (a2) => either2(f2(a2)), __trace), partitionMap(identity));
}
function partitionParN(n2, f2, __trace) {
  return (as6) => partitionParN_(as6, n2, f2, __trace);
}
function partitionParN_(as6, n2, f2, __trace) {
  return map_13(forEachParN_(as6, n2, (a2) => either2(f2(a2)), __trace), partitionMap(identity));
}

// node_modules/@effect-ts/system/_mjs/Effect/promise.mjs
function tryCatchPromise(promise2, onReject, __trace) {
  return effectAsync((resolve) => {
    promise2().then((x2) => resolve(succeed5(x2))).catch((x2) => resolve(fail6(onReject(x2))));
  }, __trace);
}
function tryPromise(effect2, __trace) {
  return effectAsync((resolve) => {
    effect2().then((x2) => resolve(succeed5(x2))).catch((x2) => resolve(fail6(x2)));
  }, __trace);
}
function promise(effect2, __trace) {
  return effectAsync((resolve) => {
    effect2().then((x2) => resolve(succeed5(x2))).catch((x2) => resolve(die3(x2)));
  }, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/provide.mjs
function provide2(r2, __trace) {
  return (next2) => provide_(next2, r2, __trace);
}
function provide_(next2, r2, __trace) {
  return provideSome_(next2, (r0) => ({
    ...r0,
    ...r2
  }), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/provideManaged.mjs
function provideSomeManaged(managed2) {
  return (self) => managedUse_(managed2, (a2) => provide_(self, a2));
}
function provideServiceManaged(tag2) {
  return (managed2) => (self) => managedUse_(managed2, (a2) => provideService(tag2)(a2)(self));
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/reduce.mjs
function reduce_7(self, s2, f2) {
  ;
  switch (self._typeId) {
    case SingletonTypeId: {
      return f2(s2, self.a);
    }
    case ArrTypeId: {
      const arr = self.arrayLike();
      const len = arr.length;
      let s1 = s2;
      let i2 = 0;
      while (i2 < len) {
        s1 = f2(s1, arr[i2]);
        i2++;
      }
      return s1;
    }
    default: {
      const iterator = self.arrayLikeIterator();
      let next2;
      let s1 = s2;
      while ((next2 = iterator.next()) && !next2.done) {
        const array2 = next2.value;
        const len = array2.length;
        let i2 = 0;
        while (i2 < len) {
          const a2 = array2[i2];
          s1 = f2(s1, a2);
          i2++;
        }
      }
      return s1;
    }
  }
}
function reduce5(s2, f2) {
  return (self) => reduce_7(self, s2, f2);
}

// node_modules/@effect-ts/system/_mjs/Managed/succeed.mjs
function succeed7(a2, __trace) {
  return fromEffect(succeed5(a2), __trace);
}

// node_modules/@effect-ts/system/_mjs/Managed/do.mjs
function bind3(tag2, f2, __trace) {
  return (mk) => bind_2(mk, tag2, f2, __trace);
}
function bind_2(mk, tag2, f2, __trace) {
  return chain_13(mk, (k2) => map_14(f2(k2), (a2) => ({
    ...k2,
    [tag2]: a2
  }), __trace));
}
function let__2(tag2, f2, __trace) {
  return (mk) => map_14(mk, (k2) => ({
    ...k2,
    [tag2]: f2(k2)
  }), __trace);
}
function let_3(mk, tag2, f2) {
  return map_14(mk, (k2) => ({
    ...k2,
    [tag2]: f2(k2)
  }));
}
var do_3 = /* @__PURE__ */ succeed7({});

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/unzip.mjs
function unzip2(as6) {
  let fa = empty4();
  let fb = empty4();
  forEach_4(as6, ({
    tuple: [a2, b2]
  }) => {
    fa = append_4(fa, a2);
    fb = append_4(fb, b2);
  });
  return tuple2(fa, fb);
}

// node_modules/@effect-ts/system/_mjs/Managed/forEach.mjs
function forEach5(f2, __trace) {
  return (as6) => forEach_7(as6, f2, __trace);
}
function forEach_7(as6, f2, __trace) {
  return managedApply(map_13(forEach_5(as6, (a2) => f2(a2).effect, __trace), (res) => {
    const fins = map_8(res, (k2) => k2.get(0));
    const as7 = map_8(res, (k2) => k2.get(1));
    return tuple2((e2) => forEach_5(reverse3(fins), (fin) => fin(e2), __trace), as7);
  }));
}
function forEachExec_2(as6, es, f2, __trace) {
  switch (es._tag) {
    case "Sequential": {
      return forEach_7(as6, f2, __trace);
    }
    case "Parallel": {
      return forEachPar_2(as6, f2, __trace);
    }
    case "ParallelN": {
      return forEachParN_2(as6, es.n, f2, __trace);
    }
  }
}
function forEachExec2(es, f2, __trace) {
  return (as6) => forEachExec_2(as6, es, f2, __trace);
}
function forEachUnit_2(as6, f2, __trace) {
  return managedApply(map_13(forEach_5(as6, (a2) => f2(a2).effect, __trace), (result4) => {
    const {
      tuple: [fins]
    } = unzip2(result4);
    return tuple2((e2) => forEach_5(reverse3(fins), (f3) => f3(e2), __trace), void 0);
  }));
}
function forEachUnit2(f2, __trace) {
  return (as6) => forEachUnit_2(as6, f2, __trace);
}
function forEachPar2(f2, __trace) {
  return (as6) => forEachPar_2(as6, f2, __trace);
}
function forEachPar_2(as6, f2, __trace) {
  return mapM_(makeManagedReleaseMap(parallel, __trace), (parallelReleaseMap) => {
    const makeInnerMap = provideSome_(map_13(makeManagedReleaseMap(sequential).effect, ({
      tuple: [_2, x2]
    }) => x2), (x2) => tuple2(x2, parallelReleaseMap));
    return forEachPar_(as6, (a2) => map_13(chain_12(makeInnerMap, (innerMap) => provideSome_(f2(a2).effect, (u2) => tuple2(u2, innerMap))), ({
      tuple: [_2, b2]
    }) => b2));
  });
}
function forEachParN2(n2, f2, __trace) {
  return (as6) => forEachParN_2(as6, n2, f2, __trace);
}
function forEachParN_2(as6, n2, f2, __trace) {
  return mapM_(makeManagedReleaseMap(parallelN(n2), __trace), (parallelReleaseMap) => {
    const makeInnerMap = provideSome_(map_13(makeManagedReleaseMap(sequential).effect, ({
      tuple: [_2, x2]
    }) => x2), (x2) => tuple2(x2, parallelReleaseMap));
    return forEachParN_(as6, n2, (a2) => map_13(chain_12(makeInnerMap, (innerMap) => provideSome_(f2(a2).effect, (u2) => tuple2(u2, innerMap))), ({
      tuple: [_2, b2]
    }) => b2));
  });
}

// node_modules/@effect-ts/system/_mjs/Managed/methods/environment.mjs
function environment3(__trace) {
  return fromEffect(environment2(), __trace);
}

// node_modules/@effect-ts/system/_mjs/Layer/definitions.mjs
var _a4;
function fromRawEffect(resource) {
  return new LayerManaged(fromEffect(resource));
}
function fromRawFunction(f2) {
  return fromRawEffect(access3(f2));
}
function fromRawFunctionM(f2) {
  return fromRawEffect(accessM3(f2));
}
function fromRawManaged(resource) {
  return new LayerManaged(resource);
}
function identity2() {
  return fromRawManaged(environment3());
}
function and_(self, that) {
  return new LayerZipWithPar(self, that, (l2, r2) => ({
    ...l2,
    ...r2
  }));
}
function and(that) {
  return (self) => new LayerZipWithPar(self, that, (l2, r2) => ({
    ...l2,
    ...r2
  }));
}
function fold7(self) {
  return (failure) => (success) => new LayerFold(self, failure, success);
}
function using(from4) {
  return (to2) => compose_3(from4["+++"](identity2()), to2);
}
function usingAnd(from4) {
  return (to2) => compose_3(from4["+++"](identity2()), to2["+++"](identity2()));
}
function compose_3(from4, to2) {
  return fold7(from4)(fromRawFunctionM((_2) => halt2(_2.get(1))))(to2);
}
function compose2(to2) {
  return (from4) => compose_3(from4, to2);
}
var hashSym2 = /* @__PURE__ */ Symbol();
var Layer = class {
  constructor() {
    this[_a4] = new AtomicReference(Symbol());
  }
  /**
   * Set the hash key for memoization
   */
  setKey(hash2) {
    this[hashSym2].set(hash2);
    return this;
  }
  [(_a4 = hashSym2, "_I")]() {
    return this;
  }
  /**
   * Use that Layer to provide data to this
   */
  ["<=<"](that) {
    return that[">=>"](this);
  }
  /**
   * Use this Layer to provide data to that
   */
  [">=>"](that) {
    return compose_3(this, that);
  }
  /**
   * Use that Layer to partially provide data to this
   */
  ["<<<"](that) {
    return that[">>>"](this);
  }
  [">>>"](that) {
    return this["+++"](identity2())[">=>"](that);
  }
  /**
   * Create a Layer with the data from both Layers, while providing the data from this to that
   */
  [">+>"](that) {
    return this[">>>"](that["+++"](identity2()));
  }
  /**
   * Create a Layer with the data from both Layers, while providing the data from that to this
   */
  ["<+<"](that) {
    return that[">+>"](this);
  }
  /**
   * Combine both layers in parallel
   */
  ["+++"](from4) {
    return and_(from4, this);
  }
  /**
   * Use the layer to provide partial environment to an effect
   */
  use(effect2) {
    return provideSomeLayer(this)(effect2);
  }
  /**
   * Use the layer to provide the full environment to an effect
   */
  useAll(effect2) {
    return provideLayer(this)(effect2);
  }
  /**
   * Use the layer to provide the full environment to an effect
   */
  get useForever() {
    return provideLayer(this)(never);
  }
};
function provideSomeLayer(layer) {
  return (self) => provideLayer_(self, layer["+++"](identity2()));
}
function provideSomeLayer_(self, layer) {
  return provideLayer_(self, layer["+++"](identity2()));
}
function provideLayer_(self, layer) {
  return managedUse_(build(layer), (p2) => provideAll_3(self, p2));
}
function provideLayer(layer) {
  return (self) => provideLayer_(self, layer);
}
var LayerFold = class extends Layer {
  constructor(self, failure, success) {
    super();
    this.self = self;
    this.failure = failure;
    this.success = success;
    this._tag = "LayerFold";
  }
};
var LayerMap = class extends Layer {
  constructor(self, f2) {
    super();
    this.self = self;
    this.f = f2;
    this._tag = "LayerMap";
  }
};
var LayerChain = class extends Layer {
  constructor(self, f2) {
    super();
    this.self = self;
    this.f = f2;
    this._tag = "LayerChain";
  }
};
var LayerFresh = class extends Layer {
  constructor(self) {
    super();
    this.self = self;
    this._tag = "LayerFresh";
  }
};
var LayerManaged = class extends Layer {
  constructor(self) {
    super();
    this.self = self;
    this._tag = "LayerManaged";
  }
};
var LayerSuspend = class extends Layer {
  constructor(self) {
    super();
    this.self = self;
    this._tag = "LayerSuspend";
  }
};
var LayerZipWithPar = class extends Layer {
  constructor(self, that, f2) {
    super();
    this.self = self;
    this.that = that;
    this.f = f2;
    this._tag = "LayerZipWithPar";
  }
};
var LayerAllPar = class extends Layer {
  constructor(layers) {
    super();
    this.layers = layers;
    this._tag = "LayerAllPar";
  }
};
var LayerAllSeq = class extends Layer {
  constructor(layers) {
    super();
    this.layers = layers;
    this._tag = "LayerAllSeq";
  }
};
var LayerZipWithSeq = class extends Layer {
  constructor(self, that, f2) {
    super();
    this.self = self;
    this.that = that;
    this.f = f2;
    this._tag = "LayerZipWithSeq";
  }
};
function scope(_2) {
  const I2 = _2._I();
  switch (I2._tag) {
    case "LayerFresh": {
      return succeed7(() => build(I2.self));
    }
    case "LayerManaged": {
      return succeed7(() => I2.self);
    }
    case "LayerSuspend": {
      return succeed7((memo) => memo.getOrElseMemoize(I2.self()));
    }
    case "LayerMap": {
      return succeed7((memo) => map_14(memo.getOrElseMemoize(I2.self), I2.f));
    }
    case "LayerChain": {
      return succeed7((memo) => chain_13(memo.getOrElseMemoize(I2.self), (a2) => memo.getOrElseMemoize(I2.f(a2))));
    }
    case "LayerZipWithPar": {
      return succeed7((memo) => zipWithPar_2(memo.getOrElseMemoize(I2.self), memo.getOrElseMemoize(I2.that), I2.f));
    }
    case "LayerZipWithSeq": {
      return succeed7((memo) => zipWith_6(memo.getOrElseMemoize(I2.self), memo.getOrElseMemoize(I2.that), I2.f));
    }
    case "LayerAllPar": {
      return succeed7((memo) => {
        return map10(reduce5({}, (b2, a2) => ({
          ...b2,
          ...a2
        })))(forEachPar_2(I2.layers, memo.getOrElseMemoize));
      });
    }
    case "LayerAllSeq": {
      return succeed7((memo) => {
        return map10(reduce5({}, (b2, a2) => ({
          ...b2,
          ...a2
        })))(forEach_7(I2.layers, memo.getOrElseMemoize));
      });
    }
    case "LayerFold": {
      return succeed7((memo) => foldCauseM_2(memo.getOrElseMemoize(I2.self), (e2) => chain9((r2) => provideSome_2(memo.getOrElseMemoize(I2.failure), () => tuple2(r2, e2)))(fromEffect(environment2())), (r2) => provideAll_4(memo.getOrElseMemoize(I2.success), r2)));
    }
  }
}
function build(_2) {
  return map10(({
    value
  }) => value)(bind3("value", ({
    memoMap,
    run: run7
  }) => run7(memoMap))(bind3("run", () => scope(_2))(bind3("memoMap", () => fromEffect(makeMemoMap()))(do_3))));
}
function makeMemoMap() {
  return chain_12(makeRefM(/* @__PURE__ */ new Map()), (r2) => succeedWith3(() => new MemoMap(r2)));
}
var MemoMap = class {
  constructor(ref) {
    this.ref = ref;
    this.getOrElseMemoize = (layer) => {
      return managedApply(flatten8(modify4((m2) => {
        const inMap = m2.get(layer[hashSym2].get);
        if (inMap) {
          const {
            tuple: [acquire, release4]
          } = inMap;
          const cached2 = accessM3(({
            tuple: [_2, rm4]
          }) => map_13(onExit_2(acquire, (ex) => {
            switch (ex._tag) {
              case "Success": {
                return add(release4)(rm4);
              }
              case "Failure": {
                return unit3;
              }
            }
          }), (x2) => tuple2(release4, x2)));
          return succeed5(tuple2(cached2, m2));
        } else {
          return map_13(let_2(let_2(bind_(bind_(bind_(do_2, "observers", () => makeRef(0)), "promise", () => make4()), "finalizerRef", () => makeRef(noopFinalizer)), "resource", ({
            finalizerRef: finalizerRef2,
            observers,
            promise: promise2
          }) => uninterruptibleMask(({
            restore: restore2
          }) => map_13(bind_(bind_(let_2(let_2(bind_(do_2, "env", () => environment2()), "a", ({
            env: {
              tuple: [a2]
            }
          }) => a2), "outerReleaseMap", ({
            env: {
              tuple: [_2, outerReleaseMap]
            }
          }) => outerReleaseMap), "innerReleaseMap", () => makeReleaseMap), "tp", ({
            a: a2,
            innerReleaseMap,
            outerReleaseMap
          }) => restore2(chain_12(result(provideAll_3(chain9((_2) => _2(this))(scope(layer)).effect, tuple2(a2, innerReleaseMap))), (e2) => {
            switch (e2._tag) {
              case "Failure": {
                return chain_12(chain_12(halt3(e2.cause)(promise2), () => releaseMapReleaseAll(e2, sequential)(innerReleaseMap)), () => halt2(e2.cause));
              }
              case "Success": {
                return map_13(tap_4(bind_(tap_4(tap_4(do_2, () => finalizerRef2.set((e3) => whenM_(releaseMapReleaseAll(e3, sequential)(innerReleaseMap), modify_2(observers, (n2) => tuple2(n2 === 1, n2 - 1))))), () => update_3(observers, (n2) => n2 + 1)), "outerFinalizer", () => add((e3) => chain_12(finalizerRef2.get, (f2) => f2(e3)))(outerReleaseMap)), () => succeed6(e2.value.get(1))(promise2)), ({
                  outerFinalizer
                }) => tuple2(outerFinalizer, e2.value.get(1)));
              }
            }
          }))), ({
            tp
          }) => tp))), "memoized", ({
            finalizerRef: finalizerRef2,
            observers,
            promise: promise2
          }) => tuple2(onExit_2(wait(promise2), (e2) => {
            switch (e2._tag) {
              case "Failure": {
                return unit3;
              }
              case "Success": {
                return update_3(observers, (n2) => n2 + 1);
              }
            }
          }), (e2) => chain_12(finalizerRef2.get, (f2) => f2(e2)))), ({
            memoized,
            resource
          }) => tuple2(resource, insert(layer[hashSym2].get, memoized)(m2)));
        }
      })(this.ref)));
    };
  }
};
var Empty4 = /* @__PURE__ */ new LayerSuspend(() => identity2());

// node_modules/@effect-ts/system/_mjs/Effect/raceAll.mjs
function arbiter(fibers, winner, promise2, fails) {
  return (res) => foldM3((e2) => flatten8(modify_2(fails, (c2) => tuple2(c2 === 0 ? asUnit(halt3(e2)(promise2)) : unit3, c2 - 1))), (a2) => chain_12(succeed6(tuple2(a2, winner))(promise2), (set3) => set3 ? reduce5(unit3, (io, f2) => f2 === winner ? io : tap_4(io, () => interrupt4(f2)))(fibers) : unit3))(res);
}
function raceAllWithStrategy(ios, interruptStrategy, __trace) {
  return map_13(tap_4(bind_(bind_(bind_(do_2, "done", () => make4()), "fails", () => makeRef(ios.length)), "c", ({
    done: done7,
    fails
  }) => uninterruptibleMask(({
    restore: restore2
  }) => map_13(bind_(let_2(tap_4(bind_(do_2, "fs", () => forEach_5(ios, (x2) => fork(interruptible2(x2)))), ({
    fs: fs3
  }) => reduce_7(fs3, unit3, (io, f2) => chain_12(io, () => fork(chain_12(f2.await, arbiter(fs3, f2, done7, fails)))))), "inheritRefs", () => (res) => as_(res.get(1).inheritRefs, res.get(0))), "c", ({
    fs: fs3,
    inheritRefs
  }) => onInterrupt_(restore2(chain_12(wait(done7), inheritRefs)), () => reduce_7(fs3, unit3, (io, f2) => tap_4(io, () => interrupt4(f2))))), ({
    c: c2,
    fs: fs3
  }) => ({
    c: c2,
    fs: fs3
  })), __trace)), ({
    c: {
      fs: fs3
    }
  }) => interruptStrategy === "wait" ? forEach_5(fs3, (f2) => f2.await) : unit3), ({
    c: {
      c: c2
    }
  }) => c2);
}
function raceAll(ios, __trace) {
  return raceAllWithStrategy(ios, "background", __trace);
}
function raceAllWait(ios, __trace) {
  return raceAllWithStrategy(ios, "wait", __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/reduceAll.mjs
function reduceAll_(as6, f2, __trace) {
  return suspend4(() => reduce_(tail3(as6), head3(as6), (acc, a2) => zipWith_4(acc, a2, f2)), __trace);
}
function reduceAll(f2, __trace) {
  return (as6) => reduceAll_(as6, f2, __trace);
}
function reduceAllPar_(as6, f2, __trace) {
  return map_13(mergeAllPar_(as6, none, (acc, elem3) => some(fold_(acc, () => elem3, (a2) => f2(a2, elem3))), __trace), getOrElse(() => {
    throw new Error("Bug");
  }));
}
function reduceAllPar(f2, __trace) {
  return (as6) => reduceAllPar_(as6, f2, __trace);
}
function reduceAllParN_(as6, n2, f2, __trace) {
  return map_13(mergeAllParN_(as6, n2, none, (acc, elem3) => some(fold_(acc, () => elem3, (a2) => f2(a2, elem3))), __trace), getOrElse(() => {
    throw new Error("Bug");
  }));
}
function reduceAllParN(n2, f2, __trace) {
  return (as6) => reduceAllParN_(as6, n2, f2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/refailWithTrace.mjs
function refailWithTrace(self, __trace) {
  return foldCauseM_(self, (cause2) => haltWith((trace3) => traced(cause2, trace3())), succeed5, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/refineOrDie.mjs
function refineOrDieWith(pf, f2, __trace) {
  return (self) => refineOrDieWith_(self, pf, f2, __trace);
}
function refineOrDieWith_(self, pf, f2, __trace) {
  return catchAll_2(self, (e2) => fold_(pf(e2), () => die3(f2(e2)), (e1) => fail6(e1)), __trace);
}
function refineOrDie(pf, __trace) {
  return (self) => refineOrDie_(self, pf, __trace);
}
function refineOrDie_(self, pf, __trace) {
  return refineOrDieWith_(self, pf, identity, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/reject.mjs
function rejectM(pf, __trace) {
  return (self) => rejectM_(self, pf, __trace);
}
function rejectM_(self, pf, __trace) {
  return chain_12(self, (a2) => fold_(pf(a2), () => succeed5(a2), (_2) => chain_12(_2, (e1) => fail6(e1))), __trace);
}
function reject(pf, __trace) {
  return (self) => reject_(self, pf);
}
function reject_(self, pf, __trace) {
  return rejectM_(self, (x2) => map_(pf(x2), fail6), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/repeatN.mjs
function repeatN(n2, __trace) {
  return (self) => repeatN_(self, n2, __trace);
}
function repeatN_(self, n2, __trace) {
  return chain_12(self, (a2) => n2 <= 0 ? succeed5(a2) : zipRight_2(yieldNow, repeatN_(self, n2 - 1)), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/repeatUntil.mjs
function repeatUntilM(f2, __trace) {
  return (self) => repeatUntilM_(self, f2);
}
function repeatUntilM_(self, f2, __trace) {
  return chain_12(self, (a2) => chain_12(f2(a2), (b2) => b2 ? succeed5(a2) : zipRight_2(yieldNow, repeatUntilM_(self, f2))), __trace);
}
function repeatUntil(f2, __trace) {
  return (self) => repeatUntil_(self, f2, __trace);
}
function repeatUntil_(self, f2, __trace) {
  return repeatUntilM_(self, (a2) => succeed5(f2(a2)), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/repeatWhile.mjs
function repeatWhileM(f2, __trace) {
  return (self) => repeatWhileM_(self, f2, __trace);
}
function repeatWhileM_(self, f2, __trace) {
  return chain_12(self, (a2) => chain_12(f2(a2), (b2) => b2 ? repeatWhileM_(self, f2) : succeed5(a2)), __trace);
}
function repeatWhile(f2, __trace) {
  return (self) => repeatWhile_(self, f2, __trace);
}
function repeatWhile_(self, f2, __trace) {
  return repeatWhileM_(self, (a2) => succeed5(f2(a2)), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/replicate.mjs
function replicate(n2, __trace) {
  return (self) => replicate_(self, n2);
}
function replicate_(self, n2) {
  return range(0, n2).map(() => self);
}
function replicateMUnit_(self, n2) {
  return collectAllUnit(replicate_(self, n2));
}
function replicateMUnit(n2) {
  return (self) => replicateMUnit_(self, n2);
}

// node_modules/@effect-ts/system/_mjs/Effect/require.mjs
function _require(error, __trace) {
  return (io) => require_(io, error, __trace);
}
function require_(io, error, __trace) {
  return chain_12(io, fold(() => chain_12(succeedWith3(error), fail6), succeed5), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/reserve.mjs
function reserve2(use2, __trace) {
  return (reservation) => reserve_(reservation, use2, __trace);
}
function reserve_(reservation, use2, __trace) {
  return managedUse_(makeReserve(reservation), use2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/restrictions.mjs
function unfailable(self) {
  return self;
}
function onlyDefaultEnv(self) {
  return self;
}
function noEnv(self) {
  return self;
}

// node_modules/@effect-ts/system/_mjs/Effect/resurrect.mjs
function resurrect(self, __trace) {
  return unrefineWith_(self, some, identity, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/retry.mjs
function loop2(self, orElse6, driver2) {
  return catchAll_2(map_13(self, (a2) => right(a2)), (e2) => foldM_2(driver2.next(e2), () => chain_12(orDie(driver2.last), (o2) => map_13(orElse6(e2, o2), (a2) => left(a2))), () => loop2(self, orElse6, driver2)));
}
function retryOrElseEither_(self, policy, orElse6, __trace) {
  return chain_12(driver(policy), (a2) => loop2(self, orElse6, a2), __trace);
}
function retryOrElseEither(policy, orElse6, __trace) {
  return (self) => retryOrElseEither_(self, policy, orElse6, __trace);
}
function retryOrElse_(self, policy, orElse6, __trace) {
  return map_13(retryOrElseEither_(self, policy, orElse6, __trace), fold2(identity, identity));
}
function retryOrElse(policy, orElse6, __trace) {
  return (self) => retryOrElse_(self, policy, orElse6, __trace);
}
function retry_(self, policy, __trace) {
  return retryOrElse_(self, policy, (e2, _2) => fail6(e2), __trace);
}
function retry(policy, __trace) {
  return (self) => retry_(self, policy, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/retryUntil.mjs
function retryUntilM(f2, __trace) {
  return (self) => retryUntilM_(self, f2);
}
function retryUntilM_(self, f2, __trace) {
  return suspend4(() => catchAll_2(self, (e2) => chain_12(f2(e2), (b2) => b2 ? fail6(e2) : zipRight_2(yieldNow, retryUntilM_(self, f2)))), __trace);
}
function retryUntil(f2, __trace) {
  return (self) => retryUntil_(self, f2, __trace);
}
function retryUntil_(self, f2, __trace) {
  return retryUntilM_(self, (a2) => succeed5(f2(a2)), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/retryWhile.mjs
function retryWhileM(f2, __trace) {
  return (self) => retryWhileM_(self, f2);
}
function retryWhileM_(self, f2, __trace) {
  return suspend4(() => catchAll_2(self, (e2) => chain_12(f2(e2), (b2) => b2 ? retryWhileM_(self, f2) : fail6(e2))), __trace);
}
function retryWhile(f2, __trace) {
  return (self) => retryWhile_(self, f2, __trace);
}
function retryWhile_(self, f2, __trace) {
  return retryWhileM_(self, (a2) => succeed5(f2(a2)), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/right.mjs
function right2(self, __trace) {
  return foldM_2(self, (e2) => fail6(some(e2)), fold2(() => fail6(none), succeed5), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/unsandbox.mjs
function unsandbox(fa, __trace) {
  return mapErrorCause_(fa, flatten6, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/sandboxWith.mjs
function sandboxWith(f2, __trace) {
  return (self) => sandboxWith_(self, f2, __trace);
}
function sandboxWith_(self, f2, __trace) {
  return unsandbox(f2(sandbox(self)), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/scopeWith.mjs
function scopeWith(f2, __trace) {
  return descriptorWith((d2) => f2(d2.scope), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/second.mjs
function second(__trace) {
  return access3((a2) => a2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/some.mjs
function some2(self, __trace) {
  return foldM_2(self, (e2) => fail6(some(e2)), fold(() => fail6(none), succeed5), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/someOrElse.mjs
function someOrElse(orElse6, __trace) {
  return (self) => someOrElse_(self, orElse6, __trace);
}
function someOrElse_(self, orElse6, __trace) {
  return map_13(self, getOrElse(orElse6), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/someOrElseM.mjs
function someOrElseM(orElse6, __trace) {
  return (self) => someOrElseM_(self, orElse6, __trace);
}
function someOrElseM_(self, orElse6, __trace) {
  return chain_12(self, (x2) => getOrElse_(map_(x2, succeed5), constant(orElse6)), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/someOrFail.mjs
function someOrFail(orFail, __trace) {
  return (self) => someOrFail_(self, orFail);
}
function someOrFail_(self, orFail, __trace) {
  return chain_12(self, fold(() => chain_12(succeedWith3(orFail), fail6), succeed5), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/someOrFailException.mjs
function someOrFailException(self, __trace) {
  return someOrFail_(self, () => new NoSuchElementException(), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/struct.mjs
function struct(r2, __trace) {
  return map_13(forEach_5(collect_(r2, (k2, v2) => [k2, v2]), ([_2, e2]) => map_13(e2, (a2) => [_2, a2]), __trace), (values3) => {
    const res = {};
    for (const [k2, v2] of values3) {
      res[k2] = v2;
    }
    return res;
  });
}
function structPar(r2, __trace) {
  return map_13(forEachPar_(collect_(r2, (k2, v2) => [k2, v2]), ([_2, e2]) => map_13(e2, (a2) => [_2, a2]), __trace), (values3) => {
    const res = {};
    for (const [k2, v2] of values3) {
      res[k2] = v2;
    }
    return res;
  });
}
function structParN(n2, __trace) {
  return (r2) => (
    // @ts-expect-error
    structParN_(r2, n2, __trace)
  );
}
function structParN_(r2, n2, __trace) {
  return map_13(forEachParN_(collect_(r2, (k2, v2) => [k2, v2]), n2, ([_2, e2]) => map_13(e2, (a2) => [_2, a2]), __trace), (values3) => {
    const res = {};
    for (const [k2, v2] of values3) {
      res[k2] = v2;
    }
    return res;
  });
}

// node_modules/@effect-ts/system/_mjs/Effect/summarized.mjs
function summarized_(self, summary, f2, __trace) {
  return suspend4(() => map_13(bind_(bind_(bind_(do_2, "start", () => summary), "value", () => self), "end", () => summary), (s2) => tuple2(f2(s2.start, s2.end), s2.value)), __trace);
}
function summarized(summary, f2, __trace) {
  return (self) => summarized_(self, summary, f2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/swap.mjs
function swap2(__trace) {
  return access3(({
    tuple: [a2, b2]
  }) => tuple2(b2, a2), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/tapEither.mjs
function tapEither_(self, f2, __trace) {
  return chain_12(either2(self), (exit) => chain_12(f2(exit), () => fromEither2(() => exit)));
}
function tapEither(f2, __trace) {
  return (self) => tapEither_(self, f2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/tapExit.mjs
function tapExit_(self, f2, __trace) {
  return foldCauseM_(self, (c2) => fold_2(failureOrCause(c2), (e2) => chain_12(f2(fail5(e2)), (_2) => halt2(c2)), (c3) => halt2(c3)), (a2) => chain_12(f2(succeed4(a2)), (_2) => succeed5(a2)), __trace);
}
function tapExit(f2, __trace) {
  return (self) => tapExit_(self, f2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/timed.mjs
function timedWith_(self, msTime, __trace) {
  return summarized_(self, msTime, (start, end4) => end4 - start, __trace);
}
function timedWith(msTime, __trace) {
  return (self) => timedWith_(self, msTime, __trace);
}
function timed(self, __trace) {
  return timedWith_(self, currentTime, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/timeoutTo.mjs
function timeoutTo(d2, b2, f2, __trace) {
  return (self) => timeoutTo_(self, d2, b2, f2);
}
function timeoutTo_(self, d2, b2, f2, __trace) {
  return raceFirst_(map_13(self, f2), as_(interruptible2(sleep2(d2)), b2), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/timeout.mjs
function timeout(d2, __trace) {
  return (self) => timeout_(self, d2, __trace);
}
function timeout_(self, d2, __trace) {
  return timeoutTo_(self, d2, none, some, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/timeoutFail.mjs
function timeoutFail(d2, e2, __trace) {
  return (self) => timeoutFail_(self, d2, e2, __trace);
}
function timeoutFail_(self, d2, e2, __trace) {
  return flatten8(timeoutTo_(self, d2, suspend4(() => fail6(e2())), succeed5, __trace));
}

// node_modules/@effect-ts/system/_mjs/Effect/timeoutFailCause.mjs
function timeoutFailCause_(self, cause2, d2, __trace) {
  return flatten8(timeoutTo_(self, d2, suspend4(() => halt2(cause2())), (_2) => succeed5(_2), __trace));
}
function timeoutFailCause(cause2, d2, __trace) {
  return (self) => timeoutFailCause_(self, cause2, d2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Layer/core.mjs
function suspend5(f2) {
  return new LayerSuspend(f2);
}
function zipWithPar_3(self, that, f2) {
  return new LayerZipWithPar(self, that, f2);
}
function fail9(e2) {
  return fromRawManaged(fail8(e2));
}
function succeed8(resource) {
  return fromRawManaged(succeed7(resource));
}
function zipWithPar3(that, f2) {
  return (self) => zipWithPar_3(self, that, f2);
}
function zipPar_2(self, that) {
  return zipWithPar_3(self, that, tuple2);
}
function zipPar3(that) {
  return (self) => zipPar_2(self, that);
}
function fromValue(has2) {
  return (resource) => new LayerManaged(fromEffect(succeed5(has2.has(resource)))).setKey(has2.key);
}
function fromEffect2(has2) {
  return (resource) => fromEffect_(resource, has2);
}
function fromEffect_(resource, has2) {
  return new LayerManaged(map_14(fromEffect(resource), has2.has)).setKey(has2.key);
}
function fromManaged(has2) {
  return (resource) => new LayerManaged(map_14(resource, has2.has)).setKey(has2.key);
}
function fromManaged_(resource, has2) {
  return new LayerManaged(map_14(resource, has2.has)).setKey(has2.key);
}
function fromFunction(tag2) {
  return (f2) => fromEffect2(tag2)(access3(f2));
}
function zip_9(self, that) {
  return new LayerZipWithSeq(self, that, tuple2);
}
function zip9(right5) {
  return (left4) => zip_9(left4, right5);
}
function andSeq(that) {
  return (self) => andSeq_(self, that);
}
function andSeq_(self, that) {
  return new LayerZipWithSeq(self, that, (l2, r2) => ({
    ...l2,
    ...r2
  }));
}
function all(...ls) {
  return new LayerAllPar(ls);
}
function allSeq(...ls) {
  return new LayerAllSeq(ls);
}
function main(layer) {
  return layer;
}
function toRuntime(_2) {
  return chain_13(build(_2), (a2) => fromEffect(checkPlatform((platform) => succeedWith3(() => makeCustomRuntime(a2, platform)))));
}
function fresh(layer) {
  return new LayerFresh(layer);
}
function map12(f2) {
  return (fa) => map_18(fa, f2);
}
function map_18(fa, f2) {
  return new LayerMap(fa, f2);
}
function chain11(f2) {
  return (fa) => chain_14(fa, f2);
}
function chain_14(fa, f2) {
  return new LayerChain(fa, f2);
}
function flatten9(ffa) {
  return chain_14(ffa, identity);
}
function restrict(...ts) {
  return (self) => compose_3(self, fromRawEffect(accessServicesT(...ts)((...servises) => servises.map((s2, i2) => ({
    [ts[i2].key]: s2
  })).reduce((x2, y2) => ({
    ...x2,
    ...y2
  })))));
}
function launch(self) {
  return useForever(build(self));
}
function catchAll3(handler) {
  return (self) => {
    return fold7(self)(fromRawFunctionM(({
      tuple: [r2, cause2]
    }) => fold_2(failureOrCause(cause2), (e2) => succeed5(tuple2(r2, e2)), (c2) => halt2(c2)))[">=>"](handler))(fromRawEffect(environment2()));
  };
}
function first3() {
  return fromRawFunction((_2) => _2.get(0));
}
function second2() {
  return fromRawFunction((_2) => _2.get(1));
}
function mapError4(f2) {
  return catchAll3(fromRawFunctionM((_2) => fail6(f2(_2.get(1)))));
}
function orDie2(self) {
  return catchAll3(fromRawFunctionM((_2) => die3(_2.get(1))))(self);
}
function orElse3(that) {
  return catchAll3(first3()[">=>"](that));
}
function retryLoop(self) {
  const update4 = fromRawFunctionM(({
    tuple: [{
      tuple: [r2, s2]
    }, e2]
  }) => provideAll_3(chain_12(orDie(currentTime), (now) => chain_12(s2(now, e2), (result4) => {
    if (result4._tag === "Done") {
      return fail6(e2);
    } else {
      return as_(sleep(Math.abs(now - result4.interval)), tuple2(r2, result4.next));
    }
  })), r2));
  return catchAll3(update4[">=>"](suspend5(() => fresh(retryLoop(self)))))(first3()[">=>"](self));
}
function retry2(self, schedule2) {
  return zipPar_2(identity2(), fromRawEffect(succeed5(schedule2.step)))[">=>"](retryLoop(self));
}

// node_modules/@effect-ts/system/_mjs/Effect/toLayer.mjs
function toLayerRaw(effect2) {
  return fromRawEffect(effect2);
}
function toLayer(tag2) {
  return (effect2) => fromEffect_(effect2, tag2);
}

// node_modules/@effect-ts/system/_mjs/Effect/toLeft.mjs
function toLeftWith(a2, __trace) {
  return chain_12(succeedWith3(a2), (x2) => succeed5(left(x2)), __trace);
}
function toLeft(a2, __trace) {
  return succeed5(left(a2), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/traceMask.mjs
function restore(b2) {
  return (self) => b2 ? traced2(self) : untraced2(self);
}
function untracedMask(f2) {
  return checkTraced((b2) => untraced2(f2(restore(b2))));
}
function tracedMask(f2) {
  return checkTraced((b2) => traced2(f2(restore(b2))));
}

// node_modules/@effect-ts/system/_mjs/Effect/tryCatchOption.mjs
function tryCatchOption_(ma, onNone) {
  return fromEither2(() => fromOption_(ma, onNone));
}
function tryCatchOption(onNone) {
  return (ma) => tryCatchOption_(ma, onNone);
}

// node_modules/@effect-ts/system/_mjs/Effect/union.mjs
function unionFn(_2) {
  return _2;
}
function union(_2) {
  return _2;
}

// node_modules/@effect-ts/system/_mjs/Effect/unless.mjs
function unless(b2, __trace) {
  return (self) => suspend4(() => b2() ? unit3 : asUnit(self), __trace);
}
function unless_(self, b2, __trace) {
  return suspend4(() => b2() ? unit3 : asUnit(self), __trace);
}
function unlessM(b2, __trace) {
  return (self) => unlessM_(self, b2, __trace);
}
function unlessM_(self, b2, __trace) {
  return chain_12(b2, (_2) => _2 ? unit3 : asUnit(self), __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/unoption.mjs
function unoption(self) {
  return foldM_2(self, fold(() => succeed5(none), (_2) => fail6(_2)), (a2) => succeed5(some(a2)));
}

// node_modules/@effect-ts/system/_mjs/Effect/unsome.mjs
function unsome(self) {
  return foldM_2(self, fold(() => succeed5(emptyOf()), fail6), (a2) => succeed5(some(a2)));
}

// node_modules/@effect-ts/system/_mjs/Effect/updateService.mjs
function updateService_(self, tag2, f2, __trace) {
  return provideSome_(self, (r2) => ({
    ...r2,
    ...tag2.has(f2(tag2.read(r2)))
  }), __trace);
}
function updateService(tag2, f2, __trace) {
  return (self) => updateService_(self, tag2, f2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/validate.mjs
function validate_(as6, f2, __trace) {
  return absolve(map_13(forEach_5(as6, (a2) => either2(f2(a2))), mergeExits()), __trace);
}
function validatePar_(as6, f2, __trace) {
  return absolve(map_13(forEachPar_(as6, (a2) => either2(f2(a2))), mergeExits()), __trace);
}
function validateParN_(as6, n2, f2, __trace) {
  return absolve(map_13(forEachParN_(as6, n2, (a2) => either2(f2(a2))), mergeExits()), __trace);
}
function mergeExits() {
  return (exits) => {
    let errors = empty4();
    let results = empty4();
    for (const e2 of exits) {
      if (e2._tag === "Left") {
        errors = append_4(errors, e2.left);
      } else {
        results = append_4(results, e2.right);
      }
    }
    if (!isEmpty5(errors)) {
      return left(errors);
    } else {
      return right(results);
    }
  };
}
function validateExec_(as6, es, f2, __trace) {
  return absolve(map_13(forEachExec_(as6, es, (a2) => either2(f2(a2))), mergeExits()), __trace);
}
function validate(f2, __trace) {
  return (as6) => validate_(as6, f2, __trace);
}
function validatePar(f2, __trace) {
  return (as6) => validatePar_(as6, f2, __trace);
}
function validateParN(n2, f2, __trace) {
  return (as6) => validateParN_(as6, n2, f2, __trace);
}
function validateExec(es, f2, __trace) {
  return (as6) => validateExec_(as6, es, f2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/validateFirst.mjs
function validateFirst_(i2, f2, __trace) {
  return flip(forEach_5(i2, (a2) => flip(f2(a2)), __trace));
}
function validateFirst(f2, __trace) {
  return (i2) => validateFirst_(i2, f2, __trace);
}
function validateFirstPar_(i2, f2, __trace) {
  return flip(forEachPar_(i2, (a2) => flip(f2(a2)), __trace));
}
function validateFirstPar(f2, __trace) {
  return (i2) => validateFirstPar_(i2, f2, __trace);
}
function validateFirstParN_(i2, n2, f2, __trace) {
  return flip(forEachParN_(i2, n2, (a2) => flip(f2(a2)), __trace));
}
function validateFirstParN(n2, f2, __trace) {
  return (i2) => validateFirstParN_(i2, n2, f2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/when.mjs
function when_(self, predicate, __trace) {
  return predicate() ? map_13(self, some, __trace) : succeed5(none, __trace);
}
function when(predicate, __trace) {
  return (self) => when_(self, predicate, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/whenCase.mjs
function whenCase_(a2, pf, __trace) {
  return suspend4(() => {
    const p2 = pf(a2);
    if (p2._tag === "None") {
      return unit3;
    }
    return asUnit(p2.value);
  }, __trace);
}
function whenCase(pf, __trace) {
  return (a2) => whenCase_(a2, pf, __trace);
}

// node_modules/@effect-ts/system/_mjs/Effect/withChildren.mjs
function withChildren(get8, __trace) {
  return chain_12(track, (supervisor) => supervised(supervisor)(get8(chain_12(supervisor.value, (children) => map_13(descriptor2, (d2) => filter_4(children, (_2) => _2.id !== d2.id))))), __trace);
}

// node_modules/@effect-ts/core/_mjs/Modules/index.mjs
var EitherURI = "Either";
var OptionURI = "Option";

// node_modules/@effect-ts/core/_mjs/Prelude/ChainRec/index.mjs
function tailRec(a2, f2) {
  let v2 = f2(a2);
  while (v2._tag === "Left") {
    v2 = f2(v2.left);
  }
  return v2.right;
}

// node_modules/@effect-ts/core/_mjs/Prelude/DSL/alternative.mjs
function orElseF(F2) {
  return (fb) => (fa) => F2.map((e2) => e2._tag === "Left" ? e2.left : e2.right)(F2.orElseEither(fb)(fa));
}

// node_modules/@effect-ts/core/_mjs/Prelude/DSL/chain.mjs
function chainF(F2) {
  return (f2) => (x2) => F2.flatten(F2.map(f2)(x2));
}

// node_modules/@effect-ts/core/_mjs/Prelude/DSL/applicative.mjs
function getApplicativeF(F2) {
  const chain14 = chainF(F2);
  return {
    any: F2.any,
    map: F2.map,
    both: (fb) => (fa) => chain14((a2) => F2.map((b2) => tuple2(b2, a2))(fa))(fb)
  };
}

// node_modules/@effect-ts/core/_mjs/Prelude/DSL/apply.mjs
function apF(F2) {
  return (fa) => (fab) => F2.map(({
    tuple: [a2, f2]
  }) => f2(a2))(F2.both(fab)(fa));
}
function curried(f2, n2, acc) {
  return function(x2) {
    const combined = acc.concat([x2]);
    return n2 === 0 ? f2.apply(null, combined) : curried(f2, n2 - 1, combined);
  };
}
function getRecordConstructor(keys4) {
  const len = keys4.length;
  return curried((...args) => {
    const r2 = {};
    for (let i2 = 0; i2 < len; i2++) {
      r2[keys4[i2]] = args[i2];
    }
    return r2;
  }, len - 1, []);
}
function structF(F2) {
  const ap7 = apF(F2);
  return (r2) => {
    const keys4 = Object.keys(r2);
    const len = keys4.length;
    const f2 = getRecordConstructor(keys4);
    let fr = F2.map(f2)(r2[keys4[0]]);
    for (let i2 = 1; i2 < len; i2++) {
      fr = ap7(r2[keys4[i2]])(fr);
    }
    return fr;
  };
}
var tupleConstructors = {};
function getTupleConstructor(len) {
  if (!tupleConstructors.hasOwnProperty(len)) {
    tupleConstructors[len] = curried(tuple, len - 1, []);
  }
  return tupleConstructors[len];
}
function tupleF(F2) {
  const ap7 = apF(F2);
  return (...args) => {
    const len = args.length;
    const f2 = getTupleConstructor(len);
    let fas = F2.map(f2)(args[0]);
    for (let i2 = 1; i2 < len; i2++) {
      fas = ap7(args[i2])(fas);
    }
    return fas;
  };
}

// node_modules/@effect-ts/core/_mjs/Prelude/DSL/conditionals.mjs
function conditionalF(_2) {
  return (onTrue, onFalse) => (b2) => b2 ? onTrue() : onFalse();
}
function conditionalF_(_2) {
  return (predicate, onTrue, onFalse) => predicate ? onTrue() : onFalse();
}

// node_modules/@effect-ts/core/_mjs/Prelude/DSL/succeed.mjs
function succeedF(F2) {
  return (a2) => F2.map(constant(a2))(F2.any());
}

// node_modules/@effect-ts/core/_mjs/Prelude/DSL/do.mjs
function doF(F2) {
  return succeedF(F2)({});
}
function bindF(F2) {
  return (tag2, f2) => (mk) => chainF(F2)((k2) => F2.map((a2) => Object.assign({}, k2, {
    [tag2]: a2
  }))(f2(k2)))(mk);
}
function letF(F2) {
  return (tag2, f2) => (mk) => F2.map((k2) => Object.assign({}, k2, {
    [tag2]: f2(k2)
  }))(mk);
}

// node_modules/@effect-ts/core/_mjs/Prelude/DSL/gen.mjs
var GenHKT = class {
  constructor(effect2) {
    this.effect = effect2;
  }
  *[Symbol.iterator]() {
    return yield this;
  }
};
var adapter5 = (_2) => {
  return new GenHKT(_2);
};
function genF(F2, config) {
  const chain14 = chainF(F2);
  const succeed12 = succeedF(F2);
  return (f2) => {
    return chain14(() => {
      const iterator = f2((config === null || config === void 0 ? void 0 : config.adapter) ? config.adapter : adapter5);
      const state = iterator.next();
      function run7(state2) {
        if (state2.done) {
          return succeed12(state2.value);
        }
        return chain14((val) => {
          const next2 = iterator.next(val);
          return run7(next2);
        })(state2.value["effect"]);
      }
      return run7(state);
    })(succeed12({}));
  };
}

// node_modules/@effect-ts/core/_mjs/Prelude/DSL/matchers.mjs
function matchers(_2) {
  function match4(tag2) {
    return (...args) => {
      return (_3) => {
        const matcher = args[0][_3[tag2]];
        return matcher ? matcher(_3, _3) : args[1](_3, _3);
      };
    };
  }
  function matchIn4(tag2) {
    return () => (...args) => {
      return (_3) => {
        const matcher = args[0][_3[tag2]];
        return matcher ? matcher(_3, _3) : args[1](_3, _3);
      };
    };
  }
  function matchMorph4(MorphADT) {
    return (...args) => {
      return (_3) => {
        const matcher = args[0][_3[MorphADT.tag]];
        return matcher ? matcher(_3, _3) : args[1](_3, _3);
      };
    };
  }
  const matchTagIn4 = matchIn4("_tag");
  const matchTag5 = match4("_tag");
  return {
    match: match4,
    matchTag: matchTag5,
    matchIn: matchIn4,
    matchTagIn: matchTagIn4,
    matchMorph: matchMorph4
  };
}

// node_modules/@effect-ts/core/_mjs/Prelude/DSL/validation.mjs
function getValidationF(F2) {
  return (A2) => ({
    any: F2.any,
    map: F2.map,
    both: (fb) => (fa) => F2.flatten(F2.map(({
      tuple: [maybeA, maybeB]
    }) => fold_2(maybeA, (ea) => fold_2(maybeB, (eb) => F2.fail(A2.combine(ea, eb)), () => F2.fail(ea)), (a2) => fold_2(maybeB, (e2) => F2.fail(e2), (b2) => succeedF(F2)(tuple2(a2, b2)))))(F2.both(F2.either(fb))(F2.either(fa))))
  });
}

// node_modules/@effect-ts/core/_mjs/Prelude/ForEach/index.mjs
function implementForEachF() {
  return (i2) => i2();
}
function sequenceF(T2) {
  return (App) => {
    const traverse = T2.forEachF(App);
    return traverse(identity);
  };
}

// node_modules/@effect-ts/core/_mjs/Prelude/ForEachWithIndex/index.mjs
function implementForEachWithIndexF() {
  return (i2) => i2();
}

// node_modules/@effect-ts/core/_mjs/Prelude/Wiltable/index.mjs
function implementSeparateF() {
  return (i2) => i2();
}

// node_modules/@effect-ts/core/_mjs/Prelude/WiltableWithIndex/index.mjs
function implementSeparateWithIndexF() {
  return (i2) => i2();
}

// node_modules/@effect-ts/core/_mjs/Prelude/Witherable/index.mjs
function implementCompactF() {
  return (i2) => i2();
}

// node_modules/@effect-ts/core/_mjs/Prelude/WitherableWithIndex/index.mjs
function implementCompactWithIndexF() {
  return (i2) => i2();
}

// node_modules/@effect-ts/core/_mjs/Associative/makeAssociative.mjs
function makeAssociative(f2) {
  return {
    combine: f2
  };
}

// node_modules/@effect-ts/core/_mjs/Associative/operations.mjs
function fold8(S2) {
  return (a2) => (as6) => as6.reduce((x2, y2) => S2.combine(x2, y2), a2);
}

// node_modules/@effect-ts/core/_mjs/Associative/common.mjs
var all2 = /* @__PURE__ */ makeAssociative((x2, y2) => x2 && y2);

// node_modules/@effect-ts/core/_mjs/Identity/makeIdentity.mjs
function makeIdentity(identity4, op) {
  return {
    combine: op,
    identity: identity4
  };
}

// node_modules/@effect-ts/core/_mjs/Identity/operations.mjs
function fold9(M2) {
  const foldM6 = fold8(M2);
  return foldM6(M2.identity);
}

// node_modules/@effect-ts/core/_mjs/Identity/common.mjs
function fromAssociative(A2) {
  return (identity4) => makeIdentity(identity4, A2.combine);
}
var all3 = /* @__PURE__ */ makeIdentity(true, all2.combine);

// node_modules/@effect-ts/core/_mjs/Effect/instances.mjs
var Any = {
  any: () => succeed5({})
};
var AssociativeEither = {
  orElseEither: orElseEither3
};
var AssociativeFlatten = {
  flatten: flatten8
};
var AssociativeBoth = {
  both: zip5
};
var Covariant = {
  map: map9
};
var IdentityFlatten = {
  ...Any,
  ...AssociativeFlatten
};
var IdentityBoth = {
  ...Any,
  ...AssociativeBoth
};
var Monad = {
  ...IdentityFlatten,
  ...Covariant
};
var Applicative = {
  ...Covariant,
  ...IdentityBoth
};
var Fail3 = {
  fail: fail6
};
var Run = {
  either: either2
};
var Access2 = {
  access: access3
};
var Provide2 = {
  provide: provideAll2
};
var getValidationApplicative = /* @__PURE__ */ getValidationF({
  ...Monad,
  ...Run,
  ...Fail3,
  ...Applicative
});
var Category = {
  id: environment2,
  compose
};
var {
  match,
  matchIn,
  matchMorph,
  matchTag: matchTag2,
  matchTagIn
} = /* @__PURE__ */ matchers(Covariant);
function getIdentity(Id) {
  return () => makeIdentity(succeed5(Id.identity), (x2, y2) => zipWith_4(x2, y2, Id.combine));
}
function getIdentityPar(Id) {
  return () => makeIdentity(succeed5(Id.identity), (x2, y2) => zipWithPar_(x2, y2, Id.combine));
}

// node_modules/@effect-ts/core/_mjs/Effect/operations.mjs
function forEachOf(C2) {
  return function() {
    if (arguments.length >= 2 && typeof arguments[1] !== "string") {
      return suspend4(() => {
        let builder2 = C2.builder();
        return map_13(forEachUnit_(arguments[0], (a2) => map_13(arguments[1](a2), (aa) => {
          builder2 = builder2.append(aa);
        }), arguments[2]), () => builder2.build());
      });
    }
    return (self) => forEachOf(C2)(self, arguments[0], arguments[1]);
  };
}
function forEachParOf(C2) {
  return function() {
    if (arguments.length >= 2 && typeof arguments[1] !== "string") {
      return map_13(forEachPar_(arguments[0], arguments[1], arguments[2]), (arr) => {
        let builder2 = C2.builder();
        for (const b2 of arr) {
          builder2 = builder2.append(b2);
        }
        return builder2.build();
      });
    }
    return (self) => forEachParOf(C2)(self, arguments[0], arguments[1]);
  };
}
function forEachParNOf(C2) {
  return function() {
    if (arguments.length >= 3 && typeof arguments[2] !== "string") {
      return map_13(forEachParN_(arguments[0], arguments[1], arguments[2], arguments[3]), (arr) => {
        let builder2 = C2.builder();
        for (const b2 of arr) {
          builder2 = builder2.append(b2);
        }
        return builder2.build();
      });
    }
    return (self) => forEachParNOf(C2)(self, arguments[0], arguments[1], arguments[2]);
  };
}

// node_modules/@effect-ts/core/_mjs/Effect/Layer/index.mjs
var Layer_exports2 = {};
__export(Layer_exports2, {
  Any: () => Any2,
  Applicative: () => Applicative2,
  AssociativeBoth: () => AssociativeBoth2,
  AssociativeFlatten: () => AssociativeFlatten2,
  Covariant: () => Covariant2,
  Empty: () => Empty4,
  IdentityBoth: () => IdentityBoth2,
  IdentityFlatten: () => IdentityFlatten2,
  Layer: () => Layer,
  MainProvider: () => MainProvider,
  MemoMap: () => MemoMap,
  Monad: () => Monad2,
  all: () => all,
  allSeq: () => allSeq,
  and: () => and,
  andSeq: () => andSeq,
  andSeq_: () => andSeq_,
  and_: () => and_,
  build: () => build,
  catchAll: () => catchAll3,
  chain: () => chain11,
  chain_: () => chain_14,
  compose: () => compose2,
  compose_: () => compose_3,
  fail: () => fail9,
  first: () => first3,
  flatten: () => flatten9,
  fold: () => fold7,
  fresh: () => fresh,
  fromEffect: () => fromEffect2,
  fromEffect_: () => fromEffect_,
  fromFunction: () => fromFunction,
  fromManaged: () => fromManaged,
  fromManaged_: () => fromManaged_,
  fromRawEffect: () => fromRawEffect,
  fromRawFunction: () => fromRawFunction,
  fromRawFunctionM: () => fromRawFunctionM,
  fromRawManaged: () => fromRawManaged,
  fromValue: () => fromValue,
  identity: () => identity2,
  launch: () => launch,
  main: () => main,
  makeMemoMap: () => makeMemoMap,
  map: () => map12,
  mapError: () => mapError4,
  map_: () => map_18,
  orDie: () => orDie2,
  orElse: () => orElse3,
  restrict: () => restrict,
  retry: () => retry2,
  scope: () => scope,
  second: () => second2,
  succeed: () => succeed8,
  suspend: () => suspend5,
  toRuntime: () => toRuntime,
  unsafeMainProvider: () => unsafeMainProvider,
  using: () => using,
  usingAnd: () => usingAnd,
  zip: () => zip9,
  zipPar: () => zipPar3,
  zipPar_: () => zipPar_2,
  zipWithPar: () => zipWithPar3,
  zipWithPar_: () => zipWithPar_3,
  zip_: () => zip_9
});

// node_modules/@effect-ts/system/_mjs/Managed/ReleaseMap/replace.mjs
function replace(key, finalizer2) {
  return (_2) => flatten8(modify_2(_2.ref, (s2) => {
    switch (s2._tag) {
      case "Exited":
        return tuple2(map_13(finalizer2(s2.exit), () => none), new Exited(s2.nextKey, s2.exit));
      case "Running":
        return tuple2(succeed5(lookup(key)(s2.finalizers())), new Running(s2.nextKey, insert(key, finalizer2)(s2.finalizers())));
      default:
        return absurd(s2);
    }
  }));
}

// node_modules/@effect-ts/system/_mjs/Promise/isDone.mjs
function isDone(promise2) {
  return succeedWith3(() => promise2.state.get._tag === "Done");
}

// node_modules/@effect-ts/system/_mjs/Promise/makeManaged.mjs
function makeManaged() {
  return toManaged(chain_12(fiberId, (id) => makeAs(id)));
}

// node_modules/@effect-ts/system/_mjs/Promise/poll.mjs
function poll(promise2) {
  return succeedWith3(() => {
    const state = promise2.state.get;
    switch (state._tag) {
      case "Done": {
        return some(state.value);
      }
      case "Pending": {
        return none;
      }
    }
  });
}

// node_modules/@effect-ts/system/_mjs/Layer/unsafe.mjs
var MainProvider = class {
  constructor(allocate2, release4, provide4) {
    this.allocate = allocate2;
    this.release = release4;
    this.provide = provide4;
  }
};
function unsafeMainProvider(self) {
  const promise2 = unsafeMake(None2);
  const relMap = new ReleaseMap(unsafeMakeRef(new Running(0, /* @__PURE__ */ new Map())));
  return new MainProvider(foldCauseM_(map_13(provideSome_(build(self["+++"](identity2())).effect, (r2) => tuple2(r2, relMap)), (_2) => _2.get(1)), (cause2) => chain_12(halt_(promise2, cause2), () => halt2(cause2)), (r2) => succeed6(r2)(promise2)), descriptorWith((d2) => asUnit(releaseMapReleaseAll(interrupt2(d2.id), sequential)(relMap))), (self2) => chain_12(wait(promise2), (env) => provide_(self2, env)));
}

// node_modules/@effect-ts/core/_mjs/Effect/Layer/instances.mjs
var AssociativeBoth2 = {
  both: zip9
};
var Any2 = {
  any: () => fromRawEffect(succeed5({}))
};
var Covariant2 = {
  map: map12
};
var IdentityBoth2 = {
  ...Any2,
  ...AssociativeBoth2
};
var Applicative2 = {
  ...Covariant2,
  ...IdentityBoth2
};
var AssociativeFlatten2 = {
  flatten: flatten9
};
var IdentityFlatten2 = {
  ...Any2,
  ...AssociativeFlatten2
};
var Monad2 = {
  ...Covariant2,
  ...IdentityFlatten2
};

// node_modules/@contentlayer2/utils/dist/effect/ConsoleService.js
var makeLiveConsole = succeedWith3(() => ({
  log: (...msg) => succeedWith3(() => {
    console.log(...msg);
  })
}));
var ConsoleService = tag();
var LiveConsole = fromEffect2(ConsoleService)(makeLiveConsole);
var provideConsole = provideSomeLayer(LiveConsole);
var { log } = deriveLifted(ConsoleService)(["log"], [], []);

// node_modules/@effect-ts/system/_mjs/Case/index.mjs
var CaseBrand = /* @__PURE__ */ Symbol();
var h0 = /* @__PURE__ */ hashString("@effect-ts/system/Case");
var caseArgs = /* @__PURE__ */ Symbol();
var caseKeys = /* @__PURE__ */ Symbol();
var Case = class {
  constructor(args) {
    this[caseArgs] = args;
    if (typeof args === "object" && args != null) {
      const keys4 = Object.keys(args);
      for (let i2 = 0; i2 < keys4.length; i2++) {
        this[keys4[i2]] = args[keys4[i2]];
      }
    }
    this[caseKeys] = Object.keys(this).sort();
  }
  static make(args) {
    return new this(args);
  }
  copy(args) {
    return new this.constructor({
      ...this[caseArgs],
      ...args
    });
  }
  get [CaseBrand]() {
    return this[caseKeys];
  }
  get [hashSym]() {
    let h2 = h0;
    for (const k2 of this[caseKeys]) {
      h2 = combineHash(h2, hash(this[k2]));
    }
    return h2;
  }
  [equalsSym](that) {
    if (this === that) {
      return true;
    }
    if (that instanceof this.constructor) {
      const kthat = that[CaseBrand];
      const len = kthat.length;
      if (len !== this[caseKeys].length) {
        return false;
      }
      let eq = true;
      let i2 = 0;
      while (eq && i2 < len) {
        eq = this[caseKeys][i2] === kthat[i2] && equals(this[this[caseKeys][i2]], that[kthat[i2]]);
        i2++;
      }
      return eq;
    }
    return false;
  }
};
function Tagged(tag2, key) {
  var _a12;
  if (key) {
    class X3 extends Case {
      constructor() {
        super(...arguments);
        this[_a12] = tag2;
      }
    }
    _a12 = key;
    X3._tag = tag2;
    return X3;
  }
  class X2 extends Case {
    constructor() {
      super(...arguments);
      this._tag = tag2;
    }
  }
  X2._tag = tag2;
  return X2;
}

// node_modules/@effect-ts/core/_mjs/Effect/Cause/index.mjs
var Cause_exports2 = {};
__export(Cause_exports2, {
  Both: () => Both,
  CauseSym: () => CauseSym,
  Die: () => Die,
  Empty: () => Empty2,
  Fail: () => Fail,
  FiberFailure: () => FiberFailure,
  FiberFailureSymbol: () => FiberFailureSymbol,
  IllegalArgumentException: () => IllegalArgumentException,
  IllegalArgumentSymbol: () => IllegalArgumentSymbol,
  IllegalStateException: () => IllegalStateException,
  IllegalStateSymbol: () => IllegalStateSymbol,
  Interrupt: () => Interrupt,
  InterruptedException: () => InterruptedException,
  InterruptedSymbol: () => InterruptedSymbol,
  RuntimeError: () => RuntimeError,
  RuntimeSymbol: () => RuntimeSymbol,
  Then: () => Then,
  Traced: () => Traced,
  Untraced: () => Untraced,
  UntracedSymbol: () => UntracedSymbol,
  ap: () => ap3,
  as: () => as,
  bind: () => bind,
  chain: () => chain6,
  chainSafe_: () => chainSafe_,
  chain_: () => chain_10,
  combinePar: () => combinePar,
  combineSeq: () => combineSeq,
  contains: () => contains,
  containsSafe: () => containsSafe,
  defaultRenderer: () => defaultRenderer,
  defects: () => defects,
  die: () => die,
  dieOption: () => dieOption,
  died: () => died,
  do: () => do_,
  empty: () => empty3,
  equals: () => equals2,
  fail: () => fail2,
  failed: () => failed,
  failureOption: () => failureOption,
  failureOrCause: () => failureOrCause,
  failures: () => failures,
  find: () => find,
  findSafe: () => findSafe,
  flatten: () => flatten6,
  flipCauseOption: () => flipCauseOption,
  fold: () => fold4,
  foldSafe: () => foldSafe,
  interrupt: () => interrupt,
  interruptOption: () => interruptOption,
  interrupted: () => interrupted,
  interruptedOnly: () => interruptedOnly,
  interruptors: () => interruptors,
  isCause: () => isCause,
  isEmpty: () => isEmpty4,
  isFiberFailure: () => isFiberFailure,
  isIllegalArgumentException: () => isIllegalArgumentException,
  isIllegalStateException: () => isIllegalStateException,
  isInterruptedException: () => isInterruptedException,
  isRuntime: () => isRuntime,
  isUntraced: () => isUntraced,
  keepDefects: () => keepDefects,
  keepDefectsSafe: () => keepDefectsSafe,
  let: () => let_,
  map: () => map7,
  map_: () => map_11,
  pretty: () => pretty,
  reduceLeft: () => reduceLeft,
  sequenceCauseEither: () => sequenceCauseEither,
  sequenceCauseEitherSafe: () => sequenceCauseEitherSafe,
  sequenceCauseOption: () => sequenceCauseOption,
  sequenceCauseOptionSafe: () => sequenceCauseOptionSafe,
  squash: () => squash,
  stripFailures: () => stripFailures,
  stripFailuresSafe: () => stripFailuresSafe,
  stripInterrupts: () => stripInterrupts,
  stripInterruptsSafe: () => stripInterruptsSafe,
  stripSomeDefects: () => stripSomeDefects,
  stripSomeDefectsSafe: () => stripSomeDefectsSafe,
  stripSomeDefects_: () => stripSomeDefects_,
  traced: () => traced,
  untraced: () => untraced,
  untracedSafe: () => untracedSafe
});

// node_modules/@effect-ts/core/_mjs/Effect/State/index.mjs
var State_exports = {};
__export(State_exports, {
  State: () => State,
  makeState: () => makeState
});
function makeState(initial2) {
  return map_13(makeRef(initial2), (ref) => ({
    get: get4(ref),
    modify: (f2) => modify_2(ref, f2),
    set: (s2) => set_2(ref, s2),
    update: (f2) => update_3(ref, f2)
  }));
}
function State(S2) {
  const Tag = tag(S2);
  const derived = deriveLifted(Tag)(["set", "update"], ["get"], []);
  return {
    Tag,
    modify: (f2) => accessServiceM2(Tag)((_2) => _2.modify(f2)),
    runState: (s2) => provideServiceM(Tag)(makeState(s2)),
    Live: (s2) => fromEffect_(makeState(s2), Tag),
    ...derived
  };
}

// node_modules/@contentlayer2/utils/dist/effect/Stream.js
var Stream_exports = {};
__export(Stream_exports, {
  DEFAULT_CHUNK_SIZE: () => DEFAULT_CHUNK_SIZE,
  Emit: () => Emit3,
  End: () => End2,
  Halt: () => Halt3,
  Stream: () => Stream,
  StreamTimeoutError: () => StreamTimeoutError,
  StreamTimeoutSymbol: () => StreamTimeoutSymbol,
  StreamTypeId: () => StreamTypeId,
  absolve: () => absolve3,
  access: () => access5,
  accessEffect: () => accessEffect,
  accessServiceEffect: () => accessServiceEffect,
  accessStream: () => accessStream,
  acquireReleaseExitWith: () => acquireReleaseExitWith,
  acquireReleaseExitWith_: () => acquireReleaseExitWith_2,
  acquireReleaseWith: () => acquireReleaseWith,
  acquireReleaseWith_: () => acquireReleaseWith_,
  aggregateAsync: () => aggregateAsync,
  aggregateAsyncWithin: () => aggregateAsyncWithin,
  aggregateAsyncWithinEither: () => aggregateAsyncWithinEither,
  aggregateAsyncWithinEither_: () => aggregateAsyncWithinEither_,
  aggregateAsyncWithin_: () => aggregateAsyncWithin_,
  aggregateAsync_: () => aggregateAsync_,
  as: () => as5,
  as_: () => as_4,
  async: () => async,
  asyncEffect: () => asyncEffect,
  asyncInterrupt: () => asyncInterrupt,
  asyncMaybe: () => asyncMaybe,
  bind: () => bind6,
  branchAfter: () => branchAfter,
  branchAfter_: () => branchAfter_,
  broadcast: () => broadcast,
  broadcastDynamic: () => broadcastDynamic,
  broadcastDynamic_: () => broadcastDynamic_,
  broadcast_: () => broadcast_,
  broadcastedQueues: () => broadcastedQueues,
  broadcastedQueuesDynamic: () => broadcastedQueuesDynamic,
  broadcastedQueuesDynamic_: () => broadcastedQueuesDynamic_,
  broadcastedQueues_: () => broadcastedQueues_,
  buffer: () => buffer,
  bufferChunks: () => bufferChunks,
  bufferChunksDropping: () => bufferChunksDropping,
  bufferChunksDropping_: () => bufferChunksDropping_,
  bufferChunksSliding: () => bufferChunksSliding,
  bufferChunksSliding_: () => bufferChunksSliding_,
  bufferChunks_: () => bufferChunks_,
  bufferUnbounded: () => bufferUnbounded,
  buffer_: () => buffer_,
  catchAll: () => catchAll5,
  catchAllCause: () => catchAllCause3,
  catchAllCause_: () => catchAllCause_4,
  catchAll_: () => catchAll_5,
  catchSome: () => catchSome3,
  catchSomeCause: () => catchSomeCause3,
  catchSomeCause_: () => catchSomeCause_3,
  catchSome_: () => catchSome_3,
  catchTag: () => catchTag2,
  catchTag_: () => catchTag_2,
  chain: () => chain12,
  chainMapEitherRight: () => chainMapEitherRight,
  chainPar: () => chainPar,
  chainParSwitch: () => chainParSwitch,
  chainParSwitch_: () => chainParSwitch_,
  chainPar_: () => chainPar_,
  chainSwitchMapEitherRight: () => chainSwitchMapEitherRight,
  chain_: () => chain_16,
  changes: () => changes,
  changesWith: () => changesWith,
  changesWith_: () => changesWith_,
  chunks: () => chunks,
  collect: () => collect4,
  collectEffect: () => collectEffect2,
  collectEffect_: () => collectEffect_2,
  collectLeft: () => collectLeft,
  collectRight: () => collectRight,
  collectSome: () => collectSome,
  collectSuccess: () => collectSuccess,
  collectWhile: () => collectWhile2,
  collectWhileEffect: () => collectWhileEffect2,
  collectWhileEffect_: () => collectWhileEffect_2,
  collectWhileLeft: () => collectWhileLeft,
  collectWhileRight: () => collectWhileRight,
  collectWhileSome: () => collectWhileSome,
  collectWhileSuccess: () => collectWhileSuccess,
  collectWhile_: () => collectWhile_2,
  collect_: () => collect_5,
  combine: () => combine2,
  combineChunks: () => combineChunks,
  combineChunks_: () => combineChunks_,
  combine_: () => combine_,
  concat: () => concat3,
  concatAll: () => concatAll,
  concat_: () => concat_4,
  cross: () => cross,
  crossLeft: () => crossLeft,
  crossLeft_: () => crossLeft_,
  crossRight: () => crossRight,
  crossRight_: () => crossRight_,
  crossWith: () => crossWith,
  crossWith_: () => crossWith_,
  cross_: () => cross_,
  debounce: () => debounce,
  debounce_: () => debounce_,
  defaultIfEmpty: () => defaultIfEmpty,
  defaultIfEmpty_: () => defaultIfEmpty_,
  die: () => die6,
  dieMessage: () => dieMessage3,
  dieWith: () => dieWith4,
  distributedWith: () => distributedWith,
  distributedWithDynamic: () => distributedWithDynamic,
  distributedWithDynamic_: () => distributedWithDynamic_,
  distributedWith_: () => distributedWith_,
  do: () => do_6,
  done: () => done6,
  drain: () => drain3,
  drainFork: () => drainFork,
  drainFork_: () => drainFork_,
  drop: () => drop2,
  dropRight: () => dropRight2,
  dropRight_: () => dropRight_2,
  dropUntil: () => dropUntil,
  dropUntil_: () => dropUntil_,
  dropWhile: () => dropWhile4,
  dropWhileEffect: () => dropWhileEffect3,
  dropWhileEffect_: () => dropWhileEffect_2,
  dropWhile_: () => dropWhile_3,
  drop_: () => drop_3,
  effect: () => effect,
  effectOption: () => effectOption,
  either: () => either4,
  empty: () => empty7,
  ensuring: () => ensuring3,
  ensuring_: () => ensuring_4,
  environment: () => environment4,
  execute: () => execute,
  fail: () => fail12,
  failCause: () => failCause5,
  failWith: () => failWith4,
  filter: () => filter5,
  filterEffect: () => filterEffect2,
  filterEffect_: () => filterEffect_2,
  filterNot: () => filterNot2,
  filterNot_: () => filterNot_2,
  filter_: () => filter_8,
  find: () => find3,
  findEffect: () => findEffect2,
  findEffect_: () => findEffect_2,
  find_: () => find_3,
  fixed: () => fixed2,
  fixed_: () => fixed_,
  flatten: () => flatten12,
  flattenChunks: () => flattenChunks,
  flattenExit: () => flattenExit,
  flattenExitOption: () => flattenExitOption,
  flattenIterables: () => flattenIterables,
  flattenPar: () => flattenPar,
  flattenParUnbounded: () => flattenParUnbounded,
  flattenParUnbounded_: () => flattenParUnbounded_,
  flattenPar_: () => flattenPar_,
  flattenTake: () => flattenTake,
  forEach: () => forEach7,
  forEach_: () => forEach_8,
  forever: () => forever3,
  fromChunk: () => fromChunk,
  fromChunkHub: () => fromChunkHub,
  fromChunkHubManaged: () => fromChunkHubManaged,
  fromChunkHubManagedWithShutdown: () => fromChunkHubManagedWithShutdown,
  fromChunkHubWithShutdown: () => fromChunkHubWithShutdown,
  fromChunkQueue: () => fromChunkQueue,
  fromChunkQueueWithShutdown: () => fromChunkQueueWithShutdown,
  fromChunkWith: () => fromChunkWith,
  fromChunks: () => fromChunks,
  fromEffect: () => fromEffect4,
  fromEffectOption: () => fromEffectOption,
  fromHub: () => fromHub,
  fromHubManaged: () => fromHubManaged,
  fromHubManagedWithShutdown: () => fromHubManagedWithShutdown,
  fromHubManagedWithShutdown_: () => fromHubManagedWithShutdown_,
  fromHubManaged_: () => fromHubManaged_,
  fromHubWithShutdown: () => fromHubWithShutdown,
  fromHubWithShutdown_: () => fromHubWithShutdown_,
  fromHub_: () => fromHub_,
  fromIterable: () => fromIterable,
  fromIterableEffect: () => fromIterableEffect,
  fromPull: () => fromPull2,
  fromQueue: () => fromQueue,
  fromQueueWithShutdown: () => fromQueueWithShutdown,
  fromQueueWithShutdown_: () => fromQueueWithShutdown_,
  fromQueue_: () => fromQueue_,
  fromSchedule: () => fromSchedule,
  fromValue: () => fromValue2,
  groupAdjacentBy: () => groupAdjacentBy,
  groupAdjacentBy_: () => groupAdjacentBy_,
  groupBy: () => groupBy,
  groupByKey: () => groupByKey,
  groupByKey_: () => groupByKey_,
  groupBy_: () => groupBy_,
  grouped: () => grouped2,
  groupedWithin: () => groupedWithin,
  groupedWithin_: () => groupedWithin_,
  grouped_: () => grouped_2,
  halfAfter: () => halfAfter,
  halfAfter_: () => halfAfter_,
  haltWhen: () => haltWhen,
  haltWhenP: () => haltWhenP,
  haltWhenP_: () => haltWhenP_,
  haltWhen_: () => haltWhen_,
  interleave: () => interleave,
  interleaveWith: () => interleaveWith,
  interleaveWith_: () => interleaveWith_,
  interleave_: () => interleave_,
  interruptAfter: () => interruptAfter,
  interruptAfter_: () => interruptAfter_,
  interruptWhen: () => interruptWhen,
  interruptWhenP: () => interruptWhenP,
  interruptWhenP_: () => interruptWhenP_2,
  interruptWhen_: () => interruptWhen_2,
  intersperse: () => intersperse,
  intersperseAffixes: () => intersperseAffixes,
  intersperseAffixes_: () => intersperseAffixes_,
  intersperse_: () => intersperse_,
  isStream: () => isStream,
  isStreamTimeoutError: () => isStreamTimeoutError,
  let: () => let_6,
  loopOnChunks: () => loopOnChunks,
  loopOnChunks_: () => loopOnChunks_,
  loopOnPartialChunks: () => loopOnPartialChunks,
  loopOnPartialChunksElements: () => loopOnPartialChunksElements,
  loopOnPartialChunksElements_: () => loopOnPartialChunksElements_,
  loopOnPartialChunks_: () => loopOnPartialChunks_,
  make: () => make11,
  managed: () => managed,
  map: () => map13,
  mapAccum: () => mapAccum2,
  mapAccumEffect: () => mapAccumEffect2,
  mapAccumEffect_: () => mapAccumEffect_2,
  mapAccum_: () => mapAccum_2,
  mapBoth: () => mapBoth2,
  mapBoth_: () => mapBoth_3,
  mapChunks: () => mapChunks,
  mapChunksEffect: () => mapChunksEffect,
  mapChunksEffect_: () => mapChunksEffect_,
  mapChunks_: () => mapChunks_,
  mapConcat: () => mapConcat,
  mapConcatChunk: () => mapConcatChunk,
  mapConcatChunkEffect: () => mapConcatChunkEffect,
  mapConcatChunkEffect_: () => mapConcatChunkEffect_,
  mapConcatChunk_: () => mapConcatChunk_,
  mapConcatEffect: () => mapConcatEffect,
  mapConcatEffect_: () => mapConcatEffect_,
  mapConcat_: () => mapConcat_,
  mapEffect: () => mapEffect3,
  mapEffectEitherRight: () => mapEffectEitherRight,
  mapEffectPar: () => mapEffectPar2,
  mapEffectParUnordered: () => mapEffectParUnordered,
  mapEffectParUnordered_: () => mapEffectParUnordered_,
  mapEffectPartitioned: () => mapEffectPartitioned,
  mapEffectPartitioned_: () => mapEffectPartitioned_,
  mapEffect_: () => mapEffect_3,
  mapEitherLeft: () => mapEitherLeft,
  mapEitherRight: () => mapEitherRight,
  mapError: () => mapError6,
  mapErrorCause: () => mapErrorCause4,
  mapErrorCause_: () => mapErrorCause_4,
  mapError_: () => mapError_6,
  map_: () => map_20,
  merge: () => merge4,
  mergeAll: () => mergeAll3,
  mergeAllUnbounded: () => mergeAllUnbounded,
  mergeEither: () => mergeEither,
  mergeEither_: () => mergeEither_,
  mergeGroupBy: () => mergeGroupBy,
  mergeGroupBy_: () => mergeGroupBy_,
  mergeTerminateEither: () => mergeTerminateEither,
  mergeTerminateEither_: () => mergeTerminateEither_,
  mergeTerminateLeft: () => mergeTerminateLeft,
  mergeTerminateLeft_: () => mergeTerminateLeft_,
  mergeTerminateRight: () => mergeTerminateRight,
  mergeTerminateRight_: () => mergeTerminateRight_,
  mergeWith: () => mergeWith,
  merge_: () => merge_,
  never: () => never2,
  onError: () => onError2,
  onError_: () => onError_2,
  orElse: () => orElse5,
  orElseEither: () => orElseEither5,
  orElseEither_: () => orElseEither_5,
  orElseFail: () => orElseFail4,
  orElseFail_: () => orElseFail_3,
  orElseOptional: () => orElseOptional3,
  orElseOptional_: () => orElseOptional_3,
  orElseSucceed: () => orElseSucceed3,
  orElseSucceed_: () => orElseSucceed_3,
  orElse_: () => orElse_5,
  paginate: () => paginate,
  paginateChunk: () => paginateChunk,
  paginateChunkEffect: () => paginateChunkEffect,
  paginateEffect: () => paginateEffect,
  partition: () => partition4,
  partitionEither: () => partitionEither,
  partitionEither_: () => partitionEither_,
  partition_: () => partition_4,
  peel: () => peel,
  peel_: () => peel_,
  pipeThrough: () => pipeThrough,
  provideAll: () => provideAll4,
  provideAll_: () => provideAll_6,
  range: () => range3,
  rechunk: () => rechunk,
  rechunk_: () => rechunk_,
  refineOrDie: () => refineOrDie3,
  refineOrDieWith: () => refineOrDieWith3,
  refineOrDieWith_: () => refineOrDieWith_3,
  refineOrDie_: () => refineOrDie_3,
  repeat: () => repeat2,
  repeatEffect: () => repeatEffect,
  repeatEffectChunk: () => repeatEffectChunk,
  repeatEffectChunkOption: () => repeatEffectChunkOption,
  repeatEffectOption: () => repeatEffectOption,
  repeatEffectWith: () => repeatEffectWith,
  repeatEither: () => repeatEither,
  repeatEither_: () => repeatEither_,
  repeatElements: () => repeatElements,
  repeatElementsEither: () => repeatElementsEither,
  repeatElementsEither_: () => repeatElementsEither_,
  repeatElementsWith: () => repeatElementsWith,
  repeatElementsWith_: () => repeatElementsWith_,
  repeatElements_: () => repeatElements_,
  repeatSchedule: () => repeatSchedule,
  repeatSchedule_: () => repeatSchedule_,
  repeatValueWith: () => repeatValueWith,
  repeatWith: () => repeatWith,
  repeatWith_: () => repeatWith_,
  retry: () => retry4,
  retry_: () => retry_3,
  right: () => right4,
  rightOrFail: () => rightOrFail,
  rightOrFail_: () => rightOrFail_,
  run: () => run6,
  runCollect: () => runCollect,
  runCount: () => runCount,
  runDrain: () => runDrain2,
  runForEach: () => runForEach,
  runForEachChunk: () => runForEachChunk,
  runForEachChunkManaged: () => runForEachChunkManaged,
  runForEachChunkManaged_: () => runForEachChunkManaged_,
  runForEachChunk_: () => runForEachChunk_,
  runForEachManaged: () => runForEachManaged,
  runForEachManaged_: () => runForEachManaged_,
  runForEachWhile: () => runForEachWhile,
  runForEachWhileManaged: () => runForEachWhileManaged,
  runForEachWhileManaged_: () => runForEachWhileManaged_,
  runForEachWhile_: () => runForEachWhile_,
  runForEach_: () => runForEach_,
  runHead: () => runHead,
  runInto: () => runInto,
  runIntoElementsManaged: () => runIntoElementsManaged,
  runIntoElementsManaged_: () => runIntoElementsManaged_,
  runIntoHub: () => runIntoHub,
  runIntoHubManaged: () => runIntoHubManaged,
  runIntoHubManaged_: () => runIntoHubManaged_,
  runIntoHub_: () => runIntoHub_,
  runIntoManaged: () => runIntoManaged,
  runIntoManaged_: () => runIntoManaged_,
  runInto_: () => runInto_,
  runLast: () => runLast,
  runManaged: () => runManaged2,
  runManaged_: () => runManaged_,
  runReduce: () => runReduce,
  runReduceEffect: () => runReduceEffect,
  runReduceEffect_: () => runReduceEffect_,
  runReduceManaged: () => runReduceManaged,
  runReduceManagedEffect: () => runReduceManagedEffect,
  runReduceManagedEffect_: () => runReduceManagedEffect_,
  runReduceManaged_: () => runReduceManaged_,
  runReduceWhile: () => runReduceWhile,
  runReduceWhileEffect: () => runReduceWhileEffect,
  runReduceWhileEffect_: () => runReduceWhileEffect_,
  runReduceWhileManaged: () => runReduceWhileManaged,
  runReduceWhileManagedEffect: () => runReduceWhileManagedEffect,
  runReduceWhileManagedEffect_: () => runReduceWhileManagedEffect_,
  runReduceWhileManaged_: () => runReduceWhileManaged_,
  runReduceWhile_: () => runReduceWhile_,
  runReduce_: () => runReduce_,
  runSum: () => runSum,
  run_: () => run_2,
  scan: () => scan,
  scanEffect: () => scanEffect,
  scanEffect_: () => scanEffect_,
  scanReduce: () => scanReduce,
  scanReduceEffect: () => scanReduceEffect,
  scanReduceEffect_: () => scanReduceEffect_,
  scanReduce_: () => scanReduce_,
  scan_: () => scan_,
  schedule: () => schedule,
  scheduleEither: () => scheduleEither,
  scheduleEither_: () => scheduleEither_,
  scheduleWith: () => scheduleWith,
  scheduleWith_: () => scheduleWith_,
  schedule_: () => schedule_,
  service: () => service3,
  serviceWith: () => serviceWith,
  serviceWithStream: () => serviceWithStream,
  sliding: () => sliding,
  sliding_: () => sliding_,
  some: () => some4,
  someOrElse: () => someOrElse3,
  someOrElse_: () => someOrElse_3,
  someOrFail: () => someOrFail3,
  someOrFail_: () => someOrFail_3,
  splitLines: () => splitLines,
  splitOn: () => splitOn,
  splitOnChunk: () => splitOnChunk,
  splitOnChunk_: () => splitOnChunk_,
  splitOn_: () => splitOn_,
  startWith: () => startWith,
  startWithRight: () => startWithRight,
  streamTapSkipFirst: () => streamTapSkipFirst,
  succeed: () => succeed10,
  succeedWith: () => succeedWith6,
  take: () => take4,
  takeRight: () => takeRight2,
  takeRight_: () => takeRight_3,
  takeUntil: () => takeUntil,
  takeUntilEffect: () => takeUntilEffect,
  takeUntilEffect_: () => takeUntilEffect_,
  takeUntil_: () => takeUntil_,
  takeWhile: () => takeWhile2,
  takeWhile_: () => takeWhile_2,
  take_: () => take_3,
  tap: () => tap6,
  tapLeft: () => tapLeft,
  tapRight: () => tapRight,
  tapRightEither: () => tapRightEither,
  tapSkipFirstRight: () => tapSkipFirstRight,
  tap_: () => tap_6,
  throttleEnforce: () => throttleEnforce,
  throttleEnforceEffect: () => throttleEnforceEffect,
  throttleEnforceEffect_: () => throttleEnforceEffect_,
  throttleEnforce_: () => throttleEnforce_,
  throttleShape: () => throttleShape,
  throttleShapeEffect: () => throttleShapeEffect,
  throttleShapeEffect_: () => throttleShapeEffect_,
  throttleShape_: () => throttleShape_,
  tick: () => tick,
  timeout: () => timeout3,
  timeoutFail: () => timeoutFail2,
  timeoutFailCause: () => timeoutFailCause2,
  timeoutFailCause_: () => timeoutFailCause_2,
  timeoutFail_: () => timeoutFail_2,
  timeoutTo: () => timeoutTo2,
  timeoutTo_: () => timeoutTo_2,
  timeout_: () => timeout_3,
  toHub: () => toHub,
  toHub_: () => toHub_,
  toPull: () => toPull2,
  toQueue: () => toQueue2,
  toQueueDropping: () => toQueueDropping,
  toQueueDropping_: () => toQueueDropping_,
  toQueueOfElements: () => toQueueOfElements,
  toQueueOfElements_: () => toQueueOfElements_,
  toQueueSliding: () => toQueueSliding,
  toQueueSliding_: () => toQueueSliding_,
  toQueueUnbounded: () => toQueueUnbounded,
  toQueue_: () => toQueue_,
  transduce: () => transduce,
  transduce_: () => transduce_,
  unfold: () => unfold2,
  unfoldChunk: () => unfoldChunk,
  unfoldChunkEffect: () => unfoldChunkEffect,
  unfoldChunksEffect: () => unfoldChunksEffect,
  unfoldEffect: () => unfoldEffect2,
  unit: () => unit6,
  unwrap: () => unwrap3,
  unwrapManaged: () => unwrapManaged2,
  via: () => via,
  via_: () => via_,
  when: () => when3,
  whenCase: () => whenCase2,
  whenCaseEffect: () => whenCaseEffect,
  whenCaseEffect_: () => whenCaseEffect_,
  whenCase_: () => whenCase_2,
  whenEffect: () => whenEffect,
  whenEffect_: () => whenEffect_,
  when_: () => when_2,
  zip: () => zip10,
  zipAll: () => zipAll2,
  zipAllLeft: () => zipAllLeft,
  zipAllLeft_: () => zipAllLeft_,
  zipAllRight: () => zipAllRight,
  zipAllRight_: () => zipAllRight_,
  zipAllWith: () => zipAllWith2,
  zipAllWithExec: () => zipAllWithExec,
  zipAllWithExec_: () => zipAllWithExec_,
  zipAllWith_: () => zipAllWith_2,
  zipAll_: () => zipAll_2,
  zipLeft: () => zipLeft4,
  zipLeft_: () => zipLeft_3,
  zipRight: () => zipRight4,
  zipRight_: () => zipRight_6,
  zipWith: () => zipWith7,
  zipWithIndex: () => zipWithIndex2,
  zipWithLatest: () => zipWithLatest,
  zipWithLatest_: () => zipWithLatest_,
  zipWithNext: () => zipWithNext,
  zipWithPrevious: () => zipWithPrevious,
  zipWithPreviousAndNext: () => zipWithPreviousAndNext,
  zipWith_: () => zipWith_9,
  zip_: () => zip_11
});

// node_modules/@effect-ts/core/_mjs/Ordering/operations.mjs
var Associative = /* @__PURE__ */ makeAssociative((x2, y2) => x2 !== 0 ? x2 : y2);
var Identity = /* @__PURE__ */ makeIdentity(0, Associative.combine);

// node_modules/@effect-ts/core/_mjs/Ord/operations.mjs
function getAssociative() {
  return makeAssociative((x2, y2) => makeOrd((a2, b2) => Associative.combine(x2.compare(a2, b2), y2.compare(a2, b2))));
}
function getIdentity2() {
  return makeIdentity(makeOrd(() => 0), getAssociative().combine);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/collectEffect.mjs
function collectEffect_(self, f2) {
  ;
  switch (self._typeId) {
    case SingletonTypeId: {
      return fold_(f2(self.a), () => succeed5(empty4()), (b2) => map_13(b2, single));
    }
    case ArrTypeId: {
      const array2 = self.arrayLike();
      let dest = succeed5(empty4());
      for (let i2 = 0; i2 < array2.length; i2++) {
        const rhs = f2(array2[i2]);
        if (isSome(rhs)) {
          dest = zipWith_4(dest, rhs.value, append_4);
        }
      }
      return dest;
    }
    default: {
      return collectEffect_(self.materialize(), f2);
    }
  }
}
function collectEffect(f2) {
  return (self) => collectEffect_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/collectWhile.mjs
function collectWhile_(self, f2) {
  ;
  switch (self._typeId) {
    case SingletonTypeId: {
      return fold_(f2(self.a), () => empty4(), single);
    }
    case ArrTypeId: {
      const array2 = self.arrayLike();
      let dest = empty4();
      for (let i2 = 0; i2 < array2.length; i2++) {
        const rhs = f2(array2[i2]);
        if (isSome(rhs)) {
          dest = append_4(dest, rhs.value);
        } else {
          return dest;
        }
      }
      return dest;
    }
    default: {
      return collectWhile_(self.materialize(), f2);
    }
  }
}
function collectWhile(f2) {
  return (self) => collectWhile_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/collectWhileEffect.mjs
function collectWhileEffect_(self, f2) {
  ;
  switch (self._typeId) {
    case SingletonTypeId: {
      return fold_(f2(self.a), () => succeed5(empty4()), (b2) => map_13(b2, single));
    }
    case ArrTypeId: {
      const array2 = self.arrayLike();
      let dest = succeed5(empty4());
      for (let i2 = 0; i2 < array2.length; i2++) {
        const rhs = f2(array2[i2]);
        if (isSome(rhs)) {
          dest = zipWith_4(dest, rhs.value, append_4);
        } else {
          return dest;
        }
      }
      return dest;
    }
    default: {
      return collectWhileEffect_(self.materialize(), f2);
    }
  }
}
function collectWhileEffect(f2) {
  return (self) => collectWhileEffect_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/collectWithIndex.mjs
function collectWithIndex_(self, f2) {
  ;
  switch (self._typeId) {
    case ArrTypeId: {
      const array2 = self.arrayLike();
      let dest = empty4();
      for (let i2 = 0; i2 < array2.length; i2++) {
        const rhs = f2(i2, array2[i2]);
        if (isSome(rhs)) {
          dest = append_4(dest, rhs.value);
        }
      }
      return dest;
    }
    default: {
      return collectWithIndex_(self.materialize(), f2);
    }
  }
}
function collectWithIndex(f2) {
  return (self) => collectWithIndex_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/dedupe.mjs
function dedupe(chunk2) {
  const builder2 = builder();
  let lastA = null;
  forEach_4(chunk2, (a2) => {
    if (!equals(lastA, a2)) {
      builder2.append(a2);
      lastA = a2;
    }
  });
  return builder2.build();
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/dropWhile.mjs
function dropWhile_2(self, f2) {
  ;
  switch (self._typeId) {
    case ArrTypeId: {
      const arr = self.arrayLike();
      const len = arr.length;
      let i2 = 0;
      while (i2 < len && f2(arr[i2])) {
        i2++;
      }
      return drop_2(self, i2);
    }
    default: {
      const iterator = self.arrayLikeIterator();
      let cont = true;
      let i2 = 0;
      let next2;
      while (cont && (next2 = iterator.next()) && !next2.done) {
        const array2 = next2.value;
        const len = array2.length;
        let j2 = 0;
        while (cont && j2 < len) {
          const a2 = array2[j2];
          if (f2(a2)) {
            i2++;
            j2++;
          } else {
            cont = false;
          }
        }
      }
      return drop_2(self, i2);
    }
  }
}
function dropWhile2(f2) {
  return (self) => dropWhile_2(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/dropWhileEffect.mjs
function dropWhileEffect_(self, f2) {
  return suspend4(() => {
    const iterator = self.arrayLikeIterator();
    let next2;
    let dropping = succeed5(true);
    let builder2 = empty4();
    while ((next2 = iterator.next()) && !next2.done) {
      const array2 = next2.value;
      const len = array2.length;
      let i2 = 0;
      while (i2 < len) {
        const a2 = array2[i2];
        dropping = chain_12(dropping, (d2) => map_13(d2 ? f2(a2) : succeed5(false), (b2) => {
          if (!b2) {
            builder2 = append_4(builder2, a2);
          }
          return b2;
        }));
        i2++;
      }
    }
    return map_13(dropping, () => builder2);
  });
}
function dropWhileEffect(f2) {
  return (self) => dropWhileEffect_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/exists.mjs
function exists_3(self, f2) {
  const iterator = self.arrayLikeIterator();
  let next2;
  while ((next2 = iterator.next()) && !next2.done) {
    const array2 = next2.value;
    const len = array2.length;
    let i2 = 0;
    while (i2 < len) {
      const a2 = array2[i2];
      if (f2(a2)) {
        return true;
      }
      i2++;
    }
  }
  return false;
}
function exists4(f2) {
  return (self) => exists_3(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/fill.mjs
function fill(n2, f2) {
  if (n2 <= 0) {
    return empty4();
  }
  let builder2 = empty4();
  for (let i2 = 0; i2 < n2; i2++) {
    builder2 = append_4(builder2, f2(i2));
  }
  return builder2;
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/filterWithIndex.mjs
function filterWithIndex_2(self, f2) {
  ;
  switch (self._typeId) {
    case ArrTypeId: {
      const arr = self.arrayLike();
      const len = arr.length;
      let i2 = 0;
      let builder2 = empty4();
      while (i2 < len) {
        const elem3 = arr[i2];
        if (f2(i2, elem3)) {
          builder2 = append_4(builder2, elem3);
        }
        i2++;
      }
      return builder2;
    }
    default: {
      const iterator = self.arrayLikeIterator();
      let next2;
      let builder2 = empty4();
      let index = 0;
      while ((next2 = iterator.next()) && !next2.done) {
        const array2 = next2.value;
        const len = array2.length;
        let i2 = 0;
        while (i2 < len) {
          const a2 = array2[i2];
          if (f2(index, a2)) {
            builder2 = append_4(builder2, a2);
          }
          i2++;
          index++;
        }
      }
      return builder2;
    }
  }
}
function filterWithIndex2(f2) {
  return (self) => filterWithIndex_2(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/find.mjs
function find_2(self, f2) {
  const iterator = self.arrayLikeIterator();
  let next2;
  while ((next2 = iterator.next()) && !next2.done) {
    const array2 = next2.value;
    const len = array2.length;
    let i2 = 0;
    while (i2 < len) {
      const a2 = array2[i2];
      if (f2(a2)) {
        return some(a2);
      }
      i2++;
    }
  }
  return none;
}
function find2(f2) {
  return (self) => find_2(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/findEffect.mjs
function findEffect_(self, f2) {
  return suspend4(() => {
    const iterator = self.arrayLikeIterator();
    let next2;
    const loop6 = (iterator2, array2, i2, length) => {
      if (i2 < length) {
        const a2 = array2[i2];
        return chain_12(f2(a2), (r2) => r2 ? succeed5(some(a2)) : loop6(iterator2, array2, i2 + 1, length));
      } else if (!(next2 = iterator2.next()).done) {
        return loop6(iterator2, next2.value, 0, next2.value.length);
      } else {
        return succeed5(none);
      }
    };
    next2 = iterator.next();
    if (!next2.done) {
      return loop6(iterator, next2.value, 0, next2.value.length);
    } else {
      return succeed5(none);
    }
  });
}
function findEffect(f2) {
  return (self) => findEffect_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/findIndex.mjs
function findIndex_(self, f2) {
  const iterator = self.arrayLikeIterator();
  let next2;
  let index = 0;
  while ((next2 = iterator.next()) && !next2.done) {
    const array2 = next2.value;
    const len = array2.length;
    let i2 = 0;
    while (i2 < len) {
      const a2 = array2[i2];
      if (f2(a2)) {
        return some(index);
      }
      i2++;
      index++;
    }
  }
  return none;
}
function findIndex(f2) {
  return (self) => findIndex_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/findLast.mjs
function findLast_(self, f2) {
  const iterator = self.reverseArrayLikeIterator();
  let next2;
  while ((next2 = iterator.next()) && !next2.done) {
    const array2 = next2.value;
    const len = array2.length;
    let i2 = len - 1;
    while (i2 >= 0) {
      const a2 = array2[i2];
      if (f2(a2)) {
        return some(a2);
      }
      i2--;
    }
  }
  return none;
}
function findLast(f2) {
  return (self) => findLast_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/findLastIndex.mjs
function findLastIndex_(self, f2) {
  ;
  const iterator = self.reverseArrayLikeIterator();
  let next2;
  let index = self.length - 1;
  while ((next2 = iterator.next()) && !next2.done) {
    const array2 = next2.value;
    const len = array2.length;
    let i2 = len - 1;
    while (i2 >= 0) {
      const a2 = array2[i2];
      if (f2(a2)) {
        return some(index);
      }
      i2--;
      index--;
    }
  }
  return none;
}
function findLastIndex(f2) {
  return (self) => findLastIndex_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/forAll.mjs
function forAll_(self, f2) {
  const iterator = self.arrayLikeIterator();
  let next2;
  while ((next2 = iterator.next()) && !next2.done) {
    const array2 = next2.value;
    const len = array2.length;
    let i2 = 0;
    while (i2 < len) {
      const a2 = array2[i2];
      if (!f2(a2)) {
        return false;
      }
      i2++;
    }
  }
  return true;
}
function forAll(f2) {
  return (self) => forAll_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/forAny.mjs
function forAny_(self, f2) {
  const iterator = self.arrayLikeIterator();
  let next2;
  while ((next2 = iterator.next()) && !next2.done) {
    const array2 = next2.value;
    const len = array2.length;
    let i2 = 0;
    while (i2 < len) {
      const a2 = array2[i2];
      if (f2(a2)) {
        return true;
      }
      i2++;
    }
  }
  return false;
}
function forAny(f2) {
  return (self) => forAny_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/grouped.mjs
function grouped_(self, n2) {
  let gr = empty4();
  let current = empty4();
  forEach_4(self, (a2) => {
    current = append_4(current, a2);
    if (size4(current) >= n2) {
      gr = append_4(gr, current);
      current = empty4();
    }
  });
  if (size4(current) > 0) {
    gr = append_4(gr, current);
  }
  return gr;
}
function grouped(n2) {
  return (self) => grouped_(self, n2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/join.mjs
function join_2(self, sep) {
  return reduce_7(self, "", (s2, a2) => s2.length > 0 ? `${s2}${sep}${a2}` : a2);
}
function join3(sep) {
  return (self) => join_2(self, sep);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/mapAccum.mjs
function mapAccum_(self, s2, f2) {
  const iterator = self.arrayLikeIterator();
  let next2;
  let s1 = s2;
  let builder2 = empty4();
  while ((next2 = iterator.next()) && !next2.done) {
    const array2 = next2.value;
    const len = array2.length;
    let i2 = 0;
    while (i2 < len) {
      const a2 = array2[i2];
      const x2 = f2(s1, a2);
      s1 = x2.get(0);
      builder2 = append_4(builder2, x2.get(1));
      i2++;
    }
  }
  return tuple2(s1, builder2);
}
function mapAccum(s2, f2) {
  return (self) => mapAccum_(self, s2, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/mapAccumEffect.mjs
function mapAccumEffect_(self, s2, f2) {
  return suspend4(() => {
    const iterator = self.arrayLikeIterator();
    let dest = succeed5(s2);
    let builder2 = empty4();
    let next2;
    while ((next2 = iterator.next()) && !next2.done) {
      const array2 = next2.value;
      const length = array2.length;
      let i2 = 0;
      while (i2 < length) {
        const a2 = array2[i2];
        dest = chain_12(dest, (state) => map_13(f2(state, a2), ({
          tuple: [s3, b2]
        }) => {
          builder2 = append_4(builder2, b2);
          return s3;
        }));
        i2++;
      }
    }
    return map_13(dest, (s3) => tuple2(s3, builder2));
  });
}
function mapAccumEffect(s2, f2) {
  return (self) => mapAccumEffect_(self, s2, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/mapEffectPar.mjs
function mapEffectPar_(self, f2) {
  return forEachPar_(self, f2);
}
function mapEffectPar(f2) {
  return (self) => mapEffectPar_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/mapEffectParN.mjs
function mapMParEffect_(self, n2, f2) {
  return forEachParN_(self, n2, f2);
}
function mapMParEffect(n2, f2) {
  return (self) => mapMParEffect_(self, n2, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/mapEffectUnit.mjs
function mapEffectUnit_(self, f2) {
  return forEachUnit_(self, f2);
}
function mapEffectUnit(f2) {
  return (self) => mapEffectUnit_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/mapEffectUnitPar.mjs
function mapEffectUnitParN_(self, n2, f2) {
  return forEachUnitParN_(self, n2, f2);
}
function mapEffectUnitParN(n2, f2) {
  return (self) => mapEffectUnitParN_(self, n2, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/mapEffectUnitParN.mjs
function mapEffectUnitPar_(self, f2) {
  return forEachUnitPar_(self, f2);
}
function mapEffectUnitPar(f2) {
  return (self) => mapEffectUnitPar_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/partitionMap.mjs
function partitionMap_(self, f2) {
  let bs = empty4();
  let cs = empty4();
  forEach_4(self, (a2) => {
    const x2 = f2(a2);
    if (x2._tag === "Left") {
      bs = append_4(bs, x2.left);
    } else {
      cs = append_4(cs, x2.right);
    }
  });
  return tuple2(bs, cs);
}
function partitionMap2(f2) {
  return (self) => partitionMap_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/range.mjs
function range2(min2, max2) {
  let builder2 = empty4();
  for (let i2 = min2; i2 <= max2; i2++) {
    builder2 = append_4(builder2, i2);
  }
  return builder2;
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/reduceEffect.mjs
function reduceEffect_(self, s2, f2) {
  ;
  if (self._typeId === SingletonTypeId) {
    return f2(s2, self.a);
  }
  return reduce_7(self, succeed5(s2), (s3, a2) => chain_12(s3, (s1) => f2(s1, a2)));
}
function reduceEffect(s2, f2) {
  return (self) => reduceEffect_(self, s2, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/reduceRightEffect.mjs
function reduceRightEffect_(self, s2, f2) {
  ;
  if (self._typeId === SingletonTypeId) {
    return f2(self.a, s2);
  }
  return reduceRight_5(self, succeed5(s2), (a2, s3) => chain_12(s3, (s1) => f2(a2, s1)));
}
function reduceRightEffect(s2, f2) {
  return (self) => reduceRightEffect_(self, s2, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/reduceRightWithIndex.mjs
function reduceRightWithIndex_2(self, s2, f2) {
  ;
  switch (self._typeId) {
    case SingletonTypeId: {
      return f2(0, self.a, s2);
    }
    case ArrTypeId: {
      const arr = self.arrayLike();
      const len = arr.length;
      let s1 = s2;
      let i2 = len - 1;
      while (i2 >= 0) {
        s1 = f2(i2, arr[i2], s1);
        i2--;
      }
      return s1;
    }
    default: {
      const iterator = self.reverseArrayLikeIterator();
      let next2;
      let s1 = s2;
      let index = self.length - 1;
      while ((next2 = iterator.next()) && !next2.done) {
        const array2 = next2.value;
        const len = array2.length;
        let i2 = len - 1;
        while (i2 >= 0) {
          const a2 = array2[i2];
          s1 = f2(index, a2, s1);
          i2--;
          index--;
        }
      }
      return s1;
    }
  }
}
function reduceRightWithIndex2(s2, f2) {
  return (self) => reduceRightWithIndex_2(self, s2, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/reduceWhile.mjs
function reduceWhile_(self, s2, pred, f2) {
  const iterator = self.arrayLikeIterator();
  let next2;
  let s1 = s2;
  let cont = true;
  while (cont && (next2 = iterator.next()) && !next2.done) {
    const array2 = next2.value;
    const len = array2.length;
    let i2 = 0;
    while (cont && i2 < len) {
      const a2 = array2[i2];
      s1 = f2(s1, a2);
      cont = pred(s1);
      i2++;
    }
    next2 = iterator.next();
  }
  return s1;
}
function reduceWhile(s2, pred, f2) {
  return (self) => reduceWhile_(self, s2, pred, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/reduceWhileEffect.mjs
function loop3(s2, iterator, array2, i2, length, pred, f2) {
  if (i2 < length) {
    if (pred(s2)) {
      return chain_12(f2(s2, array2[i2]), (s1) => loop3(s1, iterator, array2, i2 + 1, length, pred, f2));
    } else {
      return succeed5(s2);
    }
  } else {
    const next2 = iterator.next();
    if (next2.done) {
      return succeed5(s2);
    } else {
      const arr = next2.value;
      return suspend4(() => loop3(s2, iterator, arr, 0, arr.length, pred, f2));
    }
  }
}
function reduceWhileEffect_(self, s2, pred, f2) {
  const iterator = self.arrayLikeIterator();
  const next2 = iterator.next();
  if (next2.done) {
    return succeed5(s2);
  } else {
    const array2 = next2.value;
    const length = array2.length;
    return loop3(s2, iterator, array2, 0, length, pred, f2);
  }
}
function reduceWhileEffect(s2, pred, f2) {
  return (self) => reduceWhileEffect_(self, s2, pred, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/reduceWithIndex.mjs
function reduceWithIndex_4(self, s2, f2) {
  ;
  switch (self._typeId) {
    case SingletonTypeId: {
      return f2(0, s2, self.a);
    }
    case ArrTypeId: {
      const arr = self.arrayLike();
      const len = arr.length;
      let s1 = s2;
      let i2 = 0;
      while (i2 < len) {
        s1 = f2(i2, s1, arr[i2]);
        i2++;
      }
      return s1;
    }
    default: {
      const iterator = self.arrayLikeIterator();
      let next2;
      let s1 = s2;
      let index = 0;
      while ((next2 = iterator.next()) && !next2.done) {
        const array2 = next2.value;
        const len = array2.length;
        let i2 = 0;
        while (i2 < len) {
          const a2 = array2[i2];
          s1 = f2(index, s1, a2);
          i2++;
          index++;
        }
      }
      return s1;
    }
  }
}
function reduceWithIndex3(s2, f2) {
  return (self) => reduceWithIndex_4(self, s2, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/separate.mjs
function separate2(self) {
  return partitionMap_(self, identity);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/split.mjs
function split_(self, n2) {
  const length = self.length;
  const k2 = Math.floor(n2);
  const quotient = Math.floor(length / k2);
  const remainder = length % k2;
  let chunks2 = empty4();
  let i2 = 0;
  let chunk2 = empty4();
  forEach_4(self, (a2) => {
    chunk2 = append_4(chunk2, a2);
    if (i2 <= remainder && chunk2.length > quotient || i2 > remainder && chunk2.length >= quotient) {
      chunks2 = append_4(chunks2, chunk2);
      chunk2 = empty4();
    }
    i2++;
  });
  if (chunk2.length > 0) {
    chunks2 = append_4(chunks2, chunk2);
  }
  return chunks2;
}
function split(n2) {
  return (self) => split_(self, n2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/splitWhere.mjs
function splitWhere_(self, f2) {
  const iterator = self.arrayLikeIterator();
  let next2;
  let cont = true;
  let i2 = 0;
  while (cont && (next2 = iterator.next()) && !next2.done) {
    const array2 = next2.value;
    const len = array2.length;
    let j2 = 0;
    while (cont && j2 < len) {
      const a2 = array2[j2];
      if (f2(a2)) {
        cont = false;
      } else {
        i2++;
        j2++;
      }
    }
  }
  return splitAt_(self, i2);
}
function splitWhere(f2) {
  return (self) => splitWhere_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/takeWhile.mjs
function takeWhile_(self, f2) {
  ;
  switch (self._typeId) {
    case ArrTypeId: {
      const arr = self.arrayLike();
      const len = arr.length;
      let i2 = 0;
      while (i2 < len && f2(arr[i2])) {
        i2++;
      }
      return take_2(self, i2);
    }
    default: {
      const iterator = self.arrayLikeIterator();
      let next2;
      let cont = true;
      let i2 = 0;
      while (cont && (next2 = iterator.next()) && !next2.done) {
        const array2 = next2.value;
        const len = array2.length;
        let j2 = 0;
        while (cont && j2 < len) {
          const a2 = array2[j2];
          if (!f2(a2)) {
            cont = false;
          } else {
            i2++;
            j2++;
          }
        }
      }
      return take_2(self, i2);
    }
  }
}
function takeWhile(f2) {
  return (self) => takeWhile_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/takeWhileEffect.mjs
function takeWhileEffect_(self, f2) {
  return suspend4(() => {
    const iterator = self.arrayLikeIterator();
    let next2;
    let taking = succeed5(true);
    let builder2 = empty4();
    while ((next2 = iterator.next()) && !next2.done) {
      const array2 = next2.value;
      const len = array2.length;
      let i2 = 0;
      while (i2 < len) {
        const a2 = array2[i2];
        taking = chain_12(taking, (d2) => map_13(d2 ? f2(a2) : succeed5(false), (b2) => {
          if (b2) {
            builder2 = append_4(builder2, a2);
          }
          return b2;
        }));
        i2++;
      }
    }
    return map_13(taking, () => builder2);
  });
}
function takeWhileEffect(f2) {
  return (self) => takeWhileEffect_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/unfold.mjs
function unfold(s2, f2) {
  let builder2 = empty4();
  let cont = true;
  let s1 = s2;
  while (cont) {
    const x2 = f2(s1);
    if (isSome(x2)) {
      s1 = x2[1];
      builder2 = append_4(builder2, x2[0]);
    } else {
      cont = false;
    }
  }
  return builder2;
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/unfoldEffect.mjs
function loop4(s2, f2, builder2) {
  return chain_12(f2(s2), (o2) => {
    if (isSome(o2)) {
      return loop4(o2.value.get(1), f2, append_4(builder2, o2.value.get(0)));
    } else {
      return succeed5(builder2);
    }
  });
}
function unfoldEffect(s2, f2) {
  return loop4(s2, f2, empty4());
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/zipAllWith.mjs
function zipAllWith_(self, that, f2, left4, right5) {
  const length = Math.max(self.length, that.length);
  if (length === 0) {
    return empty4();
  }
  const leftIterator = self.arrayLikeIterator();
  const rightIterator = that.arrayLikeIterator();
  let i2 = 0;
  let j2 = 0;
  let k2 = 0;
  let leftLength = 0;
  let rightLength = 0;
  let leftArray = void 0;
  let rightArray = void 0;
  let leftNext;
  let rightNext;
  let builder2 = empty4();
  while (i2 < length) {
    if (j2 < leftLength && k2 < rightLength) {
      builder2 = append_4(builder2, f2(leftArray[j2], rightArray[k2]));
      i2++;
      j2++;
      k2++;
    } else if (j2 === leftLength && (leftNext = leftIterator.next()) && !leftNext.done) {
      leftArray = leftNext.value;
      leftLength = leftArray.length;
      j2 = 0;
    } else if (k2 === rightLength && (rightNext = rightIterator.next()) && !rightNext.done) {
      rightArray = rightNext.value;
      rightLength = rightArray.length;
      k2 = 0;
    } else if (j2 < leftLength) {
      builder2 = append_4(builder2, left4(leftArray[j2]));
      i2++;
      j2++;
    } else if (k2 < rightLength) {
      builder2 = append_4(builder2, right5(rightArray[k2]));
      i2++;
      k2++;
    }
  }
  return builder2;
}
function zipAllWith(that, f2, left4, right5) {
  return (self) => zipAllWith_(self, that, f2, left4, right5);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/zipAll.mjs
function zipAll_(self, that) {
  return zipAllWith_(self, that, (a2, b2) => tuple2(some(a2), some(b2)), (a2) => tuple2(some(a2), none), (b2) => tuple2(none, some(b2)));
}
function zipAll(that) {
  return (self) => zipAll_(self, that);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/zipWithIndexOffset.mjs
function zipWithIndexOffset_(self, offset) {
  const iterator = self.arrayLikeIterator();
  let next2;
  let i2 = offset;
  let builder2 = empty4();
  while ((next2 = iterator.next()) && !next2.done) {
    const array2 = next2.value;
    const len = array2.length;
    let j2 = 0;
    while (j2 < len) {
      const a2 = array2[j2];
      builder2 = append_4(builder2, tuple2(a2, i2));
      j2++;
      i2++;
    }
  }
  return builder2;
}
function zipWithIndexOffset(offset) {
  return (self) => zipWithIndexOffset_(self, offset);
}

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/Chunk/api/zipWithIndex.mjs
function zipWithIndex(self) {
  return zipWithIndexOffset_(self, 0);
}

// node_modules/@effect-ts/core/_mjs/Collections/Immutable/Chunk/operations.mjs
var forEachWithIndexF = /* @__PURE__ */ implementForEachWithIndexF()((_2) => (G2) => {
  const succeed12 = succeedF(G2);
  return (f2) => (fa) => {
    let base = succeed12(empty4());
    for (let k2 = 0; k2 < fa.length; k2 += 1) {
      base = G2.map(({
        tuple: [bs, b2]
      }) => append_4(bs, b2))(G2.both(f2(k2, unsafeGet_2(fa, k2)))(base));
    }
    return base;
  };
});
var forEachF = /* @__PURE__ */ implementForEachF()((_2) => (G2) => (f2) => forEachWithIndexF(G2)((_3, a2) => f2(a2)));
var forEachF_ = (fa, G2) => (f2) => forEachF(G2)(f2)(fa);
var separateF = /* @__PURE__ */ implementSeparateF()((_2) => (G2) => (f2) => (x2) => G2.map(partitionMap2(identity))(forEachF(G2)(f2)(x2)));
var separateWithIndexF = /* @__PURE__ */ implementSeparateWithIndexF()((_2) => (G2) => (f2) => (x2) => G2.map(partitionMap2(identity))(forEachWithIndexF(G2)(f2)(x2)));
var compactF = /* @__PURE__ */ implementCompactF()((_2) => (G2) => (f2) => (x2) => G2.map(compact3)(forEachF(G2)(f2)(x2)));
var compactWithIndexF = /* @__PURE__ */ implementCompactWithIndexF()((_2) => (G2) => (f2) => (x2) => G2.map(compact3)(forEachWithIndexF(G2)(f2)(x2)));
function elem(E2, a2) {
  return (as6) => elem_(as6, E2, a2);
}
function elem_(as6, E2, a2) {
  const predicate = (element) => E2.equals(element, a2);
  let i2 = 0;
  const len = as6.length;
  for (; i2 < len; i2++) {
    if (predicate(unsafeGet_2(as6, i2))) {
      return true;
    }
  }
  return false;
}
function difference_(xs, E2, ys) {
  return filter_3(xs, (a2) => !elem_(ys, E2, a2));
}
function difference(E2, ys) {
  return (xs) => difference_(xs, E2, ys);
}
function getEqual(E2) {
  return makeEqual((xs, ys) => xs === ys || corresponds_(xs, ys, E2.equals));
}
function getIdentity3() {
  return makeIdentity(empty4(), concat_3);
}
function getOrd(O2) {
  return makeOrd((a2, b2) => {
    const aLen = a2.length;
    const bLen = b2.length;
    const len = Math.min(aLen, bLen);
    for (let i2 = 0; i2 < len; i2++) {
      const ordering = O2.compare(unsafeGet_2(a2, i2), unsafeGet_2(b2, i2));
      if (ordering !== 0) {
        return ordering;
      }
    }
    return number.compare(aLen, bLen);
  });
}
function getShow(S2) {
  return {
    show: (as6) => `[${join_2(map_8(as6, S2.show), ", ")}]`
  };
}
function intersection_2(xs, E2, ys) {
  return filter_3(xs, (a2) => elem_(ys, E2, a2));
}
function intersection(E2, ys) {
  return (xs) => intersection_2(xs, E2, ys);
}
function foldMap(M2) {
  return (f2) => foldMapWithIndex(M2)((_2, a2) => f2(a2));
}
function foldMap_(fa, M2, f2) {
  return foldMapWithIndex_(fa, M2, (_2, a2) => f2(a2));
}
function foldMapWithIndex(M2) {
  return (f2) => (fa) => foldMapWithIndex_(fa, M2, f2);
}
function foldMapWithIndex_(fa, M2, f2) {
  return reduce_7(zipWithIndex(fa), M2.identity, (b2, {
    tuple: [a2, i2]
  }) => M2.combine(b2, f2(i2, a2)));
}
function sort(O2) {
  return (as6) => sort_(as6, O2);
}
function sort_(as6, O2) {
  return from3([...toArray2(as6)].sort((x2, y2) => O2.compare(x2, y2)));
}
function sortBy(ords) {
  return (as6) => sortBy_(as6, ords);
}
function sortBy_(as6, ords) {
  const M2 = getIdentity2();
  return sort_(as6, ords.reduce((x2, y2) => M2.combine(x2, y2), M2.identity));
}
function union_3(xs, E2, ys) {
  return concat_3(xs, filter_3(ys, (a2) => !elem_(xs, E2, a2)));
}
function union2(E2, ys) {
  return (xs) => union_3(xs, E2, ys);
}
function uniq_(as6, E2) {
  let r2 = empty4();
  const len = as6.length;
  let i2 = 0;
  for (; i2 < len; i2++) {
    const a2 = unsafeGet_2(as6, i2);
    if (!elem_(r2, E2, a2)) {
      r2 = append_4(r2, a2);
    }
  }
  return len === r2.length ? as6 : r2;
}
function uniq(E2) {
  return (as6) => uniq_(as6, E2);
}
function partition2(predicate) {
  return (fa) => partitionWithIndex((_2, a2) => predicate(a2))(fa);
}
function partition_2(fa, predicate) {
  return partitionWithIndex((_2, a2) => predicate(a2))(fa);
}
function partitionMapWithIndex_(fa, f2) {
  const left4 = [];
  const right5 = [];
  for (let i2 = 0; i2 < fa.length; i2++) {
    const e2 = f2(i2, unsafeGet_2(fa, i2));
    if (e2._tag === "Left") {
      left4.push(e2.left);
    } else {
      right5.push(e2.right);
    }
  }
  return tuple2(from3(left4), from3(right5));
}
function partitionMapWithIndex(f2) {
  return (fa) => partitionMapWithIndex_(fa, f2);
}
function partitionWithIndex(predicateWithIndex) {
  return (fa) => partitionWithIndex_(fa, predicateWithIndex);
}
function partitionWithIndex_(fa, predicateWithIndex) {
  const left4 = [];
  const right5 = [];
  for (let i2 = 0; i2 < fa.length; i2++) {
    const a2 = unsafeGet_2(fa, i2);
    if (predicateWithIndex(i2, a2)) {
      right5.push(a2);
    } else {
      left4.push(a2);
    }
  }
  return tuple2(from3(left4), from3(right5));
}

// node_modules/@effect-ts/core/_mjs/Collections/Immutable/Tuple/index.mjs
var Tuple_exports2 = {};
__export(Tuple_exports2, {
  Tuple: () => Tuple,
  TupleSym: () => TupleSym,
  append: () => append,
  append_: () => append_,
  concat: () => concat,
  concat_: () => concat_,
  fromNative: () => fromNative,
  get: () => get,
  get_: () => get_,
  isTuple: () => isTuple,
  prepend: () => prepend,
  prepend_: () => prepend_,
  toNative: () => toNative,
  tuple: () => tuple2,
  update: () => update,
  update_: () => update_
});

// node_modules/@effect-ts/core/_mjs/Branded/index.mjs
var Branded_exports = {};
__export(Branded_exports, {
  _brand: () => _brand,
  makeBranded: () => makeBranded
});
var _brand = /* @__PURE__ */ Symbol();
function makeBranded(self) {
  return self;
}

// node_modules/@effect-ts/core/_mjs/Collections/Immutable/Chunk/index.mjs
var Chunk_exports2 = {};
__export(Chunk_exports2, {
  Any: () => Any4,
  AppendN: () => AppendN,
  AppendNTypeId: () => AppendNTypeId,
  Applicative: () => Applicative4,
  ApplyZip: () => ApplyZip,
  Arr: () => Arr,
  ArrTypeId: () => ArrTypeId,
  AssociativeBothZip: () => AssociativeBothZip,
  AssociativeFlatten: () => AssociativeFlatten4,
  BreadthFirstChainRec: () => BreadthFirstChainRec,
  BufferSize: () => BufferSize,
  ChunkBuilder: () => ChunkBuilder,
  ChunkInternal: () => ChunkInternal,
  ChunkTypeId: () => ChunkTypeId,
  Collection: () => Collection,
  Compact: () => Compact,
  Concat: () => Concat,
  ConcatTypeId: () => ConcatTypeId,
  Covariant: () => Covariant4,
  DepthFirstChainRec: () => DepthFirstChainRec,
  Empty: () => Empty3,
  EmptyTypeId: () => EmptyTypeId,
  Extend: () => Extend2,
  Filter: () => Filter,
  FilterMap: () => FilterMap,
  FilterMapWithIndex: () => FilterMapWithIndex,
  FilterWithIndex: () => FilterWithIndex,
  Filterable: () => Filterable2,
  FilterableWithIndex: () => FilterableWithIndex,
  FoldMap: () => FoldMap,
  FoldMapWithIndex: () => FoldMapWithIndex,
  Foldable: () => Foldable2,
  FoldableWithIndex: () => FoldableWithIndex,
  ForEach: () => ForEach2,
  ForEachWithIndex: () => ForEachWithIndex,
  Monad: () => Monad4,
  Partition: () => Partition,
  PartitionMap: () => PartitionMap,
  PartitionMapWithIndex: () => PartitionMapWithIndex,
  PartitionWithIndex: () => PartitionWithIndex,
  PlainArr: () => PlainArr,
  PrependN: () => PrependN,
  PrependNTypeId: () => PrependNTypeId,
  Reduce: () => Reduce,
  ReduceRight: () => ReduceRight,
  ReduceRightWithIndex: () => ReduceRightWithIndex,
  ReduceWithIndex: () => ReduceWithIndex,
  Separate: () => Separate,
  Singleton: () => Singleton,
  SingletonTypeId: () => SingletonTypeId,
  Slice: () => Slice,
  SliceTypeId: () => SliceTypeId,
  Uint8Arr: () => Uint8Arr,
  Wiltable: () => Wiltable2,
  WiltableWithIndex: () => WiltableWithIndex,
  Witherable: () => Witherable2,
  WitherableWithIndex: () => WitherableWithIndex,
  _Empty: () => _Empty,
  _copy: () => _copy,
  alloc: () => alloc,
  append: () => append2,
  append_: () => append_4,
  breadthFirstChainRec: () => breadthFirstChainRec,
  buckets: () => buckets,
  builder: () => builder,
  chain: () => chain4,
  chain_: () => chain_7,
  collect: () => collect,
  collectEffect: () => collectEffect,
  collectEffect_: () => collectEffect_,
  collectWhile: () => collectWhile,
  collectWhileEffect: () => collectWhileEffect,
  collectWhileEffect_: () => collectWhileEffect_,
  collectWhile_: () => collectWhile_,
  collectWithIndex: () => collectWithIndex,
  collectWithIndex_: () => collectWithIndex_,
  collect_: () => collect_2,
  compact: () => compact3,
  compactF: () => compactF,
  compactWithIndexF: () => compactWithIndexF,
  concat: () => concat2,
  concat_: () => concat_3,
  concrete: () => concrete,
  concreteId: () => concreteId,
  corresponds: () => corresponds2,
  corresponds_: () => corresponds_,
  dedupe: () => dedupe,
  depthFirstChainRec: () => depthFirstChainRec,
  difference: () => difference,
  difference_: () => difference_,
  drop: () => drop,
  dropRight: () => dropRight,
  dropRight_: () => dropRight_,
  dropWhile: () => dropWhile2,
  dropWhileEffect: () => dropWhileEffect,
  dropWhileEffect_: () => dropWhileEffect_,
  dropWhile_: () => dropWhile_2,
  drop_: () => drop_2,
  elem: () => elem,
  elem_: () => elem_,
  empty: () => empty4,
  equals: () => equals3,
  equals_: () => equals_,
  exists: () => exists4,
  exists_: () => exists_3,
  fill: () => fill,
  filter: () => filter2,
  filterEffect: () => filterEffect,
  filterEffect_: () => filterEffect_,
  filterWithIndex: () => filterWithIndex2,
  filterWithIndex_: () => filterWithIndex_2,
  filter_: () => filter_3,
  find: () => find2,
  findEffect: () => findEffect,
  findEffect_: () => findEffect_,
  findIndex: () => findIndex,
  findIndex_: () => findIndex_,
  findLast: () => findLast,
  findLastIndex: () => findLastIndex,
  findLastIndex_: () => findLastIndex_,
  findLast_: () => findLast_,
  find_: () => find_2,
  flatten: () => flatten5,
  foldMap: () => foldMap,
  foldMapWithIndex: () => foldMapWithIndex,
  foldMapWithIndex_: () => foldMapWithIndex_,
  foldMap_: () => foldMap_,
  forAll: () => forAll,
  forAll_: () => forAll_,
  forAny: () => forAny,
  forAny_: () => forAny_,
  forEach: () => forEach3,
  forEachF: () => forEachF,
  forEachF_: () => forEachF_,
  forEachWithIndexF: () => forEachWithIndexF,
  forEach_: () => forEach_4,
  from: () => from3,
  get: () => get3,
  getEqual: () => getEqual,
  getIdentity: () => getIdentity3,
  getOrd: () => getOrd,
  getShow: () => getShow,
  get_: () => get_3,
  grouped: () => grouped,
  grouped_: () => grouped_,
  head: () => head2,
  indexWhere: () => indexWhere,
  indexWhereFrom: () => indexWhereFrom,
  indexWhereFrom_: () => indexWhereFrom_,
  indexWhere_: () => indexWhere_,
  intersection: () => intersection,
  intersection_: () => intersection_2,
  isByte: () => isByte,
  isChunk: () => isChunk,
  isEmpty: () => isEmpty5,
  isNonEmpty: () => isNonEmpty2,
  join: () => join3,
  join_: () => join_2,
  last: () => last2,
  make: () => make3,
  makeBy_: () => makeBy_2,
  map: () => map5,
  mapAccum: () => mapAccum,
  mapAccumEffect: () => mapAccumEffect,
  mapAccumEffect_: () => mapAccumEffect_,
  mapAccum_: () => mapAccum_,
  mapEffect: () => mapEffect,
  mapEffectPar: () => mapEffectPar,
  mapEffectPar_: () => mapEffectPar_,
  mapEffectUnit: () => mapEffectUnit,
  mapEffectUnitPar: () => mapEffectUnitPar,
  mapEffectUnitParN: () => mapEffectUnitParN,
  mapEffectUnitParN_: () => mapEffectUnitParN_,
  mapEffectUnitPar_: () => mapEffectUnitPar_,
  mapEffectUnit_: () => mapEffectUnit_,
  mapEffect_: () => mapEffect_,
  mapMParEffect: () => mapMParEffect,
  mapMParEffect_: () => mapMParEffect_,
  mapWithIndex: () => mapWithIndex2,
  mapWithIndex_: () => mapWithIndex_2,
  map_: () => map_8,
  materialize: () => materialize,
  partition: () => partition2,
  partitionMap: () => partitionMap2,
  partitionMapWithIndex: () => partitionMapWithIndex,
  partitionMapWithIndex_: () => partitionMapWithIndex_,
  partitionMap_: () => partitionMap_,
  partitionWithIndex: () => partitionWithIndex,
  partitionWithIndex_: () => partitionWithIndex_,
  partition_: () => partition_2,
  prepend: () => prepend2,
  prepend_: () => prepend_3,
  range: () => range2,
  reduce: () => reduce5,
  reduceEffect: () => reduceEffect,
  reduceEffect_: () => reduceEffect_,
  reduceRight: () => reduceRight2,
  reduceRightEffect: () => reduceRightEffect,
  reduceRightEffect_: () => reduceRightEffect_,
  reduceRightWithIndex: () => reduceRightWithIndex2,
  reduceRightWithIndex_: () => reduceRightWithIndex_2,
  reduceRight_: () => reduceRight_5,
  reduceWhile: () => reduceWhile,
  reduceWhileEffect: () => reduceWhileEffect,
  reduceWhileEffect_: () => reduceWhileEffect_,
  reduceWhile_: () => reduceWhile_,
  reduceWithIndex: () => reduceWithIndex3,
  reduceWithIndex_: () => reduceWithIndex_4,
  reduce_: () => reduce_7,
  reverse: () => reverse3,
  reverseBuckets: () => reverseBuckets,
  separate: () => separate2,
  separateF: () => separateF,
  separateWithIndexF: () => separateWithIndexF,
  single: () => single,
  size: () => size4,
  sort: () => sort,
  sortBy: () => sortBy,
  sortBy_: () => sortBy_,
  sort_: () => sort_,
  split: () => split,
  splitAt: () => splitAt,
  splitAt_: () => splitAt_,
  splitWhere: () => splitWhere,
  splitWhere_: () => splitWhere_,
  split_: () => split_,
  tail: () => tail2,
  take: () => take,
  takeRight: () => takeRight,
  takeRight_: () => takeRight_2,
  takeWhile: () => takeWhile,
  takeWhileEffect: () => takeWhileEffect,
  takeWhileEffect_: () => takeWhileEffect_,
  takeWhile_: () => takeWhile_,
  take_: () => take_2,
  toArray: () => toArray2,
  toArrayLike: () => toArrayLike,
  toString: () => toString,
  unfold: () => unfold,
  unfoldEffect: () => unfoldEffect,
  union: () => union2,
  union_: () => union_3,
  uniq: () => uniq,
  uniq_: () => uniq_,
  unit: () => unit,
  unsafeGet: () => unsafeGet2,
  unsafeGet_: () => unsafeGet_2,
  unsafeHead: () => unsafeHead,
  unsafeLast: () => unsafeLast2,
  unsafeTail: () => unsafeTail,
  unzip: () => unzip2,
  zip: () => zip6,
  zipAll: () => zipAll,
  zipAllWith: () => zipAllWith,
  zipAllWith_: () => zipAllWith_,
  zipAll_: () => zipAll_,
  zipWith: () => zipWith4,
  zipWithIndex: () => zipWithIndex,
  zipWithIndexOffset: () => zipWithIndexOffset,
  zipWithIndexOffset_: () => zipWithIndexOffset_,
  zipWith_: () => zipWith_5,
  zip_: () => zip_5
});

// node_modules/@effect-ts/core/_mjs/Option/index.mjs
var Option_exports2 = {};
__export(Option_exports2, {
  Any: () => Any3,
  Applicative: () => Applicative3,
  AssociativeBoth: () => AssociativeBoth3,
  AssociativeEither: () => AssociativeEither2,
  AssociativeFlatten: () => AssociativeFlatten3,
  Compactable: () => Compactable,
  Covariant: () => Covariant3,
  Extend: () => Extend,
  Fail: () => Fail4,
  Filterable: () => Filterable,
  Foldable: () => Foldable,
  ForEach: () => ForEach,
  IdentityBoth: () => IdentityBoth3,
  IdentityFlatten: () => IdentityFlatten3,
  Monad: () => Monad3,
  None: () => None,
  OptionURI: () => OptionURI,
  PartialException: () => PartialException,
  PartialExceptionTypeId: () => PartialExceptionTypeId,
  Some: () => Some,
  Wiltable: () => Wiltable,
  Witherable: () => Witherable,
  alt: () => alt2,
  ap: () => ap,
  ap_: () => ap_,
  bind: () => bind4,
  chain: () => chain,
  chain_: () => chain_,
  compactF: () => compactF2,
  do: () => do_4,
  do_: () => do_4,
  duplicate: () => duplicate,
  elem: () => elem2,
  elem_: () => elem_2,
  emptyOf: () => emptyOf,
  exists: () => exists,
  exists_: () => exists_,
  extend: () => extend,
  extend_: () => extend_,
  filter: () => filter4,
  filterMap: () => filterMap2,
  filterMap_: () => filterMap_2,
  filter_: () => filter_7,
  flatten: () => flatten,
  fold: () => fold,
  fold_: () => fold_,
  forEachF: () => forEachF2,
  fromEither: () => fromEither,
  fromNullable: () => fromNullable,
  fromPredicate: () => fromPredicate,
  fromPredicate_: () => fromPredicate_,
  gen: () => gen5,
  getApplyAssociative: () => getApplyAssociative,
  getApplyIdentity: () => getApplyIdentity,
  getEqual: () => getEqual2,
  getFirst: () => getFirst,
  getFirstAssociative: () => getFirstAssociative,
  getFirstIdentity: () => getFirstIdentity,
  getIdentity: () => getIdentity4,
  getLast: () => getLast,
  getLastAssociative: () => getLastAssociative,
  getLastIdentity: () => getLastIdentity,
  getLeft: () => getLeft,
  getOrElse: () => getOrElse,
  getOrElseS: () => getOrElseS,
  getOrElseS_: () => getOrElseS_,
  getOrElse_: () => getOrElse_,
  getOrd: () => getOrd2,
  getRefinement: () => getRefinement,
  getRight: () => getRight,
  getShow: () => getShow2,
  if: () => branch,
  if_: () => branch_,
  isNone: () => isNone,
  isSome: () => isSome,
  let: () => let_4,
  let_: () => let_4,
  map: () => map,
  mapNullable: () => mapNullable,
  map_: () => map_,
  match: () => match2,
  matchIn: () => matchIn2,
  matchMorph: () => matchMorph2,
  matchTag: () => matchTag3,
  matchTagIn: () => matchTagIn2,
  none: () => none,
  partial: () => partial,
  partition: () => partition3,
  partitionMap: () => partitionMap3,
  partitionMap_: () => partitionMap_2,
  partition_: () => partition_3,
  separate: () => separate3,
  separateF: () => separateF2,
  sequence: () => sequence,
  some: () => some,
  struct: () => struct3,
  tap: () => tap,
  tap_: () => tap_,
  toNullable: () => toNullable,
  toUndefined: () => toUndefined,
  tryCatch: () => tryCatch,
  tuple: () => tuple5,
  zip: () => zip,
  zipFirst: () => zipFirst,
  zipFirst_: () => zipFirst_,
  zipSecond: () => zipSecond,
  zipSecond_: () => zipSecond_,
  zip_: () => zip_
});

// node_modules/@effect-ts/core/_mjs/Option/instances/Any.mjs
var Any3 = {
  any: () => some({})
};

// node_modules/@effect-ts/core/_mjs/Option/instances/Covariant.mjs
var Covariant3 = {
  map
};

// node_modules/@effect-ts/core/_mjs/Option/instances/AssociativeBoth.mjs
var AssociativeBoth3 = {
  both: zip
};

// node_modules/@effect-ts/core/_mjs/Option/instances/IdentityBoth.mjs
var IdentityBoth3 = {
  ...Any3,
  ...AssociativeBoth3
};

// node_modules/@effect-ts/core/_mjs/Option/instances/Applicative.mjs
var Applicative3 = {
  ...Covariant3,
  ...IdentityBoth3
};

// node_modules/@effect-ts/core/_mjs/Option/instances/AssociativeEither.mjs
var AssociativeEither2 = {
  orElseEither: (fb) => (fa) => fa._tag === "Some" ? some(left(fa.value)) : map_(fb(), right)
};

// node_modules/@effect-ts/core/_mjs/Option/instances/AssociativeFlatten.mjs
var AssociativeFlatten3 = {
  flatten
};

// node_modules/@effect-ts/core/_mjs/Option/operations/separate.mjs
var defaultSeparate = /* @__PURE__ */ tuple2(none, none);
function separate3(ma) {
  const o2 = map_(ma, (e2) => tuple2(getLeft(e2), getRight(e2)));
  return isNone(o2) ? defaultSeparate : o2.value;
}

// node_modules/@effect-ts/core/_mjs/Option/instances/Compactable.mjs
var Compactable = {
  compact: flatten,
  separate: separate3
};

// node_modules/@effect-ts/core/_mjs/Option/instances/Extend.mjs
var Extend = {
  extend
};

// node_modules/@effect-ts/core/_mjs/Option/instances/Fail.mjs
var Fail4 = {
  fail: () => none
};

// node_modules/@effect-ts/core/_mjs/Option/operations/filter.mjs
function filter4(predicate) {
  return (fa) => filter_7(fa, predicate);
}
function filter_7(fa, predicate) {
  return isNone(fa) ? none : predicate(fa.value) ? fa : none;
}

// node_modules/@effect-ts/core/_mjs/Option/operations/filterMap.mjs
function filterMap2(f2) {
  return (fa) => filterMap_2(fa, f2);
}
function filterMap_2(fa, f2) {
  return isNone(fa) ? none : f2(fa.value);
}

// node_modules/@effect-ts/core/_mjs/Option/operations/partition.mjs
function partition3(predicate) {
  return (fa) => partition_3(fa, predicate);
}
function partition_3(fa, predicate) {
  return tuple2(filter4((a2) => !predicate(a2))(fa), filter4(predicate)(fa));
}

// node_modules/@effect-ts/core/_mjs/Option/operations/partitionMap.mjs
function partitionMap3(f2) {
  return (fa) => partitionMap_2(fa, f2);
}
function partitionMap_2(fa, f2) {
  return separate3(map_(fa, f2));
}

// node_modules/@effect-ts/core/_mjs/Option/instances/Filterable.mjs
var Filterable = {
  filter: filter4,
  filterMap: filterMap2,
  partition: partition3,
  partitionMap: partitionMap3
};

// node_modules/@effect-ts/core/_mjs/Option/instances/Foldable.mjs
var Foldable = {
  reduce: (b2, f2) => (fa) => isNone(fa) ? b2 : f2(b2, fa.value),
  reduceRight: (b2, f2) => (fa) => isNone(fa) ? b2 : f2(fa.value, b2),
  foldMap: (M2) => (f2) => (fa) => isNone(fa) ? M2.identity : f2(fa.value)
};

// node_modules/@effect-ts/core/_mjs/Option/operations/forEachF.mjs
var forEachF2 = /* @__PURE__ */ implementForEachF()(() => (G2) => (f2) => (fa) => isNone(fa) ? succeedF(G2)(none) : G2.map(some)(f2(fa.value)));

// node_modules/@effect-ts/core/_mjs/Option/instances/ForEach.mjs
var ForEach = {
  ...Covariant3,
  forEachF: forEachF2
};

// node_modules/@effect-ts/core/_mjs/Option/instances/IdentityFlatten.mjs
var IdentityFlatten3 = {
  ...Any3,
  ...AssociativeFlatten3
};

// node_modules/@effect-ts/core/_mjs/Option/instances/Monad.mjs
var Monad3 = {
  ...Covariant3,
  ...IdentityFlatten3
};

// node_modules/@effect-ts/core/_mjs/Option/operations/separateF.mjs
var separateF2 = /* @__PURE__ */ implementSeparateF()((_2) => (F2) => (f2) => (fa) => {
  const o2 = map_(fa, (a2) => F2.map((e2) => tuple2(getLeft(e2), getRight(e2)))(f2(a2)));
  return isNone(o2) ? succeedF(F2)(tuple2(none, none)) : o2.value;
});

// node_modules/@effect-ts/core/_mjs/Option/instances/Wiltable.mjs
var Wiltable = {
  separateF: separateF2
};

// node_modules/@effect-ts/core/_mjs/Option/operations/compactF.mjs
var compactF2 = /* @__PURE__ */ implementCompactF()((_2) => (F2) => (f2) => (fa) => {
  return isNone(fa) ? succeedF(F2)(none) : f2(fa.value);
});

// node_modules/@effect-ts/core/_mjs/Option/instances/Witherable.mjs
var Witherable = {
  compactF: compactF2
};

// node_modules/@effect-ts/core/_mjs/Option/operations/alt.mjs
var alt2 = /* @__PURE__ */ orElseF({
  ...Covariant3,
  ...AssociativeEither2
});

// node_modules/@effect-ts/core/_mjs/Option/operations/elem.mjs
function elem2(E2) {
  const el = elem_2(E2);
  return (a2) => (ma) => el(ma, a2);
}
function elem_2(E2) {
  return (ma, a2) => isNone(ma) ? false : E2.equals(a2, ma.value);
}

// node_modules/@effect-ts/core/_mjs/Option/operations/getApplyAssociative.mjs
function getApplyAssociative(S2) {
  return makeAssociative((x2, y2) => isSome(x2) && isSome(y2) ? some(S2.combine(x2.value, y2.value)) : none);
}

// node_modules/@effect-ts/core/_mjs/Option/operations/getApplyIdentity.mjs
function getApplyIdentity(M2) {
  return fromAssociative(getApplyAssociative(M2))(some(M2.identity));
}

// node_modules/@effect-ts/core/_mjs/Option/operations/getEqual.mjs
function getEqual2(E2) {
  return {
    equals: (x2, y2) => x2 === y2 || (isNone(x2) ? isNone(y2) : isNone(y2) ? false : E2.equals(x2.value, y2.value))
  };
}

// node_modules/@effect-ts/core/_mjs/Option/operations/getFirstAssociative.mjs
function getFirstAssociative() {
  return makeAssociative((x2, y2) => isNone(x2) ? y2 : x2);
}

// node_modules/@effect-ts/core/_mjs/Option/operations/getFirstIdentity.mjs
function getFirstIdentity() {
  return fromAssociative(getFirstAssociative())(none);
}

// node_modules/@effect-ts/core/_mjs/Option/operations/getFirst.mjs
function getFirst(...items) {
  return fold9(getFirstIdentity())(items);
}

// node_modules/@effect-ts/core/_mjs/Option/operations/getIdentity.mjs
function getIdentity4(A2) {
  return makeIdentity(none, (x2, y2) => isNone(x2) ? y2 : isNone(y2) ? x2 : some(A2.combine(x2.value, y2.value)));
}

// node_modules/@effect-ts/core/_mjs/Option/operations/getLastAssociative.mjs
function getLastAssociative() {
  return makeAssociative((x2, y2) => isNone(x2) ? x2 : y2);
}

// node_modules/@effect-ts/core/_mjs/Option/operations/getLastIdentity.mjs
function getLastIdentity() {
  return fromAssociative(getLastAssociative())(none);
}

// node_modules/@effect-ts/core/_mjs/Option/operations/getLast.mjs
function getLast(...items) {
  return fold9(getLastIdentity())(items);
}

// node_modules/@effect-ts/core/_mjs/Option/operations/getOrd.mjs
function getOrd2(_2) {
  return makeOrd((x2, y2) => x2 === y2 ? 0 : isSome(x2) ? isSome(y2) ? _2.compare(x2.value, y2.value) : 1 : -1);
}

// node_modules/@effect-ts/core/_mjs/Option/operations/getShow.mjs
function getShow2(S2) {
  return {
    show: (ma) => isNone(ma) ? "none" : `some(${S2.show(ma.value)})`
  };
}

// node_modules/@effect-ts/core/_mjs/Option/operations/sequence.mjs
var sequence = /* @__PURE__ */ sequenceF(ForEach);

// node_modules/@effect-ts/core/_mjs/Option/dsl/conditionals.mjs
var branch = /* @__PURE__ */ conditionalF(Covariant3);
var branch_ = /* @__PURE__ */ conditionalF_(Covariant3);

// node_modules/@effect-ts/core/_mjs/Option/dsl/do.mjs
var do_4 = /* @__PURE__ */ doF(Monad3);
var let_4 = /* @__PURE__ */ letF(Monad3);
var bind4 = /* @__PURE__ */ bindF(Monad3);

// node_modules/@effect-ts/core/_mjs/Option/dsl/gen.mjs
var gen5 = /* @__PURE__ */ genF(Monad3);

// node_modules/@effect-ts/core/_mjs/Option/dsl/matchers.mjs
var {
  match: match2,
  matchIn: matchIn2,
  matchMorph: matchMorph2,
  matchTag: matchTag3,
  matchTagIn: matchTagIn2
} = /* @__PURE__ */ matchers(Covariant3);

// node_modules/@effect-ts/core/_mjs/Option/dsl/struct.mjs
var struct3 = /* @__PURE__ */ structF({
  ...Monad3,
  ...Applicative3
});

// node_modules/@effect-ts/core/_mjs/Option/dsl/tuple.mjs
var tuple5 = /* @__PURE__ */ tupleF({
  ...Monad3,
  ...Applicative3
});

// node_modules/@effect-ts/core/_mjs/Collections/Immutable/Chunk/instances.mjs
var Collection = {
  builder
};
var Any4 = {
  any: () => single({})
};
var AssociativeBothZip = {
  both: zip6
};
var AssociativeFlatten4 = {
  flatten: flatten5
};
var Covariant4 = {
  map: map5
};
var ApplyZip = {
  ...Covariant4,
  ...AssociativeBothZip
};
var Monad4 = {
  ...Any4,
  ...Covariant4,
  ...AssociativeFlatten4
};
var Applicative4 = /* @__PURE__ */ getApplicativeF(Monad4);
var ForEach2 = {
  map: map5,
  forEachF
};
var ForEachWithIndex = {
  map: map5,
  forEachWithIndexF
};
var Wiltable2 = {
  separateF
};
var WiltableWithIndex = {
  separateWithIndexF
};
var Witherable2 = {
  compactF
};
var WitherableWithIndex = {
  compactWithIndexF
};
var Compact = {
  compact: compact3
};
var Separate = {
  separate: separate2
};
var Extend2 = {
  extend: (f2) => (fa) => single(f2(fa))
};
var Reduce = {
  reduce: reduce5
};
var ReduceWithIndex = {
  reduceWithIndex: (b2, f2) => (fa) => reduce_7(zipWithIndex(fa), b2, (b3, {
    tuple: [a2, i2]
  }) => f2(i2, b3, a2))
};
var ReduceRightWithIndex = {
  reduceRightWithIndex: (b2, f2) => (fa) => reduceRight_5(zipWithIndex(fa), b2, ({
    tuple: [a2, i2]
  }, b3) => f2(i2, a2, b3))
};
var ReduceRight = {
  reduceRight: reduceRight2
};
var FoldMap = {
  foldMap
};
var FoldMapWithIndex = {
  foldMapWithIndex
};
var Foldable2 = {
  ...FoldMap,
  ...Reduce,
  ...ReduceRight
};
var FoldableWithIndex = {
  ...FoldMapWithIndex,
  ...ReduceWithIndex,
  ...ReduceRightWithIndex
};
var Filter = {
  filter: filter2
};
var FilterWithIndex = {
  filterWithIndex: (predicate) => (fa) => collect_2(zipWithIndex(fa), ({
    tuple: [a2, i2]
  }) => predicate(i2, a2) ? some(a2) : none)
};
var FilterMap = {
  filterMap: collect
};
var FilterMapWithIndex = {
  filterMapWithIndex: (f2) => (fa) => collect_2(zipWithIndex(fa), ({
    tuple: [a2, i2]
  }) => f2(i2, a2))
};
var Partition = {
  partition: partition2
};
var PartitionWithIndex = {
  partitionWithIndex
};
var PartitionMap = {
  partitionMap: partitionMap2
};
var PartitionMapWithIndex = {
  partitionMapWithIndex
};
var Filterable2 = {
  ...Filter,
  ...FilterMap,
  ...Partition,
  ...PartitionMap
};
var FilterableWithIndex = {
  ...FilterWithIndex,
  ...FilterMapWithIndex,
  ...PartitionWithIndex,
  ...PartitionMapWithIndex
};
var DepthFirstChainRec = {
  chainRec: (f2) => (a2) => {
    let todo = f2(a2);
    let result4 = empty4();
    while (size4(todo) > 0) {
      const e2 = unsafeHead(todo);
      todo = unsafeTail(todo);
      if (e2._tag === "Left") {
        todo = concat_3(f2(e2.left), todo);
      } else {
        result4 = append_4(result4, e2.right);
      }
    }
    return result4;
  }
};
var depthFirstChainRec = DepthFirstChainRec.chainRec;
var BreadthFirstChainRec = {
  chainRec: (f2) => (a2) => {
    let todo = f2(a2);
    let result4 = empty4();
    while (size4(todo) > 0) {
      const e2 = unsafeHead(todo);
      todo = unsafeTail(todo);
      if (e2._tag === "Left") {
        todo = concat_3(todo, f2(e2.left));
      } else {
        result4 = append_4(result4, e2.right);
      }
    }
    return result4;
  }
};
var breadthFirstChainRec = BreadthFirstChainRec.chainRec;

// node_modules/@effect-ts/core/_mjs/Effect/Managed/index.mjs
var Managed_exports = {};
__export(Managed_exports, {
  Allocation: () => Allocation,
  GenManaged: () => GenManaged,
  ManagedImpl: () => ManagedImpl,
  ManagedURI: () => ManagedURI,
  Reservation: () => Reservation,
  absolve: () => absolve2,
  absorb: () => absorb2,
  absorb_: () => absorb_,
  access: () => access4,
  accessM: () => accessM4,
  accessManaged: () => accessManaged,
  accessService: () => accessService3,
  accessServiceM: () => accessServiceM3,
  accessServices: () => accessServices2,
  accessServicesM: () => accessServicesM2,
  accessServicesT: () => accessServicesT2,
  accessServicesTM: () => accessServicesTM2,
  allocate: () => allocate,
  andThen: () => andThen2,
  andThen_: () => andThen_3,
  as: () => as4,
  asService: () => asService2,
  asService_: () => asService_2,
  asSome: () => asSome2,
  asSomeError: () => asSomeError2,
  asUnit: () => asUnit2,
  as_: () => as_2,
  bimap: () => bimap5,
  bimap_: () => bimap_4,
  bind: () => bind3,
  bindAll: () => bindAll2,
  bindAllPar: () => bindAllPar2,
  bindAllParN: () => bindAllParN2,
  bindAllParN_: () => bindAllParN_2,
  bindAllPar_: () => bindAllPar_2,
  bindAll_: () => bindAll_2,
  bind_: () => bind_2,
  catchAll: () => catchAll4,
  catchAllCause: () => catchAllCause2,
  catchAllCause_: () => catchAllCause_2,
  catchAll_: () => catchAll_3,
  catchSome: () => catchSome2,
  catchSomeCause: () => catchSomeCause2,
  catchSomeCause_: () => catchSomeCause_2,
  catchSome_: () => catchSome_2,
  chain: () => chain9,
  chainError: () => chainError2,
  chainError_: () => chainError_2,
  chain_: () => chain_13,
  collect: () => collect3,
  collectAll: () => collectAll4,
  collectAllPar: () => collectAllPar3,
  collectAllParN: () => collectAllParN2,
  collectAllParN_: () => collectAllParN_2,
  collectAllSuccesses: () => collectAllSuccesses2,
  collectAllSuccessesPar: () => collectAllSuccessesPar2,
  collectAllSuccessesParN: () => collectAllSuccessesParN2,
  collectAllSuccessesParN_: () => collectAllSuccessesParN_2,
  collectAllUnit: () => collectAllUnit2,
  collectAllUnitPar: () => collectAllUnitPar2,
  collectAllUnitParN: () => collectAllUnitParN2,
  collectAllUnitParN_: () => collectAllUnitParN_2,
  collectAllWith: () => collectAllWith2,
  collectAllWithPar: () => collectAllWithPar2,
  collectAllWithParN: () => collectAllWithParN2,
  collectAllWithParN_: () => collectAllWithParN_2,
  collectAllWithPar_: () => collectAllWithPar_2,
  collectAllWith_: () => collectAllWith_2,
  collectPar: () => collectPar2,
  collectParN: () => collectParN2,
  collectParN_: () => collectParN_2,
  collectPar_: () => collectPar_2,
  collect_: () => collect_4,
  compose: () => compose3,
  compose_: () => compose_4,
  cond: () => cond2,
  cond_: () => cond_2,
  continueOrFail: () => continueOrFail2,
  continueOrFailM: () => continueOrFailM2,
  continueOrFailM_: () => continueOrFailM_2,
  continueOrFail_: () => continueOrFail_2,
  create: () => create,
  die: () => die4,
  dieMessage: () => dieMessage2,
  dieWith: () => dieWith2,
  do: () => do_3,
  either: () => either3,
  ensuring: () => ensuring2,
  ensuringFirst: () => ensuringFirst,
  ensuringFirst_: () => ensuringFirst_,
  ensuring_: () => ensuring_2,
  environment: () => environment3,
  eventually: () => eventually2,
  exposeTracer: () => exposeTracer,
  fail: () => fail8,
  failWith: () => failWith2,
  fiberId: () => fiberId2,
  finalizer: () => finalizer,
  finalizerExit: () => finalizerExit,
  finalizerRef: () => finalizerRef,
  first: () => first4,
  flatten: () => flatten10,
  flattenM: () => flattenM,
  flip: () => flip2,
  flipWith: () => flipWith2,
  flipWith_: () => flipWith_2,
  fold: () => fold10,
  foldCause: () => foldCause2,
  foldCauseM: () => foldCauseM2,
  foldCauseM_: () => foldCauseM_2,
  foldCause_: () => foldCause_2,
  foldM: () => foldM4,
  foldM_: () => foldM_4,
  fold_: () => fold_6,
  forEach: () => forEach5,
  forEachExec: () => forEachExec2,
  forEachExec_: () => forEachExec_2,
  forEachPar: () => forEachPar2,
  forEachParN: () => forEachParN2,
  forEachParN_: () => forEachParN_2,
  forEachPar_: () => forEachPar_2,
  forEachUnit: () => forEachUnit2,
  forEachUnitPar: () => forEachUnitPar2,
  forEachUnitParN: () => forEachUnitParN2,
  forEachUnitParN_: () => forEachUnitParN_2,
  forEachUnitPar_: () => forEachUnitPar_2,
  forEachUnit_: () => forEachUnit_2,
  forEach_: () => forEach_7,
  fork: () => managedFork,
  fromAutoClosable: () => fromAutoClosable,
  fromAutoClosableM: () => fromAutoClosableM,
  fromEffect: () => fromEffect,
  fromEffectUninterruptible: () => fromEffectUninterruptible,
  fromEither: () => fromEither4,
  fromEitherWith: () => fromEitherWith,
  gen: () => gen6,
  get: () => get7,
  halt: () => halt4,
  haltWith: () => haltWith2,
  identityLeft: () => identityLeft,
  if: () => _if2,
  ifM: () => ifM2,
  ifM_: () => ifM_2,
  if_: () => if_2,
  ignore: () => ignore2,
  interrupt: () => interrupt5,
  interruptAs: () => interruptAs3,
  isFailure: () => isFailure2,
  isSuccess: () => isSuccess2,
  iterate: () => iterate2,
  join: () => join4,
  joinEither: () => joinEither2,
  joinEither_: () => joinEither_2,
  join_: () => join_3,
  left: () => left3,
  let: () => let__2,
  let_: () => let_3,
  loop: () => loop5,
  loopUnit: () => loopUnit2,
  make: () => make5,
  makeExit: () => makeExit,
  makeExit_: () => makeExit_,
  makeInterruptible: () => makeInterruptible,
  makeInterruptible_: () => makeInterruptible_,
  makeManagedReleaseMap: () => makeManagedReleaseMap,
  makeReservation: () => makeReservation,
  makeReservation_: () => makeReservation_,
  makeReserve: () => makeReserve,
  makeSucceedWith: () => makeSucceedWith,
  make_: () => make_,
  managedApply: () => managedApply,
  managedReserve: () => managedReserve,
  map: () => map10,
  mapEffect: () => mapEffect2,
  mapEffect_: () => mapEffect_2,
  mapError: () => mapError5,
  mapErrorCause: () => mapErrorCause3,
  mapErrorCause_: () => mapErrorCause_2,
  mapError_: () => mapError_4,
  mapM: () => mapM,
  mapM_: () => mapM_,
  mapN: () => mapN2,
  mapNPar: () => mapNPar2,
  mapNParN: () => mapNParN2,
  mapNParN_: () => mapNParN_2,
  mapNPar_: () => mapNPar_2,
  mapN_: () => mapN_2,
  mapTryCatch: () => mapTryCatch2,
  mapTryCatch_: () => mapTryCatch_2,
  map_: () => map_14,
  memoize: () => memoize2,
  merge: () => merge3,
  mergeAll: () => mergeAll2,
  mergeAllPar: () => mergeAllPar2,
  mergeAllParN: () => mergeAllParN2,
  mergeAllParN_: () => mergeAllParN_2,
  mergeAllPar_: () => mergeAllPar_2,
  mergeAll_: () => mergeAll_2,
  none: () => none4,
  onExit: () => onExit,
  onExitFirst: () => onExitFirst,
  onExitFirst_: () => onExitFirst_,
  onExit_: () => onExit_,
  option: () => option2,
  optional: () => optional2,
  orDie: () => orDie3,
  orDieWith: () => orDieWith2,
  orDieWith_: () => orDieWith_2,
  orElse: () => orElse4,
  orElseEither: () => orElseEither4,
  orElseEither_: () => orElseEither_4,
  orElseFail: () => orElseFail3,
  orElseFail_: () => orElseFail_2,
  orElseOptional: () => orElseOptional2,
  orElseOptional_: () => orElseOptional_2,
  orElseSucceed: () => orElseSucceed2,
  orElseSucceed_: () => orElseSucceed_2,
  orElse_: () => orElse_3,
  preallocate: () => preallocate,
  preallocateManaged: () => preallocateManaged,
  preallocationScope: () => preallocationScope,
  provide: () => provide3,
  provideAll: () => provideAll3,
  provideAll_: () => provideAll_4,
  provideLayer: () => provideLayer2,
  provideLayer_: () => provideLayer_2,
  provideService: () => provideService2,
  provideServiceM: () => provideServiceM2,
  provideSome: () => provideSome3,
  provideSomeLayer: () => provideSomeLayer2,
  provideSome_: () => provideSome_2,
  reduce: () => reduce6,
  reduceAll: () => reduceAll2,
  reduceAllPar: () => reduceAllPar2,
  reduceAllParN: () => reduceAllParN2,
  reduceAllParN_: () => reduceAllParN_2,
  reduceAllPar_: () => reduceAllPar_2,
  reduceAll_: () => reduceAll_2,
  reduceRight: () => reduceRight5,
  reduceRight_: () => reduceRight_7,
  reduce_: () => reduce_8,
  refineOrDie: () => refineOrDie2,
  refineOrDieWith: () => refineOrDieWith2,
  refineOrDieWith_: () => refineOrDieWith_2,
  refineOrDie_: () => refineOrDie_2,
  reject: () => reject2,
  rejectM: () => rejectM2,
  rejectM_: () => rejectM_2,
  reject_: () => reject_2,
  release: () => release2,
  releaseMap: () => releaseMap,
  replaceService: () => replaceService2,
  replaceServiceM: () => replaceServiceM2,
  replaceServiceM_: () => replaceServiceM_2,
  replaceService_: () => replaceService_2,
  reserve: () => reserve,
  result: () => result2,
  retry: () => retry3,
  retryOrElse: () => retryOrElse2,
  retryOrElseEither: () => retryOrElseEither2,
  retryOrElseEither_: () => retryOrElseEither_2,
  retryOrElse_: () => retryOrElse_2,
  retry_: () => retry_2,
  right: () => right3,
  runtime: () => runtime2,
  sandbox: () => sandbox2,
  sandboxWith: () => sandboxWith2,
  sandboxWith_: () => sandboxWith_2,
  scope: () => scope2,
  second: () => second3,
  service: () => service2,
  services: () => services2,
  some: () => some3,
  someOrElse: () => someOrElse2,
  someOrElseM: () => someOrElseM2,
  someOrElseM_: () => someOrElseM_2,
  someOrElse_: () => someOrElse_2,
  someOrFail: () => someOrFail2,
  someOrFailException: () => someOrFailException2,
  someOrFail_: () => someOrFail_2,
  struct: () => struct4,
  structPar: () => structPar2,
  structParN: () => structParN2,
  structParN_: () => structParN_2,
  succeed: () => succeed7,
  succeedWith: () => succeedWith4,
  suspend: () => suspend6,
  swap: () => swap3,
  switchable: () => switchable,
  tap: () => tap5,
  tapBoth: () => tapBoth2,
  tapBoth_: () => tapBoth_2,
  tapCause: () => tapCause2,
  tapCause_: () => tapCause_2,
  tapError: () => tapError2,
  tapError_: () => tapError_2,
  tapM: () => tapM,
  tapM_: () => tapM_,
  tap_: () => tap_5,
  timed: () => timed2,
  timeout: () => timeout2,
  timeout_: () => timeout_2,
  toLayer: () => toLayer2,
  toLayerMany: () => toLayerMany,
  toLayer_: () => toLayer_,
  tryCatch: () => tryCatch5,
  tuple: () => tuple6,
  tuplePar: () => tuplePar2,
  tupleParN: () => tupleParN2,
  union: () => union3,
  unionFn: () => unionFn2,
  unit: () => unit4,
  unless: () => unless2,
  unlessM: () => unlessM2,
  unlessM_: () => unlessM_2,
  unless_: () => unless_2,
  unsandbox: () => unsandbox2,
  unwrap: () => unwrap,
  updateService: () => updateService2,
  updateService_: () => updateService_2,
  use: () => use,
  useForever: () => useForever,
  useNow: () => useNow,
  use_: () => managedUse_,
  when: () => when2,
  whenM: () => whenM2,
  withChildren: () => withChildren2,
  withEarlyRelease: () => withEarlyRelease,
  withEarlyReleaseExit: () => withEarlyReleaseExit,
  withEarlyReleaseExit_: () => withEarlyReleaseExit_,
  zip: () => zip7,
  zipLeft: () => zipLeft3,
  zipLeftPar: () => zipLeftPar2,
  zipLeftPar_: () => zipLeftPar_2,
  zipLeft_: () => zipLeft_2,
  zipPar: () => zipPar4,
  zipPar_: () => zipPar_3,
  zipRight: () => zipRight3,
  zipRightPar: () => zipRightPar2,
  zipRightPar_: () => zipRightPar_2,
  zipRight_: () => zipRight_3,
  zipWith: () => zipWith5,
  zipWithPar: () => zipWithPar2,
  zipWithPar_: () => zipWithPar_2,
  zipWith_: () => zipWith_6,
  zip_: () => zip_6
});

// node_modules/@effect-ts/system/_mjs/Managed/struct.mjs
function struct4(r2, __trace) {
  return map_14(forEach_7(collect_(r2, (k2, v2) => [k2, v2]), ([_2, e2]) => map_14(e2, (a2) => [_2, a2]), __trace), (values3) => {
    const res = {};
    for (const [k2, v2] of values3) {
      res[k2] = v2;
    }
    return res;
  });
}
function structPar2(r2, __trace) {
  return map_14(forEachPar_2(collect_(r2, (k2, v2) => [k2, v2]), ([_2, e2]) => map_14(e2, (a2) => [_2, a2]), __trace), (values3) => {
    const res = {};
    for (const [k2, v2] of values3) {
      res[k2] = v2;
    }
    return res;
  });
}
function structParN2(n2, __trace) {
  return (r2) => structParN_2(r2, n2, __trace);
}
function structParN_2(r2, n2, __trace) {
  return map_14(forEachParN_2(collect_(r2, (k2, v2) => [k2, v2]), n2, ([_2, e2]) => map_14(e2, (a2) => [_2, a2]), __trace), (values3) => {
    const res = {};
    for (const [k2, v2] of values3) {
      res[k2] = v2;
    }
    return res;
  });
}
function bindAll2(r2, __trace) {
  return (s2) => bindAll_2(s2, r2, __trace);
}
function bindAll_2(s2, r2, __trace) {
  return chain_13(s2, (k2) => map_14(forEach_7(collect_(r2(k2), (k3, v2) => [k3, v2]), ([_2, e2]) => map_14(e2, (a2) => [_2, a2]), __trace), (values3) => {
    const res = {};
    for (const [k3, v2] of values3) {
      res[k3] = v2;
    }
    return Object.assign(res, k2);
  }));
}
function bindAllPar2(r2, __trace) {
  return (s2) => bindAllPar_2(s2, r2, __trace);
}
function bindAllPar_2(s2, r2, __trace) {
  return chain_13(s2, (k2) => map_14(forEachPar_2(collect_(r2(k2), (k3, v2) => [k3, v2]), ([_2, e2]) => map_14(e2, (a2) => [_2, a2]), __trace), (values3) => {
    const res = {};
    for (const [k3, v2] of values3) {
      res[k3] = v2;
    }
    return Object.assign(res, k2);
  }));
}
function bindAllParN2(n2, r2, __trace) {
  return (s2) => bindAllParN_2(s2, n2, r2, __trace);
}
function bindAllParN_2(s2, n2, r2, __trace) {
  return chain_13(s2, (k2) => map_14(forEachParN_2(collect_(r2(k2), (k3, v2) => [k3, v2]), n2, ([_2, e2]) => map_14(e2, (a2) => [_2, a2]), __trace), (values3) => {
    const res = {};
    for (const [k3, v2] of values3) {
      res[k3] = v2;
    }
    return Object.assign(res, k2);
  }));
}

// node_modules/@effect-ts/system/_mjs/Managed/methods/fromEither.mjs
function fromEitherWith(self, __trace) {
  return fromEffect(fromEither2(self), __trace);
}
function fromEither4(self, __trace) {
  return fromEffect(fromEither2(() => self), __trace);
}

// node_modules/@effect-ts/system/_mjs/Managed/methods/absolve.mjs
function absolve2(self, __trace) {
  return chain_13(self, fromEither4, __trace);
}

// node_modules/@effect-ts/system/_mjs/Managed/methods/halt.mjs
function halt4(self, __trace) {
  return fromEffect(halt2(self), __trace);
}
function haltWith2(self, __trace) {
  return fromEffect(haltWith(self, __trace));
}

// node_modules/@effect-ts/system/_mjs/Managed/methods/foldM.mjs
function foldM4(failure, success, __trace) {
  return (self) => foldM_4(self, failure, success, __trace);
}
function foldM_4(self, failure, success, __trace) {
  return foldCauseM_2(self, (x2) => fold_2(failureOrCause(x2), failure, halt4), success, __trace);
}

// node_modules/@effect-ts/system/_mjs/Managed/methods/releaseMap.mjs
var releaseMap = /* @__PURE__ */ managedApply(/* @__PURE__ */ map9((tp) => tuple2(noopFinalizer, tp.get(1)))(/* @__PURE__ */ environment2()));

// node_modules/@effect-ts/system/_mjs/Managed/methods/suspend.mjs
function suspend6(f2, __trace) {
  return managedApply(suspend4(() => f2().effect, __trace));
}

// node_modules/@effect-ts/system/_mjs/Managed/methods/api.mjs
function absorb2(f2, __trace) {
  return (self) => absorb_(self, f2, __trace);
}
function absorb_(self, f2, __trace) {
  return foldM_4(sandbox2(self), (c2) => fail8(squash(f2)(c2)), succeed7, __trace);
}
function get7(self, __trace) {
  return absolve2(map_14(self, fromOption(() => none)), __trace);
}
function mapError_4(self, f2, __trace) {
  return managedApply(mapError_3(self.effect, f2, __trace));
}
function mapError5(f2, __trace) {
  return (self) => mapError_4(self, f2, __trace);
}
function mapErrorCause_2(self, f2, __trace) {
  return managedApply(mapErrorCause_(self.effect, f2, __trace));
}
function mapErrorCause3(f2, __trace) {
  return (self) => mapErrorCause_2(self, f2, __trace);
}
function memoize2(self, __trace) {
  return mapM_(releaseMap, (finalizers) => map_13(bind_(bind_(do_2, "promise", () => make4()), "complete", ({
    promise: promise2
  }) => once(accessM3((r2) => to_(map_13(provideAll_3(self.effect, tuple2(r2, finalizers)), (_2) => _2.get(1)), promise2)))), ({
    complete,
    promise: promise2
  }) => toManaged(zipRight_2(complete, wait(promise2)))), __trace);
}
function merge3(self, __trace) {
  return foldM_4(self, succeed7, succeed7, __trace);
}
var unit4 = /* @__PURE__ */ suspend6(() => fromEffect(unit3));
function none4(self, __trace) {
  return foldM_4(self, (x2) => fail8(some(x2)), fold(() => unit4, () => fail8(none)), __trace);
}
function fold_6(self, onFail, onSuccess, __trace) {
  return foldM_4(self, (x2) => succeed7(onFail(x2)), (x2) => succeed7(onSuccess(x2)), __trace);
}
function fold10(onFail, onSuccess, __trace) {
  return (self) => fold_6(self, onFail, onSuccess, __trace);
}
function option2(self, __trace) {
  return fold_6(self, () => none, some, __trace);
}
function optional2(self, __trace) {
  return foldM_4(self, fold(() => succeed7(none), fail8), (x2) => succeed7(some(x2)), __trace);
}
function orDieWith2(f2, __trace) {
  return (self) => orDieWith_2(self, f2, __trace);
}
function orDieWith_2(self, f2, __trace) {
  return managedApply(orDieWith_(self.effect, f2, __trace));
}
function orDie3(self, __trace) {
  return orDieWith_2(self, identity, __trace);
}
function orElse4(that, __trace) {
  return (self) => orElse_3(self, that, __trace);
}
function orElse_3(self, that, __trace) {
  return foldM_4(self, () => that(), succeed7, __trace);
}
function orElseFail3(e2, __trace) {
  return (self) => orElseFail_2(self, e2, __trace);
}
function orElseFail_2(self, e2, __trace) {
  return orElse_3(self, () => fail8(e2), __trace);
}
function orElseEither4(that, __trace) {
  return (self) => orElseEither_4(self, that, __trace);
}
function orElseEither_4(self, that, __trace) {
  return foldM_4(self, () => map_14(that(), left), (x2) => succeed7(right(x2)), __trace);
}
function orElseOptional_2(self, that, __trace) {
  return catchAll_3(self, fold(() => that(), (e2) => fail8(some(e2))), __trace);
}
function orElseOptional2(that, __trace) {
  return (self) => orElseOptional_2(self, that, __trace);
}
function orElseSucceed_2(self, that, __trace) {
  return orElse_3(self, () => succeed7(that()), __trace);
}
function orElseSucceed2(that, __trace) {
  return (self) => orElseSucceed_2(self, that, __trace);
}
function catchAll_3(self, f2, __trace) {
  return foldM_4(self, f2, succeed7, __trace);
}
function catchAll4(f2, __trace) {
  return (self) => catchAll_3(self, f2, __trace);
}
function catchAllCause_2(self, f2, __trace) {
  return foldCauseM_2(self, f2, succeed7, __trace);
}
function catchAllCause2(f2, __trace) {
  return (self) => foldCauseM_2(self, f2, succeed7, __trace);
}
function catchSome_2(self, pf, __trace) {
  return catchAll_3(self, (e2) => getOrElse_(pf(e2), () => fail8(e2)), __trace);
}
function catchSome2(pf, __trace) {
  return (self) => catchSome_2(self, pf, __trace);
}
function catchSomeCause_2(self, pf, __trace) {
  return catchAllCause_2(self, (e2) => getOrElse_(pf(e2), () => halt4(e2)), __trace);
}
function catchSomeCause2(pf, __trace) {
  return (self) => catchSomeCause_2(self, pf, __trace);
}
function continueOrFailM_2(self, e2, pf, __trace) {
  return chain_13(self, (a2) => getOrElse_(pf(a2), () => fail8(e2())), __trace);
}
function continueOrFailM2(e2, pf, __trace) {
  return (self) => continueOrFailM_2(self, e2, pf, __trace);
}
function continueOrFail_2(self, e2, pf, __trace) {
  return continueOrFailM_2(self, e2, (x2) => map_(pf(x2), succeed7), __trace);
}
function continueOrFail2(e2, pf, __trace) {
  return (self) => continueOrFail_2(self, e2, pf, __trace);
}
function provide3(r2, __trace) {
  return (next2) => provideSome_2(next2, (r0) => ({
    ...r0,
    ...r2
  }), __trace);
}
function compose3(that, __trace) {
  return (self) => compose_4(self, that, __trace);
}
function compose_4(self, that, __trace) {
  return chain_13(environment3(), (r1) => chain_13(provideAll_4(self, r1), (r2) => provideAll_4(that, r2)));
}
function either3(self, __trace) {
  return fold_6(self, left, right, __trace);
}
function eventually2(self, __trace) {
  return managedApply(eventually(self.effect, __trace));
}
function first4(self, __trace) {
  return zip_6(self, environment3(), __trace);
}
function chainError_2(self, f2, __trace) {
  return flipWith_2(self, chain9(f2, __trace));
}
function chainError2(f2, __trace) {
  return (self) => chainError_2(self, f2, __trace);
}
function flip2(self, __trace) {
  return foldM_4(self, succeed7, fail8, __trace);
}
function flipWith_2(self, f2, __trace) {
  return flip2(f2(flip2(self)), __trace);
}
function flipWith2(f2, __trace) {
  return (self) => flipWith_2(self, f2, __trace);
}
function flatten10(self, __trace) {
  return chain_13(self, identity, __trace);
}
function flattenM(self, __trace) {
  return mapM_(self, identity, __trace);
}
function foldCause_2(self, f2, g2, __trace) {
  return fold_6(sandbox2(self), f2, g2, __trace);
}
function foldCause2(f2, g2, __trace) {
  return (self) => fold_6(sandbox2(self), f2, g2, __trace);
}
function ignore2(self, __trace) {
  return fold_6(self, constVoid, constVoid, __trace);
}
function isFailure2(self, __trace) {
  return fold_6(self, () => true, () => false, __trace);
}
function isSuccess2(self, __trace) {
  return fold_6(self, () => false, () => true, __trace);
}
function join4(that, __trace) {
  return (self) => join_3(self, that, __trace);
}
function join_3(self, that, __trace) {
  return chain_13(environment3(), fold2((r2) => provideAll_4(self, r2), (r1) => provideAll_4(that, r1)), __trace);
}
function joinEither2(that, __trace) {
  return (self) => joinEither_2(self, that, __trace);
}
function joinEither_2(self, that, __trace) {
  return chain_13(environment3(), fold2((r0) => provideAll_4(map_14(self, left), r0), (r1) => provideAll_4(map_14(that, right), r1)), __trace);
}
function identityLeft(__trace) {
  return (self) => joinEither_2(self, environment3(), __trace);
}
function tryCatch5(f2, onThrow, __trace) {
  return fromEffect(tryCatch4(f2, onThrow), __trace);
}
function mapTryCatch2(onThrow, f2, __trace) {
  return (self) => mapTryCatch_2(self, onThrow, f2, __trace);
}
function mapTryCatch_2(self, onThrow, f2, __trace) {
  return foldM_4(self, (e2) => fail8(e2), (a2) => tryCatch5(() => f2(a2), onThrow), __trace);
}
function mapEffect_2(self, f2, __trace) {
  return mapTryCatch_2(self, identity, f2, __trace);
}
function mapEffect2(f2, __trace) {
  return (self) => mapEffect_2(self, f2, __trace);
}
function preallocate(self, __trace) {
  return uninterruptibleMask(({
    restore: restore2
  }) => map_13(bind_(bind_(bind_(do_2, "releaseMap", () => makeReleaseMap), "tp", ({
    releaseMap: releaseMap2
  }) => result(restore2(provideSome_(self.effect, (r2) => tuple2(r2, releaseMap2)), __trace))), "preallocated", ({
    releaseMap: releaseMap2,
    tp
  }) => foldM_3(tp, (c2) => zipRight_2(releaseMapReleaseAll(fail5(c2), sequential)(releaseMap2), halt2(c2)), ({
    tuple: [release4, a2]
  }) => succeed5(managedApply(accessM3(({
    tuple: [_2, releaseMap3]
  }) => map_13(add(release4)(releaseMap3), (_3) => tuple2(_3, a2))))))), ({
    preallocated
  }) => preallocated));
}
function preallocateManaged(self, __trace) {
  return managedApply(map_13(self.effect, ({
    tuple: [release4, a2]
  }) => tuple2(release4, managedApply(accessM3(({
    tuple: [_2, releaseMap2]
  }) => map_13(add(release4)(releaseMap2), (_3) => tuple2(_3, a2))))), __trace));
}
function provideLayer2(layer, __trace) {
  return (self) => provideLayer_2(self, layer, __trace);
}
function provideLayer_2(self, layer, __trace) {
  return chain_13(build(layer), (r2) => provideAll_4(self, r2), __trace);
}
function provideSomeLayer2(layer, __trace) {
  return (self) => provideLayer_2(self, layer["+++"](identity2()), __trace);
}
function refineOrDieWith2(pf, f2, __trace) {
  return (self) => refineOrDieWith_2(self, pf, f2);
}
function refineOrDieWith_2(self, pf, f2, __trace) {
  return catchAll_3(self, (e2) => fold_(pf(e2), () => die4(f2(e2), __trace), (e1) => fail8(e1, __trace)));
}
function refineOrDie2(pf, __trace) {
  return (self) => refineOrDie_2(self, pf, __trace);
}
function refineOrDie_2(self, pf, __trace) {
  return refineOrDieWith_2(self, pf, identity, __trace);
}
function die4(e2, __trace) {
  return fromEffect(die3(e2, __trace));
}
function dieWith2(e2, __trace) {
  return fromEffect(dieWith(e2, __trace));
}
function dieMessage2(message, __trace) {
  return die4(new RuntimeError(message), __trace);
}
function rejectM2(pf, __trace) {
  return (self) => rejectM_2(self, pf, __trace);
}
function rejectM_2(self, pf, __trace) {
  return chain_13(self, (a2) => fold_(pf(a2), () => succeed7(a2, __trace), (_2) => chain_13(_2, (e1) => fail8(e1), __trace)));
}
function reject2(pf, __trace) {
  return (self) => reject_2(self, pf, __trace);
}
function reject_2(self, pf, __trace) {
  return rejectM_2(self, (x2) => map_(pf(x2), fail8), __trace);
}
function release2(self, __trace) {
  return fromEffect(useNow(self), __trace);
}
function retryOrElseEither_2(self, policy, orElse6, __trace) {
  return managedApply(map_13(accessM3(({
    tuple: [env, releaseMap2]
  }) => provideAll_3(retryOrElseEither_(provideAll_3(self.effect, tuple2(env, releaseMap2)), policy, (e2, o2) => provideAll_3(orElse6(e2, o2).effect, tuple2(env, releaseMap2)), __trace), env)), fold2(({
    tuple: [f2, a2]
  }) => tuple2(f2, left(a2)), ({
    tuple: [f2, a2]
  }) => tuple2(f2, right(a2)))));
}
function retryOrElseEither2(policy, orElse6, __trace) {
  return (self) => retryOrElseEither_2(self, policy, orElse6, __trace);
}
function retryOrElse_2(self, policy, orElse6, __trace) {
  return map_14(retryOrElseEither_2(self, policy, orElse6, __trace), fold2(identity, identity));
}
function retryOrElse2(policy, orElse6, __trace) {
  return (self) => retryOrElse_2(self, policy, orElse6, __trace);
}
function retry_2(self, policy, __trace) {
  return retryOrElse_2(self, policy, (e2, _2) => fail8(e2), __trace);
}
function retry3(policy, __trace) {
  return (self) => retry_2(self, policy, __trace);
}
function result2(self, __trace) {
  return foldCauseM_2(self, (x2) => succeed7(halt(x2)), (x2) => succeed7(succeed4(x2)), __trace);
}
function sandbox2(self, __trace) {
  return managedApply(sandbox(self.effect, __trace));
}
function unsandbox2(self) {
  return mapErrorCause_2(self, flatten6);
}
function sandboxWith2(f2) {
  return (self) => sandboxWith_2(self, f2);
}
function sandboxWith_2(self, f2) {
  return unsandbox2(f2(sandbox2(self)));
}
function second3(self) {
  return zip_6(environment3(), self);
}
function some3(self) {
  return foldM_4(self, (x2) => fail8(some(x2)), fold(() => fail8(none), succeed7));
}
function someOrElse2(orElse6) {
  return (self) => someOrElse_2(self, orElse6);
}
function someOrElse_2(self, orElse6) {
  return map_14(self, getOrElse(orElse6));
}
function someOrElseM2(orElse6) {
  return (self) => someOrElseM_2(self, orElse6);
}
function someOrElseM_2(self, orElse6) {
  return chain_13(self, fold(() => orElse6, succeed7));
}
function someOrFail2(e2) {
  return (self) => someOrFail_2(self, e2);
}
function someOrFail_2(self, e2) {
  return chain_13(self, fold(() => fail8(e2()), succeed7));
}
function someOrFailException2(self) {
  return someOrFail_2(self, () => new NoSuchElementException());
}
function tapBoth_2(self, f2, g2) {
  return foldM_4(self, (e2) => chain_13(f2(e2), () => fail8(e2)), (a2) => map_14(g2(a2), () => a2));
}
function tapBoth2(f2, g2) {
  return (self) => tapBoth_2(self, f2, g2);
}
function tapCause_2(self, f2) {
  return catchAllCause_2(self, (c2) => chain_13(f2(c2), () => halt4(c2)));
}
function tapCause2(f2) {
  return (self) => tapCause_2(self, f2);
}
function tapError_2(self, f2) {
  return tapBoth_2(self, f2, succeed7);
}
function tapError2(f2) {
  return (self) => tapError_2(self, f2);
}
function tapM(f2) {
  return (self) => tapM_(self, f2);
}
function tapM_(self, f2) {
  return mapM_(self, (a2) => as_(f2(a2), a2));
}
function timed2(self) {
  return managedApply(chain_12(environment2(), ({
    tuple: [r2, releaseMap2]
  }) => provideSome_(map_13(timed(provideAll_3(self.effect, tuple2(r2, releaseMap2))), ({
    tuple: [duration, {
      tuple: [fin, a2]
    }]
  }) => tuple2(fin, tuple2(duration, a2))), (r3) => r3.get(0))));
}
function timeout_2(self, d2) {
  return managedApply(uninterruptibleMask(({
    restore: restore2
  }) => gen4(function* (_2) {
    const env = yield* _2(environment2());
    const {
      tuple: [r2, outerReleaseMap]
    } = env;
    const innerReleaseMap = yield* _2(makeReleaseMap);
    const earlyRelease = yield* _2(add((exit) => releaseMapReleaseAll(exit, sequential)(innerReleaseMap))(outerReleaseMap));
    const raceResult = yield* _2(restore2(provideAll_3(raceWith_(provideAll_3(self.effect, tuple2(r2, innerReleaseMap)), as_(sleep2(d2), none), (result4, sleeper) => zipRight_2(interrupt4(sleeper), done(map_12(result4, (tp) => right(tp.get(1))))), (_3, resultFiber) => succeed5(left(resultFiber))), r2)));
    const a2 = yield* _2(fold_2(raceResult, (f2) => as_(chain_12(fiberId, (id) => forkDaemon(ensuring_(interrupt4(f2), releaseMapReleaseAll(interrupt2(id), sequential)(innerReleaseMap)))), none), (v2) => succeed5(some(v2))));
    return tuple2(earlyRelease, a2);
  })));
}
function timeout2(d2) {
  return (self) => timeout_2(self, d2);
}
function toLayer2(tag2) {
  return fromManaged(tag2);
}
function toLayer_(self, tag2) {
  return toLayer2(tag2)(self);
}
function toLayerMany(...tags) {
  return (self) => fromRawManaged(map_14(self, (r2) => {
    const env = {};
    for (const tag2 of tags) {
      env[tag2.key] = tag2.read(r2);
    }
    return env;
  }));
}
function asUnit2(self) {
  return as_2(self, void 0);
}
function unlessM2(b2) {
  return (self) => unlessM_2(self, b2);
}
function unlessM_2(self, b2) {
  return chain_13(b2, (b3) => b3 ? unit4 : asUnit2(self));
}
function unless2(b2) {
  return unlessM2(succeedWith4(b2));
}
function unless_2(self, b2) {
  return unless2(b2)(self);
}
function as_2(self, b2) {
  return map_14(self, () => b2);
}
function as4(b2) {
  return (self) => as_2(self, b2);
}
function asSome2(self) {
  return map_14(self, some);
}
function asSomeError2(self) {
  return mapError_4(self, some);
}
function asService2(tag2) {
  return (self) => asService_2(self, tag2);
}
function asService_2(self, tag2) {
  return map_14(self, tag2.has);
}
function andThen_3(self, that) {
  return chain_13(self, (a2) => provideAll_4(that, a2));
}
function andThen2(that) {
  return (self) => andThen_3(self, that);
}
function bimap5(f2, g2) {
  return (self) => bimap_4(self, f2, g2);
}
function bimap_4(self, f2, g2) {
  return map_14(mapError_4(self, f2), g2);
}
function right3() {
  return (self) => joinEither_2(environment3(), self);
}
function left3() {
  return (self) => joinEither_2(self, environment3());
}
function access4(f2, __trace) {
  return fromEffect(access3(f2), __trace);
}
function accessManaged(f2) {
  return chain_13(environment3(), f2);
}
function accessM4(f2) {
  return mapM_(environment3(), f2);
}
function accessServicesM2(s2) {
  return (f2) => accessManaged((r2) => f2(map_10(s2, (v2) => r2[v2.key])));
}
function accessServicesTM2(...s2) {
  return (f2) => accessManaged((r2) => f2(...map_2(s2, (v2) => r2[v2.key])));
}
function accessServicesT2(...s2) {
  return (f2) => access4((r2) => f2(...map_2(s2, (v2) => r2[v2.key])));
}
function accessServices2(s2) {
  return (f2) => access4((r2) => f2(map_10(s2, (v2) => r2[v2.key])));
}
function accessServiceM3(s2) {
  return (f2) => accessManaged((r2) => f2(r2[s2.key]));
}
function accessService3(s2) {
  return (f2) => accessServiceM3(s2)((a2) => succeed7(f2(a2)));
}
function service2(s2) {
  return accessServiceM3(s2)((a2) => succeed7(a2));
}
function services2(...s2) {
  return access4((r2) => s2.map((tag2) => tag2.read(r2)));
}
function provideServiceM2(_2) {
  return (f2) => (ma) => accessManaged((r2) => chain_13(f2, (t2) => provideAll_4(ma, mergeEnvironments(_2, r2, t2))));
}
function provideService2(_2) {
  return (f2) => (ma) => provideServiceM2(_2)(succeed7(f2))(ma);
}
function replaceServiceM2(_2, f2) {
  return (ma) => accessServiceM3(_2)((t2) => provideServiceM2(_2)(f2(t2))(ma));
}
function replaceServiceM_2(ma, _2, f2) {
  return accessServiceM3(_2)((t2) => provideServiceM2(_2)(f2(t2))(ma));
}
function replaceService2(_2, f2) {
  return (ma) => accessServiceM3(_2)((t2) => provideServiceM2(_2)(succeed7(f2(t2)))(ma));
}
function replaceService_2(ma, _2, f2) {
  return accessServiceM3(_2)((t2) => provideServiceM2(_2)(succeed7(f2(t2)))(ma));
}
function whenM2(b2) {
  return unlessM2(map_14(b2, (b3) => !b3));
}
function when2(b2) {
  return unless2(() => !b2());
}
function withEarlyReleaseExit_(self, exit) {
  return managedApply(map_13(self.effect, (tp) => tuple2(tp.get(0), tuple2(uninterruptible2(tp.get(0)(exit)), tp.get(1)))));
}
function withEarlyReleaseExit(exit) {
  return (self) => withEarlyReleaseExit_(self, exit);
}
var fiberId2 = /* @__PURE__ */ fromEffect(fiberId);
function withEarlyRelease(self) {
  return chain_13(fiberId2, (id) => withEarlyReleaseExit_(self, interrupt2(id)));
}
function zipLeft_2(a2, b2) {
  return zipWith_6(a2, b2, (a3) => a3);
}
function zipLeft3(b2) {
  return (a2) => zipLeft_2(a2, b2);
}
function zipLeftPar_2(a2, b2) {
  return zipWithPar_2(a2, b2, (a3) => a3);
}
function zipLeftPar2(b2) {
  return (a2) => zipLeftPar_2(a2, b2);
}
function zipRight_3(a2, b2) {
  return zipWith_6(a2, b2, (_2, a3) => a3);
}
function zipRight3(b2) {
  return (a2) => zipRight_3(a2, b2);
}
function zipRightPar_2(a2, b2) {
  return zipWithPar_2(a2, b2, (_2, a3) => a3);
}
function zipRightPar2(b2) {
  return (a2) => zipRightPar_2(a2, b2);
}
function zipPar_3(a2, b2) {
  return zipWithPar_2(a2, b2, (a3, b3) => [a3, b3]);
}
function zipPar4(b2) {
  return (a2) => zipPar_3(a2, b2);
}
function create(effect2) {
  return managedApply(effect2);
}
function cond_2(pred, result4, error) {
  return pred ? succeed7(result4()) : fail8(error());
}
function cond2(result4, error) {
  return (pred) => cond_2(pred, result4, error);
}
function forEachUnitPar_2(as6, f2, __trace) {
  return mapM_(makeManagedReleaseMap(parallel, __trace), (parallelReleaseMap) => {
    const makeInnerMap = provideSome_(map_13(makeManagedReleaseMap(sequential).effect, (_2) => _2.get(1)), (r2) => tuple2(r2, parallelReleaseMap));
    return forEachUnitPar_(as6, (a2) => chain_12(makeInnerMap, (innerMap) => provideSome_(map_13(f2(a2).effect, (_2) => _2.get(1)), (r2) => tuple2(r2, innerMap))));
  });
}
function forEachUnitPar2(f2, __trace) {
  return (as6) => forEachUnitPar_2(as6, f2, __trace);
}
function forEachUnitParN_2(as6, n2, f2, __trace) {
  return mapM_(makeManagedReleaseMap(parallel, __trace), (parallelReleaseMap) => {
    const makeInnerMap = provideSome_(map_13(makeManagedReleaseMap(sequential).effect, (_2) => _2.get(1)), (r2) => tuple2(r2, parallelReleaseMap));
    return forEachUnitParN_(as6, n2, (a2) => chain_12(makeInnerMap, (innerMap) => provideSome_(map_13(f2(a2).effect, (_2) => _2.get(1)), (r2) => tuple2(r2, innerMap))));
  });
}
function forEachUnitParN2(n2, f2) {
  return (as6) => forEachUnitParN_2(as6, n2, f2);
}
function collect3(f2) {
  return (self) => collect_4(self, f2);
}
function collect_4(self, f2) {
  return map_14(forEach_7(self, (a2) => optional2(f2(a2))), compact3);
}
function collectPar2(f2) {
  return (self) => collectPar_2(self, f2);
}
function collectPar_2(self, f2) {
  return map_14(forEachPar_2(self, (a2) => optional2(f2(a2))), compact3);
}
function collectParN_2(self, n2, f2) {
  return map_14(forEachParN_2(self, n2, (a2) => optional2(f2(a2))), compact3);
}
function collectParN2(n2, f2) {
  return (self) => collectParN_2(self, n2, f2);
}
function collectAll4(as6, __trace) {
  return forEach_7(as6, identity, __trace);
}
function collectAllPar3(as6, __trace) {
  return forEachPar_2(as6, identity, __trace);
}
function collectAllParN2(n2, __trace) {
  return (as6) => forEachParN_2(as6, n2, identity, __trace);
}
function collectAllParN_2(as6, n2, __trace) {
  return forEachParN_2(as6, n2, identity, __trace);
}
function collectAllUnit2(as6, __trace) {
  return forEachUnit_2(as6, identity, __trace);
}
function collectAllUnitPar2(as6, __trace) {
  return forEachUnitPar_2(as6, identity, __trace);
}
function collectAllUnitParN2(n2, __trace) {
  return (as6) => forEachUnitParN_2(as6, n2, identity, __trace);
}
function collectAllUnitParN_2(as6, n2, __trace) {
  return forEachUnitParN_2(as6, n2, identity, __trace);
}
function collectAllWith_2(as6, pf, __trace) {
  return map_14(collectAll4(as6, __trace), collect(pf));
}
function collectAllWith2(pf, __trace) {
  return (as6) => collectAllWith_2(as6, pf, __trace);
}
function collectAllWithPar_2(as6, pf, __trace) {
  return map_14(collectAllPar3(as6, __trace), collect(pf));
}
function collectAllWithPar2(pf, __trace) {
  return (as6) => collectAllWithPar_2(as6, pf, __trace);
}
function collectAllWithParN_2(as6, n2, pf, __trace) {
  return map_14(collectAllParN_2(as6, n2, __trace), collect(pf));
}
function collectAllWithParN2(n2, pf, __trace) {
  return (as6) => collectAllWithParN_2(as6, n2, pf, __trace);
}
function collectAllSuccesses2(as6, __trace) {
  return collectAllWith_2(map_5(as6, (x2) => result2(x2)), (e2) => e2._tag === "Success" ? some(e2.value) : none, __trace);
}
function collectAllSuccessesPar2(as6, __trace) {
  return collectAllWithPar_2(map_5(as6, (x2) => result2(x2)), (e2) => e2._tag === "Success" ? some(e2.value) : none, __trace);
}
function collectAllSuccessesParN2(n2, __trace) {
  return (as6) => collectAllSuccessesParN_2(as6, n2, __trace);
}
function collectAllSuccessesParN_2(as6, n2, __trace) {
  return collectAllWithParN_2(map_5(as6, (x2) => result2(x2)), n2, (e2) => e2._tag === "Success" ? some(e2.value) : none, __trace);
}
function finalizerExit(f2, __trace) {
  return makeExit_(unit3, (_2, e2) => f2(e2), __trace);
}
function finalizer(f2, __trace) {
  return finalizerExit(() => f2, __trace);
}
function reduce_8(i2, zero2, f2, __trace) {
  return suspend6(() => reduce_(Array.from(i2), succeed7(zero2), (acc, el) => chain_13(acc, (a2) => f2(a2, el))), __trace);
}
function reduce6(zero2, f2, __trace) {
  return (i2) => reduce_8(i2, zero2, f2, __trace);
}
function reduceRight_7(i2, zero2, f2, __trace) {
  return suspend6(() => reduceRight_(Array.from(i2), succeed7(zero2), (el, acc) => chain_13(acc, (a2) => f2(el, a2))), __trace);
}
function reduceRight5(zero2, f2) {
  return (i2) => reduceRight_7(i2, zero2, f2);
}
function reduceAll_2(as6, f2) {
  return reduce_(tail3(as6), head3(as6), (acc, a2) => zipWith_6(acc, a2, f2));
}
function reduceAll2(f2) {
  return (as6) => reduceAll_2(as6, f2);
}
function reduceAllPar_2(as6, f2) {
  return mapM_(makeManagedReleaseMap(parallel), (parallelReleaseMap) => provideSome_(reduceAllPar_(map_15(as6, (_2) => map_13(_2.effect, (_3) => _3.get(1))), f2), (r2) => tuple2(r2, parallelReleaseMap)));
}
function reduceAllPar2(f2) {
  return (as6) => reduceAllPar_2(as6, f2);
}
function reduceAllParN_2(as6, n2, f2) {
  return mapM_(makeManagedReleaseMap(parallel), (parallelReleaseMap) => provideSome_(reduceAllParN_(map_15(as6, (_2) => map_13(_2.effect, (_3) => _3.get(1))), n2, f2), (r2) => tuple2(r2, parallelReleaseMap)));
}
function reduceAllParN2(n2, f2) {
  return (as6) => reduceAllParN_2(as6, n2, f2);
}
function mergeAll2(zero2, f2) {
  return (as6) => mergeAll_2(as6, zero2, f2);
}
function mergeAll_2(as6, zero2, f2) {
  return reduce_3(as6, succeed7(zero2), (b2, a2) => zipWith_6(b2, a2, f2));
}
function mergeAllPar2(zero2, f2) {
  return (as6) => mergeAllPar_2(as6, zero2, f2);
}
function mergeAllPar_2(as6, zero2, f2) {
  return mapM_(makeManagedReleaseMap(parallel), (parallelReleaseMap) => provideSome_(mergeAllPar_(map_5(as6, (_2) => map_13(_2.effect, (_3) => _3.get(1))), zero2, f2), (r2) => tuple2(r2, parallelReleaseMap)));
}
function mergeAllParN2(n2, zero2, f2) {
  return (as6) => mergeAllParN_2(as6, n2, zero2, f2);
}
function mergeAllParN_2(as6, n2, zero2, f2) {
  return mapM_(makeManagedReleaseMap(parallel), (parallelReleaseMap) => provideSome_(mergeAllParN_(map_5(as6, (_2) => map_13(_2.effect, (_3) => _3.get(1))), n2, zero2, f2), (r2) => tuple2(r2, parallelReleaseMap)));
}
var scope2 = /* @__PURE__ */ map_14(releaseMap, (finalizers) => (ma) => chain_12(environment2(), (r2) => provideAll_3(ma.effect, tuple2(r2, finalizers))));
function withChildren2(get8) {
  return unwrap(map_13(track, (supervisor) => managedApply(supervised_(get8(chain_12(supervisor.value, (children) => map_13(descriptor2, (d2) => filter_4(children, (_2) => _2.id !== d2.id)))).effect, supervisor))));
}
function unwrap(fa) {
  return flatten10(fromEffect(fa));
}
function fromAutoClosable(fa) {
  return make_(fa, (a2) => succeedWith3(() => a2.close()));
}
function fromAutoClosableM(fa) {
  return make_(fa, (a2) => a2.close);
}
var interrupt5 = /* @__PURE__ */ chain_13(/* @__PURE__ */ fromEffect(descriptor2), (d2) => interruptAs3(d2.id));
function interruptAs3(id) {
  return halt4(interrupt(id));
}
function exposeTracer(f2) {
  return managedApply(new ITracer((tracer2) => f2(tracer2).effect));
}

// node_modules/@effect-ts/system/_mjs/Managed/tuple.mjs
function tuple6(...t2) {
  const trace3 = accessCallTrace();
  return map_14(collectAll4(t2, trace3), (x2) => tuple2(...x2));
}
function tuplePar2(...t2) {
  return map_14(collectAllPar3(t2), (x2) => tuple2(...x2));
}
function tupleParN2(n2) {
  return (...t2) => map_14(collectAllParN_2(t2, n2, accessCallTrace()), (x2) => tuple2(...x2));
}

// node_modules/@effect-ts/system/_mjs/Managed/methods/allocate.mjs
var Allocation = class {
  constructor(value, release4) {
    this.value = value;
    this.release = release4;
  }
};
function allocate(self) {
  return chain_12(makeReleaseMap, (rm4) => foldCauseM_(provideSome_(self.effect, (r2) => tuple2(r2, rm4)), (cause2) => chain_12(releaseMapReleaseAll(halt(cause2), sequential)(rm4), () => halt2(cause2)), ({
    tuple: [_2, a2]
  }) => succeed5(new Allocation(a2, descriptorWith((d2) => releaseMapReleaseAll(interrupt2(d2.id), sequential)(rm4))))));
}

// node_modules/@effect-ts/system/_mjs/Managed/methods/ensuringFirst.mjs
function ensuringFirst(f2, __trace) {
  return onExitFirst(() => f2, __trace);
}
function ensuringFirst_(self, f2, __trace) {
  return onExitFirst_(self, () => f2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Managed/methods/gen.mjs
var GenManaged = class {
  constructor(effect2, trace3) {
    this.effect = effect2;
    this.trace = trace3;
  }
  *[Symbol.iterator]() {
    return yield this;
  }
};
var adapter6 = (_2, __, ___) => {
  if (isTag(_2)) {
    return new GenManaged(fromEffect(accessService2(_2)(identity)), __);
  }
  if (isEither(_2)) {
    return new GenManaged(fromEffect(fromEither2(() => _2)), __);
  }
  if (isOption(_2)) {
    if (typeof __ === "function") {
      return new GenManaged(__ ? _2._tag === "None" ? fail8(__()) : succeed7(_2.value) : fromEffect(getOrFail(_2)), ___);
    }
    return new GenManaged(fromEffect(getOrFail(_2)), __);
  }
  if (_2 instanceof ManagedImpl) {
    return new GenManaged(_2, __);
  }
  return new GenManaged(fromEffect(_2), __);
};
function gen6(f2) {
  return suspend6(() => {
    const iterator = f2(adapter6);
    const state = iterator.next();
    function run7(state2) {
      if (state2.done) {
        return succeed7(state2.value);
      }
      return chain_13(suspend6(() => state2.value["effect"], state2.value.trace), (val) => {
        const next2 = iterator.next(val);
        return run7(next2);
      });
    }
    return run7(state);
  });
}

// node_modules/@effect-ts/system/_mjs/Managed/methods/ifM.mjs
function ifM2(onTrue, onFalse, __trace) {
  return (b2) => ifM_2(b2, onTrue, onFalse, __trace);
}
function ifM_2(b2, onTrue, onFalse, __trace) {
  return chain_13(b2, (x2) => x2 ? onTrue() : onFalse(), __trace);
}
function _if2(onTrue, onFalse) {
  return (b2) => if_2(b2, onTrue, onFalse);
}
function if_2(b2, onTrue, onFalse, __trace) {
  return ifM_2(succeed7(b2), onTrue, onFalse, __trace);
}

// node_modules/@effect-ts/system/_mjs/Managed/methods/iterate.mjs
function iterate2(initial2) {
  return (cont) => (body, __trace) => suspend6(() => {
    if (cont(initial2)) {
      return chain_13(body(initial2), (z2) => iterate2(z2)(cont)(body));
    }
    return succeed7(initial2);
  }, __trace);
}

// node_modules/@effect-ts/system/_mjs/Managed/methods/loop.mjs
function loop5(initial2, cont, inc) {
  return (body, __trace) => suspend6(() => {
    if (cont(initial2)) {
      return chain_13(body(initial2), (a2) => map10((as6) => [a2, ...as6])(loop5(inc(initial2), cont, inc)(body)));
    }
    return succeed7([]);
  }, __trace);
}
function loopUnit2(initial2, cont, inc) {
  return (body, __trace) => suspend6(() => {
    if (cont(initial2)) {
      return chain_13(body(initial2), () => loopUnit2(inc(initial2), cont, inc)(body));
    }
    return unit4;
  }, __trace);
}

// node_modules/@effect-ts/system/_mjs/Managed/methods/makeSucceedWith.mjs
function makeSucceedWith(acquire, release4, __trace) {
  return make_(succeedWith3(acquire, __trace), (a2) => succeedWith3(() => release4(a2), __trace));
}

// node_modules/@effect-ts/system/_mjs/Managed/methods/mapN.mjs
function mapN2(f2, __trace) {
  return (t2) => mapN_2(t2, f2, __trace);
}
function mapN_2(t2, f2, __trace) {
  return map_14(tuple6(...t2.tuple), (x2) => f2(...x2), __trace);
}
function mapNPar2(f2, __trace) {
  return (t2) => mapNPar_2(t2, f2, __trace);
}
function mapNPar_2(t2, f2, __trace) {
  return map_14(tuplePar2(...t2.tuple), (x2) => f2(...x2.tuple), __trace);
}
function mapNParN2(n2, f2, __trace) {
  return (t2) => mapNParN_2(t2, n2, f2, __trace);
}
function mapNParN_2(t2, n2, f2, __trace) {
  return map_14(tupleParN2(n2)(...t2.tuple), (x2) => f2(...x2.tuple), __trace);
}

// node_modules/@effect-ts/system/_mjs/Managed/methods/preallocationScope.mjs
var preallocationScope = /* @__PURE__ */ map_14(scope2, (allocate2) => (managed2) => map_13(allocate2(managed2), ({
  tuple: [release4, res]
}) => makeExit_(succeed5(res), (_2, exit) => release4(exit))));

// node_modules/@effect-ts/system/_mjs/Managed/methods/runtime.mjs
function runtime2(__trace) {
  return fromEffect(runtime(), __trace);
}

// node_modules/@effect-ts/system/_mjs/Managed/methods/swap.mjs
function swap3(__trace) {
  return access4(({
    tuple: [a2, b2]
  }) => tuple2(b2, a2), __trace);
}

// node_modules/@effect-ts/system/_mjs/Managed/methods/switchable.mjs
function switchable(__trace) {
  return map10(({
    key,
    releaseMap: releaseMap2
  }) => (newResource) => uninterruptibleMask(({
    restore: restore2
  }) => map_13(tap_4(bind_(bind_(bind_(zipRight_2(chain_12(replace(key, (_2) => unit3)(releaseMap2), fold(() => unit3, (fin) => fin(unit2))), do_2), "r", () => environment2()), "inner", () => makeReleaseMap), "a", ({
    inner,
    r: r2
  }) => restore2(provideAll_3(newResource.effect, tuple2(r2, inner)))), ({
    inner
  }) => replace(key, (exit) => releaseMapReleaseAll(exit, sequential)(inner))(releaseMap2)), ({
    a: a2
  }) => a2.get(1))), __trace)(bind_2(bind_2(do_3, "releaseMap", () => releaseMap), "key", ({
    releaseMap: releaseMap2
  }) => toManaged(chain_12(addIfOpen((_2) => unit3)(releaseMap2), fold(() => interrupt3, succeed5)))));
}

// node_modules/@effect-ts/system/_mjs/Managed/methods/union.mjs
function unionFn2(_2) {
  return _2;
}
function union3(_2) {
  return _2;
}

// node_modules/@effect-ts/system/_mjs/Managed/methods/updateService.mjs
function updateService_2(self, tag2, f2, __trace) {
  return provideSome_2(self, (r2) => ({
    ...r2,
    ...tag2.has(f2(tag2.read(r2)))
  }), __trace);
}
function updateService2(tag2, f2, __trace) {
  return (self) => updateService_2(self, tag2, f2, __trace);
}

// node_modules/@effect-ts/system/_mjs/Collections/Mutable/HashMap/index.mjs
var HashMapTypeId = /* @__PURE__ */ Symbol();
var Node3 = class {
  constructor(k2, v2, next2) {
    this.k = k2;
    this.v = v2;
    this.next = next2;
  }
  [Symbol.iterator]() {
    let c2 = this;
    let n2 = 0;
    return {
      next: () => {
        if (c2) {
          const kv = [c2.k, c2.v];
          c2 = c2.next;
          n2++;
          return {
            value: kv,
            done: false
          };
        } else {
          return {
            value: n2,
            done: true
          };
        }
      }
    };
  }
};
var HashMap2 = class {
  constructor() {
    this._typeId = HashMapTypeId;
    this.backingMap = /* @__PURE__ */ new Map();
    this.length = new AtomicNumber(0);
  }
  get(k2) {
    const hash2 = hash(k2);
    const arr = this.backingMap.get(hash2);
    if (typeof arr === "undefined") {
      return none;
    }
    let c2 = arr;
    while (c2) {
      if (equals(k2, c2.k)) {
        return some(c2.v);
      }
      c2 = c2.next;
    }
    return none;
  }
  remove(k2) {
    const hash2 = hash(k2);
    const arr = this.backingMap.get(hash2);
    if (typeof arr === "undefined") {
      return this;
    }
    if (equals(k2, arr.k)) {
      if (typeof arr.next !== "undefined") {
        this.backingMap.set(hash2, arr.next);
      } else {
        this.backingMap.delete(hash2);
      }
      this.length.decrementAndGet();
      return this;
    }
    let next2 = arr.next;
    let curr = arr;
    while (next2) {
      if (equals(k2, next2.k)) {
        curr.next = next2.next;
        this.length.decrementAndGet();
        return this;
      }
      curr = next2;
      next2 = next2.next;
    }
    return this;
  }
  set(k2, v2) {
    const hash2 = hash(k2);
    const arr = this.backingMap.get(hash2);
    if (typeof arr === "undefined") {
      this.backingMap.set(hash2, new Node3(k2, v2));
      this.length.incrementAndGet();
      return this;
    }
    let c2 = arr;
    let l2 = arr;
    while (c2) {
      if (equals(k2, c2.k)) {
        c2.v = v2;
        return this;
      }
      l2 = c2;
      c2 = c2.next;
    }
    this.length.incrementAndGet();
    l2.next = new Node3(k2, v2);
    return this;
  }
  update(k2, f2) {
    const hash2 = hash(k2);
    const arr = this.backingMap.get(hash2);
    if (typeof arr === "undefined") {
      return this;
    }
    let c2 = arr;
    while (c2) {
      if (equals(k2, c2.k)) {
        c2.v = f2(c2.v);
        return this;
      }
      c2 = c2.next;
    }
    return this;
  }
  [Symbol.iterator]() {
    return chain_5(this.backingMap, ([, _2]) => _2)[Symbol.iterator]();
  }
};
function make8() {
  return new HashMap2();
}

// node_modules/@effect-ts/system/_mjs/Collections/Mutable/HashSet/index.mjs
var HashSet2 = class {
  constructor() {
    this.hashMap = make8();
  }
  size() {
    return this.hashMap.length.get;
  }
  isEmpty() {
    return this.size() === 0;
  }
  contains(a2) {
    return getOrElse_(this.hashMap.get(a2), () => false);
  }
  add(a2) {
    this.hashMap.set(a2, true);
    return this.contains(a2);
  }
  remove(a2) {
    this.hashMap.remove(a2);
    return !this.contains(a2);
  }
  [Symbol.iterator]() {
    return map_5(this.hashMap, ([a2]) => a2)[Symbol.iterator]();
  }
};
function make9() {
  return new HashSet2();
}

// node_modules/@effect-ts/system/_mjs/Hub/_internal/Hub.mjs
var Subscription = class {
};
var Hub = class {
};

// node_modules/@effect-ts/system/_mjs/Hub/_internal/BoundedHubArb.mjs
var BoundedHubArb = class extends Hub {
  constructor(requestedCapacity) {
    super();
    this.publisherIndex = 0;
    this.subscriberCount = 0;
    this.subscribersIndex = 0;
    this.array = Array.from({
      length: requestedCapacity
    });
    this.subscribers = Array.from({
      length: requestedCapacity
    });
    this.capacity = requestedCapacity;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  publish(a2) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index = this.publisherIndex % this.capacity;
      this.array[index] = a2;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    return true;
  }
  publishAll(as6) {
    const asArray = from3(as6);
    const n2 = size4(asArray);
    const size7 = this.publisherIndex - this.subscribersIndex;
    const available = this.capacity - size7;
    const forHub = Math.min(n2, available);
    if (forHub === 0) {
      return asArray;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forHub;
    while (this.publisherIndex !== publishAllIndex) {
      const a2 = unsafeGet_2(asArray, iteratorIndex++);
      const index = this.publisherIndex % this.capacity;
      this.array[index] = a2;
      this.publisherIndex += 1;
    }
    return drop_2(asArray, iteratorIndex - 1);
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index = this.subscribersIndex % this.capacity;
      this.array[index] = null;
      this.subscribers[index] = 0;
      this.subscribersIndex += 1;
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedHubArbSubscription(this, this.publisherIndex, false);
  }
};
var BoundedHubArbSubscription = class extends Subscription {
  constructor(self, subscriberIndex, unsubscribed) {
    super();
    this.self = self;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index = this.subscriberIndex % this.self.capacity;
      const a2 = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = null;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return a2;
    }
    return default_;
  }
  pollUpTo(n2) {
    if (this.unsubscribed) {
      return empty4();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size7 = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n2, size7);
    if (toPoll <= 0) {
      return empty4();
    }
    let builder2 = empty4();
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index = this.subscriberIndex % this.self.capacity;
      const a2 = this.self.array[index];
      builder2 = append_4(builder2, a2);
      this.subscriberIndex += 1;
    }
    return builder2;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex !== this.self.publisherIndex) {
        const index = this.subscriberIndex % this.self.capacity;
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = null;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
};

// node_modules/@effect-ts/system/_mjs/Hub/_internal/BoundedHubPow2.mjs
var BoundedHubPow2 = class extends Hub {
  constructor(requestedCapacity) {
    super();
    this.publisherIndex = 0;
    this.subscriberCount = 0;
    this.subscribersIndex = 0;
    this.array = Array.from({
      length: requestedCapacity
    });
    this.mask = requestedCapacity = 1;
    this.subscribers = Array.from({
      length: requestedCapacity
    });
    this.capacity = requestedCapacity;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  publish(a2) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index = this.publisherIndex & this.mask;
      this.array[index] = a2;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    return true;
  }
  publishAll(as6) {
    const asArray = from3(as6);
    const n2 = size4(asArray);
    const size7 = this.publisherIndex - this.subscribersIndex;
    const available = this.capacity - size7;
    const forHub = Math.min(n2, available);
    if (forHub === 0) {
      return asArray;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forHub;
    while (this.publisherIndex !== publishAllIndex) {
      const a2 = asArray[iteratorIndex++];
      const index = this.publisherIndex & this.mask;
      this.array[index] = a2;
      this.publisherIndex += 1;
    }
    return drop_2(asArray, iteratorIndex - 1);
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index = this.subscribersIndex & this.mask;
      this.array[index] = null;
      this.subscribers[index] = 0;
      this.subscribersIndex += 1;
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedHubPow2Subcription(this, this.publisherIndex, false);
  }
};
var BoundedHubPow2Subcription = class extends Subscription {
  constructor(self, subscriberIndex, unsubscribed) {
    super();
    this.self = self;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index = this.subscriberIndex & this.self.mask;
      const a2 = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = null;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return a2;
    }
    return default_;
  }
  pollUpTo(n2) {
    if (this.unsubscribed) {
      return empty4();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size7 = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n2, size7);
    if (toPoll <= 0) {
      return empty4();
    }
    let builder2 = empty4();
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index = this.subscriberIndex & this.self.mask;
      const a2 = this.self.array[index];
      builder2 = append_4(builder2, a2);
      this.subscriberIndex += 1;
    }
    return builder2;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex < this.self.publisherIndex) {
        const index = this.subscriberIndex & this.self.mask;
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = null;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
};

// node_modules/@effect-ts/system/_mjs/Hub/_internal/BoundedHubSingle.mjs
var BoundedHubSingle = class extends Hub {
  constructor() {
    super();
    this.publisherIndex = 0;
    this.subscriberCount = 0;
    this.subscribers = 0;
    this.value = null;
    this.capacity = 1;
  }
  isEmpty() {
    return this.subscribers === 0;
  }
  isFull() {
    return !this.isEmpty();
  }
  publish(a2) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      this.value = a2;
      this.subscribers = this.subscriberCount;
      this.publisherIndex += 1;
    }
    return true;
  }
  publishAll(as6) {
    const list2 = from3(as6);
    if (isEmpty5(list2)) {
      return empty4();
    }
    if (this.publish(unsafeHead(list2))) {
      return drop_2(list2, 1);
    } else {
      return list2;
    }
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  slide() {
    if (this.isFull()) {
      this.subscribers = 0;
      this.value = null;
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedHubSingleSubscription(this, this.publisherIndex, false);
  }
};
var BoundedHubSingleSubscription = class extends Subscription {
  constructor(self, subscriberIndex, unsubscribed) {
    super();
    this.self = self;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.subscribers === 0 || this.subscriberIndex === this.self.publisherIndex;
  }
  poll(default_) {
    if (this.isEmpty()) {
      return default_;
    }
    const a2 = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = null;
    }
    this.subscriberIndex += 1;
    return a2;
  }
  pollUpTo(n2) {
    if (this.isEmpty() || n2 < 1) {
      return empty4();
    }
    const a2 = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = null;
    }
    this.subscriberIndex += 1;
    return single(a2);
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      if (this.subscriberIndex !== this.self.publisherIndex) {
        this.self.subscribers -= 1;
        if (this.self.subscribers === 0) {
          this.self.value = null;
        }
      }
    }
  }
};

// node_modules/@effect-ts/system/_mjs/Hub/_internal/errors.mjs
var _a5;
var InvalidCapacityErrorSymbol = /* @__PURE__ */ Symbol.for("@effect-ts/core/symbols/errors/InvalidCapacity");
var InvalidCapacityError = class extends Error {
  constructor(message) {
    super(message);
    this[_a5] = "InvalidCapacityError";
    this.name = this[InvalidCapacityErrorSymbol];
  }
};
_a5 = InvalidCapacityErrorSymbol;
function ensureCapacity(capacity) {
  if (capacity <= 0) {
    throw new InvalidCapacityError(`A Hub cannot have a capacity of ${capacity}`);
  }
}

// node_modules/@effect-ts/system/_mjs/Hub/_internal/UnboundedHub.mjs
var Node4 = class {
  constructor(value, subscribers, next2) {
    this.value = value;
    this.subscribers = subscribers;
    this.next = next2;
  }
};
var UnboundedHub = class extends Hub {
  constructor() {
    super();
    this.publisherHead = new Node4(null, 0, null);
    this.publisherIndex = 0;
    this.subscribersIndex = 0;
    this.capacity = Number.MAX_SAFE_INTEGER;
    this.publisherTail = this.publisherHead;
  }
  isEmpty() {
    return this.publisherHead === this.publisherTail;
  }
  isFull() {
    return false;
  }
  publish(a2) {
    const subscribers = this.publisherTail.subscribers;
    if (subscribers !== 0) {
      this.publisherTail.next = new Node4(a2, subscribers, null);
      this.publisherTail = this.publisherTail.next;
      this.publisherIndex += 1;
    }
    return true;
  }
  publishAll(as6) {
    for (const a2 of as6) {
      this.publish(a2);
    }
    return empty4();
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  slide() {
    if (this.publisherHead !== this.publisherTail) {
      this.publisherHead = this.publisherHead.next;
      this.publisherHead.value = null;
      this.subscribersIndex += 1;
    }
  }
  subscribe() {
    this.publisherTail.subscribers += 1;
    return new UnboundedHubSubscription(this, this.publisherTail, this.publisherIndex, false);
  }
};
var UnboundedHubSubscription = class extends Subscription {
  constructor(self, subscriberHead, subscriberIndex, unsubscribed) {
    super();
    this.self = self;
    this.subscriberHead = subscriberHead;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    if (this.unsubscribed) {
      return true;
    }
    let empty8 = true;
    let loop6 = true;
    while (loop6) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop6 = false;
      } else {
        if (this.subscriberHead.next.value !== null) {
          empty8 = false;
          loop6 = false;
        } else {
          this.subscriberHead = this.subscriberHead.next;
          this.subscriberIndex += 1;
        }
      }
    }
    return empty8;
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    let loop6 = true;
    let polled = default_;
    while (loop6) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop6 = false;
      } else {
        const a2 = this.subscriberHead.next.value;
        if (a2 !== null) {
          polled = a2;
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = null;
            this.self.subscribersIndex += 1;
          }
          loop6 = false;
        }
        this.subscriberHead = this.subscriberHead.next;
        this.subscriberIndex += 1;
      }
    }
    return polled;
  }
  pollUpTo(n2) {
    let builder2 = empty4();
    const default_ = null;
    let i2 = 0;
    while (i2 !== n2) {
      const a2 = this.poll(default_);
      if (a2 === default_) {
        i2 = n2;
      } else {
        builder2 = append_4(builder2, a2);
        i2 += 1;
      }
    }
    return builder2;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.publisherTail.subscribers -= 1;
      while (this.subscriberHead !== this.self.publisherTail) {
        if (this.subscriberHead.next.value !== null) {
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = null;
            this.self.subscribersIndex += 1;
          }
        }
        this.subscriberHead = this.subscriberHead.next;
      }
    }
  }
};

// node_modules/@effect-ts/system/_mjs/Hub/_internal/hubFactory.mjs
function nextPow2(n2) {
  const nextPow = Math.ceil(Math.log(n2) / Math.log(2));
  return Math.max(Math.pow(2, nextPow), 2);
}
function makeBounded(requestedCapacity) {
  ensureCapacity(requestedCapacity);
  if (requestedCapacity === 1) {
    return new BoundedHubSingle();
  } else if (nextPow2(requestedCapacity) === requestedCapacity) {
    return new BoundedHubPow2(requestedCapacity);
  } else {
    return new BoundedHubArb(requestedCapacity);
  }
}
function makeUnbounded2() {
  return new UnboundedHub();
}

// node_modules/@effect-ts/system/_mjs/Hub/_internal/unsafe.mjs
function unsafeCompletePromise2(promise2, a2) {
  unsafeDone(succeed5(a2))(promise2);
}
function unsafeOfferAll2(queue, as6) {
  return queue.offerAll(as6);
}
function unsafePollAllQueue(queue) {
  return queue.pollUpTo(Number.MAX_SAFE_INTEGER);
}
function unsafePollAllSubscription(subscription) {
  return subscription.pollUpTo(Number.MAX_SAFE_INTEGER);
}
function unsafePollN2(subscription, max2) {
  return subscription.pollUpTo(max2);
}
function unsafePublishAll(hub, as6) {
  return hub.publishAll(as6);
}
function unsafeRemove2(queue, a2) {
  unsafeOfferAll2(queue, filter_3(unsafePollAllQueue(queue), (_2) => _2 !== a2));
}

// node_modules/@effect-ts/system/_mjs/Hub/Strategy.mjs
var Strategy = class {
  /**
   * Describes how subscribers waiting for additional values from the hub
   * should take those values and signal to publishers that they are no
   * longer waiting for additional values.
   */
  unsafeCompletePollers(hub, subscribers, subscription, pollers) {
    let keepPolling = true;
    while (keepPolling && !subscription.isEmpty()) {
      const poller = pollers.poll(EmptyQueue);
      if (poller === EmptyQueue) {
        const subPollerPair = tuple2(subscription, pollers);
        subscribers.remove(subPollerPair);
        if (!pollers.isEmpty) {
          subscribers.add(subPollerPair);
        }
        keepPolling = false;
      } else {
        const pollResult = subscription.poll(EmptyQueue);
        if (pollResult === EmptyQueue) {
          unsafeOfferAll2(pollers, prepend_3(unsafePollAllQueue(pollers), poller));
        } else {
          unsafeCompletePromise2(poller, pollResult);
          this.unsafeOnHubEmptySpace(hub, subscribers);
        }
      }
    }
  }
  /**
   * Describes how publishers should signal to subscribers waiting for
   * additional values from the hub that new values are available.
   */
  unsafeCompleteSubscribers(hub, subscribers) {
    for (const {
      tuple: [subscription, pollers]
    } of subscribers) {
      this.unsafeCompletePollers(hub, subscribers, subscription, pollers);
    }
  }
};
var BackPressure = class extends Strategy {
  constructor() {
    super(...arguments);
    this.publishers = new Unbounded();
  }
  handleSurplus(hub, subscribers, as6, isShutdown2) {
    return suspend4((_2, fiberId3) => {
      const promise2 = unsafeMake(fiberId3);
      return onInterrupt_(suspend4(() => {
        this.unsafeOffer(as6, promise2);
        this.unsafeOnHubEmptySpace(hub, subscribers);
        this.unsafeCompleteSubscribers(hub, subscribers);
        return isShutdown2.get ? interrupt3 : wait(promise2);
      }), () => succeedWith3(() => this.unsafeRemove(promise2)));
    });
  }
  get shutdown() {
    return asUnit(tap_4(bind_(bind_(do_2, "fiberId", () => fiberId), "publishers", () => succeedWith3(() => unsafePollAllQueue(this.publishers))), ({
      fiberId: fiberId3,
      publishers
    }) => forEachPar_(publishers, ([_2, promise2, last4]) => last4 ? interruptAs2(fiberId3)(promise2) : unit3)));
  }
  unsafeOnHubEmptySpace(hub, subscribers) {
    let keepPolling = true;
    while (keepPolling && !hub.isFull()) {
      const publisher = this.publishers.poll(EmptyQueue);
      if (publisher === EmptyQueue) {
        keepPolling = false;
      } else {
        const published = hub.publish(publisher[0]);
        if (published && publisher[2]) {
          unsafeCompletePromise2(publisher[1], true);
        } else if (!published) {
          unsafeOfferAll2(this.publishers, prepend_3(unsafePollAllQueue(this.publishers), publisher));
        }
        this.unsafeCompleteSubscribers(hub, subscribers);
      }
    }
  }
  unsafeOffer(as6, promise2) {
    const it2 = as6[Symbol.iterator]();
    let curr = it2.next();
    if (!curr.done) {
      let next2;
      while ((next2 = it2.next()) && !next2.done) {
        this.publishers.offer([curr.value, promise2, false]);
        curr = next2;
      }
      this.publishers.offer([curr.value, promise2, true]);
    }
  }
  unsafeRemove(promise2) {
    unsafeOfferAll2(this.publishers, filter_3(unsafePollAllQueue(this.publishers), ([_2, a2]) => a2 !== promise2));
  }
};
var Dropping = class extends Strategy {
  constructor() {
    super(...arguments);
    this.shutdown = unit3;
  }
  handleSurplus(_hub, _subscribers, _as, _isShutdown) {
    return succeed5(false);
  }
  unsafeOnHubEmptySpace(_hub, _subscribers) {
  }
};

// node_modules/@effect-ts/system/_mjs/Hub/core.mjs
var HubTypeId = /* @__PURE__ */ Symbol();
var XHubInternal = class {
  constructor() {
    this.typeId = HubTypeId;
  }
};
function publish_(self, a2) {
  ;
  return self.publish(a2);
}
function shutdown2(self) {
  ;
  return self.shutdown;
}
function subscribe(self) {
  ;
  return self.subscribe;
}
var ToQueueImplementation = class extends XQueueInternal {
  constructor(source) {
    super();
    this.source = source;
    this.awaitShutdown = source.awaitShutdown;
    this.capacity = source.capacity;
    this.isShutdown = source.isShutdown;
    this.shutdown = source.shutdown;
    this.size = source.size;
    this.take = never;
    this.takeAll = succeed5(empty4());
  }
  offer(a2) {
    return this.source.publish(a2);
  }
  offerAll(as6) {
    return this.source.publishAll(as6);
  }
  takeUpTo() {
    return succeed5(empty4());
  }
};
function toQueue(self) {
  ;
  return new ToQueueImplementation(self);
}
function makeBounded2(requestedCapacity) {
  return chain_12(succeedWith3(() => makeBounded(requestedCapacity)), (_2) => makeHub(_2, new BackPressure()));
}
function makeUnbounded3() {
  return chain_12(succeedWith3(() => {
    return makeUnbounded2();
  }), (_2) => makeHub(_2, new Dropping()));
}
function unsafeMakeUnbounded() {
  const releaseMap2 = new ReleaseMap(unsafeMakeRef(new Running(0, /* @__PURE__ */ new Map())));
  return unsafeMakeHub(makeUnbounded2(), makeSubscribersHashSet(), releaseMap2, unsafeMake(None2), new AtomicBoolean(false), new Dropping());
}
var UnsafeMakeHubImplementation = class extends XHubInternal {
  constructor(hub, subscribers, releaseMap2, shutdownHook, shutdownFlag, strategy) {
    super();
    this.hub = hub;
    this.subscribers = subscribers;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
    this.awaitShutdown = wait(shutdownHook);
    this.capacity = hub.capacity;
    this.isShutdown = succeedWith3(() => shutdownFlag.get);
    this.shutdown = uninterruptible2(suspend4((_2, fiberId3) => {
      shutdownFlag.set(true);
      return asUnit(whenM_(zipRight_2(releaseMapReleaseAll(interrupt2(fiberId3), parallel)(releaseMap2), strategy.shutdown), succeed_(shutdownHook, void 0)));
    }));
    this.size = suspend4(() => {
      if (shutdownFlag.get) {
        return interrupt3;
      }
      return succeed5(hub.size());
    });
    this.subscribe = map_14(tap_5(bind_2(do_3, "dequeue", () => toManaged(makeSubscription(hub, subscribers, strategy))), ({
      dequeue
    }) => makeExit_(add((_2) => shutdown(dequeue))(releaseMap2), (finalizer2, exit) => finalizer2(exit))), ({
      dequeue
    }) => dequeue);
  }
  publish(a2) {
    return suspend4(() => {
      if (this.shutdownFlag.get) {
        return interrupt3;
      }
      if (this.hub.publish(a2)) {
        this.strategy.unsafeCompleteSubscribers(this.hub, this.subscribers);
        return succeed5(true);
      }
      return this.strategy.handleSurplus(this.hub, this.subscribers, single(a2), this.shutdownFlag);
    });
  }
  publishAll(as6) {
    return suspend4(() => {
      if (this.shutdownFlag.get) {
        return interrupt3;
      }
      const surplus = unsafePublishAll(this.hub, as6);
      this.strategy.unsafeCompleteSubscribers(this.hub, this.subscribers);
      if (isEmpty5(surplus)) {
        return succeed5(true);
      }
      return this.strategy.handleSurplus(this.hub, this.subscribers, surplus, this.shutdownFlag);
    });
  }
};
function makeHub(hub, strategy) {
  return chain_12(makeReleaseMap, (releaseMap2) => {
    return map_13(make4(), (promise2) => {
      return unsafeMakeHub(hub, makeSubscribersHashSet(), releaseMap2, promise2, new AtomicBoolean(false), strategy);
    });
  });
}
function unsafeMakeHub(hub, subscribers, releaseMap2, shutdownHook, shutdownFlag, strategy) {
  return new UnsafeMakeHubImplementation(hub, subscribers, releaseMap2, shutdownHook, shutdownFlag, strategy);
}
function makeSubscription(hub, subscribers, strategy) {
  return map_13(make4(), (promise2) => {
    return unsafeMakeSubscription(hub, subscribers, hub.subscribe(), new Unbounded(), promise2, new AtomicBoolean(false), strategy);
  });
}
var UnsafeMakeSubscriptionImplementation = class extends XQueueInternal {
  constructor(hub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy) {
    super();
    this.hub = hub;
    this.subscribers = subscribers;
    this.subscription = subscription;
    this.pollers = pollers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
    this.awaitShutdown = wait(this.shutdownHook);
    this.capacity = this.hub.capacity;
    this.isShutdown = succeedWith3(() => this.shutdownFlag.get);
    this.shutdown = uninterruptible2(suspend4((_2, fiberId3) => {
      this.shutdownFlag.set(true);
      return asUnit(whenM_(zipRight_2(forEachPar_(unsafePollAllQueue(this.pollers), (_3) => {
        return interruptAs2(fiberId3)(_3);
      }), succeedWith3(() => this.subscription.unsubscribe())), succeed_(this.shutdownHook, void 0)));
    }));
    this.size = suspend4(() => {
      if (this.shutdownFlag.get) {
        return interrupt3;
      }
      return succeed5(this.subscription.size());
    });
    this.take = suspend4((_2, fiberId3) => {
      if (this.shutdownFlag.get) {
        return interrupt3;
      }
      const message = this.pollers.isEmpty ? this.subscription.poll(EmptyQueue) : EmptyQueue;
      if (message === EmptyQueue) {
        const promise2 = unsafeMake(fiberId3);
        return onInterrupt_(suspend4(() => {
          this.pollers.offer(promise2);
          this.subscribers.add(tuple2(this.subscription, this.pollers));
          this.strategy.unsafeCompletePollers(this.hub, this.subscribers, this.subscription, this.pollers);
          if (this.shutdownFlag.get) {
            return interrupt3;
          } else {
            return wait(promise2);
          }
        }), () => succeedWith3(() => {
          unsafeRemove2(this.pollers, promise2);
        }));
      } else {
        this.strategy.unsafeOnHubEmptySpace(this.hub, this.subscribers);
        return succeed5(message);
      }
    });
    this.takeAll = suspend4(() => {
      if (this.shutdownFlag.get) {
        return interrupt3;
      }
      const as6 = this.pollers.isEmpty ? unsafePollAllSubscription(this.subscription) : empty4();
      this.strategy.unsafeOnHubEmptySpace(this.hub, this.subscribers);
      return succeed5(as6);
    });
  }
  offer(_2) {
    return succeed5(false);
  }
  offerAll(_2) {
    return succeed5(false);
  }
  takeUpTo(n2) {
    return suspend4(() => {
      if (this.shutdownFlag.get) {
        return interrupt3;
      }
      const as6 = this.pollers.isEmpty ? unsafePollN2(this.subscription, n2) : empty4();
      this.strategy.unsafeOnHubEmptySpace(this.hub, this.subscribers);
      return succeed5(as6);
    });
  }
};
function unsafeMakeSubscription(hub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy) {
  return new UnsafeMakeSubscriptionImplementation(hub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy);
}
function makeSubscribersHashSet() {
  return make9();
}

// node_modules/@effect-ts/core/_mjs/Either/index.mjs
var Either_exports2 = {};
__export(Either_exports2, {
  Any: () => Any5,
  Applicative: () => Applicative5,
  AssociativeBoth: () => AssociativeBoth4,
  AssociativeEither: () => AssociativeEither3,
  AssociativeFlatten: () => AssociativeFlatten5,
  ChainRec: () => ChainRec,
  Covariant: () => Covariant5,
  EitherURI: () => EitherURI,
  Fail: () => Fail5,
  FoldMap: () => FoldMap2,
  Foldable: () => Foldable3,
  ForEach: () => ForEach3,
  GenEither: () => GenEither,
  Left: () => Left,
  Monad: () => Monad5,
  Reduce: () => Reduce2,
  ReduceRight: () => ReduceRight2,
  Right: () => Right,
  Run: () => Run2,
  alt: () => alt,
  alt_: () => alt_,
  ap: () => ap2,
  ap_: () => ap_2,
  bimap: () => bimap,
  bimap_: () => bimap_,
  bind: () => bind5,
  chain: () => chain2,
  chainRec: () => chainRec,
  chain_: () => chain_3,
  compact: () => compact,
  compactOption: () => compactOption,
  do: () => do_5,
  duplicate: () => duplicate2,
  exists: () => exists2,
  exists_: () => exists_2,
  extend: () => extend2,
  extend_: () => extend_2,
  filterOrElse: () => filterOrElse,
  filterOrElse_: () => filterOrElse_,
  flatten: () => flatten3,
  fold: () => fold2,
  foldMap: () => foldMap2,
  foldMap_: () => foldMap_2,
  fold_: () => fold_2,
  forEachF: () => forEachF3,
  fromNullable: () => fromNullable2,
  fromNullable_: () => fromNullable_,
  fromOption: () => fromOption,
  fromOption_: () => fromOption_,
  fromPredicate: () => fromPredicate2,
  fromPredicate_: () => fromPredicate_2,
  gen: () => gen,
  getAssociative: () => getAssociative2,
  getCompact: () => getCompact,
  getCompactF: () => getCompactF,
  getCompactable: () => getCompactable,
  getEqual: () => getEqual3,
  getLeft: () => getLeft2,
  getOrElse: () => getOrElse2,
  getOrElse_: () => getOrElse_2,
  getRight: () => getRight2,
  getSeparate: () => getSeparate,
  getSeparateF: () => getSeparateF,
  getShow: () => getShow3,
  getValidationApplicative: () => getValidationApplicative2,
  getValidationAssociative: () => getValidationAssociative,
  getWiltable: () => getWiltable,
  getWitherable: () => getWitherable,
  if: () => branch2,
  if_: () => branch_2,
  isLeft: () => isLeft,
  isRight: () => isRight,
  left: () => left,
  leftW: () => leftW,
  let: () => let_5,
  map: () => map2,
  mapLeft: () => mapLeft,
  mapLeft_: () => mapLeft_,
  map_: () => map_3,
  match: () => match3,
  matchIn: () => matchIn3,
  matchMorph: () => matchMorph3,
  matchTag: () => matchTag4,
  matchTagIn: () => matchTagIn3,
  merge: () => merge,
  orElse: () => orElse,
  orElseEither: () => orElseEither,
  orElseEither_: () => orElseEither_,
  orElse_: () => orElse_,
  parseJSON: () => parseJSON,
  parseJSON_: () => parseJSON_,
  reduce: () => reduce,
  reduceRight: () => reduceRight,
  reduceRight_: () => reduceRight_2,
  reduce_: () => reduce_2,
  right: () => right,
  rightW: () => rightW,
  separate: () => separate4,
  sequence: () => sequence2,
  stringifyJSON: () => stringifyJSON,
  stringifyJSON_: () => stringifyJSON_,
  struct: () => struct5,
  swap: () => swap,
  tap: () => tap2,
  tap_: () => tap_2,
  toError: () => toError,
  tryCatch: () => tryCatch2,
  tuple: () => tuple7,
  unsafeGetLeft: () => unsafeGetLeft,
  unsafeGetRight: () => unsafeGetRight,
  widenA: () => widenA,
  widenE: () => widenE,
  zip: () => zip2,
  zipFirst: () => zipFirst2,
  zipFirst_: () => zipFirst_2,
  zipSecond: () => zipSecond2,
  zipSecond_: () => zipSecond_2,
  zipValidation: () => zipValidation,
  zip_: () => zip_2
});

// node_modules/@effect-ts/core/_mjs/Either/operations/forEachF.mjs
var forEachF3 = /* @__PURE__ */ implementForEachF()((_2) => (G2) => (f2) => (fa) => isLeft(fa) ? succeedF(G2)(fa) : G2.map(right)(f2(fa.right)));

// node_modules/@effect-ts/core/_mjs/Either/operations/compactOption.mjs
function compactOption(M2) {
  return (ma) => {
    return isLeft(ma) ? ma : ma.right._tag === "None" ? left(M2.identity) : right(ma.right.value);
  };
}
function getCompactF(M2) {
  const com = compactOption(M2);
  return implementCompactF()((_2) => (G2) => {
    const traverseF = forEachF3(G2);
    return (f2) => (x2) => G2.map(com)(traverseF(f2)(x2));
  });
}
function getCompact(M2) {
  const _compact = compactOption(M2);
  return {
    compact: _compact
  };
}

// node_modules/@effect-ts/core/_mjs/Either/operations/foldMap.mjs
var foldMap_2 = (M2) => (fa, f2) => isLeft(fa) ? M2.identity : f2(fa.right);
var foldMap2 = (M2) => (f2) => (fa) => foldMap_2(M2)(fa, f2);

// node_modules/@effect-ts/core/_mjs/Either/operations/getAssociative.mjs
function getAssociative2(S2) {
  return makeAssociative((x2, y2) => isLeft(y2) ? x2 : isLeft(x2) ? y2 : right(S2.combine(x2.right, y2.right)));
}

// node_modules/@effect-ts/core/_mjs/Either/operations/separate.mjs
function separate4(M2) {
  const empty8 = left(M2.identity);
  return (ma) => {
    return isLeft(ma) ? tuple2(ma, ma) : isLeft(ma.right) ? tuple2(right(ma.right.left), empty8) : tuple2(empty8, right(ma.right.right));
  };
}
function getSeparateF(M2) {
  const sep = separate4(M2);
  return implementSeparateF()((_2) => (G2) => {
    const traverseF = forEachF3(G2);
    return (f2) => (x2) => G2.map(sep)(traverseF(f2)(x2));
  });
}
function getSeparate(M2) {
  const _separate = separate4(M2);
  return {
    separate: _separate
  };
}

// node_modules/@effect-ts/core/_mjs/Either/operations/getCompactable.mjs
function getCompactable(M2) {
  const C2 = getCompact(M2);
  const S2 = getSeparate(M2);
  return {
    ...C2,
    ...S2
  };
}

// node_modules/@effect-ts/core/_mjs/Either/operations/getEqual.mjs
function getEqual3(EL, EA) {
  return {
    equals: (x2, y2) => x2 === y2 || (isLeft(x2) ? isLeft(y2) && EL.equals(x2.left, y2.left) : isRight(y2) && EA.equals(x2.right, y2.right))
  };
}

// node_modules/@effect-ts/core/_mjs/Either/operations/getLeft.mjs
function unsafeGetLeft(self) {
  return self._tag === "Left" ? self.left : void 0;
}
function getLeft2(self) {
  return self._tag === "Left" ? some(self.left) : none;
}

// node_modules/@effect-ts/core/_mjs/Either/operations/getRight.mjs
function getRight2(self) {
  return self._tag === "Right" ? some(self.right) : none;
}
function unsafeGetRight(self) {
  return self._tag === "Right" ? self.right : void 0;
}

// node_modules/@effect-ts/core/_mjs/Either/operations/getShow.mjs
function getShow3(SE, SA) {
  return {
    show: (ma) => isLeft(ma) ? `left(${SE.show(ma.left)})` : `right(${SA.show(ma.right)})`
  };
}

// node_modules/@effect-ts/core/_mjs/Either/operations/getValidationAssociative.mjs
function getValidationAssociative(SE, SA) {
  return makeAssociative((fx, fy) => isLeft(fx) ? isLeft(fy) ? left(SE.combine(fx.left, fy.left)) : fx : isLeft(fy) ? fy : right(SA.combine(fx.right, fy.right)));
}

// node_modules/@effect-ts/core/_mjs/Either/operations/getWiltable.mjs
function getWiltable(M2) {
  const separateF3 = getSeparateF(M2);
  return {
    separateF: separateF3
  };
}

// node_modules/@effect-ts/core/_mjs/Either/operations/getWitherable.mjs
function getWitherable(M2) {
  const compactF3 = getCompactF(M2);
  return {
    compactF: compactF3
  };
}

// node_modules/@effect-ts/core/_mjs/Either/operations/zipValidation.mjs
function zipValidation(A2) {
  return (fb) => fold2((ea) => fold_2(fb, (eb) => left(A2.combine(ea, eb)), () => left(ea)), (a2) => fold_2(fb, left, (b2) => right(tuple(a2, b2))));
}

// node_modules/@effect-ts/core/_mjs/Either/instances.mjs
var Any5 = {
  any: () => right({})
};
var AssociativeBoth4 = {
  both: zip2
};
var AssociativeEither3 = {
  orElseEither: (fb) => (fa) => fa._tag === "Right" ? right(left(fa.right)) : map_3(fb(), right)
};
var AssociativeFlatten5 = {
  flatten: flatten3
};
var Covariant5 = {
  map: map2
};
var Applicative5 = {
  ...Any5,
  ...Covariant5,
  ...AssociativeBoth4
};
var Monad5 = {
  ...Any5,
  ...Covariant5,
  ...AssociativeFlatten5
};
var Fail5 = {
  fail: left
};
var Run2 = {
  either: right
};
var ForEach3 = {
  map: map2,
  forEachF: forEachF3
};
var FoldMap2 = {
  foldMap: foldMap2
};
var Reduce2 = {
  reduce
};
var ReduceRight2 = {
  reduceRight
};
var Foldable3 = {
  ...FoldMap2,
  ...Reduce2,
  ...ReduceRight2
};
var ChainRec = {
  chainRec: (f2) => (a2) => tailRec(f2(a2), (e2) => isLeft(e2) ? right(left(e2.left)) : isLeft(e2.right) ? left(f2(e2.right.left)) : right(right(e2.right.right)))
};
var {
  chainRec
} = ChainRec;

// node_modules/@effect-ts/core/_mjs/Either/dsls/conditionals.mjs
var branch2 = /* @__PURE__ */ conditionalF(Covariant5);
var branch_2 = /* @__PURE__ */ conditionalF_(Covariant5);

// node_modules/@effect-ts/core/_mjs/Either/dsls/do.mjs
var do_5 = /* @__PURE__ */ doF(Monad5);
var let_5 = /* @__PURE__ */ bindF(Monad5);
var bind5 = /* @__PURE__ */ bindF(Monad5);

// node_modules/@effect-ts/core/_mjs/Either/dsls/getValidationApplicative.mjs
var getValidationApplicative2 = /* @__PURE__ */ getValidationF({
  ...Monad5,
  ...Fail5,
  ...Applicative5,
  ...Run2
});

// node_modules/@effect-ts/core/_mjs/Either/dsls/matchers.mjs
var {
  match: match3,
  matchIn: matchIn3,
  matchMorph: matchMorph3,
  matchTag: matchTag4,
  matchTagIn: matchTagIn3
} = /* @__PURE__ */ matchers(Covariant5);

// node_modules/@effect-ts/core/_mjs/Either/dsls/sequence.mjs
var sequence2 = /* @__PURE__ */ sequenceF(ForEach3);

// node_modules/@effect-ts/core/_mjs/Either/dsls/struct.mjs
var struct5 = /* @__PURE__ */ structF(Applicative5);

// node_modules/@effect-ts/core/_mjs/Either/dsls/tuple.mjs
var tuple7 = /* @__PURE__ */ tupleF(Applicative5);

// node_modules/@effect-ts/core/_mjs/Collections/Immutable/HashMap/index.mjs
var HashMap_exports2 = {};
__export(HashMap_exports2, {
  HashMap: () => HashMap,
  HashMapIterator: () => HashMapIterator,
  applyCont: () => applyCont,
  beginMutation: () => beginMutation,
  chain: () => chain3,
  chainWithIndex: () => chainWithIndex,
  chainWithIndex_: () => chainWithIndex_,
  chain_: () => chain_6,
  compact: () => compact2,
  endMutation: () => endMutation,
  filter: () => filter,
  filterMap: () => filterMap,
  filterMapWithIndex: () => filterMapWithIndex,
  filterMapWithIndex_: () => filterMapWithIndex_,
  filterMap_: () => filterMap_,
  filterWithIndex: () => filterWithIndex,
  filterWithIndex_: () => filterWithIndex_,
  filter_: () => filter_,
  forEach: () => forEach,
  forEachWithIndex: () => forEachWithIndex,
  forEachWithIndex_: () => forEachWithIndex_,
  forEach_: () => forEach_,
  from: () => from,
  get: () => get2,
  getHash_: () => getHash_,
  get_: () => get_2,
  has: () => has,
  hasHash_: () => hasHash_,
  has_: () => has_,
  isEmpty: () => isEmpty2,
  keySet: () => keySet,
  keys: () => keys2,
  make: () => make,
  map: () => map3,
  mapWithIndex: () => mapWithIndex,
  mapWithIndex_: () => mapWithIndex_,
  map_: () => map_6,
  modify: () => modify,
  modifyHash_: () => modifyHash_,
  modify_: () => modify_,
  mutate: () => mutate,
  mutate_: () => mutate_,
  reduce: () => reduce2,
  reduceWithIndex: () => reduceWithIndex,
  reduceWithIndex_: () => reduceWithIndex_2,
  reduce_: () => reduce_4,
  remove: () => remove,
  removeMany: () => removeMany,
  removeMany_: () => removeMany_,
  remove_: () => remove_,
  set: () => set,
  setTree_: () => setTree_,
  set_: () => set_,
  size: () => size,
  tryGetHash_: () => tryGetHash_,
  unsafeGet: () => unsafeGet,
  unsafeGet_: () => unsafeGet_,
  update: () => update2,
  update_: () => update_2,
  values: () => values,
  visitLazy: () => visitLazy,
  visitLazyChildren: () => visitLazyChildren
});

// node_modules/@effect-ts/system/_mjs/Collections/Immutable/HashMap/keySet.mjs
function keySet(self) {
  return new HashSet(self);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/core.mjs
var _a6;
var StreamTypeId = /* @__PURE__ */ Symbol();
var Stream = class {
  constructor(channel) {
    this.channel = channel;
    this[_a6] = StreamTypeId;
  }
};
_a6 = StreamTypeId, _R, _E, _A;
function isStream(u2) {
  return typeof u2 === "object" && u2 != null && StreamTypeId in u2;
}
var DEFAULT_CHUNK_SIZE = 4096;

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/_internal/primitives.mjs
var Channel = class {
  constructor() {
    this[">>>"] = (that) => new PipeTo(() => this, () => that);
  }
};
var Continuation = class {
};
var ContinuationKTypeId = /* @__PURE__ */ Symbol();
var ContinuationK = class extends Continuation {
  constructor(onSuccess, onHalt) {
    super();
    this.onSuccess = onSuccess;
    this.onHalt = onHalt;
    this._typeId = ContinuationKTypeId;
  }
  onExit(exit) {
    switch (exit._tag) {
      case "Failure": {
        return this.onHalt(exit.cause);
      }
      case "Success": {
        return this.onSuccess(exit.value);
      }
    }
  }
};
var ContinuationFinalizerTypeId = /* @__PURE__ */ Symbol();
var ContinuationFinalizer = class extends Continuation {
  constructor(finalizer2) {
    super();
    this.finalizer = finalizer2;
    this._typeId = ContinuationFinalizerTypeId;
  }
};
var PipeToTypeId = /* @__PURE__ */ Symbol();
var PipeTo = class extends Channel {
  constructor(left4, right5) {
    super();
    this.left = left4;
    this.right = right5;
    this._typeId = PipeToTypeId;
  }
};
var ReadTypeId = /* @__PURE__ */ Symbol();
var Read = class extends Channel {
  constructor(more, done7) {
    super();
    this.more = more;
    this.done = done7;
    this._typeId = ReadTypeId;
  }
};
var DoneTypeId = /* @__PURE__ */ Symbol();
var Done4 = class extends Channel {
  constructor(terminal) {
    super();
    this.terminal = terminal;
    this._typeId = DoneTypeId;
  }
};
var HaltTypeId = /* @__PURE__ */ Symbol();
var Halt = class extends Channel {
  constructor(error) {
    super();
    this.error = error;
    this._typeId = HaltTypeId;
  }
};
var EffectTypeId = /* @__PURE__ */ Symbol();
var Effect = class extends Channel {
  constructor(effect2) {
    super();
    this.effect = effect2;
    this._typeId = EffectTypeId;
  }
};
var EmitTypeId = /* @__PURE__ */ Symbol();
var Emit = class extends Channel {
  constructor(out) {
    super();
    this.out = out;
    this._typeId = EmitTypeId;
  }
};
var EnsuringTypeId = /* @__PURE__ */ Symbol();
var Ensuring = class extends Channel {
  constructor(channel, finalizer2) {
    super();
    this.channel = channel;
    this.finalizer = finalizer2;
    this._typeId = EnsuringTypeId;
  }
};
var ConcatAllTypeId = /* @__PURE__ */ Symbol();
var ConcatAll = class extends Channel {
  constructor(combineInners, combineAll, value, k2) {
    super();
    this.combineInners = combineInners;
    this.combineAll = combineAll;
    this.value = value;
    this.k = k2;
    this._typeId = ConcatAllTypeId;
  }
};
var FoldTypeId = /* @__PURE__ */ Symbol();
var Fold2 = class extends Channel {
  constructor(value, k2) {
    super();
    this.value = value;
    this.k = k2;
    this._typeId = FoldTypeId;
  }
};
var BridgeTypeId = /* @__PURE__ */ Symbol();
var Bridge = class extends Channel {
  constructor(input, channel) {
    super();
    this.input = input;
    this.channel = channel;
    this._typeId = BridgeTypeId;
  }
};
var BracketOutTypeId = /* @__PURE__ */ Symbol();
var BracketOut = class extends Channel {
  constructor(acquire, finalizer2) {
    super();
    this.acquire = acquire;
    this.finalizer = finalizer2;
    this._typeId = BracketOutTypeId;
  }
};
var ProvideTypeId = /* @__PURE__ */ Symbol();
var Provide3 = class extends Channel {
  constructor(env, channel) {
    super();
    this.env = env;
    this.channel = channel;
    this._typeId = ProvideTypeId;
  }
};
var EffectTotalTypeId = /* @__PURE__ */ Symbol();
var EffectTotal = class extends Channel {
  constructor(effect2) {
    super();
    this.effect = effect2;
    this._typeId = EffectTotalTypeId;
  }
};
var EffectSuspendTotalTypeId = /* @__PURE__ */ Symbol();
var EffectSuspendTotal = class extends Channel {
  constructor(effect2) {
    super();
    this.effect = effect2;
    this._typeId = EffectSuspendTotalTypeId;
  }
};

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/_internal/producer.mjs
var DoneTypeId2 = /* @__PURE__ */ Symbol();
var StateDone = class {
  constructor(a2) {
    this.a = a2;
    this._typeId = DoneTypeId2;
  }
};
var ErrorTypeId = /* @__PURE__ */ Symbol();
var StateError = class {
  constructor(cause2) {
    this.cause = cause2;
    this._typeId = ErrorTypeId;
  }
};
var EmptyTypeId2 = /* @__PURE__ */ Symbol();
var StateEmpty = class {
  constructor(notifyProducer) {
    this.notifyProducer = notifyProducer;
    this._typeId = EmptyTypeId2;
  }
};
var EmitTypeId2 = /* @__PURE__ */ Symbol();
var StateEmit = class {
  constructor(notifyConsumers) {
    this.notifyConsumers = notifyConsumers;
    this._typeId = EmitTypeId2;
  }
};
var SingleProducerAsyncInput = class {
  constructor(ref) {
    this.ref = ref;
    this.take = this.takeWith((c2) => halt(map_11(c2, left)), (el) => succeed4(el), (d2) => fail5(right(d2)));
    this.close = chain_12(fiberId, (id) => this.error(interrupt(id)));
    this.awaitRead = flatten8(modify_2(this.ref, (state) => {
      if (state._typeId === EmptyTypeId2) {
        return tuple2(wait(state.notifyProducer), state);
      }
      return tuple2(unit3, state);
    }));
  }
  emit(el) {
    return chain_12(make4(), (p2) => flatten8(modify_2(this.ref, (state) => {
      switch (state._typeId) {
        case EmitTypeId2: {
          const dequeued = state.notifyConsumers.dequeue();
          if (dequeued._tag === "Some") {
            const {
              tuple: [notifyConsumer, notifyConsumers]
            } = dequeued.value;
            return tuple2(succeed_(notifyConsumer, right(el)), notifyConsumers.size === 0 ? new StateEmpty(p2) : new StateEmit(notifyConsumers));
          }
          throw new Error("SingleProducerAsyncInput#emit: queue was empty");
        }
        case ErrorTypeId: {
          return tuple2(interrupt3, state);
        }
        case DoneTypeId2: {
          return tuple2(interrupt3, state);
        }
        case EmptyTypeId2: {
          return tuple2(wait(state.notifyProducer), state);
        }
      }
    })));
  }
  done(a2) {
    return chain_12(make4(), (p2) => flatten8(modify_2(this.ref, (state) => {
      switch (state._typeId) {
        case EmitTypeId2: {
          return tuple2(forEachUnit_(state.notifyConsumers, (p3) => succeed_(p3, left(a2))), new StateDone(a2));
        }
        case ErrorTypeId: {
          return tuple2(interrupt3, state);
        }
        case DoneTypeId2: {
          return tuple2(interrupt3, state);
        }
        case EmptyTypeId2: {
          return tuple2(wait(state.notifyProducer), state);
        }
      }
    })));
  }
  error(cause2) {
    return chain_12(make4(), (p2) => flatten8(modify_2(this.ref, (state) => {
      switch (state._typeId) {
        case EmitTypeId2: {
          return tuple2(forEachUnit_(state.notifyConsumers, (p3) => halt_(p3, cause2)), new StateError(cause2));
        }
        case ErrorTypeId: {
          return tuple2(interrupt3, state);
        }
        case DoneTypeId2: {
          return tuple2(interrupt3, state);
        }
        case EmptyTypeId2: {
          return tuple2(wait(state.notifyProducer), state);
        }
      }
    })));
  }
  takeWith(onError3, onElement, onDone) {
    return chain_12(make4(), (p2) => flatten8(modify_2(this.ref, (state) => {
      switch (state._typeId) {
        case EmitTypeId2: {
          return tuple2(foldCause_(wait(p2), onError3, fold2(onDone, onElement)), new StateEmit(state.notifyConsumers.push(p2)));
        }
        case ErrorTypeId: {
          return tuple2(succeed5(onError3(state.cause)), state);
        }
        case DoneTypeId2: {
          return tuple2(succeed5(onDone(state.a)), state);
        }
        case EmptyTypeId2: {
          return tuple2(zipRight_2(succeed_(state.notifyProducer, void 0), foldCause_(wait(p2), onError3, fold2(onDone, onElement))), new StateEmit(ImmutableQueue.single(p2)));
        }
      }
    })));
  }
};
function makeSingleProducerAsyncInput() {
  return map_13(chain_12(make4(), (p2) => makeRef(new StateEmpty(p2))), (ref) => new SingleProducerAsyncInput(ref));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/core.mjs
function pipeTo_(left4, right5) {
  return new PipeTo(() => left4, () => right5);
}
function readWithCause(inp, halt6, done7) {
  return new Read(inp, new ContinuationK(done7, halt6));
}
function end(result4) {
  return new Done4(() => result4);
}
function failCause2(result4) {
  return new Halt(() => result4);
}
function failWith3(error) {
  return new Halt(() => fail2(error()));
}
function fail10(error) {
  return new Halt(() => fail2(error));
}
function die5(defect) {
  return new Halt(() => die(defect));
}
function dieWith3(defect) {
  return new Halt(() => die(defect()));
}
function writeWith(out) {
  return new Emit(out);
}
function write(out) {
  return new Emit(() => out);
}
function ensuringWith_(channel, finalizer2) {
  return new Ensuring(channel, finalizer2);
}
function concatMapWith_(self, f2, g2, h2) {
  return new ConcatAll(g2, h2, self, f2);
}
function concatAllWith_(channels, f2, g2) {
  return new ConcatAll(f2, g2, channels, identity);
}
function foldCauseChannel_(self, onErr, onSucc) {
  return new Fold2(self, new ContinuationK(onSucc, onErr));
}
function embedInput_(self, input) {
  return new Bridge(input, self);
}
function acquireReleaseOutExitWith_(self, release4) {
  return new BracketOut(self, release4);
}
function provideAll_5(self, env) {
  return new Provide3(env, self);
}
function chain_15(self, f2) {
  return new Fold2(self, new ContinuationK(f2, failCause2));
}
function suspend7(effect2) {
  return new EffectSuspendTotal(effect2);
}
function fromEffect3(self) {
  return new Effect(self);
}
function succeedWith5(effect2) {
  return new EffectTotal(effect2);
}
function catchAllCause_3(self, f2) {
  return new Fold2(self, new ContinuationK((_2) => end(_2), f2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/acquireReleaseExitWith.mjs
function acquireReleaseExitWith_(acquire, use2, release4) {
  return chain_15(fromEffect3(makeRef((_2) => unit3)), (ref) => ensuringWith_(chain_15(fromEffect3(uninterruptible2(tap_4(acquire, (a2) => ref.set((_2) => release4(a2, _2))))), use2), (ex) => chain_12(ref.get, (_2) => _2(ex))));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/succeed.mjs
function succeed9(z2) {
  return end(z2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/map.mjs
function map_19(self, f2) {
  return chain_15(self, (z2) => succeed9(f2(z2)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/as.mjs
function as_3(self, z2) {
  return map_19(self, (_2) => z2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/readWith.mjs
function readWith(inp, error, done7) {
  return readWithCause(inp, (c2) => fold_2(failureOrCause(c2), error, failCause2), done7);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/flatten.mjs
function flatten11(self) {
  return chain_15(self, identity);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/unwrap.mjs
function unwrap2(self) {
  return flatten11(fromEffect3(self));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/zip.mjs
function zip_10(self, that) {
  return chain_15(self, (z2) => map_19(that, (z22) => tuple2(z2, z22)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/zipRight.mjs
function zipRight_4(self, that) {
  return map_19(zip_10(self, that), get(1));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/catchAll.mjs
function catchAll_4(self, f2) {
  return catchAllCause_3(self, (cause2) => fold_2(failureOrCause(cause2), (l2) => f2(l2), (r2) => failCause2(r2)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/concatMap.mjs
function concatMap_(self, f2) {
  return concatMapWith_(self, f2, () => void 0, () => void 0);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/mapOut.mjs
function mapOut_(self, f2) {
  const reader = readWith((i2) => chain_15(write(f2(i2)), () => reader), fail10, end);
  return self[">>>"](reader);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/doneCollect.mjs
function doneCollectReader(builder2) {
  return readWith((out) => zipRight_4(succeedWith5(() => {
    builder2.append(out);
  }), doneCollectReader(builder2)), (err) => fail10(err), (done7) => end(done7));
}
function doneCollect(self) {
  return suspend7(() => {
    const builder2 = builder();
    return chain_15(pipeTo_(self, doneCollectReader(builder2)), (z2) => succeedWith5(() => tuple2(builder2.build(), z2)));
  });
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/drain.mjs
function drain(self) {
  const drainer = readWithCause((_2) => drainer, failCause2, end);
  return self[">>>"](drainer);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/ensuring.mjs
function ensuring_3(self, finalizer2) {
  return ensuringWith_(self, (_2) => finalizer2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/foldChannel.mjs
function foldChannel_(self, onErr, onSucc) {
  return foldCauseChannel_(self, (_2) => {
    return fold_2(failureOrCause(_2), (err) => onErr(err), (cause2) => failCause2(cause2));
  }, onSucc);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/managed.mjs
function managed_(m2, use2) {
  return acquireReleaseExitWith_(makeReleaseMap, (releaseMap2) => {
    return chain_15(fromEffect3(map_13(provideSome_(m2.effect, (_2) => tuple2(_2, releaseMap2)), get(1))), use2);
  }, (releaseMap2, exit) => releaseMapReleaseAll(exit, sequential)(releaseMap2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/fromInput.mjs
function fromInput(input) {
  return unwrap2(input.takeWith((_2) => failCause2(_2), (_2) => zipRight_4(write(_2), fromInput(input)), (_2) => end(_2)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/identity.mjs
function identity3() {
  return readWith((_in2) => zipRight_4(write(_in2), identity3()), (err) => fail10(err), (done7) => end(done7));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/_internal/mergeHelpers.mjs
var BothRunningTypeId = /* @__PURE__ */ Symbol();
var BothRunning = class {
  constructor(left4, right5) {
    this.left = left4;
    this.right = right5;
    this._typeId = BothRunningTypeId;
  }
};
var LeftDoneTypeId = /* @__PURE__ */ Symbol();
var LeftDone = class {
  constructor(f2) {
    this.f = f2;
    this._typeId = LeftDoneTypeId;
  }
};
var RightDoneTypeId = /* @__PURE__ */ Symbol();
var RightDone = class {
  constructor(f2) {
    this.f = f2;
    this._typeId = RightDoneTypeId;
  }
};
var MergeDecisionTypeId = /* @__PURE__ */ Symbol();
var MergeDecision = class {
  constructor() {
    this._mergeDecisionTypeId = MergeDecisionTypeId;
  }
};
function concrete4(decision) {
}
var DoneTypeId3 = /* @__PURE__ */ Symbol();
var Done5 = class extends MergeDecision {
  constructor(io) {
    super();
    this.io = io;
    this._typeId = DoneTypeId3;
  }
};
var AwaitTypeId = /* @__PURE__ */ Symbol();
var Await = class extends MergeDecision {
  constructor(f2) {
    super();
    this.f = f2;
    this._typeId = AwaitTypeId;
  }
};
function done4(io) {
  return new Done5(io);
}
function await_(f2) {
  return new Await(f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/_internal/executor.mjs
var FromKAndTypeId = /* @__PURE__ */ Symbol();
var FromKAnd = class {
  constructor(fromK, rest) {
    this.fromK = fromK;
    this.rest = rest;
    this._typeId = FromKAndTypeId;
  }
};
var InnerTypeId = /* @__PURE__ */ Symbol();
var Inner = class {
  constructor(exec, subK, lastDone, combineSubK, combineSubKAndInner) {
    this.exec = exec;
    this.subK = subK;
    this.lastDone = lastDone;
    this.combineSubK = combineSubK;
    this.combineSubKAndInner = combineSubKAndInner;
    this._typeId = InnerTypeId;
  }
  close(ex) {
    const fin = this.exec.close(ex);
    if (fin) {
      return result(fin);
    }
  }
};
var ChannelStateDoneTypeId = /* @__PURE__ */ Symbol();
var ChannelStateDone = class {
  constructor() {
    this._typeId = ChannelStateDoneTypeId;
  }
};
var ChannelStateEmitTypeId = /* @__PURE__ */ Symbol();
var ChannelStateEmit = class {
  constructor() {
    this._typeId = ChannelStateEmitTypeId;
  }
};
var ChannelStateEffectTypeId = /* @__PURE__ */ Symbol();
var ChannelStateEffect = class {
  constructor(effect2) {
    this.effect = effect2;
    this._typeId = ChannelStateEffectTypeId;
  }
};
var _ChannelStateDone = /* @__PURE__ */ new ChannelStateDone();
var _ChannelStateEmit = /* @__PURE__ */ new ChannelStateEmit();
function channelStateEffect(state) {
  if ((state === null || state === void 0 ? void 0 : state._typeId) === ChannelStateEffectTypeId) {
    return state.effect;
  }
  return unit3;
}
var endUnit = /* @__PURE__ */ new Done4(() => void 0);
var ChannelExecutor = class _ChannelExecutor {
  constructor(initialChannel, providedEnv, executeCloseLastSubstream) {
    this.providedEnv = providedEnv;
    this.executeCloseLastSubstream = executeCloseLastSubstream;
    this.doneStack = empty2();
    this.currentChannel = initialChannel();
  }
  restorePipe(exit, prev) {
    const currInput = this.input;
    this.input = prev;
    return currInput === null || currInput === void 0 ? void 0 : currInput.close(exit);
  }
  unwindAllFinalizers(acc, conts, exit) {
    while (!isEmpty3(conts)) {
      const head6 = unsafeFirst(conts);
      ;
      if (head6._typeId === ContinuationKTypeId) {
        conts = tail(conts);
      } else {
        return chain_12(result(head6.finalizer(exit)), (finExit) => this.unwindAllFinalizers(zipRight_(acc, finExit), tail(conts), exit));
      }
    }
    return done(acc);
  }
  popAllFinalizers(exit) {
    const effect2 = result(this.unwindAllFinalizers(unit2, this.doneStack, exit));
    this.doneStack = empty2();
    this.storeInProgressFinalizer(effect2);
    return effect2;
  }
  popNextFinalizersGo(stack, builder2) {
    while (!isEmpty3(stack)) {
      const head6 = unsafeFirst(stack);
      ;
      if (head6._typeId === ContinuationKTypeId) {
        return stack;
      }
      push_(builder2, head6);
      stack = tail(stack);
    }
    return empty2();
  }
  popNextFinalizers() {
    const builder2 = emptyPushable();
    this.doneStack = this.popNextFinalizersGo(this.doneStack, builder2);
    return builder2;
  }
  storeInProgressFinalizer(effect2) {
    this.inProgressFinalizer = effect2;
  }
  clearInProgressFinalizer() {
    this.inProgressFinalizer = void 0;
  }
  ifNotNull(effect2) {
    return effect2 ? effect2 : succeed5(unit2);
  }
  close(ex) {
    const runInProgressFinalizer = this.inProgressFinalizer ? ensuring_(this.inProgressFinalizer, succeedWith3(() => this.clearInProgressFinalizer())) : void 0;
    let closeSubexecutors;
    if (this.subexecutorStack) {
      if (this.subexecutorStack._typeId === InnerTypeId) {
        closeSubexecutors = this.subexecutorStack.close(ex);
      } else {
        const fin1 = this.subexecutorStack.fromK.close(ex);
        const fin2 = this.subexecutorStack.rest.close(ex);
        if (fin1 && fin2) {
          closeSubexecutors = zipWith_4(result(fin1), result(fin2), (a2, b2) => zipRight_(a2, b2));
        } else if (fin1) {
          closeSubexecutors = result(fin1);
        } else if (fin2) {
          closeSubexecutors = result(fin2);
        }
      }
    }
    let closeSelf;
    const selfFinalizers = this.popAllFinalizers(ex);
    if (selfFinalizers) {
      closeSelf = ensuring_(selfFinalizers, succeedWith3(() => this.clearInProgressFinalizer()));
    }
    if (closeSubexecutors || runInProgressFinalizer || closeSelf) {
      return uninterruptible2(map_13(tuple3(this.ifNotNull(closeSubexecutors), this.ifNotNull(runInProgressFinalizer), this.ifNotNull(closeSelf)), ({
        tuple: [a2, b2, c2]
      }) => zipRight_(a2, zipRight_(b2, c2))));
    }
  }
  getDone() {
    return this.done;
  }
  getEmit() {
    return this.emitted;
  }
  cancelWith(exit) {
    this.cancelled = exit;
  }
  run() {
    let result4 = void 0;
    while (!result4) {
      if (this.cancelled) {
        result4 = this.processCancellation();
      } else if (this.subexecutorStack) {
        result4 = this.drainSubexecutor();
      } else {
        if (!this.currentChannel) {
          result4 = _ChannelStateDone;
        } else {
          ;
          const currentChannel = this.currentChannel;
          switch (currentChannel._typeId) {
            case BridgeTypeId: {
              this.currentChannel = currentChannel.channel;
              if (this.input) {
                const inputExecutor = this.input;
                this.input = void 0;
                const drainer = zipRight_2(currentChannel.input.awaitRead, suspend4(() => {
                  const state = inputExecutor.run();
                  switch (state._typeId) {
                    case ChannelStateEmitTypeId: {
                      return chain_12(currentChannel.input.emit(inputExecutor.getEmit()), () => drainer);
                    }
                    case ChannelStateEffectTypeId: {
                      return foldCauseM_(state.effect, (cause2) => currentChannel.input.error(cause2), () => drainer);
                    }
                    case ChannelStateDoneTypeId: {
                      const done7 = inputExecutor.getDone();
                      return done7._tag === "Success" ? currentChannel.input.done(done7.value) : currentChannel.input.error(done7.cause);
                    }
                  }
                }));
                result4 = new ChannelStateEffect(chain_12(fork(drainer), (fiber) => succeedWith3(() => {
                  this.addFinalizer(new ContinuationFinalizer((exit) => chain_12(interrupt4(fiber), () => suspend4(() => this.restorePipe(exit, inputExecutor) || unit3))));
                })));
              }
              break;
            }
            case PipeToTypeId: {
              const previousInput = this.input;
              const leftExec = new _ChannelExecutor(currentChannel.left, this.providedEnv, this.executeCloseLastSubstream);
              leftExec.input = previousInput;
              this.input = leftExec;
              this.addFinalizer(new ContinuationFinalizer((exit) => this.restorePipe(exit, previousInput) || unit3));
              this.currentChannel = currentChannel.right();
              break;
            }
            case ReadTypeId: {
              result4 = this.runRead(currentChannel);
              break;
            }
            case DoneTypeId: {
              result4 = this.doneSucceed(currentChannel.terminal());
              break;
            }
            case HaltTypeId: {
              result4 = this.doneHalt(currentChannel.error());
              break;
            }
            case EffectTypeId: {
              const peffect = typeof this.providedEnv !== "undefined" ? provideAll_3(currentChannel.effect, this.providedEnv) : currentChannel.effect;
              result4 = new ChannelStateEffect(foldCauseM_(peffect, (cause2) => {
                const res = this.doneHalt(cause2);
                if ((res === null || res === void 0 ? void 0 : res._typeId) === ChannelStateEffectTypeId) {
                  return res.effect;
                } else {
                  return unit3;
                }
              }, (z2) => {
                const res = this.doneSucceed(z2);
                if ((res === null || res === void 0 ? void 0 : res._typeId) === ChannelStateEffectTypeId) {
                  return res.effect;
                } else {
                  return unit3;
                }
              }));
              break;
            }
            case EmitTypeId: {
              this.emitted = currentChannel.out();
              this.currentChannel = endUnit;
              result4 = _ChannelStateEmit;
              break;
            }
            case EnsuringTypeId: {
              this.addFinalizer(new ContinuationFinalizer((e2) => currentChannel.finalizer(e2)));
              this.currentChannel = currentChannel.channel;
              break;
            }
            case ConcatAllTypeId: {
              const innerExecuteLastClose = (f2) => succeedWith3(() => {
                const prevLastClose = this.closeLastSubstream ? this.closeLastSubstream : unit3;
                this.closeLastSubstream = zipRight_2(prevLastClose, f2);
              });
              const exec = new _ChannelExecutor(() => currentChannel.value, this.providedEnv, innerExecuteLastClose);
              exec.input = this.input;
              this.subexecutorStack = new Inner(exec, currentChannel.k, void 0, currentChannel.combineInners, currentChannel.combineAll);
              this.closeLastSubstream = void 0;
              this.currentChannel = void 0;
              break;
            }
            case FoldTypeId: {
              this.doneStack = prepend_2(this.doneStack, currentChannel.k);
              this.currentChannel = currentChannel.value;
              break;
            }
            case BracketOutTypeId: {
              result4 = this.runBracketOut(currentChannel);
              break;
            }
            case ProvideTypeId: {
              const previousEnv = this.providedEnv;
              this.providedEnv = currentChannel.env;
              this.currentChannel = currentChannel.channel;
              this.addFinalizer(new ContinuationFinalizer(() => succeedWith3(() => {
                this.providedEnv = previousEnv;
              })));
              break;
            }
            case EffectTotalTypeId: {
              result4 = this.doneSucceed(currentChannel.effect());
              break;
            }
            case EffectSuspendTotalTypeId: {
              this.currentChannel = currentChannel.effect();
              break;
            }
          }
        }
      }
    }
    return result4;
  }
  runReadGo(state, read, input) {
    switch (state._typeId) {
      case ChannelStateEmitTypeId: {
        return succeedWith3(() => {
          this.currentChannel = read.more(input.getEmit());
        });
      }
      case ChannelStateDoneTypeId: {
        return succeedWith3(() => {
          this.currentChannel = read.done.onExit(input.getDone());
        });
      }
      case ChannelStateEffectTypeId: {
        return foldCauseM_(state.effect, (cause2) => succeedWith3(() => {
          this.currentChannel = read.done.onHalt(cause2);
        }), () => this.runReadGo(input.run(), read, input));
      }
    }
  }
  runRead(read) {
    if (this.input) {
      const input = this.input;
      const state = input.run();
      switch (state._typeId) {
        case ChannelStateEmitTypeId: {
          this.currentChannel = read.more(input.getEmit());
          return;
        }
        case ChannelStateDoneTypeId: {
          this.currentChannel = read.done.onExit(input.getDone());
          return;
        }
        case ChannelStateEffectTypeId: {
          return new ChannelStateEffect(foldCauseM_(state.effect, (cause2) => succeedWith3(() => {
            this.currentChannel = read.done.onHalt(cause2);
          }), () => this.runReadGo(input.run(), read, input)));
        }
      }
    } else {
      this.currentChannel = read.more(void 0);
    }
  }
  runBracketOut(bracketOut) {
    return new ChannelStateEffect(uninterruptibleMask((mask2) => foldCauseM_(mask2.restore(bracketOut.acquire), (cause2) => succeedWith3(() => {
      this.currentChannel = new Halt(() => cause2);
    }), (out) => succeedWith3(() => {
      this.addFinalizer(new ContinuationFinalizer((e2) => bracketOut.finalizer(out, e2)));
      this.currentChannel = new Emit(() => out);
    }))));
  }
  addFinalizer(f2) {
    this.doneStack = prepend_2(this.doneStack, f2);
  }
  drainSubexecutor() {
    const subexecutorStack = this.subexecutorStack;
    if (subexecutorStack._typeId === InnerTypeId) {
      return this.drainInnerSubExecutor(subexecutorStack);
    } else {
      return this.drainFromKAndSubexecutor(subexecutorStack.fromK, subexecutorStack.rest);
    }
  }
  handleSubexecFailure(exec, rest, self, cause2) {
    return self.finishSubexecutorWithCloseEffect(halt(cause2), (_2) => rest.exec.close(_2), (_2) => exec.close(_2));
  }
  drainFromKAndSubexecutor(exec, rest) {
    const run7 = exec.run();
    switch (run7._typeId) {
      case ChannelStateEffectTypeId: {
        return new ChannelStateEffect(catchAllCause_(run7.effect, (cause2) => channelStateEffect(this.handleSubexecFailure(exec, rest, this, cause2))));
      }
      case ChannelStateEmitTypeId: {
        this.emitted = exec.getEmit();
        return _ChannelStateEmit;
      }
      case ChannelStateDoneTypeId: {
        const done7 = exec.getDone();
        switch (done7._tag) {
          case "Failure": {
            return this.handleSubexecFailure(exec, rest, this, done7.cause);
          }
          case "Success": {
            const modifiedRest = new Inner(rest.exec, rest.subK, rest.lastDone ? rest.combineSubK(rest.lastDone, done7.value) : done7.value, rest.combineSubK, rest.combineSubKAndInner);
            this.closeLastSubstream = exec.close(done7);
            this.replaceSubexecutor(modifiedRest);
            return void 0;
          }
        }
      }
    }
  }
  replaceSubexecutor(nextSubExec) {
    this.currentChannel = void 0;
    this.subexecutorStack = nextSubExec;
  }
  finishSubexecutorWithCloseEffect(subexecDone, ...closeFns) {
    this.addFinalizer(new ContinuationFinalizer((_2) => forEachUnit_(closeFns, (closeFn) => chain_12(succeedWith3(() => closeFn(subexecDone)), (closeEffect) => {
      if (closeEffect) {
        return closeEffect;
      } else {
        return unit3;
      }
    }))));
    const state = fold_4(subexecDone, (e2) => this.doneHalt(e2), (a2) => this.doneSucceed(a2));
    this.subexecutorStack = void 0;
    return state;
  }
  doneSucceed(z2) {
    if (isEmpty3(this.doneStack)) {
      this.done = succeed4(z2);
      this.currentChannel = void 0;
      return _ChannelStateDone;
    }
    const head6 = unsafeFirst(this.doneStack);
    ;
    if (head6._typeId === ContinuationKTypeId) {
      this.doneStack = tail(this.doneStack);
      this.currentChannel = head6.onSuccess(z2);
      return;
    } else {
      const finalizers = this.popNextFinalizers();
      if (isEmpty3(this.doneStack)) {
        this.doneStack = finalizers;
        this.done = succeed4(z2);
        this.currentChannel = void 0;
        return _ChannelStateDone;
      } else {
        const finalizerEffect = this.runFinalizers(map_7(finalizers, (_2) => _2.finalizer), succeed4(z2));
        this.storeInProgressFinalizer(finalizerEffect);
        return new ChannelStateEffect(chain_12(uninterruptible2(ensuring_(finalizerEffect, succeedWith3(() => {
          this.clearInProgressFinalizer();
        }))), () => succeedWith3(() => this.doneSucceed(z2))));
      }
    }
  }
  runFinalizers(finalizers, ex) {
    if (isEmpty3(finalizers)) {
      return succeed5(unit2);
    }
    return map_13(forEach_5(finalizers, (cont) => result(cont(ex))), (results) => getOrElse_(collectAll(...results), () => unit2));
  }
  doneHalt(cause2) {
    if (isEmpty3(this.doneStack)) {
      this.done = halt(cause2);
      this.currentChannel = void 0;
      return _ChannelStateDone;
    }
    const head6 = unsafeFirst(this.doneStack);
    ;
    if (head6._typeId === ContinuationKTypeId) {
      this.doneStack = tail(this.doneStack);
      this.currentChannel = head6.onHalt(cause2);
      return;
    } else {
      const finalizers = this.popNextFinalizers();
      if (isEmpty3(this.doneStack)) {
        this.doneStack = finalizers;
        this.done = halt(cause2);
        this.currentChannel = void 0;
        return _ChannelStateDone;
      } else {
        const finalizerEffect = this.runFinalizers(map_7(finalizers, (_2) => _2.finalizer), halt(cause2));
        this.storeInProgressFinalizer(finalizerEffect);
        return new ChannelStateEffect(chain_12(uninterruptible2(ensuring_(finalizerEffect, succeedWith3(() => {
          this.clearInProgressFinalizer();
        }))), () => succeedWith3(() => this.doneHalt(cause2))));
      }
    }
  }
  drainInnerSubExecutor(inner) {
    const run7 = inner.exec.run();
    switch (run7._typeId) {
      case ChannelStateEmitTypeId: {
        if (this.closeLastSubstream) {
          const closeLast = this.closeLastSubstream;
          this.closeLastSubstream = void 0;
          return new ChannelStateEffect(map_13(this.executeCloseLastSubstream(closeLast), (_2) => {
            const fromK = new _ChannelExecutor(() => inner.subK(inner.exec.getEmit()), this.providedEnv, this.executeCloseLastSubstream);
            fromK.input = this.input;
            this.subexecutorStack = new FromKAnd(fromK, inner);
          }));
        } else {
          const fromK = new _ChannelExecutor(() => inner.subK(inner.exec.getEmit()), this.providedEnv, this.executeCloseLastSubstream);
          fromK.input = this.input;
          this.subexecutorStack = new FromKAnd(fromK, inner);
          return void 0;
        }
      }
      case ChannelStateDoneTypeId: {
        const lastClose = this.closeLastSubstream;
        const done7 = inner.exec.getDone();
        switch (done7._tag) {
          case "Failure": {
            return this.finishSubexecutorWithCloseEffect(done7, () => lastClose, (_2) => inner.exec.close(_2));
          }
          case "Success": {
            const doneValue = succeed4(inner.combineSubKAndInner(inner.lastDone, done7.value));
            return this.finishSubexecutorWithCloseEffect(doneValue, () => lastClose, (_2) => inner.exec.close(_2));
          }
        }
      }
      case ChannelStateEffectTypeId: {
        const closeLast = this.closeLastSubstream ? this.closeLastSubstream : unit3;
        this.closeLastSubstream = void 0;
        return new ChannelStateEffect(zipRight_2(this.executeCloseLastSubstream(closeLast), catchAllCause_(run7.effect, (cause2) => channelStateEffect(this.finishSubexecutorWithCloseEffect(halt(cause2), (_2) => inner.exec.close(_2), (_2) => inner.exec.close(_2))))));
      }
    }
  }
  processCancellation() {
    this.currentChannel = void 0;
    this.done = this.cancelled;
    this.cancelled = void 0;
    return _ChannelStateDone;
  }
};

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/toPull.mjs
function toPullInterpret(channelState, exec) {
  switch (channelState._typeId) {
    case ChannelStateEffectTypeId: {
      return chain_12(channelState.effect, () => toPullInterpret(exec.run(), exec));
    }
    case ChannelStateEmitTypeId: {
      return succeed5(right(exec.getEmit()));
    }
    case ChannelStateDoneTypeId: {
      const done7 = exec.getDone();
      if (done7._tag === "Success") {
        return succeed5(left(done7.value));
      } else {
        return halt2(done7.cause);
      }
    }
  }
}
function toPull(self) {
  return map_14(makeExit_(succeedWith3(() => new ChannelExecutor(() => self, void 0, identity)), (exec, exit) => exec.close(exit) || unit3), (exec) => suspend4(() => toPullInterpret(exec.run(), exec)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/managedOut.mjs
function managedOut(self) {
  return mapOut_(acquireReleaseOutExitWith_(chain_12(makeReleaseMap, (releaseMap2) => map_13(provideSome_(self.effect, (_2) => tuple2(_2, releaseMap2)), ({
    tuple: [_2, out]
  }) => tuple2(out, releaseMap2))), ({
    tuple: [_2, releaseMap2]
  }, exit) => releaseMapReleaseAll(exit, sequential)(releaseMap2)), get(0));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/unwrapManaged.mjs
function unwrapManaged(self) {
  return concatAllWith_(managedOut(self), identity, identity);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/mergeWith.mjs
function mergeWith_(self, that, leftDone, rightDone) {
  const m2 = map_14(chain_13(bind_2(bind_2(let_3(bind_2(do_3, "input", () => toManaged(makeSingleProducerAsyncInput())), "queueReader", ({
    input
  }) => fromInput(input)), "pullL", ({
    queueReader
  }) => toPull(queueReader[">>>"](self))), "pullR", ({
    queueReader
  }) => toPull(queueReader[">>>"](that))), ({
    input,
    pullL,
    pullR,
    queueReader
  }) => toManaged(transplant((graft) => succeed5({
    input,
    pullL: graft(pullL),
    pullR: graft(pullR),
    queueReader
  })))), ({
    input,
    pullL,
    pullR
  }) => {
    const handleSide = (exit, fiber, pull) => (done7, both, single4) => {
      const onDecision = (decision) => {
        concrete4(decision);
        if (decision._typeId === DoneTypeId3) {
          return succeed5(fromEffect3(zipRight_2(interrupt4(fiber), decision.io)));
        } else {
          return map_13(fiber.await, fold5((cause2) => fromEffect3(decision.f(halt(cause2))), fold2((z2) => fromEffect3(decision.f(succeed4(z2))), (elem3) => zipRight_4(write(elem3), go(single4(decision.f))))));
        }
      };
      return fold_4(exit, (failure) => onDecision(done7(halt(failure))), fold2((z2) => onDecision(done7(succeed4(z2))), (elem3) => map_13(forkDaemon(pull), (leftFiber) => zipRight_4(write(elem3), go(both(leftFiber, fiber))))));
    };
    const go = (state) => {
      if (state._typeId === BothRunningTypeId) {
        const lj = join(state.left);
        const rj = join(state.right);
        return unwrap2(raceWith_(lj, rj, (leftEx, _2) => handleSide(leftEx, state.right, pullL)(leftDone, (l2, r2) => new BothRunning(l2, r2), (_3) => new LeftDone(_3)), (rightEx, _2) => handleSide(rightEx, state.left, pullR)(rightDone, (l2, r2) => new BothRunning(r2, l2), (_3) => new RightDone(_3))));
      } else if (state._typeId === LeftDoneTypeId) {
        return unwrap2(map_13(result(pullR), fold5((cause2) => fromEffect3(state.f(halt(cause2))), fold2((z2) => fromEffect3(state.f(succeed4(z2))), (elem3) => zipRight_4(write(elem3), go(new LeftDone(state.f)))))));
      } else {
        return unwrap2(map_13(result(pullL), fold5((cause2) => fromEffect3(state.f(halt(cause2))), fold2((z2) => fromEffect3(state.f(succeed4(z2))), (elem3) => zipRight_4(write(elem3), go(new RightDone(state.f)))))));
      }
    };
    return embedInput_(chain_15(fromEffect3(zipWith_4(forkDaemon(pullL), forkDaemon(pullR), (a2, b2) => new BothRunning(a2, b2))), go), input);
  });
  return unwrapManaged(m2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/interruptWhen.mjs
function interruptWhen_(self, io) {
  return mergeWith_(self, fromEffect3(io), (selfDone) => done4(done(selfDone)), (ioDone) => done4(done(ioDone)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/interruptWhenP.mjs
function interruptWhenP_(self, promise2) {
  return interruptWhen_(self, wait(promise2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/mapErrorCause.mjs
function mapErrorCause_3(self, f2) {
  return catchAllCause_3(self, (cause2) => failCause2(f2(cause2)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/mapError.mjs
function mapError_5(self, f2) {
  return mapErrorCause_3(self, (cause2) => map_11(cause2, f2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/mapOutEffect.mjs
var mapOutMReader = (f2) => readWith((out) => zipRight_4(chain_15(fromEffect3(f2(out)), (_2) => write(_2)), mapOutMReader(f2)), (e2) => fail10(e2), (z2) => end(z2));
function mapOutEffect_(self, f2) {
  return pipeTo_(self, mapOutMReader(f2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/mapOutEffectPar.mjs
function mapOutEffectPar_(self, n2, f2) {
  return managed_(withChildren2((getChildren) => map_14(tap_5(bind_2(bind_2(bind_2(bind_2(tap_5(do_3, () => finalizer(chain_12(getChildren, interruptAll))), "queue", () => toManagedRelease_(makeBoundedQueue(n2), shutdown)), "errorSignal", () => makeManaged()), "permits", () => toManaged(makeSemaphore(n2))), "pull", () => toPull(self)), ({
    errorSignal,
    permits,
    pull,
    queue
  }) => forkManaged(interruptible2(forever2(foldCauseM_(pull, (cause2) => offer_(queue, halt2(cause2)), fold2((outDone) => asUnit(zipRight_2(interruptible2(withPermits_(unit3, permits, n2)), offer_(queue, succeed5(left(outDone))))), (outElem) => asUnit(tap_4(tap_4(tap_4(bind_(bind_(do_2, "p", () => make4()), "latch", () => make4()), ({
    p: p2
  }) => offer_(queue, map_13(wait(p2), right))), ({
    latch,
    p: p2
  }) => fork(withPermit_(zipRight_2(succeed_(latch, void 0), to_(tapCause_(raceFirst_(wait(errorSignal), f2(outElem)), (_2) => halt_(errorSignal, _2)), p2)), permits))), ({
    latch
  }) => wait(latch))))))))), ({
    queue
  }) => queue)), (queue) => {
    const consumer = unwrap2(foldCause_(flatten8(take2(queue)), (_2) => failCause2(_2), fold2((outDone) => end(outDone), (outElem) => zipRight_4(write(outElem), consumer))));
    return consumer;
  });
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/mergeAllWith.mjs
function mergeAllWith_(channels, n2, f2, bufferSize = 16, mergeStrategy = "BackPressure") {
  return managed_(withChildren2((getChildren) => map_14(tap_5(let_3(bind_2(bind_2(bind_2(bind_2(bind_2(bind_2(tap_5(do_3, () => finalizer(chain_12(getChildren, interruptAll))), "queue", () => toManagedRelease_(makeBoundedQueue(bufferSize), shutdown)), "cancelers", () => toManagedRelease_(makeUnbounded(), shutdown)), "lastDone", () => makeManagedRef(none)), "errorSignal", () => makeManaged()), "permits", () => toManaged(makeSemaphore(n2))), "pull", () => toPull(channels)), "evaluatePull", ({
    errorSignal,
    lastDone,
    queue
  }) => (pull) => catchAllCause_(chain_12(repeatUntil_(chain_12(pull, fold2((done7) => succeed5(some(done7)), (outElem) => as_(offer_(queue, succeed5(right(outElem))), none))), isSome), fold(() => unit3, (outDone) => update_3(lastDone, fold(() => some(outDone), (lastDone2) => some(f2(lastDone2, outDone)))))), (cause2) => zipRight_2(offer_(queue, halt2(cause2)), asUnit(succeed_(errorSignal, void 0))))), ({
    cancelers,
    errorSignal,
    evaluatePull,
    lastDone,
    permits,
    pull,
    queue
  }) => forkManaged(repeatWhile_(foldCauseM_(pull, (cause2) => zipRight_2(chain_12(getChildren, interruptAll), as_(offer_(queue, halt2(cause2)), false)), fold2((outDone) => raceWith_(wait(errorSignal), withPermits_(unit3, permits, n2), (_2, permitAcquisition) => zipRight_2(chain_12(getChildren, interruptAll), as_(interrupt4(permitAcquisition), false)), (_2, failureAwait) => zipRight_2(interrupt4(failureAwait), as_(chain_12(lastDone.get, fold(() => offer_(queue, succeed5(left(outDone))), (lastDone2) => offer_(queue, succeed5(left(f2(lastDone2, outDone)))))), false))), (channel) => {
    if (mergeStrategy === "BackPressure") {
      return map_13(bind_(tap_4(tap_4(let_2(bind_(do_2, "latch", () => make4()), "raceIOs", () => managedUse_(toPull(channel), (_2) => race_(evaluatePull(_2), wait(errorSignal)))), ({
        latch,
        raceIOs
      }) => fork(withPermit_(zipRight_2(succeed_(latch, void 0), raceIOs), permits))), ({
        latch
      }) => wait(latch)), "errored", () => isDone(errorSignal)), ({
        errored
      }) => !errored);
    } else {
      return map_13(bind_(tap_4(tap_4(let_2(tap_4(tap_4(bind_(bind_(bind_(do_2, "canceler", () => make4()), "latch", () => make4()), "size", () => size5(cancelers)), ({
        size: size7
      }) => when_(chain_12(take2(cancelers), (_2) => succeed_(_2, void 0)), () => size7 >= n2)), ({
        canceler
      }) => offer_(cancelers, canceler)), "raceIOs", ({
        canceler
      }) => managedUse_(toPull(channel), (_2) => race_(race_(evaluatePull(_2), wait(errorSignal)), wait(canceler)))), ({
        latch,
        raceIOs
      }) => fork(withPermit_(zipRight_2(succeed_(latch, void 0), raceIOs), permits))), ({
        latch
      }) => wait(latch)), "errored", () => isDone(errorSignal)), ({
        errored
      }) => !errored);
    }
  })), (x2) => x2 === true))), ({
    queue
  }) => queue)), (queue) => {
    const consumer = unwrap2(foldCause_(flatten8(take2(queue)), (cause2) => failCause2(cause2), fold2((outDone) => end(outDone), (outElem) => zipRight_4(write(outElem), consumer))));
    return consumer;
  });
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/mergeAll.mjs
function mergeAll_3(channels, n2, bufferSize = 16, mergeStrategy = "BackPressure") {
  return mergeAllWith_(channels, n2, (_2, __) => void 0, bufferSize, mergeStrategy);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/mergeMap.mjs
function mergeMap_(self, n2, f2, bufferSize = 16, mergeStrategy = "BackPressure") {
  return mergeAll_3(mapOut_(self, f2), n2, bufferSize, mergeStrategy);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/orElse.mjs
function orElse_4(self, that) {
  return catchAll_4(self, (_2) => that);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/repeated.mjs
function repeated(self) {
  return chain_15(self, () => repeated(self));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/runManaged.mjs
function runManagedInterpret(channelState, exec) {
  while (1) {
    switch (channelState._typeId) {
      case ChannelStateEffectTypeId: {
        return chain_12(channelState.effect, () => runManagedInterpret(exec.run(), exec));
      }
      case ChannelStateEmitTypeId: {
        channelState = exec.run();
        break;
      }
      case ChannelStateDoneTypeId: {
        return done(exec.getDone());
      }
    }
  }
  throw new Error("Bug");
}
function runManaged(self) {
  return mapM_(makeExit_(succeedWith3(() => new ChannelExecutor(() => self, void 0, identity)), (exec, exit) => exec.close(exit) || unit3), (exec) => suspend4(() => runManagedInterpret(exec.run(), exec)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/run.mjs
function run5(self) {
  return useNow(runManaged(self));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/runDrain.mjs
function runDrain(self) {
  return run5(drain(self));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/unit.mjs
var unit5 = /* @__PURE__ */ end(void 0);

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/writeAll.mjs
function writeAll(...outs) {
  return reduceRight_(outs, end(void 0), (out, conduit) => zipRight_4(write(out), conduit));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Channel/api/writeChunk.mjs
function writeChunk(outs) {
  const writer = (idx, len) => idx === len ? unit5 : zipRight_4(write(unsafeGet_2(outs, idx)), writer(idx + 1, len));
  return writer(0, size4(outs));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/loopOnChunks.mjs
function loopOnChunks_(self, f2) {
  const loop6 = readWith((chunk2) => chain_15(f2(chunk2), (cont) => cont ? loop6 : end(false)), fail10, (_2) => succeed9(false));
  return new Stream(self.channel[">>>"](loop6));
}
function loopOnChunks(f2) {
  return (self) => loopOnChunks_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/loopOnPartialChunks.mjs
function loopOnPartialChunks_(self, f2) {
  return loopOnChunks_(self, (chunk2) => unwrap2(suspend4(() => {
    const outputChunk = builder();
    const emit = (a2) => succeedWith3(() => {
      outputChunk.append(a2);
    });
    return catchAll_2(map_13(f2(chunk2, emit), (cont) => chain_15(write(outputChunk.build()), () => end(cont))), (failure) => succeedWith3(() => {
      const partialResult = outputChunk.build();
      if (isEmpty5(partialResult)) {
        return fail10(failure);
      } else {
        return zipRight_4(write(partialResult), fail10(failure));
      }
    }));
  })));
}
function loopOnPartialChunks(f2) {
  return (self) => loopOnPartialChunks_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/loopOnPartialChunksElements.mjs
function loopOnPartialChunksElements_(self, f2) {
  return loopOnPartialChunks_(self, (a2, emit) => as_(forEachUnit_(a2, (a3) => f2(a3, emit)), true));
}
function loopOnPartialChunksElements(f2) {
  return (self) => loopOnPartialChunksElements_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/mapEffect.mjs
function mapEffect_3(self, f2) {
  return loopOnPartialChunksElements_(self, (a2, emit) => chain_12(f2(a2), emit));
}
function mapEffect3(f2) {
  return (self) => mapEffect_3(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/absolve.mjs
function absolve3(xs) {
  return mapEffect_3(xs, (_2) => fromEither2(() => _2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/fromEffectOption.mjs
function fromEffectOption(fa) {
  return new Stream(unwrap2(fold_5(fa, fold(() => end(void 0), (e2) => fail10(e2)), (a2) => write(single(a2)))));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/fromEffect.mjs
function fromEffect4(fa) {
  return fromEffectOption(mapError_3(fa, some));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/environment.mjs
function environment4() {
  return fromEffect4(environment2());
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/map.mjs
function map_20(self, f2) {
  return new Stream(mapOut_(self.channel, (o2) => map_8(o2, f2)));
}
function map13(f2) {
  return (self) => map_20(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/access.mjs
function access5(f2) {
  return map_20(environment4(), f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/accessEffect.mjs
function accessEffect(f2) {
  return mapEffect_3(environment4(), f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/accessServiceEffect.mjs
function accessServiceEffect(s2) {
  return (f2) => accessEffect((r2) => f2(r2[s2.key]));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/chain.mjs
function chain_16(self, f2) {
  return new Stream(concatMap_(self.channel, (o2) => reduce_7(map_8(o2, (x2) => f2(x2).channel), unit5, (s2, a2) => chain_15(s2, () => a2))));
}
function chain12(f2) {
  return (self) => chain_16(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/accessStream.mjs
function accessStream(f2) {
  return chain_16(environment4(), f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/managed.mjs
function managed(self) {
  return new Stream(managedOut(map_14(self, single)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/acquireReleaseExitWith.mjs
function acquireReleaseExitWith_2(acquire, release4) {
  return managed(makeExit_(acquire, release4));
}
function acquireReleaseExitWith(release4) {
  return (acquire) => acquireReleaseExitWith_2(acquire, release4);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/acquireReleaseWith.mjs
function acquireReleaseWith_(acquire, release4) {
  return managed(make_(acquire, release4));
}
function acquireReleaseWith(release4) {
  return (acquire) => acquireReleaseWith_(acquire, release4);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/Handoff.mjs
var Handoff = class {
  constructor(ref) {
    this.ref = ref;
  }
};
function make10() {
  return map_13(chain_12(make4(), (p2) => makeRef(new Empty5(p2))), (_2) => new Handoff(_2));
}
var StateTypeId = /* @__PURE__ */ Symbol();
var EmptyTypeId3 = /* @__PURE__ */ Symbol();
var Empty5 = class {
  constructor(notifyConsumer) {
    this.notifyConsumer = notifyConsumer;
    this._stateTypeId = StateTypeId;
    this._typeId = EmptyTypeId3;
  }
};
var FullTypeId = /* @__PURE__ */ Symbol();
var Full = class {
  constructor(a2, notifyConsumer) {
    this.a = a2;
    this.notifyConsumer = notifyConsumer;
    this._stateTypeId = StateTypeId;
    this._typeId = FullTypeId;
  }
};
function offer(handoff, a2) {
  return chain_12(make4(), (p2) => {
    return flatten8(modify_2(handoff.ref, (s2) => {
      if (s2._typeId === FullTypeId) {
        return tuple2(zipRight_2(wait(s2.notifyConsumer), offer(handoff, a2)), s2);
      } else {
        return tuple2(zipRight_2(succeed_(s2.notifyConsumer, void 0), wait(p2)), new Full(a2, p2));
      }
    }));
  });
}
function take3(handoff) {
  return chain_12(make4(), (p2) => {
    return flatten8(modify_2(handoff.ref, (s2) => {
      if (s2._typeId === FullTypeId) {
        return tuple2(as_(succeed_(s2.notifyConsumer, void 0), s2.a), new Empty5(p2));
      } else {
        return tuple2(zipRight_2(wait(s2.notifyConsumer), take3(handoff)), s2);
      }
    }));
  });
}
var HandoffSignalTypeId = /* @__PURE__ */ Symbol();
var EmitTypeId3 = /* @__PURE__ */ Symbol();
var Emit2 = class {
  constructor(els) {
    this.els = els;
    this._handoffSignalTypeId = HandoffSignalTypeId;
    this._typeId = EmitTypeId3;
  }
};
var HaltTypeId2 = /* @__PURE__ */ Symbol();
var Halt2 = class {
  constructor(error) {
    this.error = error;
    this._handoffSignalTypeId = HandoffSignalTypeId;
    this._typeId = HaltTypeId2;
  }
};
var EndTypeId = /* @__PURE__ */ Symbol();
var End = class {
  constructor(reason) {
    this.reason = reason;
    this._handoffSignalTypeId = HandoffSignalTypeId;
    this._typeId = EndTypeId;
  }
};

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/SinkEndReason.mjs
var SinkEndReasonTypeId = /* @__PURE__ */ Symbol();
var SinkEndTypeId = /* @__PURE__ */ Symbol();
var SinkEnd = class {
  constructor() {
    this._sinkEndReasonTypeId = SinkEndReasonTypeId;
    this._typeId = SinkEndTypeId;
  }
};
var ScheduleTimeoutTypeId = /* @__PURE__ */ Symbol();
var ScheduleTimeout = class {
  constructor() {
    this._sinkEndReasonTypeId = SinkEndReasonTypeId;
    this._typeId = ScheduleTimeoutTypeId;
  }
};
var ScheduleEndTypeId = /* @__PURE__ */ Symbol();
var ScheduleEnd = class {
  constructor(c2) {
    this.c = c2;
    this._sinkEndReasonTypeId = SinkEndReasonTypeId;
    this._typeId = ScheduleEndTypeId;
  }
};
var UpstreamEndTypeId = /* @__PURE__ */ Symbol();
var UpstreamEnd = class {
  constructor() {
    this._sinkEndReasonTypeId = SinkEndReasonTypeId;
    this._typeId = UpstreamEndTypeId;
  }
};

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/crossWith.mjs
function crossWith_(self, that, f2) {
  return chain_16(self, (l2) => map_20(that, (r2) => f2(l2, r2)));
}
function crossWith(that, f2) {
  return (self) => crossWith_(self, that, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/cross.mjs
function cross_(...[s1, s2, ...streams]) {
  const init = crossWith_(s1, s2, tuple2);
  return reduce_(streams, init, (acc, v2) => (
    // @ts-expect-error
    crossWith_(acc, v2, (a2, b2) => append_(a2, b2))
  ));
}
function cross(...[s1, ...streams]) {
  return (self) => (
    // @ts-expect-error
    cross_(self, s1, ...streams)
  );
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/crossRight.mjs
function crossRight_(self, that) {
  return map_20(cross_(self, that), get(1));
}
function crossRight(that) {
  return (self) => crossRight_(self, that);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/aggregateAsyncWithinEither.mjs
function aggregateAsyncWithinEither_(self, sink, schedule2) {
  const deps = tuple3(make10(), makeRef(new SinkEnd()), makeRef(empty4()), driver(schedule2));
  return chain_16(fromEffect4(deps), ({
    tuple: [handoff, sinkEndReason, sinkLeftovers, scheduleDriver]
  }) => {
    const handoffProducer = readWithCause((_in2) => zipRight_4(fromEffect3(offer(handoff, new Emit2(_in2))), handoffProducer), (cause2) => fromEffect3(offer(handoff, new Halt2(cause2))), (_2) => fromEffect3(offer(handoff, new End(new UpstreamEnd()))));
    const handoffConsumer = unwrap2(chain_12(getAndSet_(sinkLeftovers, empty4()), (leftovers) => {
      if (isEmpty5(leftovers)) {
        return succeed5(zipRight_4(write(leftovers), handoffConsumer));
      } else {
        return map_13(take3(handoff), (_2) => {
          switch (_2._typeId) {
            case EmitTypeId3:
              return zipRight_4(write(_2.els), handoffConsumer);
            case HaltTypeId2:
              return failCause2(_2.error);
            case EndTypeId:
              return fromEffect3(set_2(sinkEndReason, _2.reason));
          }
        });
      }
    }));
    const scheduledAggregator = (lastB) => {
      const timeout4 = foldCauseM_(scheduleDriver.next(lastB), (_2) => fold_2(failureOrCause(_2), (_3) => offer(handoff, new End(new ScheduleTimeout())), (cause2) => offer(handoff, new Halt2(cause2))), (c2) => offer(handoff, new End(new ScheduleEnd(c2))));
      return chain_15(managed_(forkManaged(timeout4), (fiber) => {
        return chain_15(doneCollect(handoffConsumer[">>>"](sink.channel)), ({
          tuple: [leftovers, b2]
        }) => {
          return zipRight_4(fromEffect3(zipRight_2(interrupt4(fiber), set_2(sinkLeftovers, flatten5(leftovers)))), unwrap2(modify_2(sinkEndReason, (reason) => {
            switch (reason._typeId) {
              case ScheduleEndTypeId:
                return tuple2(as_3(write(from3([right(b2), left(reason.c)])), some(b2)), new SinkEnd());
              case ScheduleTimeoutTypeId:
                return tuple2(as_3(write(single(right(b2))), some(b2)), new SinkEnd());
              case SinkEndTypeId:
                return tuple2(as_3(write(single(right(b2))), some(b2)), new SinkEnd());
              case UpstreamEndTypeId:
                return tuple2(as_3(write(single(right(b2))), none), new UpstreamEnd());
            }
          })));
        });
      }), (_2) => {
        if (isNone(_2)) {
          return unit5;
        } else {
          return scheduledAggregator(_2);
        }
      });
    };
    return crossRight_(managed(managedFork(runManaged(self.channel[">>>"](handoffProducer)))), new Stream(scheduledAggregator(none)));
  });
}
function aggregateAsyncWithinEither(sink, schedule2) {
  return (self) => aggregateAsyncWithinEither_(self, sink, schedule2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/mapChunks.mjs
function mapChunks_(self, f2) {
  return new Stream(mapOut_(self.channel, f2));
}
function mapChunks(f2) {
  return (self) => mapChunks_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/collect.mjs
function collect_5(self, f2) {
  return mapChunks_(self, collect(f2));
}
function collect4(f2) {
  return (self) => collect_5(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/aggregateAsyncWithin.mjs
function aggregateAsyncWithin_(self, sink, schedule2) {
  return collect_5(aggregateAsyncWithinEither_(self, sink, schedule2), fold2(() => none, (v2) => some(v2)));
}
function aggregateAsyncWithin(sink, schedule2) {
  return (self) => aggregateAsyncWithin_(self, sink, schedule2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/aggregateAsync.mjs
function aggregateAsync_(self, sink) {
  return aggregateAsyncWithin_(self, sink, forever);
}
function aggregateAsync(sink) {
  return (self) => aggregateAsync_(self, sink);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/as.mjs
function as_4(self, a2) {
  return map_20(self, (_2) => a2);
}
function as5(a2) {
  return (self) => as_4(self, a2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Take/index.mjs
var Take = class {
  constructor(exit) {
    this.exit = exit;
  }
};
function done5(self) {
  return done(self.exit);
}
function fold_7(self, end4, error, value) {
  return fold_4(self.exit, (_2) => fold_(flipCauseOption(_2), () => end4, error), value);
}
function fold11(end4, error, value) {
  return (self) => fold_7(self, end4, error, value);
}
function single3(a2) {
  return new Take(succeed4(single(a2)));
}
function chunk(as6) {
  return new Take(succeed4(as6));
}
function fail11(e2) {
  return new Take(fail5(some(e2)));
}
function failCause3(c2) {
  return new Take(failCause(map_11(c2, some)));
}
function fromPull(pull) {
  return foldCause_(pull, (_2) => fold_(flipCauseOption(_2), () => end2, halt5), chunk);
}
function halt5(c2) {
  return new Take(halt(map_11(c2, some)));
}
var end2 = /* @__PURE__ */ new Take(/* @__PURE__ */ fail5(none));

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/_internal/Emit.mjs
function toEmit(fn) {
  const ops = {
    chunk(as6) {
      return this(succeed5(as6));
    },
    die(err) {
      return this(die3(err));
    },
    dieMessage(message) {
      return this(dieMessage(message));
    },
    done(exit) {
      return this(done(mapBoth_(exit, (e2) => some(e2), (a2) => single(a2))));
    },
    end() {
      return this(fail6(none));
    },
    fail(e2) {
      return this(fail6(some(e2)));
    },
    fromEffect(io) {
      return this(mapBoth_2(io, (e2) => some(e2), (a2) => single(a2)));
    },
    fromEffectChunk(io) {
      return this(mapError_3(io, (e2) => some(e2)));
    },
    halt(cause2) {
      return this(halt2(map_11(cause2, (e2) => some(e2))));
    },
    single(a2) {
      return this(succeed5(single(a2)));
    }
  };
  return Object.assign(fn, ops);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/ensuring.mjs
function ensuring_4(self, fin) {
  return new Stream(ensuring_3(self.channel, fin));
}
function ensuring3(fin) {
  return (self) => ensuring_4(self, fin);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/effect.mjs
function effect(self) {
  return new Stream(unwrap2(fold_5(self, fail10, (x2) => write(single(x2)))));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/flatten.mjs
function flatten12(self) {
  return chain_16(self, identity);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/unwrap.mjs
function unwrap3(self) {
  return flatten12(effect(self));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/unwrapManaged.mjs
function unwrapManaged2(self) {
  return flatten12(managed(self));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/asyncInterrupt.mjs
function asyncInterrupt(register, outputBuffer = 16) {
  return unwrapManaged2(map_14(bind_2(bind_2(bind_2(do_3, "output", () => toManagedRelease_(makeBoundedQueue(outputBuffer), shutdown)), "runtime", () => runtime2()), "eitherStream", ({
    output,
    runtime: runtime3
  }) => succeed7(register(toEmit((k2) => {
    try {
      runtime3.run(chain_12(fromPull(k2), (_2) => offer_(output, _2)));
    } catch (e2) {
      if (isFiberFailure(e2)) {
        if (!interrupted(e2.cause)) {
          throw e2;
        }
      }
    }
  })))), ({
    eitherStream,
    output
  }) => fold_2(eitherStream, (canceler) => {
    const loop6 = unwrap2(fold_5(chain_12(take2(output), (_2) => done5(_2)), (maybeError) => zipRight_4(fromEffect3(shutdown(output)), fold_(maybeError, () => end(void 0), (_2) => fail10(_2))), (a2) => zipRight_4(write(a2), loop6)));
    return ensuring_4(new Stream(loop6), canceler);
  }, (value) => unwrap3(as_(shutdown(output), value)))));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/asyncMaybe.mjs
function asyncMaybe(register, outputBuffer = 16) {
  return asyncInterrupt((k2) => fromOption_(register(k2), () => unit3), outputBuffer);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/async.mjs
function async(register, outputBuffer = 16) {
  return asyncMaybe((callback) => {
    register(callback);
    return none;
  }, outputBuffer);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/asyncEffect.mjs
function asyncEffect(register, outputBuffer = 16) {
  return new Stream(unwrapManaged(map_14(tap_5(bind_2(bind_2(do_3, "output", () => toManagedRelease_(makeBoundedQueue(outputBuffer), shutdown)), "runtime", () => runtime2()), ({
    output,
    runtime: runtime3
  }) => toManaged(register(toEmit((k2) => {
    try {
      runtime3.run(chain_12(fromPull(k2), (_2) => offer_(output, _2)));
    } catch (e2) {
      if (isFiberFailure(e2)) {
        if (!interrupted(e2.cause)) {
          throw e2;
        }
      }
    }
  })))), ({
    output
  }) => {
    const loop6 = unwrap2(foldCauseM_(chain_12(take2(output), (_2) => done5(_2)), (maybeError) => {
      return as_(shutdown(output), fold_2(failureOrCause(maybeError), (l2) => fold_(l2, () => end(void 0), (failure) => fail10(failure)), (cause2) => failCause2(cause2)));
    }, (a2) => succeed5(zipRight_4(write(a2), loop6))));
    return loop6;
  })));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/fromChunk.mjs
function fromChunk(c2) {
  return new Stream(suspend7(() => isEmpty5(c2) ? unit5 : write(c2)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/empty.mjs
var empty7 = /* @__PURE__ */ fromChunk(/* @__PURE__ */ empty4());

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/branchAfter.mjs
function branchAfter_(self, n2, f2) {
  const collecting = (buf) => readWithCause((chunk2) => {
    const newBuf = concat_3(buf, chunk2);
    if (size4(newBuf) >= n2) {
      const {
        tuple: [is, is1]
      } = splitAt_(newBuf, n2);
      const pipeline = f2(is);
      return zipRight_4(pipeline(fromChunk(is1)).channel, emitting(pipeline));
    } else {
      return collecting(newBuf);
    }
  }, (_2) => failCause2(_2), (_2) => {
    if (isEmpty5(buf)) {
      return unit5;
    } else {
      const pipeline = f2(buf);
      return pipeline(empty7).channel;
    }
  });
  const emitting = (pipeline) => readWithCause((chunk2) => zipRight_4(pipeline(fromChunk(chunk2)).channel, emitting(pipeline)), (_2) => failCause2(_2), (_2) => unit5);
  return new Stream(self.channel[">>>"](collecting(empty4())));
}
function branchAfter(n2, f2) {
  return (self) => branchAfter_(self, n2, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runIntoManaged.mjs
function runIntoManaged_(self, queue) {
  const writer = readWithCause((in_2) => zipRight_4(write(chunk(in_2)), writer), (cause2) => write(halt5(cause2)), (_2) => write(end2));
  return asUnit2(runManaged(drain(mapOutEffect_(self.channel[">>>"](writer), (_2) => offer_(queue, _2)))));
}
function runIntoManaged(queue) {
  return (self) => runIntoManaged_(self, queue);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runIntoHubManaged.mjs
function runIntoHubManaged_(self, hub) {
  return runIntoManaged_(self, toQueue(hub));
}
function runIntoHubManaged(hub) {
  return (self) => runIntoHubManaged_(self, hub);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/broadcastedQueues.mjs
function broadcastedQueues_(self, n2, maximumLag) {
  return map_14(tap_5(bind_2(bind_2(do_3, "hub", () => toManaged(makeBounded2(maximumLag))), "queues", ({
    hub
  }) => collectAll4(fill(n2, () => subscribe(hub)))), ({
    hub
  }) => managedFork(runIntoHubManaged_(self, hub))), ({
    queues
  }) => queues);
}
function broadcastedQueues(n2, maximumLag) {
  return (self) => broadcastedQueues_(self, n2, maximumLag);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/flattenChunks.mjs
function flattenChunks(self) {
  return new Stream(mapOut_(self.channel, flatten5));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/flattenExitOption.mjs
function flattenExitOption(self) {
  const processChunk = (chunk2, cont) => {
    const {
      tuple: [toEmit2, rest]
    } = splitWhere_(chunk2, (_2) => !succeeded(_2));
    const next2 = fold_(head2(rest), () => cont, fold5((cause2) => fold_(flipCauseOption(cause2), () => end(void 0), (cause3) => failCause2(cause3)), () => end(void 0)));
    return zipRight_4(write(collect_2(toEmit2, fold5(() => none, (a2) => some(a2)))), next2);
  };
  const process2 = readWithCause((chunk2) => processChunk(chunk2, process2), (cause2) => failCause2(cause2), (_2) => end(void 0));
  return new Stream(self.channel[">>>"](process2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/flattenTake.mjs
function flattenTake(self) {
  return flattenChunks(flattenExitOption(map_20(self, (_2) => _2.exit)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Pull/index.mjs
function failCause4(c2) {
  return mapError_3(halt2(c2), some);
}
var end3 = /* @__PURE__ */ fail6(none);

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/unfoldChunkEffect.mjs
function unfoldChunkEffect(s2, f2) {
  const loop6 = (s3) => unwrap2(map_13(f2(s3), fold(() => end(void 0), ({
    tuple: [as6, s4]
  }) => zipRight_4(write(as6), loop6(s4)))));
  return new Stream(loop6(s2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/repeatEffectChunkOption.mjs
function repeatEffectChunkOption(fa) {
  return unfoldChunkEffect(fa, (fa2) => {
    return catchAll_2(map_13(fa2, (chunk2) => some(tuple2(chunk2, fa2))), fold(() => none3, (e2) => fail6(e2)));
  });
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/fromQueue.mjs
function fromQueue_(queue, maxChunkSize = DEFAULT_CHUNK_SIZE) {
  return repeatEffectChunkOption(catchAllCause_(map_13(takeBetween_(queue, 1, maxChunkSize), from3), (c2) => chain_12(isShutdown(queue), (down) => {
    if (down && interrupted(c2)) {
      return end3;
    } else {
      return failCause4(c2);
    }
  })));
}
function fromQueue(maxChunkSize = DEFAULT_CHUNK_SIZE) {
  return (queue) => fromQueue_(queue, maxChunkSize);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/fromQueueWithShutdown.mjs
function fromQueueWithShutdown_(queue, maxChunkSize = DEFAULT_CHUNK_SIZE) {
  return ensuring_4(fromQueue_(queue, maxChunkSize), shutdown(queue));
}
function fromQueueWithShutdown(maxChunkSize = DEFAULT_CHUNK_SIZE) {
  return (queue) => fromQueueWithShutdown_(queue, maxChunkSize);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/broadcast.mjs
function broadcast_(self, n2, maximumLag) {
  return map_14(broadcastedQueues_(self, n2, maximumLag), map5((_2) => flattenTake(fromQueueWithShutdown_(_2))));
}
function broadcast(n2, maximumLag) {
  return (self) => broadcast_(self, n2, maximumLag);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/toHub.mjs
function toHub_(self, capacity) {
  return map_14(tap_5(bind_2(do_3, "hub", () => toManagedRelease_(makeBounded2(capacity), (_2) => shutdown2(_2))), ({
    hub
  }) => managedFork(runIntoHubManaged_(self, hub))), ({
    hub
  }) => hub);
}
function toHub(capacity) {
  return (self) => toHub_(self, capacity);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/broadcastedQueuesDynamic.mjs
function broadcastedQueuesDynamic_(self, maximumLag) {
  return map_14(toHub_(self, maximumLag), (_2) => subscribe(_2));
}
function broadcastedQueuesDynamic(maximumLag) {
  return (self) => broadcastedQueuesDynamic_(self, maximumLag);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/broadcastDynamic.mjs
function broadcastDynamic_(self, maximumLag) {
  return map_14(broadcastedQueuesDynamic_(self, maximumLag), (_2) => flattenTake(chain_16(managed(_2), fromQueue())));
}
function broadcastDynamic(maximumLag) {
  return (self) => broadcastDynamic_(self, maximumLag);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runIntoElementsManaged.mjs
function runIntoElementsManaged_(self, queue) {
  const writer = () => readWith((in_2) => zipRight_4(reduce_7(in_2, unit5, (channel, a2) => zipRight_4(channel, write(succeed4(a2)))), writer()), (err) => write(fail5(some(err))), (_2) => write(fail5(none)));
  return asUnit2(runManaged(drain(mapOutEffect_(self.channel[">>>"](writer()), (_2) => offer_(queue, _2)))));
}
function runIntoElementsManaged(queue) {
  return (self) => runIntoElementsManaged_(self, queue);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/toQueueOfElements.mjs
function toQueueOfElements_(self, capacity = 2) {
  return map_14(tap_5(bind_2(do_3, "queue", () => toManagedRelease_(makeBoundedQueue(capacity), shutdown)), ({
    queue
  }) => managedFork(runIntoElementsManaged_(self, queue))), ({
    queue
  }) => queue);
}
function toQueueOfElements(capacity = 2) {
  return (self) => toQueueOfElements_(self, capacity);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/buffer.mjs
function buffer_(self, capacity) {
  const queue = toQueueOfElements_(self, capacity);
  return new Stream(managed_(queue, (queue2) => {
    const process2 = chain_15(fromEffect3(take2(queue2)), fold5((_2) => fold_(flipCauseOption(_2), () => end(void 0), (_3) => failCause2(_3)), (value) => zipRight_4(write(single(value)), process2)));
    return process2;
  }));
}
function buffer(capacity) {
  return (self) => buffer_(self, capacity);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/toQueue.mjs
function toQueue_(self, capacity = 2) {
  return map_14(tap_5(bind_2(do_3, "queue", () => toManagedRelease_(makeBoundedQueue(capacity), shutdown)), ({
    queue
  }) => managedFork(runIntoManaged_(self, queue))), ({
    queue
  }) => queue);
}
function toQueue2(capacity = 2) {
  return (self) => toQueue_(self, capacity);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/bufferChunks.mjs
function bufferChunks_(self, capacity) {
  const queue = toQueue_(self, capacity);
  return new Stream(managed_(queue, (queue2) => {
    const process2 = chain_15(fromEffect3(take2(queue2)), (take5) => fold_7(take5, end(void 0), (error) => failCause2(error), (value) => zipRight_4(write(value), process2)));
    return process2;
  }));
}
function bufferChunks(capacity) {
  return (self) => bufferChunks_(self, capacity);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/_internal/bufferSignal.mjs
function bufferSignal(managed2, channel) {
  const producer = (queue, ref) => {
    const terminate = (take5) => fromEffect3(asUnit(tap_4(tap_4(tap_4(bind_(tap_4(bind_(do_2, "latch", () => ref.get), ({
      latch
    }) => wait(latch)), "p", () => make4()), ({
      p: p2
    }) => offer_(queue, tuple2(take5, p2))), ({
      p: p2
    }) => ref.set(p2)), ({
      p: p2
    }) => wait(p2))));
    return readWith((_in2) => zipRight_4(fromEffect3(asUnit(tap_4(bind_(bind_(do_2, "p", () => make4()), "added", ({
      p: p2
    }) => offer_(queue, tuple2(chunk(_in2), p2))), ({
      added,
      p: p2
    }) => when_(ref.set(p2), () => added)))), producer(queue, ref)), (err) => terminate(fail11(err)), (_2) => terminate(end2));
  };
  const consumer = (queue) => {
    const process2 = chain_15(fromEffect3(take2(queue)), ({
      tuple: [take5, promise2]
    }) => zipRight_4(fromEffect3(succeed_(promise2, void 0)), fold_7(take5, end(void 0), (error) => failCause2(error), (value) => zipRight_4(write(value), process2))));
    return process2;
  };
  return managed_(map_14(tap_5(bind_2(tap_5(bind_2(bind_2(do_3, "queue", () => managed2), "start", () => toManaged(make4())), ({
    start
  }) => toManaged(succeed_(start, void 0))), "ref", ({
    start
  }) => makeManagedRef(start)), ({
    queue,
    ref
  }) => managedFork(runManaged(channel[">>>"](producer(queue, ref))))), ({
    queue
  }) => queue), (queue) => consumer(queue));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/bufferChunksDropping.mjs
function bufferChunksDropping_(self, capacity) {
  const queue = toManagedRelease_(makeDropping(capacity), shutdown);
  return new Stream(bufferSignal(queue, self.channel));
}
function bufferChunksDropping(capacity) {
  return (self) => bufferChunksDropping_(self, capacity);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/bufferChunksSliding.mjs
function bufferChunksSliding_(self, capacity) {
  const queue = toManagedRelease_(makeSliding(capacity), shutdown);
  return new Stream(bufferSignal(queue, self.channel));
}
function bufferChunksSliding(capacity) {
  return (self) => bufferChunksSliding_(self, capacity);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/toQueueUnbounded.mjs
function toQueueUnbounded(self) {
  return map_14(tap_5(bind_2(do_3, "queue", () => toManagedRelease_(makeUnbounded(), shutdown)), ({
    queue
  }) => managedFork(runIntoManaged_(self, queue))), ({
    queue
  }) => queue);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/bufferUnbounded.mjs
function bufferUnbounded(self) {
  const queue = toQueueUnbounded(self);
  return new Stream(managed_(queue, (queue2) => {
    const process2 = chain_15(fromEffect3(take2(queue2)), fold11(end(void 0), (error) => failCause2(error), (value) => zipRight_4(write(value), process2)));
    return process2;
  }));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/catchAllCause.mjs
function catchAllCause_4(self, f2) {
  const channel = catchAllCause_3(self.channel, (_2) => f2(_2).channel);
  return new Stream(channel);
}
function catchAllCause3(f2) {
  return (self) => catchAllCause_4(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/failCause.mjs
function failCause5(cause2) {
  return fromEffect4(halt2(cause2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/catchAll.mjs
function catchAll_5(self, f2) {
  return catchAllCause_4(self, (_2) => fold_2(failureOrCause(_2), f2, (_3) => failCause5(_3)));
}
function catchAll5(f2) {
  return (self) => catchAll_5(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/catchSome.mjs
function catchSome_3(self, pf) {
  return catchAll_5(self, (e2) => fold_(pf(e2), () => fail(e2), (_2) => _2));
}
function catchSome3(pf) {
  return (self) => catchSome_3(self, pf);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/catchSomeCause.mjs
function catchSomeCause_3(self, pf) {
  return catchAllCause_4(self, (e2) => fold_(pf(e2), () => failCause5(e2), (_2) => _2));
}
function catchSomeCause3(pf) {
  return (self) => catchSomeCause_3(self, pf);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/fail.mjs
function fail12(error) {
  return new Stream(fail10(error));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/catchTag.mjs
function catchTag2(k2, f2) {
  return (self) => catchTag_2(self, k2, f2);
}
function catchTag_2(self, k2, f2) {
  return catchAll_5(self, (e2) => {
    if ("_tag" in e2 && e2["_tag"] === k2) {
      return f2(e2);
    }
    return fail12(e2);
  });
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/chainPar.mjs
function chainPar_(self, n2, f2, bufferSize = 16) {
  return new Stream(mergeMap_(concatMap_(self.channel, (_2) => writeChunk(_2)), n2, (_2) => f2(_2).channel, bufferSize));
}
function chainPar(n2, f2, bufferSize = 16) {
  return (self) => chainPar_(self, n2, f2, bufferSize);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/chainParSwitch.mjs
function chainParSwitch_(self, f2, n2, bufferSize = 16) {
  return new Stream(mergeMap_(concatMap_(self.channel, (_2) => writeChunk(_2)), n2, (_2) => f2(_2).channel, bufferSize, "BufferSliding"));
}
function chainParSwitch(f2, n2, bufferSize = 16) {
  return (self) => chainParSwitch_(self, f2, n2, bufferSize);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/changesWith.mjs
function changesWith_(self, equal) {
  const writer = (last4) => readWithCause((chunk2) => {
    const {
      tuple: [newLast, newChunk]
    } = reduce_7(chunk2, tuple2(last4, empty4()), ({
      tuple: [op, os3]
    }, o1) => {
      if (isSome(op)) {
        if (equal.equals(op.value, o1)) {
          return tuple2(some(o1), os3);
        }
      }
      return tuple2(some(o1), append_4(os3, o1));
    });
    return zipRight_4(write(newChunk), writer(newLast));
  }, (cause2) => failCause2(cause2), (_2) => unit5);
  return new Stream(self.channel[">>>"](writer(none)));
}
function changesWith(equal) {
  return (self) => changesWith_(self, equal);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/changes.mjs
function changes(self) {
  return changesWith_(self, strict());
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/chunks.mjs
function chunks(self) {
  return mapChunks_(self, single);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/collectEffect.mjs
function collectEffect_2(self, pf) {
  return loopOnPartialChunksElements_(self, (a2, emit) => fold_(pf(a2), () => unit3, (_2) => asUnit(chain_12(_2, emit))));
}
function collectEffect2(pf) {
  return (self) => collectEffect_2(self, pf);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/collectLeft.mjs
function collectLeft(self) {
  return collect_5(self, fold2((a2) => some(a2), (_2) => none));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/collectRight.mjs
function collectRight(self) {
  return collect_5(self, fold2((_2) => none, (a2) => some(a2)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/collectSome.mjs
function collectSome(self) {
  return collect_5(self, (a2) => a2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/collectSuccess.mjs
function collectSuccess(self) {
  return collect_5(self, fold5((_2) => none, (a2) => some(a2)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/collectWhile.mjs
function collectWhile_2(self, pf) {
  const loop6 = readWith((_in2) => {
    const mapped = collectWhile_(_in2, pf);
    if (size4(mapped) === size4(_in2)) {
      return zipRight_4(write(mapped), loop6);
    } else {
      return write(mapped);
    }
  }, fail10, succeed9);
  return new Stream(self.channel[">>>"](loop6));
}
function collectWhile2(pf) {
  return (self) => collectWhile_2(self, pf);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/collectWhileEffect.mjs
function collectWhileEffect_2(self, pf) {
  return loopOnPartialChunks_(self, (chunk2, emit) => {
    const pfSome = (a2) => fold_(pf(a2), () => succeed5(false), (_2) => as_(chain_12(_2, emit), true));
    const loop6 = (chunk3) => {
      if (isEmpty5(chunk3)) {
        return succeed5(true);
      } else {
        return chain_12(pfSome(unsafeHead(chunk3)), (cont) => {
          if (cont) {
            return loop6(unsafeTail(chunk3));
          } else {
            return succeed5(false);
          }
        });
      }
    };
    return loop6(chunk2);
  });
}
function collectWhileEffect2(pf) {
  return (self) => collectWhileEffect_2(self, pf);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/collectWhileLeft.mjs
function collectWhileLeft(self) {
  return collectWhile_2(self, fold2((l2) => some(l2), (_2) => none));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/collectWhileRight.mjs
function collectWhileRight(self) {
  return collectWhile_2(self, fold2(() => none, (r2) => some(r2)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/collectWhileSome.mjs
function collectWhileSome(self) {
  return collectWhile_2(self, identity);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/collectWhileSuccess.mjs
function collectWhileSuccess(self) {
  return collectWhile_2(self, fold5(() => none, (r2) => some(r2)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/unfoldEffect.mjs
function unfoldEffect2(s2, f2) {
  return unfoldChunkEffect(s2, (_2) => map_13(f2(_2), map(({
    tuple: [a2, s3]
  }) => tuple2(single(a2), s3))));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/combine.mjs
function combine_(self, that, s2, f2) {
  const producer = (handoff, latch) => zipRight_4(fromEffect3(take3(latch)), readWithCause((value) => zipRight_4(fromEffect3(offer(handoff, succeed4(value))), producer(handoff, latch)), (cause2) => fromEffect3(offer(handoff, failCause(map_11(cause2, some)))), (_2) => zipRight_4(fromEffect3(offer(handoff, fail5(none))), producer(handoff, latch))));
  return new Stream(managed_(map_14(tap_5(tap_5(bind_2(bind_2(bind_2(bind_2(do_3, "left", () => toManaged(make10())), "right", () => toManaged(make10())), "latchL", () => toManaged(make10())), "latchR", () => toManaged(make10())), ({
    latchL,
    left: left4
  }) => managedFork(runManaged(concatMap_(self.channel, (_2) => writeChunk(_2))[">>>"](producer(left4, latchL))))), ({
    latchR,
    right: right5
  }) => managedFork(runManaged(concatMap_(that.channel, (_2) => writeChunk(_2))[">>>"](producer(right5, latchR))))), ({
    latchL,
    latchR,
    left: left4,
    right: right5
  }) => tuple2(left4, right5, latchL, latchR)), ({
    tuple: [left4, right5, latchL, latchR]
  }) => {
    const pullLeft = zipRight_2(offer(latchL, void 0), chain_12(take3(left4), done));
    const pullRight = zipRight_2(offer(latchR, void 0), chain_12(take3(right5), done));
    return unfoldEffect2(s2, (s3) => chain_12(f2(s3, pullLeft, pullRight), (_2) => unoption(done(_2)))).channel;
  }));
}
function combine2(that, s2, f2) {
  return (self) => combine_(self, that, s2, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/combineChunks.mjs
function combineChunks_(self, that, s2, f2) {
  const producer = (handoff, latch) => zipRight_4(fromEffect3(take3(latch)), readWithCause((chunk2) => zipRight_4(fromEffect3(offer(handoff, chunk(chunk2))), producer(handoff, latch)), (cause2) => fromEffect3(offer(handoff, failCause3(cause2))), (_2) => zipRight_4(fromEffect3(offer(handoff, end2)), producer(handoff, latch))));
  return new Stream(managed_(map_14(tap_5(tap_5(bind_2(bind_2(bind_2(bind_2(do_3, "left", () => toManaged(make10())), "right", () => toManaged(make10())), "latchL", () => toManaged(make10())), "latchR", () => toManaged(make10())), ({
    latchL,
    left: left4
  }) => managedFork(runManaged(self.channel[">>>"](producer(left4, latchL))))), ({
    latchR,
    right: right5
  }) => managedFork(runManaged(that.channel[">>>"](producer(right5, latchR))))), ({
    latchL,
    latchR,
    left: left4,
    right: right5
  }) => tuple2(left4, right5, latchL, latchR)), ({
    tuple: [left4, right5, latchL, latchR]
  }) => {
    const pullLeft = zipRight_2(offer(latchL, void 0), chain_12(take3(left4), done5));
    const pullRight = zipRight_2(offer(latchR, void 0), chain_12(take3(right5), done5));
    return unfoldChunkEffect(s2, (s3) => chain_12(f2(s3, pullLeft, pullRight), (_2) => unoption(done(_2)))).channel;
  }));
}
function combineChunks(that, s2, f2) {
  return (self) => combineChunks_(self, that, s2, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/concat.mjs
function concat_4(self, that) {
  return new Stream(zipRight_4(self.channel, that.channel));
}
function concat3(that) {
  return (self) => concat_4(self, that);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/concatAll.mjs
function concatAll(streams) {
  return reduce_7(streams, empty7, (a2, b2) => concat_4(a2, b2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/crossLeft.mjs
function crossLeft_(self, that) {
  return map_20(cross_(self, that), get(0));
}
function crossLeft(that) {
  return (self) => crossLeft_(self, that);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/debounce.mjs
var NotStartedTypeId = /* @__PURE__ */ Symbol();
var NotStarted = class {
  constructor() {
    this._typeId = NotStartedTypeId;
  }
};
var PreviousTypeId = /* @__PURE__ */ Symbol();
var Previous = class {
  constructor(fiber) {
    this.fiber = fiber;
    this._typeId = PreviousTypeId;
  }
};
var CurrentTypeId = /* @__PURE__ */ Symbol();
var Current = class {
  constructor(fiber) {
    this.fiber = fiber;
    this._typeId = CurrentTypeId;
  }
};
function debounce_(self, d2) {
  return unwrap3(map_13(bind_(bind_(do_2, "scope", () => forkScope), "handoff", () => make10()), ({
    handoff,
    scope: scope3
  }) => {
    const enqueue = (last4) => map_13(bind_(do_2, "f", () => forkIn_(as_(sleep(d2), last4), scope3)), ({
      f: f2
    }) => consumer(new Previous(f2)));
    const producer = readWithCause((in_2) => fold_(last2(in_2), () => producer, (last4) => zipRight_4(fromEffect3(offer(handoff, new Emit2(single(last4)))), producer)), (cause2) => fromEffect3(offer(handoff, new Halt2(cause2))), (_2) => fromEffect3(offer(handoff, new End(new UpstreamEnd()))));
    const consumer = (state) => unwrap2((() => {
      switch (state._typeId) {
        case NotStartedTypeId:
          return map_13(take3(handoff), (sig) => {
            switch (sig._typeId) {
              case EmitTypeId3:
                return unwrap2(enqueue(sig.els));
              case HaltTypeId2:
                return failCause2(sig.error);
              case EndTypeId:
                return unit5;
            }
          });
        case CurrentTypeId:
          return map_13(join(state.fiber), (sig) => {
            switch (sig._typeId) {
              case EmitTypeId3:
                return unwrap2(enqueue(sig.els));
              case HaltTypeId2:
                return failCause2(sig.error);
              case EndTypeId:
                return unit5;
            }
          });
        case PreviousTypeId:
          return raceWith_(join(state.fiber), take3(handoff), (ex, current) => {
            if (succeeded(ex)) {
              return succeed5(zipRight_4(write(ex.value), consumer(new Current(current))));
            } else {
              return as_(interrupt4(current), failCause2(ex.cause));
            }
          }, (ex, previous) => {
            if (succeeded(ex)) {
              const sig = ex.value;
              switch (sig._typeId) {
                case EmitTypeId3:
                  return zipRight_2(interrupt4(previous), enqueue(sig.els));
                case HaltTypeId2:
                  return as_(interrupt4(previous), failCause2(sig.error));
                case EndTypeId:
                  return map_13(join(previous), (_2) => zipRight_4(write(_2), unit5));
              }
            } else {
              return as_(interrupt4(previous), failCause2(ex.cause));
            }
          });
      }
    })());
    return crossRight_(managed(managedFork(runManaged(self.channel[">>>"](producer)))), new Stream(consumer(new NotStarted())));
  }));
}
function debounce(d2) {
  return (self) => debounce_(self, d2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/defaultIfEmpty.mjs
function defaultIfEmptyStream(self, stream) {
  const writer = () => readWith((in_2) => isEmpty5(in_2) ? writer() : zipRight_4(write(in_2), identity3()), (e2) => fail10(e2), (_2) => stream.channel);
  return new Stream(self.channel[">>>"](writer()));
}
function defaultIfEmptyChunk(self, chunk2) {
  return defaultIfEmptyStream(self, new Stream(write(chunk2)));
}
function defaultIfEmptyValue(self, a2) {
  return defaultIfEmptyChunk(self, single(a2));
}
function defaultIfEmpty_(self, emptyValue) {
  if (isChunk(emptyValue)) {
    return defaultIfEmptyChunk(self, emptyValue);
  }
  if (isStream(emptyValue)) {
    return defaultIfEmptyStream(self, emptyValue);
  }
  return defaultIfEmptyValue(self, emptyValue);
}
function defaultIfEmpty(emptyValue) {
  return (self) => defaultIfEmpty_(self, emptyValue);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/die.mjs
function die6(u2) {
  return new Stream(die5(u2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/dieMessage.mjs
function dieMessage3(msg) {
  return fromEffect4(dieMessage(msg));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/dieWith.mjs
function dieWith4(u2) {
  return new Stream(dieWith3(u2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/core.mjs
var Sink = class {
  constructor(channel) {
    this.channel = channel;
  }
};

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/map.mjs
function map_21(self, f2) {
  return new Sink(map_19(self.channel, f2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/foldSink.mjs
function foldSink_(self, failure, success) {
  return new Sink(foldChannel_(doneCollect(self.channel), (_2) => failure(_2).channel, ({
    tuple: [leftovers, z2]
  }) => suspend7(() => {
    const leftoversRef = new AtomicReference(filter_3(leftovers, (a2) => !isEmpty5(a2)));
    const refReader = chain_15(succeedWith5(() => leftoversRef.getAndSet(empty4())), (chunk2) => writeChunk(chunk2));
    const passthrough = identity3();
    const continationSink = zipRight_4(refReader, passthrough)[">>>"](success(z2).channel);
    return chain_15(doneCollect(continationSink), ({
      tuple: [newLeftovers, z1]
    }) => zipRight_4(chain_15(succeedWith5(() => leftoversRef.get), (_2) => writeChunk(_2)), as_3(writeChunk(newLeftovers), z1)));
  })));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/chain.mjs
function chain_17(self, f2) {
  return foldSink_(self, (_2) => fail(_2), f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/collectAll.mjs
function collectLoop(state) {
  return readWithCause((i2) => collectLoop(concat_3(state, i2)), failCause2, (_2) => end(state));
}
function collectAll5() {
  return new Sink(collectLoop(empty4()));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/fold.mjs
function fold12(z2, contFn, f2) {
  const foldChunkSplit = (z3, chunk2, contFn2, f3) => {
    const fold13 = (s2, chunk3, idx, len) => {
      if (idx === len) {
        return tuple2(s2, empty4());
      } else {
        const s1 = f3(s2, unsafeGet_2(chunk3, idx));
        if (contFn2(s1)) {
          return fold13(s1, chunk3, idx + 1, len);
        } else {
          return tuple2(s1, drop_2(chunk3, idx + 1));
        }
      }
    };
    return fold13(z3, chunk2, 0, size4(chunk2));
  };
  const reader = (s2) => {
    if (!contFn(s2)) {
      return end(s2);
    }
    return readWith((in_2) => {
      const {
        tuple: [nextS, leftovers]
      } = foldChunkSplit(s2, in_2, contFn, f2);
      if (!isEmpty5(leftovers)) {
        return as_3(write(leftovers), nextS);
      } else {
        return reader(nextS);
      }
    }, (err) => fail10(err), (_2) => end(s2));
  };
  return new Sink(reader(z2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/foldUntil.mjs
function foldUntil(z2, max2, f2) {
  return map_21(fold12(tuple2(z2, 0), (_2) => get_(_2, 1) < max2, ({
    tuple: [o2, count2]
  }, i2) => tuple2(f2(o2, i2), count2 + 1)), get(0));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/fromEffect.mjs
function fromEffect5(b2) {
  return new Sink(fromEffect3(b2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/collectAllN.mjs
function collectAllN(n2) {
  return map_21(chain_17(fromEffect5(succeedWith3(() => builder())), (cb) => foldUntil(cb, n2, (s2, in_2) => s2.append(in_2))), (_2) => _2.build());
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/dropLeftover.mjs
function dropLeftover(self) {
  return new Sink(drain(self.channel));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/foldLeft.mjs
function foldLeft(z2, f2) {
  return dropLeftover(fold12(z2, (_2) => true, f2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/count.mjs
function count() {
  return foldLeft(0, (s2, _2) => s2 + 1);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/drain.mjs
function drain2() {
  const drain4 = readWithCause((_2) => drain4, failCause2, (_2) => unit5);
  return new Sink(drain4);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/dropWhile.mjs
function dropWhile3(p2) {
  const loop6 = readWith((in_2) => {
    const leftover = dropWhile_2(in_2, p2);
    const more = isEmpty5(leftover);
    return more ? loop6 : zipRight_4(write(leftover), identity3());
  }, (_2) => fail10(_2), (_2) => unit5);
  return new Sink(loop6);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/dropWhileEffect.mjs
function dropWhileEffect2(p2) {
  const loop6 = readWith((in_2) => unwrap2(map_13(dropWhileEffect_(in_2, p2), (leftover) => {
    const more = isEmpty5(leftover);
    return more ? loop6 : zipRight_4(write(leftover), identity3());
  })), (_2) => fail10(_2), (_2) => unit5);
  return new Sink(loop6);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/exposeLeftover.mjs
function exposeLeftover(self) {
  return new Sink(map_19(doneCollect(self.channel), ({
    tuple: [chunks2, z2]
  }) => tuple2(z2, flatten5(chunks2))));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/fail.mjs
function fail13(e2) {
  return new Sink(fail10(e2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/forEach.mjs
function forEach6(f2) {
  const process2 = readWithCause((in_2) => zipRight_4(fromEffect3(forEachUnit_(in_2, f2)), process2), (halt6) => failCause2(halt6), (_2) => end(void 0));
  return new Sink(process2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/forEachChunk.mjs
function forEachChunk(f2) {
  const process2 = readWithCause((in_2) => zipRight_4(fromEffect3(f2(in_2)), process2), (halt6) => failCause2(halt6), (_2) => end(void 0));
  return new Sink(process2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/forEachWhile.mjs
function forEachWhile(f2) {
  const go = (chunk2, idx, len, cont) => {
    if (idx === len) {
      return cont;
    } else {
      return catchAll_4(chain_15(fromEffect3(f2(unsafeGet_2(chunk2, idx))), (b2) => {
        if (b2) {
          return go(chunk2, idx + 1, len, cont);
        } else {
          return write(drop_2(chunk2, idx));
        }
      }), (e2) => zipRight_4(write(drop_2(chunk2, idx)), fail10(e2)));
    }
  };
  const process2 = readWithCause((_in2) => go(_in2, 0, size4(_in2), process2), (halt6) => failCause2(halt6), (_2) => end(void 0));
  return new Sink(process2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/head.mjs
function head5() {
  return fold12(none, isNone, (s2, in_2) => fold_(s2, () => some(in_2), (_2) => s2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/last.mjs
function last3() {
  return foldLeft(none, (_2, in_2) => some(in_2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/reduce.mjs
function reduce7(z2, cont, f2) {
  const reduceChunkSplit = (z3, chunk2) => (cont2) => (f3) => {
    const reduce8 = (s2, chunk3, idx, len) => {
      if (idx === len) {
        return tuple2(s2, empty4());
      } else {
        const s1 = f3(s2, unsafeGet_2(chunk3, idx));
        if (cont2(s1)) {
          return reduce8(s1, chunk3, idx + 1, len);
        } else {
          return tuple2(s1, drop_2(chunk3, idx + 1));
        }
      }
    };
    return reduce8(z3, chunk2, 0, size4(chunk2));
  };
  const reader = (s2) => {
    if (!cont(s2)) {
      return end(s2);
    } else {
      return readWith((_in2) => {
        const {
          tuple: [nextS, leftovers]
        } = reduceChunkSplit(s2, _in2)(cont)(f2);
        if (!isEmpty5(leftovers)) {
          return as_3(write(leftovers), nextS);
        } else {
          return reader(nextS);
        }
      }, (err) => fail10(err), (_2) => end(s2));
    }
  };
  return new Sink(reader(z2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/reduceEffect.mjs
function reduceEffect2(z2, cont, f2) {
  const reduceChunkSplit = (z3, chunk2) => (cont2) => (f3) => {
    const reduce8 = (s2, chunk3, idx, len) => {
      if (idx === len) {
        return succeed5(tuple2(s2, none));
      } else {
        return chain_12(f3(s2, unsafeGet_2(chunk3, idx)), (s1) => {
          if (cont2(s1)) {
            return reduce8(s1, chunk3, idx + 1, len);
          } else {
            return succeed5(tuple2(s1, some(drop_2(chunk3, idx + 1))));
          }
        });
      }
    };
    return reduce8(z3, chunk2, 0, size4(chunk2));
  };
  const reader = (s2) => {
    if (!cont(s2)) {
      return end(s2);
    } else {
      return readWith((_in2) => {
        return chain_15(fromEffect3(reduceChunkSplit(s2, _in2)(cont)(f2)), ({
          tuple: [nextS, leftovers]
        }) => {
          return fold_(leftovers, () => reader(nextS), (l2) => as_3(write(l2), nextS));
        });
      }, (err) => fail10(err), (_2) => end(s2));
    }
  };
  return new Sink(reader(z2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/sum.mjs
function sum2() {
  return foldLeft(0, (a2, b2) => a2 + b2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/zipWith.mjs
function zipWith_8(self, that, f2) {
  return chain_17(self, (z2) => map_21(that, (_2) => f2(z2, _2)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/Sink/zipRight.mjs
function zipRight_5(self, that) {
  return zipWith_8(self, that, (_2, z1) => z1);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runManaged.mjs
function runManaged_(self, sink) {
  return runManaged(drain(pipeTo_(self.channel, sink.channel)));
}
function runManaged2(sink) {
  return (self) => runManaged_(self, sink);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runForEachManaged.mjs
function runForEachManaged_(self, f2) {
  return runManaged_(self, forEach6(f2));
}
function runForEachManaged(f2) {
  return (self) => runForEachManaged_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/distributedWithDynamic.mjs
var distributedWithDynamicId = /* @__PURE__ */ new AtomicNumber(0);
function distributedWithDynamic_(self, maximumLag, decide, done7) {
  return map_14(bind_2(bind_2(do_3, "queuesRef", () => toManagedRelease_(makeRef(make()), (_2) => chain_12(get4(_2), (qs) => forEach_5(values(qs), (_3) => shutdown(_3))))), "add", ({
    queuesRef
  }) => {
    const offer2 = (a2) => asUnit(tap_4(bind_(bind_(do_2, "shouldProcess", () => decide(a2)), "queues", () => get4(queuesRef)), ({
      queues,
      shouldProcess
    }) => chain_12(reduce_6(queues, empty2(), (acc, [id, queue]) => {
      if (shouldProcess(id)) {
        return foldCauseM_(offer_(queue, succeed4(a2)), (c2) => interrupted(c2) ? succeed5(prepend_2(acc, id)) : halt2(c2), (_2) => succeed5(acc));
      } else {
        return succeed5(acc);
      }
    }), (ids) => isEmpty3(ids) ? unit3 : update_3(queuesRef, removeMany(ids)))));
    return map_14(tap_5(let_3(bind_2(bind_2(do_3, "queuesLock", () => toManaged(makeSemaphore(1))), "newQueue", () => toManaged(makeRef(map_13(tap_4(bind_(bind_(do_2, "queue", () => makeBoundedQueue(maximumLag)), "id", () => succeedWith3(() => distributedWithDynamicId.incrementAndGet())), ({
      id,
      queue
    }) => update_3(queuesRef, set(id, queue))), ({
      id,
      queue
    }) => tuple2(id, queue))))), "finalize", ({
      newQueue,
      queuesLock
    }) => (endTake) => withPermit_(asUnit(tap_4(tap_4(bind_(tap_4(do_2, () => set_2(newQueue, map_13(tap_4(bind_(tap_4(bind_(do_2, "queue", () => makeBoundedQueue(1)), ({
      queue
    }) => offer_(queue, endTake)), "id", () => succeedWith3(() => distributedWithDynamicId.incrementAndGet())), ({
      id,
      queue
    }) => update_3(queuesRef, set(id, queue))), ({
      id,
      queue
    }) => tuple2(id, queue)))), "queues", () => map_13(get4(queuesRef), values)), ({
      queues
    }) => forEach_5(queues, (queue) => catchSomeCause_(offer_(queue, endTake), (c2) => {
      if (interrupted(c2)) {
        return some(unit3);
      } else {
        return none;
      }
    }))), (_2) => done7(endTake))), queuesLock)), ({
      finalize
    }) => managedFork(foldCauseM_2(runForEachManaged_(self, offer2), (cause2) => toManaged(finalize(halt(map_11(cause2, some)))), (_2) => toManaged(finalize(fail5(none)))))), ({
      newQueue,
      queuesLock
    }) => withPermit_(flatten8(get4(newQueue)), queuesLock));
  }), ({
    add: add3
  }) => add3);
}
function distributedWithDynamic(maximumLag, decide, done7) {
  return (self) => distributedWithDynamic_(self, maximumLag, decide, done7);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/distributedWith.mjs
function distributedWith_(self, n2, maximumLag, decide) {
  return chain_13(toManaged(make4()), (prom) => {
    return chain_13(distributedWithDynamic_(self, maximumLag, (a2) => chain_12(wait(prom), (_2) => _2(a2)), (_2) => unit3), (next2) => toManaged(chain_12(collectAll2(map_8(range2(0, n2 - 1), (id) => map_13(next2, ({
      tuple: [key, queue]
    }) => tuple2(tuple2(key, id), queue)))), (entries) => {
      const {
        tuple: [mappings, queues]
      } = reduceRight_5(entries, tuple2(make(), empty2()), ({
        tuple: [mapping, queue]
      }, {
        tuple: [mappings2, queues2]
      }) => tuple2(set_(mappings2, get_(mapping, 0), get_(mapping, 1)), prepend_2(queues2, queue)));
      return as_(succeed_(prom, (a2) => map_13(decide(a2), (f2) => (key) => f2(unsafeGet_(mappings, key)))), queues);
    })));
  });
}
function distributedWith(n2, maximumLag, decide) {
  return (self) => distributedWith_(self, n2, maximumLag, decide);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/done.mjs
function done6(exit) {
  return fromEffect4(done(exit));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/drain.mjs
function drain3(self) {
  return new Stream(drain(self.channel));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/interruptWhenP.mjs
function interruptWhenP_2(self, p2) {
  return new Stream(interruptWhenP_(self.channel, p2));
}
function interruptWhenP(p2) {
  return (self) => interruptWhenP_2(self, p2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/drainFork.mjs
function drainFork_(self, other) {
  return chain_16(fromEffect4(make4()), (bgDied) => crossRight_(managed(managedFork(catchAllCause_2(runForEachManaged_(other, (_2) => unit3), (_2) => toManaged(halt_(bgDied, _2))))), interruptWhenP_2(self, bgDied)));
}
function drainFork(other) {
  return (self) => drainFork_(self, other);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/drop.mjs
function drop_3(self, n2) {
  const loop6 = (r2) => readWith((_in2) => {
    const dropped = drop_2(_in2, r2);
    const leftover = Math.max(r2 - size4(_in2), 0);
    const more = isEmpty5(_in2) || leftover > 0;
    if (more) {
      return loop6(leftover);
    } else {
      return zipRight_4(write(dropped), identity3());
    }
  }, (e2) => fail10(e2), (_2) => unit5);
  return new Stream(self.channel[">>>"](loop6(n2)));
}
function drop2(n2) {
  return (self) => drop_3(self, n2);
}

// node_modules/@effect-ts/system/_mjs/Support/RingBufferNew/index.mjs
var RingBufferNew = class {
  constructor(capacity) {
    this.capacity = capacity;
    this.size = 0;
    this.current = 0;
    this.array = Array.from({
      length: capacity
    }, (_2) => null);
  }
  head() {
    return fromNullable(this.array[this.current]);
  }
  lastorNull() {
    var _a12;
    if (this.size === 0) {
      return null;
    }
    const index = this.current === 0 ? this.array.length - 1 : this.current - 1;
    return (_a12 = this.array[index]) !== null && _a12 !== void 0 ? _a12 : null;
  }
  put(value) {
    this.array[this.current] = value;
    this.increment();
  }
  dropLast() {
    if (this.size > 0) {
      this.decrement();
      this.array[this.current] = null;
    }
  }
  toChunk() {
    const begin = this.current - this.size;
    const newArray = begin < 0 ? this.array.slice(this.capacity + begin, this.capacity).concat(this.array.slice(0, this.current)) : this.array.slice(begin, this.current);
    return from3(newArray);
  }
  increment() {
    if (this.size < this.capacity) {
      this.size += 1;
    }
    this.current = (this.current + 1) % this.capacity;
  }
  decrement() {
    this.size -= 1;
    if (this.current > 0) {
      this.current -= 1;
    } else {
      this.current = this.capacity - 1;
    }
  }
};

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/fromChunkWith.mjs
function fromChunkWith(c2) {
  return new Stream(unwrap2(succeedWith3(() => writeWith(c2))));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/succeedWith.mjs
function succeedWith6(o2) {
  return fromChunkWith(() => single(o2()));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/dropRight.mjs
function dropRight_2(self, n2) {
  if (n2 <= 0) {
    return new Stream(self.channel);
  }
  return chain_16(succeedWith6(() => new RingBufferNew(n2)), (queue) => {
    const reader = readWith((in_2) => {
      const outs = collect_2(in_2, (elem3) => {
        const head6 = queue.head();
        queue.put(elem3);
        return head6;
      });
      return zipRight_4(write(outs), reader);
    }, (_2) => fail10(_2), (_2) => unit5);
    return new Stream(self.channel[">>>"](reader));
  });
}
function dropRight2(n2) {
  return (self) => dropRight_2(self, n2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/pipeThrough.mjs
function pipeThrough(self, sink) {
  return new Stream(self.channel[">>>"](sink.channel));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/dropWhile.mjs
function dropWhile_3(self, f2) {
  return pipeThrough(self, dropWhile3(f2));
}
function dropWhile4(f2) {
  return (self) => dropWhile_3(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/dropUntil.mjs
function dropUntil_(self, f2) {
  return drop_3(dropWhile_3(self, (_2) => !f2(_2)), 1);
}
function dropUntil(f2) {
  return (self) => dropUntil_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/dropWhileEffect.mjs
function dropWhileEffect_2(self, f2) {
  return pipeThrough(self, dropWhileEffect2(f2));
}
function dropWhileEffect3(f2) {
  return (self) => dropWhileEffect_2(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/effectOption.mjs
function effectOption(self) {
  return new Stream(unwrap2(fold_5(self, fold(() => unit5, fail10), (x2) => write(single(x2)))));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/succeed.mjs
function succeed10(o2) {
  return fromChunk(single(o2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/either.mjs
function either4(self) {
  return catchAll_5(map_20(self, right), (e2) => succeed10(left(e2)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/execute.mjs
function execute(effect2) {
  return drain3(fromEffect4(effect2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/failWith.mjs
function failWith4(error) {
  return new Stream(failWith3(error));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/filter.mjs
function filter_8(self, f2) {
  return mapChunks_(self, filter2(f2));
}
function filter5(f2) {
  return (self) => filter_8(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/filterEffect.mjs
function filterEffect_2(self, f2) {
  return loopOnPartialChunksElements_(self, (a2, emit) => chain_12(f2(a2), (r2) => r2 ? emit(a2) : unit3));
}
function filterEffect2(f2) {
  return (self) => filterEffect_2(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/filterNot.mjs
function filterNot_2(self, pred) {
  return filter_8(self, (a2) => !pred(a2));
}
function filterNot2(pred) {
  return (self) => filterNot_2(self, pred);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/find.mjs
function find_3(self, f2) {
  const loop6 = readWith((in_2) => fold_(find_2(in_2, f2), () => loop6, (i2) => write(single(i2))), (e2) => fail10(e2), (_2) => unit5);
  return new Stream(self.channel[">>>"](loop6));
}
function find3(f2) {
  return (self) => find_3(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/findEffect.mjs
function findEffect_2(self, f2) {
  const loop6 = readWith((in_2) => unwrap2(map_13(findEffect_(in_2, f2), fold(() => loop6, (i2) => write(single(i2))))), (e2) => fail10(e2), (_2) => unit5);
  return new Stream(self.channel[">>>"](loop6));
}
function findEffect2(f2) {
  return (self) => findEffect_2(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/scheduleWith.mjs
function scheduleWith_(self, schedule2, f2, g2) {
  const loop6 = (driver2, chunk2, index) => {
    if (index < size4(chunk2)) {
      return unwrap2(suspend4(() => {
        const a2 = unsafeGet_2(chunk2, index);
        return foldM_2(driver2.next(a2), () => zipLeft_(map_13(orDie(driver2.last), (b2) => zipRight_4(write(make3(f2(a2), g2(b2))), loop6(driver2, chunk2, index + 1))), driver2.reset), () => succeed5(zipRight_4(write(single(f2(a2))), loop6(driver2, chunk2, index + 1))));
      }));
    } else {
      return readWithCause((chunk3) => loop6(driver2, chunk3, 0), (_2) => failCause2(_2), (_2) => end(_2));
    }
  };
  return new Stream(chain_15(fromEffect3(driver(schedule2)), (_2) => self.channel[">>>"](loop6(_2, empty4(), 0))));
}
function scheduleWith(schedule2, f2, g2) {
  return (self) => scheduleWith_(self, schedule2, f2, g2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/scheduleEither.mjs
function scheduleEither_(self, schedule2) {
  return scheduleWith_(self, schedule2, (r2) => right(r2), (l2) => left(l2));
}
function scheduleEither(schedule2) {
  return (self) => scheduleEither_(self, schedule2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/schedule.mjs
function schedule_(self, schedule2) {
  return collect_5(scheduleEither_(self, schedule2), fold2((_2) => none, (r2) => some(r2)));
}
function schedule(schedule2) {
  return (self) => schedule_(self, schedule2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/fixed.mjs
function fixed_(self, duration) {
  return schedule_(self, fixed(duration));
}
function fixed2(duration) {
  return (self) => fixed_(self, duration);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/flattenExit.mjs
function flattenExit(self) {
  return mapEffect_3(self, (a2) => done(a2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/flattenIterables.mjs
function flattenIterables(self) {
  return flattenChunks(map_20(self, (a2) => from3(a2)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/flattenPar.mjs
function flattenPar_(self, n2, outputBuffer = 16) {
  return chainPar_(self, n2, identity, outputBuffer);
}
function flattenPar(n2, outputBuffer = 16) {
  return (self) => flattenPar_(self, n2, outputBuffer);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/flattenParUnbounded.mjs
function flattenParUnbounded_(self, outputBuffer = 16) {
  return flattenPar_(self, Number.MAX_SAFE_INTEGER, outputBuffer);
}
function flattenParUnbounded(outputBuffer = 16) {
  return (self) => flattenParUnbounded_(self, outputBuffer);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/run.mjs
function run_2(self, sink) {
  return runDrain(self.channel[">>>"](sink.channel));
}
function run6(sink) {
  return (self) => run_2(self, sink);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runForEach.mjs
function runForEach_(self, f2) {
  return run_2(self, forEach6(f2));
}
function runForEach(f2) {
  return (self) => runForEach_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/forEach.mjs
function forEach_8(self, f2) {
  return runForEach_(self, f2);
}
function forEach7(f2) {
  return (self) => forEach_8(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/forever.mjs
function forever3(self) {
  return new Stream(repeated(self.channel));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/fromChunkQueue.mjs
function fromChunkQueue(queue) {
  return repeatEffectChunkOption(catchAllCause_(take2(queue), (c2) => chain_12(isShutdown(queue), (down) => {
    if (down && interrupted(c2)) {
      return end3;
    } else {
      return failCause4(c2);
    }
  })));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/fromChunkHub.mjs
function fromChunkHub(hub) {
  return chain_16(managed(subscribe(hub)), (queue) => fromChunkQueue(queue));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/fromChunkHubManaged.mjs
function fromChunkHubManaged(hub) {
  return map_14(subscribe(hub), (queue) => fromChunkQueue(queue));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/fromChunkHubManagedWithShutdown.mjs
function fromChunkHubManagedWithShutdown(hub) {
  return map_14(fromChunkHubManaged(hub), ensuring3(shutdown2(hub)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/fromChunkHubWithShutdown.mjs
function fromChunkHubWithShutdown(hub) {
  return ensuring_4(fromChunkHub(hub), shutdown2(hub));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/fromChunkQueueWithShutdown.mjs
function fromChunkQueueWithShutdown(queue) {
  return ensuring_4(fromChunkQueue(queue), shutdown(queue));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/fromIterable.mjs
function fromIterable(as6) {
  return fromChunk(from3(as6));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/fromChunks.mjs
function fromChunks(...chunks2) {
  return chain_16(fromIterable(chunks2), (_2) => fromChunk(_2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/fromHub.mjs
function fromHub_(hub, maxChunkSize = DEFAULT_CHUNK_SIZE) {
  return chain_16(managed(subscribe(hub)), (queue) => fromQueue_(queue, maxChunkSize));
}
function fromHub(maxChunkSize = DEFAULT_CHUNK_SIZE) {
  return (hub) => fromHub_(hub, maxChunkSize);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/fromHubManaged.mjs
function fromHubManaged_(hub, maxChunkSize = DEFAULT_CHUNK_SIZE) {
  return map_14(subscribe(hub), fromQueueWithShutdown(maxChunkSize));
}
function fromHubManaged(maxChunkSize = DEFAULT_CHUNK_SIZE) {
  return (hub) => fromHubManaged_(hub, maxChunkSize);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/fromHubManagedWithShutdown.mjs
function fromHubManagedWithShutdown_(hub, maxChunkSize = DEFAULT_CHUNK_SIZE) {
  return map_14(fromHubManaged_(hub, maxChunkSize), ensuring3(shutdown2(hub)));
}
function fromHubManagedWithShutdown(maxChunkSize = DEFAULT_CHUNK_SIZE) {
  return (hub) => fromHubManagedWithShutdown_(hub, maxChunkSize);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/fromHubWithShutdown.mjs
function fromHubWithShutdown_(hub, maxChunkSize = DEFAULT_CHUNK_SIZE) {
  return ensuring_4(fromHub_(hub, maxChunkSize), shutdown2(hub));
}
function fromHubWithShutdown(maxChunkSize = DEFAULT_CHUNK_SIZE) {
  return (hub) => fromHubWithShutdown_(hub, maxChunkSize);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/mapConcatChunk.mjs
function mapConcatChunk_(self, f2) {
  return mapChunks_(self, chain4(f2));
}
function mapConcatChunk(f2) {
  return (self) => mapConcatChunk_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/mapConcat.mjs
function mapConcat_(self, f2) {
  return mapConcatChunk_(self, (a2) => from3(f2(a2)));
}
function mapConcat(f2) {
  return (self) => mapConcat_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/fromIterableEffect.mjs
function fromIterableEffect(iterable) {
  return mapConcat_(fromEffect4(iterable), identity);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/fromPull.mjs
function fromPull2(io) {
  return unwrapManaged2(map_14(io, (pull) => repeatEffectChunkOption(pull)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/repeatEffectOption.mjs
function repeatEffectOption(fa) {
  return repeatEffectChunkOption(map_13(fa, single));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/fromSchedule.mjs
function fromSchedule(schedule2) {
  return unwrap3(map_13(driver(schedule2), (driver2) => repeatEffectOption(driver2.next(void 0))));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/groupAdjacentBy.mjs
function groupAdjacentBy_(self, f2) {
  const go = (in_2, state) => reduce_7(in_2, tuple2(empty4(), state), ({
    tuple: [os3, o2]
  }, a2) => fold_(o2, () => tuple2(os3, some(tuple2(f2(a2), single(a2)))), (agg) => {
    const k2 = f2(a2);
    const {
      tuple: [k3, aggregated]
    } = agg;
    if (k3 === k2) {
      return tuple2(os3, some(tuple2(k3, append_4(aggregated, a2))));
    } else {
      return tuple2(append_4(os3, agg), some(tuple2(k2, single(a2))));
    }
  }));
  const chunkAdjacent = (buffer2) => readWithCause((chunk2) => {
    const {
      tuple: [outputs, newBuffer]
    } = go(chunk2, buffer2);
    return zipRight_4(write(outputs), chunkAdjacent(newBuffer));
  }, (_2) => failCause2(_2), (_2) => fold_(buffer2, () => unit5, (o2) => write(single(o2))));
  return new Stream(self.channel[">>>"](chunkAdjacent(none)));
}
function groupAdjacentBy(f2) {
  return (self) => groupAdjacentBy_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/mapAccum.mjs
function mapAccum_2(self, s2, f2) {
  const accumulator = (currS) => readWith((in_2) => {
    const {
      tuple: [nextS, a2s]
    } = mapAccum_(in_2, currS, f2);
    return zipRight_4(write(a2s), accumulator(nextS));
  }, (err) => fail10(err), (_2) => unit5);
  return new Stream(self.channel[">>>"](accumulator(s2)));
}
function mapAccum2(s2, f2) {
  return (self) => mapAccum_2(self, s2, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/zipWithIndex.mjs
function zipWithIndex2(self) {
  return mapAccum_2(self, 0, (index, a2) => tuple2(index + 1, tuple2(a2, index)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/GroupBy/GroupBy.mjs
var GroupBy = class {
};
var GroupByInternal = class extends GroupBy {
  constructor(stream, key, buffer2) {
    super();
    this.stream = stream;
    this.key = key;
    this.buffer = buffer2;
    this.grouped = unwrapManaged2(map_14(tap_5(bind_2(bind_2(bind_2(bind_2(do_3, "decider", () => toManaged(make4())), "out", () => toManagedRelease_(makeBoundedQueue(this.buffer), shutdown)), "ref", () => toManaged(makeRef(empty5))), "add", ({
      decider,
      out
    }) => distributedWithDynamic_(mapEffect_3(this.stream, this.key), this.buffer, ({
      tuple: [k2, v2]
    }) => chain_12(wait(decider), (_2) => _2(k2, v2)), (_2) => offer_(out, _2))), ({
      add: add3,
      decider,
      out,
      ref
    }) => toManaged(succeed_(decider, (k2, _2) => chain_12(map_13(ref.get, lookup(k2)), fold(() => chain_12(add3, ({
      tuple: [idx, q2]
    }) => as_(zipRight_2(update_3(ref, insert(k2, idx)), offer_(out, succeed4(tuple2(k2, map_17(q2, map8(({
      tuple: [_3, a2]
    }) => a2)))))), (_3) => _3 === idx)), (idx) => succeed5((_3) => _3 === idx)))))), ({
      out
    }) => flattenExitOption(fromQueueWithShutdown_(out))));
  }
  /**
   * Only consider the first n groups found in the stream.
   */
  first(n2) {
    return new FirstInternal(this.stream, this.key, this.buffer, n2);
  }
  /**
   * Only consider the first n groups found in the stream.
   */
  filter(f2) {
    return new FilterInternal(this.stream, this.key, this.buffer, f2);
  }
  apply(f2) {
    return chainPar_(this.grouped, Number.MAX_SAFE_INTEGER, ({
      tuple: [k2, q2]
    }) => f2(k2, flattenExitOption(fromQueueWithShutdown_(q2))));
  }
};
var FirstInternal = class extends GroupByInternal {
  constructor(stream, key, buffer2, n2) {
    super(stream, key, buffer2);
    this.n = n2;
    this.grouped = map_20(filterEffect_2(zipWithIndex2(super.grouped), (elem3) => {
      const {
        tuple: [{
          tuple: [_2, q2]
        }, i2]
      } = elem3;
      return i2 < this.n ? as_(succeed5(elem3), true) : as_(shutdown(q2), false);
    }), get(0));
  }
};
var FilterInternal = class extends GroupByInternal {
  constructor(stream, key, buffer2, f2) {
    super(stream, key, buffer2);
    this.f = f2;
    this.grouped = filterEffect_2(super.grouped, (elem3) => {
      const {
        tuple: [k2, q2]
      } = elem3;
      return this.f(k2) ? as_(succeed5(elem3), true) : as_(shutdown(q2), false);
    });
  }
};
function concrete5(_groupBy) {
}
function make_2(stream, key, buffer2) {
  return new GroupByInternal(stream, key, buffer2);
}
function mergeGroupBy_(self, f2) {
  concrete5(self);
  return self.apply(f2);
}
function mergeGroupBy(f2) {
  return (self) => mergeGroupBy_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/groupBy.mjs
function groupBy_(self, f2, buffer2 = 16) {
  return make_2(self, f2, buffer2);
}
function groupBy(f2, buffer2 = 16) {
  return (self) => groupBy_(self, f2, buffer2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/groupByKey.mjs
function groupByKey_(self, f2, buffer2 = 16) {
  return groupBy_(self, (a2) => succeed5(tuple2(f2(a2), a2)), buffer2);
}
function groupByKey(f2, buffer2 = 16) {
  return (self) => groupByKey_(self, f2, buffer2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/transduce.mjs
function transduce_(self, sink) {
  return new Stream(suspend7(() => {
    const leftovers = new AtomicReference(empty4());
    const upstreamDone = new AtomicBoolean(false);
    const buffer2 = suspend7(() => {
      const l2 = leftovers.get;
      if (isEmpty5(l2)) {
        return readWith((c2) => zipRight_4(write(c2), buffer2), (e2) => fail10(e2), (done7) => end(done7));
      } else {
        leftovers.set(empty4());
        return zipRight_4(writeChunk(l2), buffer2);
      }
    });
    const concatAndGet = (c2) => {
      const ls = leftovers.get;
      const concat4 = concat_3(ls, filter_3(c2, (a2) => !isEmpty5(a2)));
      leftovers.set(concat4);
      return concat4;
    };
    const upstreamMarker = readWith((_in2) => zipRight_4(write(_in2), upstreamMarker), (err) => fail10(err), (done7) => zipRight_4(succeedWith5(() => upstreamDone.set(true)), end(done7)));
    const transducer = chain_15(doneCollect(sink.channel), ({
      tuple: [leftover, z2]
    }) => chain_15(succeedWith5(() => tuple2(upstreamDone.get, concatAndGet(leftover))), ({
      tuple: [done7, newLeftovers]
    }) => {
      const nextChannel = done7 && isEmpty5(newLeftovers) ? end(void 0) : transducer;
      return zipRight_4(write(single(z2)), nextChannel);
    }));
    return self.channel[">>>"](upstreamMarker)[">>>"](buffer2)[">>>"](transducer);
  }));
}
function transduce(sink) {
  return (self) => transduce_(self, sink);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/grouped.mjs
function grouped_2(self, chunkSize) {
  return transduce_(self, collectAllN(chunkSize));
}
function grouped2(chunkSize) {
  return (self) => grouped_2(self, chunkSize);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/groupedWithin.mjs
function groupedWithin_(self, chunkSize, within) {
  return aggregateAsyncWithin_(self, collectAllN(chunkSize), spaced(within));
}
function groupedWithin(chunkSize, within) {
  return (self) => groupedWithin_(self, chunkSize, within);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/haltWhen.mjs
function haltWhen_(self, io) {
  const writer = (fiber) => unwrap2(map_13(fiber.poll, fold(() => readWith((in_2) => zipRight_4(write(in_2), writer(fiber)), (err) => fail10(err), (_2) => unit5), (exit) => fold_4(exit, (_2) => failCause2(_2), (_2) => unit5))));
  return new Stream(unwrapManaged(map_14(forkManaged(io), (fiber) => self.channel[">>>"](writer(fiber)))));
}
function haltWhen(io) {
  return (self) => haltWhen_(self, io);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/haltAfter.mjs
function halfAfter_(self, duration) {
  return haltWhen_(self, sleep(duration));
}
function halfAfter(duration) {
  return (self) => halfAfter_(self, duration);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/haltWhenP.mjs
function haltWhenP_(self, p2) {
  const writer = () => unwrap2(map_13(poll(p2), fold(() => readWith((in_2) => zipRight_4(write(in_2), writer()), (err) => fail10(err), (_2) => unit5), (io) => unwrap2(fold_5(io, (_2) => fail10(_2), (_2) => unit5)))));
  return new Stream(self.channel[">>>"](writer()));
}
function haltWhenP(p2) {
  return (self) => haltWhenP_(self, p2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/interleaveWith.mjs
function interleaveWith_(self, that, b2) {
  const producer = (handoff) => readWithCause((value) => zipRight_4(fromEffect3(offer(handoff, single3(value))), producer(handoff)), (cause2) => fromEffect3(offer(handoff, failCause3(cause2))), (_2) => fromEffect3(offer(handoff, end2)));
  return new Stream(managed_(map_14(tap_5(tap_5(bind_2(bind_2(do_3, "left", () => toManaged(make10())), "right", () => toManaged(make10())), ({
    left: left4
  }) => managedFork(runManaged(concatMap_(self.channel, (_2) => writeChunk(_2))[">>>"](producer(left4))))), ({
    right: right5
  }) => managedFork(runManaged(concatMap_(that.channel, (_2) => writeChunk(_2))[">>>"](producer(right5))))), ({
    left: left4,
    right: right5
  }) => tuple2(left4, right5)), ({
    tuple: [left4, right5]
  }) => {
    const process2 = (leftDone, rightDone) => readWithCause((bool) => {
      if (bool && !leftDone) {
        return chain_15(fromEffect3(take3(left4)), fold11(rightDone ? unit5 : process2(true, rightDone), (cause2) => failCause2(cause2), (chunk2) => zipRight_4(write(chunk2), process2(leftDone, rightDone))));
      }
      if (!bool && !rightDone) {
        return chain_15(fromEffect3(take3(right5)), fold11(leftDone ? unit5 : process2(leftDone, true), (cause2) => failCause2(cause2), (chunk2) => zipRight_4(write(chunk2), process2(leftDone, rightDone))));
      }
      return process2(leftDone, rightDone);
    }, (cause2) => failCause2(cause2), (_2) => unit5);
    return concatMap_(b2.channel, (_2) => writeChunk(_2))[">>>"](process2(false, false));
  }));
}
function interleaveWith(that, b2) {
  return (self) => interleaveWith_(self, that, b2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/interleave.mjs
function interleave_(self, that) {
  return interleaveWith_(self, that, forever3(fromChunk(from3([true, false]))));
}
function interleave(that) {
  return (self) => interleave_(self, that);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/interruptWhen.mjs
function interruptWhen_2(self, io) {
  return new Stream(interruptWhen_(self.channel, io));
}
function interruptWhen(io) {
  return (self) => interruptWhen_2(self, io);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/interruptAfter.mjs
function interruptAfter_(self, duration) {
  return interruptWhen_2(self, sleep(duration));
}
function interruptAfter(duration) {
  return (self) => interruptAfter_(self, duration);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/intersperse.mjs
function intersperse_(self, middle) {
  const writer = (isFirst) => readWith((chunk2) => {
    const builder2 = builder();
    let flagResult = isFirst;
    forEach_4(chunk2, (o2) => {
      if (flagResult) {
        flagResult = false;
        builder2.append(o2);
      } else {
        builder2.append(middle);
        builder2.append(o2);
      }
    });
    return zipRight_4(write(builder2.build()), writer(flagResult));
  }, (err) => fail10(err), (_2) => unit5);
  return new Stream(self.channel[">>>"](writer(true)));
}
function intersperse(middle) {
  return (self) => intersperse_(self, middle);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/intersperseAffixes.mjs
function intersperseAffixes_(self, start, middle, end4) {
  return concat_4(concat_4(fromChunk(single(start)), intersperse_(self, middle)), fromChunk(single(end4)));
}
function intersperseAffixes(start, middle, end4) {
  return (self) => intersperseAffixes_(self, start, middle, end4);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/make.mjs
function make11(...values3) {
  return fromIterable(values3);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/mapAccumEffect.mjs
function mapAccumEffect_2(self, s2, f2) {
  const accumulator = (s3) => readWith((in_2) => unwrap2(suspend4(() => {
    const outputChunk = builder();
    const emit = (a2) => asUnit(succeedWith3(() => {
      outputChunk.append(a2);
    }));
    return fold_5(reduce_6(in_2, s3, (s1, a2) => chain_12(f2(s1, a2), (sa) => as_(emit(get_(sa, 1)), get_(sa, 0)))), (failure) => {
      const partialResult = outputChunk.build();
      if (!isEmpty5(partialResult)) {
        return zipRight_4(write(partialResult), fail10(failure));
      } else {
        return fail10(failure);
      }
    }, (_2) => zipRight_4(write(outputChunk.build()), accumulator(_2)));
  })), (_2) => fail10(_2), (_2) => unit5);
  return new Stream(self.channel[">>>"](accumulator(s2)));
}
function mapAccumEffect2(s2, f2) {
  return (self) => mapAccumEffect_2(self, s2, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/mapError.mjs
function mapError_6(self, f2) {
  return new Stream(mapError_5(self.channel, f2));
}
function mapError6(f2) {
  return (self) => mapError_6(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/mapBoth.mjs
function mapBoth_3(self, f2, g2) {
  return map_20(mapError_6(self, f2), g2);
}
function mapBoth2(f2, g2) {
  return (self) => mapBoth_3(self, f2, g2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/mapChunksEffect.mjs
function mapChunksEffect_(self, f2) {
  return new Stream(mapOutEffect_(self.channel, f2));
}
function mapChunksEffect(f2) {
  return (self) => mapChunksEffect_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/mapConcatChunkEffect.mjs
function mapConcatChunkEffect_(self, f2) {
  return mapConcatChunk_(mapEffect_3(self, f2), identity);
}
function mapConcatChunkEffect(f2) {
  return (self) => mapConcatChunkEffect_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/mapConcatEffect.mjs
function mapConcatEffect_(self, f2) {
  return mapConcatChunk_(mapEffect_3(self, (a2) => map_13(f2(a2), from3)), identity);
}
function mapConcatEffect(f2) {
  return (self) => mapConcatEffect_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/mapEffectPar.mjs
function mapEffectPar2(self, f2, n2) {
  return new Stream(mapOut_(mapOutEffectPar_(concatMap_(self.channel, writeChunk), n2, f2), single));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/mapEffectPartitioned.mjs
function mapEffectPartitioned_(self, keyBy, f2, buffer2 = 16) {
  return mergeGroupBy_(groupByKey_(self, keyBy, buffer2), (_2, s2) => mapEffect_3(s2, f2));
}
function mapEffectPartitioned(keyBy, f2, buffer2 = 16) {
  return (self) => mapEffectPartitioned_(self, keyBy, f2, buffer2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/mapEffectParUnordered.mjs
function mapEffectParUnordered_(self, n2, f2) {
  return chainPar_(self, n2, (a2) => fromEffect4(f2(a2)));
}
function mapEffectParUnordered(n2, f2) {
  return (self) => mapEffectParUnordered_(self, n2, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/mapErrorCause.mjs
function mapErrorCause_4(self, f2) {
  return new Stream(mapErrorCause_3(self.channel, f2));
}
function mapErrorCause4(f2) {
  return (self) => mapErrorCause_4(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/mergeWith.mjs
function mergeWith(self, that, l2, r2, strategy = "Both") {
  const handler = (terminate) => (exit) => {
    if (terminate || !succeeded(exit)) {
      return done4(done(exit));
    } else {
      return await_(done);
    }
  };
  return new Stream(mergeWith_(map_20(self, l2).channel, map_20(that, r2).channel, handler(strategy === "Either" || strategy === "Left"), handler(strategy === "Either" || strategy === "Right")));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/merge.mjs
function merge_(self, that, strategy = "Both") {
  return mergeWith(self, that, identity, identity, strategy);
}
function merge4(that, strategy = "Both") {
  return (self) => merge_(self, that, strategy);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/mergeAll.mjs
function mergeAll3(n2, outputBuffer = 16) {
  return (...streams) => flattenPar_(fromIterable(streams), n2, outputBuffer);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/mergeAllUnbounded.mjs
function mergeAllUnbounded(outputBuffer = 16) {
  return (...streams) => mergeAll3(Number.MAX_SAFE_INTEGER, outputBuffer)(...streams);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/mergeEither.mjs
function mergeEither_(self, that) {
  return mergeWith(self, that, left, right);
}
function mergeEither(that) {
  return (self) => mergeEither_(self, that);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/mergeTerminateEither.mjs
function mergeTerminateEither_(self, that) {
  return merge_(self, that, "Either");
}
function mergeTerminateEither(that) {
  return (self) => mergeTerminateEither_(self, that);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/mergeTerminateLeft.mjs
function mergeTerminateLeft_(self, that) {
  return merge_(self, that, "Left");
}
function mergeTerminateLeft(that) {
  return (self) => mergeTerminateLeft_(self, that);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/mergeTerminateRight.mjs
function mergeTerminateRight_(self, that) {
  return merge_(self, that, "Right");
}
function mergeTerminateRight(that) {
  return (self) => mergeTerminateRight_(self, that);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/never.mjs
var never2 = /* @__PURE__ */ fromEffect4(never);

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/onError.mjs
function onError_2(self, cleanup) {
  return catchAllCause_4(self, (cause2) => fromEffect4(zipRight_2(cleanup(cause2), halt2(cause2))));
}
function onError2(cleanup) {
  return (self) => onError_2(self, cleanup);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/orElse.mjs
function orElse_5(self, that) {
  return new Stream(orElse_4(self.channel, that.channel));
}
function orElse5(that) {
  return (self) => orElse_5(self, that);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/orElseEither.mjs
function orElseEither_5(self, that) {
  return orElse_5(map_20(self, left), map_20(that, right));
}
function orElseEither5(that) {
  return (self) => orElseEither_5(self, that);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/orElseFail.mjs
function orElseFail_3(self, e1) {
  return orElse_5(self, fail12(e1()));
}
function orElseFail4(e1) {
  return (self) => orElseFail_3(self, e1);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/orElseOptional.mjs
function orElseOptional_3(self, that) {
  return catchAll_5(self, fold(() => that, (e2) => fail12(some(e2))));
}
function orElseOptional3(that) {
  return (self) => orElseOptional_3(self, that);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/orElseSucceed.mjs
function orElseSucceed_3(self, a1) {
  return orElse_5(self, succeed10(a1));
}
function orElseSucceed3(a1) {
  return (self) => orElseSucceed_3(self, a1);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/paginateChunk.mjs
function paginateChunk(s2, f2) {
  const loop6 = (s3) => {
    const {
      tuple: [as6, o2]
    } = f2(s3);
    return fold_(o2, () => zipRight_4(write(as6), end(void 0)), (s4) => zipRight_4(write(as6), loop6(s4)));
  };
  return new Stream(loop6(s2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/paginate.mjs
function paginate(s2, f2) {
  return paginateChunk(s2, (s3) => {
    const {
      tuple: [a2, b2]
    } = f2(s3);
    return tuple2(single(a2), b2);
  });
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/paginateChunkEffect.mjs
function paginateChunkEffect(s2, f2) {
  const loop6 = (s3) => unwrap2(map_13(f2(s3), ({
    tuple: [as6, o2]
  }) => fold_(o2, () => zipRight_4(write(as6), end(void 0)), (s4) => zipRight_4(write(as6), loop6(s4)))));
  return new Stream(loop6(s2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/paginateEffect.mjs
function paginateEffect(s2, f2) {
  return paginateChunkEffect(s2, (_2) => map_13(f2(_2), ({
    tuple: [a2, s3]
  }) => tuple2(single(a2), s3)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/partitionEither.mjs
function partitionEither_(self, p2, buffer2 = 16) {
  return chain_13(distributedWith_(mapEffect_3(self, p2), 2, buffer2, fold2((_2) => succeed5((_3) => _3 === 0), (_2) => succeed5((_3) => _3 === 1))), (dequeues) => {
    if (size3(dequeues) === 2) {
      return succeed7(tuple2(collectLeft(flattenExitOption(fromQueueWithShutdown_(unsafeFirst(dequeues)))), collectRight(flattenExitOption(fromQueueWithShutdown_(unsafeLast(dequeues))))));
    }
    return dieMessage2(`partitionEither: expected two streams but got ${size3(dequeues)}`);
  });
}
function partitionEither(p2, buffer2 = 16) {
  return (self) => partitionEither_(self, p2, buffer2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/partition.mjs
function partition_4(self, p2, buffer2 = 16) {
  return partitionEither_(self, (a2) => p2(a2) ? succeed5(left(a2)) : succeed5(right(a2)), buffer2);
}
function partition4(p2, buffer2 = 16) {
  return (self) => partition_4(self, p2, buffer2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/peel.mjs
var SignalTypeId = /* @__PURE__ */ Symbol();
var EmitTypeId4 = /* @__PURE__ */ Symbol();
var Emit3 = class {
  constructor(els) {
    this.els = els;
    this._signalTypeId = SignalTypeId;
    this._typeId = EmitTypeId4;
  }
};
var HaltTypeId3 = /* @__PURE__ */ Symbol();
var Halt3 = class {
  constructor(cause2) {
    this.cause = cause2;
    this._signalTypeId = SignalTypeId;
    this._typeId = HaltTypeId3;
  }
};
var EndTypeId2 = /* @__PURE__ */ Symbol();
var End2 = class {
  constructor() {
    this._signalTypeId = SignalTypeId;
    this._typeId = EndTypeId2;
  }
};
function peel_(self, sink) {
  return flatten10(map_14(bind_2(bind_2(do_3, "p", () => toManaged(make4())), "handoff", () => toManaged(make10())), ({
    handoff,
    p: p2
  }) => {
    const consumer = foldSink_(exposeLeftover(sink), (e2) => zipRight_5(fromEffect5(fail_(p2, e2)), fail13(e2)), ({
      tuple: [z1, leftovers]
    }) => {
      const loop6 = readWithCause((in_2) => zipRight_4(fromEffect3(offer(handoff, new Emit3(in_2))), loop6), (e2) => zipRight_4(fromEffect3(offer(handoff, new Halt3(e2))), failCause2(e2)), (_2) => zipRight_4(fromEffect3(offer(handoff, new End2())), unit5));
      return new Sink(zipRight_4(zipRight_4(fromEffect3(succeed_(p2, z1)), fromEffect3(offer(handoff, new Emit3(leftovers)))), loop6));
    });
    const producer = unwrap2(map_13(take3(handoff), (sig) => {
      switch (sig._typeId) {
        case EmitTypeId4:
          return zipRight_4(write(sig.els), producer);
        case HaltTypeId3:
          return failCause2(sig.cause);
        default:
          return unit5;
      }
    }));
    return map_14(chain_13(managedFork(runManaged_(self, consumer)), (_2) => toManaged(wait(p2))), (z2) => tuple2(z2, new Stream(producer)));
  }));
}
function peel(sink) {
  return (self) => peel_(self, sink);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/provideAll.mjs
function provideAll_6(self, r2) {
  return new Stream(provideAll_5(self.channel, r2));
}
function provideAll4(r2) {
  return (self) => provideAll_6(self, r2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/range.mjs
function range3(min2, max2, chunkSize = DEFAULT_CHUNK_SIZE) {
  const go = (current) => {
    const remaining = max2 - current;
    if (remaining > chunkSize) {
      return zipRight_4(write(range2(current, current + chunkSize)), go(current + chunkSize));
    } else {
      return write(range2(current, current + remaining));
    }
  };
  return new Stream(go(min2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/rechunk.mjs
var Rechunker = class {
  constructor(n2) {
    this.n = n2;
    this.builder = builder();
    this.pos = 0;
  }
  write(elem3) {
    this.builder.append(elem3);
    this.pos += 1;
    if (this.pos === this.n) {
      const result4 = this.builder.build();
      this.builder = builder();
      this.pos = 0;
      return result4;
    }
    return null;
  }
  emitOfNotEmpty() {
    if (this.pos !== 0) {
      return write(this.builder.build());
    } else {
      return unit5;
    }
  }
};
function rechunk_(self, n2) {
  return unwrap3(succeedWith3(() => {
    const rechunker = new Rechunker(n2);
    const process2 = readWithCause((chunk2) => {
      const chunkSize = size4(chunk2);
      if (chunkSize > 0) {
        let chunks2 = empty2();
        let result4 = null;
        let i2 = 0;
        while (i2 < chunkSize) {
          while (i2 < chunkSize && result4 === null) {
            result4 = rechunker.write(unsafeGet_2(chunk2, i2));
            i2 += 1;
          }
          if (result4 !== null) {
            chunks2 = prepend_2(chunks2, result4);
            result4 = null;
          }
        }
        return zipRight_4(writeAll(...toArray(reverse2(chunks2))), process2);
      }
      return process2;
    }, (cause2) => zipRight_4(rechunker.emitOfNotEmpty(), failCause2(cause2)), (_2) => rechunker.emitOfNotEmpty());
    return new Stream(self.channel[">>>"](process2));
  }));
}
function rechunk(n2) {
  return (self) => rechunk_(self, n2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/refineOrDieWith.mjs
function refineOrDieWith_3(self, pf, f2) {
  return new Stream(catchAll_4(self.channel, (e2) => fold_(pf(e2), () => failCause2(die(f2(e2))), (e1) => fail10(e1))));
}
function refineOrDieWith3(pf, f2) {
  return (self) => refineOrDieWith_3(self, pf, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/refineOrDie.mjs
function refineOrDie_3(self, pf) {
  return refineOrDieWith_3(self, pf, identity);
}
function refineOrDie3(pf) {
  return (self) => refineOrDie_3(self, pf);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/repeat.mjs
function repeat2(a2) {
  return new Stream(repeated(write(single(a2))));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/repeatEffect.mjs
function repeatEffect(fa) {
  return repeatEffectOption(mapError_3(fa, some));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/repeatEffectChunk.mjs
function repeatEffectChunk(fa) {
  return repeatEffectChunkOption(mapError_3(fa, some));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/repeatEffectWith.mjs
function repeatEffectWith(effect2, schedule2) {
  return chain_16(fromEffect4(zip_4(effect2, driver(schedule2))), ({
    tuple: [a2, driver2]
  }) => concat_4(succeed10(a2), unfoldEffect2(a2, (_2) => foldM_2(driver2.next(_2), (_3) => succeed5(_3), (_3) => map_13(effect2, (nextA) => some(tuple2(nextA, nextA)))))));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/repeatWith.mjs
function repeatWith_(self, schedule2, f2, g2) {
  return unwrap3(map_13(bind_(do_2, "driver", () => driver(schedule2)), ({
    driver: driver2
  }) => {
    const scheduleOutput = map_13(orDie(driver2.last), g2);
    const process2 = map_20(self, f2).channel;
    const loop6 = unwrap2(fold_5(driver2.next(void 0), (_2) => unit5, (_2) => zipRight_4(zipRight_4(process2, unwrap2(map_13(scheduleOutput, (o2) => write(single(o2))))), loop6)));
    return new Stream(zipRight_4(process2, loop6));
  }));
}
function repeatWith(schedule2, f2, g2) {
  return (self) => repeatWith_(self, schedule2, f2, g2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/repeatEither.mjs
function repeatEither_(self, schedule2) {
  return repeatWith_(self, schedule2, right, left);
}
function repeatEither(schedule2) {
  return (self) => repeatEither_(self, schedule2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/repeatElementsWith.mjs
function repeatElementsWith_(self, schedule2, f2, g2) {
  return new Stream(self.channel[">>>"](unwrap2(map_13(bind_(do_2, "driver", () => driver(schedule2)), ({
    driver: driver2
  }) => {
    const feed = (in_2) => fold_(head2(in_2), () => loop6(), (a2) => zipRight_4(write(single(f2(a2))), step2(drop_2(in_2, 1), a2)));
    const step2 = (in_2, a2) => {
      const advance = as_(driver2.next(a2), zipRight_4(write(single(f2(a2))), step2(in_2, a2)));
      const reset = map_13(tap_4(bind_(do_2, "b", () => orDie(driver2.last)), () => driver2.reset), ({
        b: b2
      }) => zipRight_4(write(single(g2(b2))), feed(in_2)));
      return unwrap2(orElse_2(advance, () => reset));
    };
    const loop6 = () => readWith(feed, (_2) => fail10(_2), (_2) => unit5);
    return loop6();
  }))));
}
function repeatElementsWith(schedule2, f2, g2) {
  return (self) => repeatElementsWith_(self, schedule2, f2, g2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/repeatElementsEither.mjs
function repeatElementsEither_(self, schedule2) {
  return repeatElementsWith_(self, schedule2, right, left);
}
function repeatElementsEither(schedule2) {
  return (self) => repeatElementsEither_(self, schedule2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/repeatElements.mjs
function repeatElements_(self, schedule2) {
  return collect_5(repeatElementsEither_(self, schedule2), fold2(() => none, (a2) => some(a2)));
}
function repeatElements(schedule2) {
  return (self) => repeatElements_(self, schedule2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/repeatSchedule.mjs
function repeatSchedule_(self, schedule2) {
  return collect_5(repeatEither_(self, schedule2), fold2((_2) => none, (a2) => some(a2)));
}
function repeatSchedule(schedule2) {
  return (self) => repeatSchedule_(self, schedule2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/repeatValueWith.mjs
function repeatValueWith(a2, schedule2) {
  return repeatEffectWith(succeed5(a2), schedule2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/tap.mjs
function tap_6(self, f2) {
  return mapEffect_3(self, (a2) => as_(f2(a2), a2));
}
function tap6(f2) {
  return (self) => tap_6(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/retry.mjs
function retry_3(self, schedule2) {
  return unwrap3(map_13(bind_(do_2, "driver", () => driver(schedule2)), ({
    driver: driver2
  }) => {
    const loop6 = catchAll_5(self, (e2) => unwrap3(foldM_2(driver2.next(e2), (_2) => fail6(e2), (_2) => succeed5(tap_6(loop6, (_3) => driver2.reset)))));
    return loop6;
  }));
}
function retry4(schedule2) {
  return (self) => retry_3(self, schedule2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/rightOrFail.mjs
function rightOrFail_(self, e2) {
  return mapEffect_3(self, fold2(() => fail6(e2()), (_2) => succeed5(_2)));
}
function rightOrFail(e2) {
  return (self) => rightOrFail_(self, e2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/right.mjs
function right4(self) {
  return rightOrFail_(mapError_6(self, some), () => none);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runCollect.mjs
function runCollect(self) {
  return run_2(self, collectAll5());
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runCount.mjs
function runCount(self) {
  return run_2(self, count());
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runDrain.mjs
function runDrain2(self) {
  return run_2(self, drain2());
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runForEachChunk.mjs
function runForEachChunk_(self, f2) {
  return run_2(self, forEachChunk(f2));
}
function runForEachChunk(f2) {
  return (self) => runForEachChunk_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runForEachChunkManaged.mjs
function runForEachChunkManaged_(self, f2) {
  return runManaged_(self, forEachChunk(f2));
}
function runForEachChunkManaged(f2) {
  return (self) => runForEachChunkManaged_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runForEachWhile.mjs
function runForEachWhile_(self, f2) {
  return run_2(self, forEachWhile(f2));
}
function runForEachWhile(f2) {
  return (self) => runForEachWhile_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runForEachWhileManaged.mjs
function runForEachWhileManaged_(self, f2) {
  return runManaged_(self, forEachWhile(f2));
}
function runForEachWhileManaged(f2) {
  return (self) => runForEachWhileManaged_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runHead.mjs
function runHead(self) {
  return run_2(self, head5());
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runInto.mjs
function runInto_(self, queue) {
  return managedUse_(runIntoManaged_(self, queue), (_2) => unit3);
}
function runInto(queue) {
  return (self) => runInto_(self, queue);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runIntoHub.mjs
function runIntoHub_(self, hub) {
  return runInto_(self, toQueue(hub));
}
function runIntoHub(hub) {
  return (self) => runIntoHub_(self, hub);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runLast.mjs
function runLast(self) {
  return run_2(self, last3());
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runReduceWhileManaged.mjs
function runReduceWhileManaged_(self, s2, cont, f2) {
  return runManaged_(self, reduce7(s2, cont, f2));
}
function runReduceWhileManaged(s2, cont, f2) {
  return (self) => runReduceWhileManaged_(self, s2, cont, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runReduce.mjs
function runReduce_(self, s2, f2) {
  return managedUse_(runReduceWhileManaged_(self, s2, (_2) => true, (s3, a2) => f2(s3, a2)), succeed5);
}
function runReduce(s2, f2) {
  return (self) => runReduce_(self, s2, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runReduceWhileManagedEffect.mjs
function runReduceWhileManagedEffect_(self, s2, cont, f2) {
  return runManaged_(self, reduceEffect2(s2, cont, f2));
}
function runReduceWhileManagedEffect(s2, cont, f2) {
  return (self) => runReduceWhileManagedEffect_(self, s2, cont, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runReduceEffect.mjs
function runReduceEffect_(self, s2, f2) {
  return managedUse_(runReduceWhileManagedEffect_(self, s2, (_2) => true, f2), succeed5);
}
function runReduceEffect(s2, f2) {
  return (self) => runReduceEffect_(self, s2, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runReduceManaged.mjs
function runReduceManaged_(self, s2, f2) {
  return runReduceWhileManaged_(self, s2, (_2) => true, (s3, a2) => f2(s3, a2));
}
function runReduceManaged(s2, f2) {
  return (self) => runReduceManaged_(self, s2, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runReduceManagedEffect.mjs
function runReduceManagedEffect_(self, s2, f2) {
  return runReduceWhileManagedEffect_(self, s2, (_2) => true, f2);
}
function runReduceManagedEffect(s2, f2) {
  return (self) => runReduceManagedEffect_(self, s2, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runReduceWhile.mjs
function runReduceWhile_(self, s2, cont, f2) {
  return managedUse_(runReduceWhileManaged_(self, s2, cont, (s3, a2) => f2(s3, a2)), succeed5);
}
function runReduceWhile(s2, cont, f2) {
  return (self) => runReduceWhile_(self, s2, cont, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runReduceWhileEffect.mjs
function runReduceWhileEffect_(self, s2, cont, f2) {
  return managedUse_(runReduceWhileManagedEffect_(self, s2, cont, f2), succeed5);
}
function runReduceWhileEffect(s2, cont, f2) {
  return (self) => runReduceWhileEffect_(self, s2, cont, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/runSum.mjs
function runSum(self) {
  return run_2(self, sum2());
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/scanEffect.mjs
function scanEffect_(self, s2, f2) {
  return concat_4(succeed10(s2), mapAccumEffect_2(self, s2, (s3, a2) => map_13(f2(s3, a2), (s4) => tuple2(s4, s4))));
}
function scanEffect(s2, f2) {
  return (self) => scanEffect_(self, s2, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/scan.mjs
function scan_(self, s2, f2) {
  return scanEffect_(self, s2, (s3, a2) => succeed5(f2(s3, a2)));
}
function scan(s2, f2) {
  return (self) => scan_(self, s2, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/scanReduceEffect.mjs
function scanReduceEffect_(self, f2) {
  return mapAccumEffect_2(self, emptyOf(), (s2, a2) => fold_(s2, () => succeed5(tuple2(some(a2), a2)), (a1) => map_13(f2(a1, a2), (a22) => tuple2(some(a22), a22))));
}
function scanReduceEffect(f2) {
  return (self) => scanReduceEffect_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/scanReduce.mjs
function scanReduce_(self, f2) {
  return scanReduceEffect_(self, (curr, next2) => succeed5(f2(curr, next2)));
}
function scanReduce(f2) {
  return (self) => scanReduce_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/service.mjs
function service3(s2) {
  return accessServiceEffect(s2)(succeed5);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/serviceWith.mjs
function serviceWith(s2) {
  return (f2) => fromEffect4(accessServiceM2(s2)(f2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/serviceWithStream.mjs
function serviceWithStream(s2) {
  return (f2) => chain_16(service3(s2), f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/sliding.mjs
function sliding_(self, chunkSize, stepSize = 1) {
  if (chunkSize <= 0 || stepSize <= 0) {
    return die6(new IllegalArgumentException("invalid bounds. `chunkSize` and `stepSize` must be greater than zero"));
  }
  return chain_16(succeedWith6(() => new RingBufferNew(chunkSize)), (queue) => {
    const emitOnStreamEnd = (queueSize, channelEnd) => {
      if (queueSize < chunkSize) {
        const items = queue.toChunk();
        const result4 = isEmpty5(items) ? empty4() : single(items);
        return zipRight_4(write(result4), channelEnd);
      } else {
        const lastEmitIndex = queueSize - (queueSize - chunkSize) % stepSize;
        if (lastEmitIndex === queueSize) {
          return channelEnd;
        } else {
          const leftovers = queueSize - (lastEmitIndex - chunkSize + stepSize);
          const lastItems = takeRight_2(queue.toChunk(), leftovers);
          const result4 = isEmpty5(lastItems) ? empty4() : single(lastItems);
          return zipRight_4(write(result4), channelEnd);
        }
      }
    };
    const reader = (queueSize) => readWithCause((in_2) => zipRight_4(write(collect_2(zipWithIndex(in_2), ({
      tuple: [i2, idx]
    }) => {
      queue.put(i2);
      const currentIndex = queueSize + idx + 1;
      if (currentIndex < chunkSize || (currentIndex - chunkSize) % stepSize > 0) {
        return none;
      } else {
        return some(queue.toChunk());
      }
    })), reader(queueSize + size4(in_2))), (cause2) => emitOnStreamEnd(queueSize, failCause2(cause2)), (_2) => emitOnStreamEnd(queueSize, unit5));
    return new Stream(self.channel[">>>"](reader(0)));
  });
}
function sliding(chunkSize, stepSize = 1) {
  return (self) => sliding_(self, chunkSize, stepSize);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/someOrFail.mjs
function someOrFail_3(self, e2) {
  return mapEffect_3(self, fold(() => fail6(e2()), (_2) => succeed5(_2)));
}
function someOrFail3(e2) {
  return (self) => someOrFail_3(self, e2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/some.mjs
function some4(self) {
  return someOrFail_3(mapError_6(self, some), () => none);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/someOrElse.mjs
function someOrElse_3(self, default_) {
  return map_20(self, getOrElseS(() => default_));
}
function someOrElse3(default_) {
  return (self) => someOrElse_3(self, default_);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/splitLines.mjs
function splitLines(self) {
  const next2 = (leftover, wasSplitCRLF) => readWithCause((incomingChunk) => {
    const buffer2 = builder();
    let inCRLF = wasSplitCRLF;
    let carry = getOrElse_(leftover, () => "");
    forEach_4(incomingChunk, (string3) => {
      const concatenated = carry + string3;
      if (string3.length > 0) {
        const continueFrom = inCRLF && carry.length > 0 ? carry.length - 1 : carry.length;
        return (({
          tuple: [sliceStart, _2, midCRLF]
        }) => {
          carry = concatenated.slice(sliceStart);
          inCRLF = midCRLF;
        })(reduce_7(drop_2(zipWithIndex(from3(concatenated)), continueFrom), tuple2(0, false, inCRLF), ({
          tuple: [sliceStart, skipNext, midCRLF]
        }, {
          tuple: [char, index]
        }) => {
          if (skipNext) {
            return tuple2(sliceStart, false, false);
          } else {
            switch (char) {
              case "\n": {
                buffer2.append(concatenated.slice(sliceStart, index));
                return tuple2(index + 1, false, midCRLF);
              }
              case "\r": {
                if (index + 1 < concatenated.length && concatenated[index + 1] === "\n") {
                  buffer2.append(concatenated.slice(sliceStart, index));
                  return tuple2(index + 2, true, false);
                } else if (index === concatenated.length - 1) {
                  return tuple2(sliceStart, false, true);
                } else {
                  return tuple2(index, false, false);
                }
              }
              default: {
                return tuple2(sliceStart, false, midCRLF);
              }
            }
          }
        }));
      }
    });
    return zipRight_4(write(buffer2.build()), next2(carry.length > 0 ? some(carry) : none, inCRLF));
  }, (halt6) => fold_(leftover, () => failCause2(halt6), (value) => zipRight_4(write(single(value)), failCause2(halt6))), (done7) => fold_(leftover, () => end(done7), (value) => zipRight_4(write(single(value)), end(done7))));
  return new Stream(self.channel[">>>"](next2(none, false)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/splitOnChunk.mjs
function splitOnChunk_(self, delimiter) {
  const next2 = (leftover, delimiterIndex) => readWithCause((inputChunk) => {
    const buffer2 = builder();
    const {
      tuple: [carry, delimiterCursor]
    } = reduce_7(inputChunk, tuple2(getOrElse_(leftover, () => empty4()), delimiterIndex), ({
      tuple: [carry2, delimiterCursor2]
    }, a2) => {
      const concatenated = append_4(carry2, a2);
      if (delimiterCursor2 < size4(delimiter) && a2 === unsafeGet_2(delimiter, delimiterCursor2)) {
        if (delimiterCursor2 + 1 === size4(delimiter)) {
          buffer2.append(take_2(concatenated, size4(concatenated) - size4(delimiter)));
          return tuple2(empty4(), 0);
        } else {
          return tuple2(concatenated, delimiterCursor2 + 1);
        }
      } else {
        return tuple2(concatenated, a2 === unsafeGet_2(delimiter, 0) ? 1 : 0);
      }
    });
    return zipRight_4(write(buffer2.build()), next2(!isEmpty5(carry) ? some(carry) : none, delimiterCursor));
  }, (halt6) => fold_(leftover, () => failCause2(halt6), (chunk2) => zipRight_4(write(single(chunk2)), failCause2(halt6))), (done7) => fold_(leftover, () => succeed9(done7), (chunk2) => zipRight_4(write(single(chunk2)), succeed9(done7))));
  return new Stream(self.channel[">>>"](next2(none, 0)));
}
function splitOnChunk(delimiter) {
  return (self) => splitOnChunk_(self, delimiter);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/splitOn.mjs
function splitOn_(self, delimiter) {
  return map_20(splitOnChunk_(mapChunks_(map_20(self, (str) => from3(str)), flatten5), from3(delimiter)), (_2) => [..._2].join(""));
}
function splitOn(delimiter) {
  return (self) => splitOn_(self, delimiter);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/take.mjs
function takeLoop(n2) {
  return readWith((i2) => {
    const taken = take_2(i2, n2);
    const left4 = Math.max(n2 - size4(taken), 0);
    if (left4 > 0) {
      return chain_15(write(taken), () => takeLoop(left4));
    } else {
      return write(taken);
    }
  }, fail10, end);
}
function take_3(self, n2) {
  if (n2 <= 0) {
    return empty7;
  }
  if (!Number.isInteger(n2)) {
    return die6(new IllegalArgumentException(`${n2} should be an integer`));
  }
  return new Stream(self.channel[">>>"](takeLoop(n2)));
}
function take4(n2) {
  return (self) => take_3(self, n2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/takeRight.mjs
function takeRight_3(self, n2) {
  if (n2 <= 0) {
    return empty7;
  }
  return new Stream(unwrap2(map_13(bind_(do_2, "queue", () => succeedWith3(() => new RingBufferNew(n2))), ({
    queue
  }) => {
    const reader = readWith((in_2) => {
      forEach_4(in_2, (_2) => queue.put(_2));
      return reader;
    }, (_2) => fail10(_2), (_2) => zipRight_4(write(queue.toChunk()), unit5));
    return self.channel[">>>"](reader);
  })));
}
function takeRight2(n2) {
  return (self) => takeRight_3(self, n2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/takeUntil.mjs
function takeUntil_(self, f2) {
  const loop6 = readWith((chunk2) => {
    const taken = takeWhile_(chunk2, (_2) => !f2(_2));
    const last4 = take_2(drop_2(chunk2, size4(taken)), 1);
    if (isEmpty5(last4)) {
      return zipRight_4(write(taken), loop6);
    } else {
      return write(concat_3(taken, last4));
    }
  }, (_2) => fail10(_2), (_2) => succeed9(_2));
  return new Stream(self.channel[">>>"](loop6));
}
function takeUntil(f2) {
  return (self) => takeUntil_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/takeUntilEffect.mjs
function takeUntilEffect_(self, f2) {
  return loopOnPartialChunks_(self, (chunk2, emit) => map_13(let_2(bind_(do_2, "taken", () => takeWhileEffect_(chunk2, (v2) => zipRight_2(emit(v2), map_13(f2(v2), (_2) => !_2)))), "last", ({
    taken
  }) => take_2(drop_2(chunk2, size4(taken)), 1)), ({
    last: last4
  }) => isEmpty5(last4)));
}
function takeUntilEffect(f2) {
  return (self) => takeUntilEffect_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/takeWhile.mjs
function takeWhile_2(self, f2) {
  const loop6 = readWith((chunk2) => {
    const taken = takeWhile_(chunk2, f2);
    const more = size4(taken) === size4(chunk2);
    if (more) {
      return zipRight_4(write(taken), loop6);
    } else {
      return write(taken);
    }
  }, (_2) => fail10(_2), (_2) => succeed9(_2));
  return new Stream(self.channel[">>>"](loop6));
}
function takeWhile2(f2) {
  return (self) => takeWhile_2(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/throttleEnforceEffect.mjs
function throttleEnforceEffect_(self, units, duration, costFn, burst = 0) {
  const loop6 = (tokens, timestamp) => readWith((in_2) => unwrap2(map_13(zip_4(costFn(in_2), currentTime), ({
    tuple: [weight, current]
  }) => {
    const elapsed = current - timestamp;
    const cycles = elapsed / duration;
    const available = (() => {
      const sum3 = Math.floor(tokens + cycles * units);
      const max2 = units + burst < 0 ? Number.MAX_SAFE_INTEGER : units + burst;
      return sum3 < 0 ? max2 : Math.min(sum3, max2);
    })();
    if (weight <= available) {
      return zipRight_4(write(in_2), loop6(available - weight, current));
    } else {
      return loop6(available, current);
    }
  })), (e2) => fail10(e2), (_2) => unit5);
  return new Stream(chain_15(fromEffect3(currentTime), (_2) => self.channel[">>>"](loop6(units, _2))));
}
function throttleEnforceEffect(units, duration, costFn, burst = 0) {
  return (self) => throttleEnforceEffect_(self, units, duration, costFn, burst);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/throttleEnforce.mjs
function throttleEnforce_(self, units, duration, costFn, burst = 0) {
  return throttleEnforceEffect_(self, units, duration, (as6) => succeed5(costFn(as6)), burst);
}
function throttleEnforce(units, duration, costFn, burst = 0) {
  return (self) => throttleEnforce_(self, units, duration, costFn, burst);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/throttleShapeEffect.mjs
function throttleShapeEffect_(self, units, duration, costFn, burst = 0) {
  const loop6 = (tokens, timestamp) => readWith((in_2) => unwrap2(map_13(bind_(bind_(do_2, "weight", () => costFn(in_2)), "current", () => currentTime), ({
    current,
    weight
  }) => {
    const elapsed = current - timestamp;
    const cycles = elapsed - duration;
    const available = (() => {
      const sum3 = Math.floor(tokens + cycles * units);
      const max2 = units + burst < 0 ? Number.MAX_SAFE_INTEGER : units + burst;
      return sum3 < 0 ? max2 : Math.min(sum3, max2);
    })();
    const remaining = available - weight;
    const waitCycles = remaining >= 0 ? 0 : -remaining / units;
    const delay2 = Math.floor(waitCycles * duration);
    if (delay2 > 0) {
      return zipRight_4(zipRight_4(fromEffect3(sleep(delay2)), write(in_2)), loop6(remaining, current));
    } else {
      return zipRight_4(write(in_2), loop6(remaining, current));
    }
  })), (e2) => fail10(e2), (_2) => unit5);
  return new Stream(chain_15(fromEffect3(currentTime), (_2) => self.channel[">>>"](loop6(units, _2))));
}
function throttleShapeEffect(units, duration, costFn, burst = 0) {
  return (self) => throttleShapeEffect_(self, units, duration, costFn, burst);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/throttleShape.mjs
function throttleShape_(self, units, duration, costFn, burst = 0) {
  return throttleShapeEffect_(self, units, duration, (os3) => succeed5(costFn(os3)), burst);
}
function throttleShape(units, duration, costFn, burst = 0) {
  return (self) => throttleShape_(self, units, duration, costFn, burst);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/tick.mjs
function tick(interval) {
  return repeatValueWith(void 0, spaced(interval));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/toPull.mjs
function toPull2(self) {
  return map_14(toPull(self.channel), (pull) => chain_12(mapError_3(pull, some), fold2(() => fail6(none), (elem3) => succeed5(elem3))));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/timeout.mjs
function timeout_3(self, d2) {
  return fromPull2(map_14(toPull2(self), (pull) => timeoutFail_(pull, d2, () => none)));
}
function timeout3(d2) {
  return (self) => timeout_3(self, d2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/timeoutFailCause.mjs
function timeoutFailCause_2(self, cause2, d2) {
  return fromPull2(map_14(toPull2(self), (pull) => timeoutFailCause_(pull, () => map_11(cause2, (_2) => some(_2)), d2)));
}
function timeoutFailCause2(cause2, d2) {
  return (self) => timeoutFailCause_2(self, cause2, d2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/timeoutTo.mjs
var _a7;
var StreamTimeoutSymbol = /* @__PURE__ */ Symbol.for("@matechs/core/symbols/errors/StreamTimeout");
var StreamTimeoutError = class {
  constructor(message) {
    this.message = message;
    this[_a7] = "StreamTimeoutError";
  }
};
_a7 = StreamTimeoutSymbol;
var isStreamTimeoutError = (u2) => u2 instanceof StreamTimeoutError && u2[StreamTimeoutSymbol] === "StreamTimeoutError";
function timeoutTo_2(self, d2, that) {
  return catchSomeCause_3(timeoutFailCause_2(self, die(new StreamTimeoutError()), d2), (e2) => {
    if (e2._tag === "Die") {
      return some(that);
    }
    return none;
  });
}
function timeoutTo2(d2, that) {
  return (self) => timeoutTo_2(self, d2, that);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/timeoutFail.mjs
function timeoutFail_2(self, e2, d2) {
  return timeoutTo_2(self, d2, fail12(e2));
}
function timeoutFail2(e2, d2) {
  return (self) => timeoutFail_2(self, e2, d2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/toQueueDropping.mjs
function toQueueDropping_(self, capacity = 2) {
  return map_14(tap_5(bind_2(do_3, "queue", () => toManagedRelease_(makeDropping(capacity), shutdown)), ({
    queue
  }) => managedFork(runIntoManaged_(self, queue))), ({
    queue
  }) => queue);
}
function toQueueDropping(capacity = 2) {
  return (self) => toQueueDropping_(self, capacity);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/toQueueSliding.mjs
function toQueueSliding_(self, capacity = 2) {
  return map_14(tap_5(bind_2(do_3, "queue", () => toManagedRelease_(makeSliding(capacity), shutdown)), ({
    queue
  }) => managedFork(runIntoManaged_(self, queue))), ({
    queue
  }) => queue);
}
function toQueueSliding(capacity = 2) {
  return (self) => toQueueSliding_(self, capacity);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/unfoldChunk.mjs
function unfoldChunk(s2, f2) {
  const loop6 = (s3) => fold_(f2(s3), () => end(void 0), ({
    tuple: [as6, s4]
  }) => zipRight_4(write(as6), loop6(s4)));
  return new Stream(loop6(s2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/unfold.mjs
function unfold2(s2, f2) {
  return unfoldChunk(s2, (_2) => map_(f2(_2), ({
    tuple: [a2, s3]
  }) => tuple2(single(a2), s3)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/unfoldChunksEffect.mjs
function unfoldChunksLoop(s2, f2) {
  return unwrap2(map_13(f2(s2), fold(() => unit5, ({
    tuple: [as6, s3]
  }) => chain_15(write(as6), () => unfoldChunksLoop(s3, f2)))));
}
function unfoldChunksEffect(s2, f2) {
  return new Stream(unfoldChunksLoop(s2, f2));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/unit.mjs
var unit6 = /* @__PURE__ */ succeed10(void 0);

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/via.mjs
function via_(self, f2) {
  return f2(self);
}
function via(f2) {
  return (self) => via_(self, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/whenEffect.mjs
function whenEffect_(self, b2) {
  return chain_16(fromEffect4(b2), (_2) => _2 ? self : empty7);
}
function whenEffect(b2) {
  return (self) => whenEffect_(self, b2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/when.mjs
function when_2(stream, b2) {
  return whenEffect_(stream, succeed5(b2()));
}
function when3(b2) {
  return (stream) => when_2(stream, b2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/whenCaseEffect.mjs
function whenCaseEffect_(a2, pf) {
  return chain_16(fromEffect4(a2), (_2) => fold_(pf(_2), () => empty7, (s2) => s2));
}
function whenCaseEffect(pf) {
  return (a2) => whenCaseEffect_(a2, pf);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/whenCase.mjs
function whenCase_2(a2, pf) {
  return whenCaseEffect_(succeed5(a2()), pf);
}
function whenCase2(pf) {
  return (a2) => whenCase_2(a2, pf);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/_internal/zipChunks.mjs
function zipChunks_(fa, fb, f2) {
  let fc = empty4();
  const len = Math.min(size4(fa), size4(fb));
  for (let i2 = 0; i2 < len; i2++) {
    fc = append_4(fc, f2(unsafeGet_2(fa, i2), unsafeGet_2(fb, i2)));
  }
  if (size4(fa) > size4(fb)) {
    return tuple2(fc, left(drop_2(fa, size4(fb))));
  }
  return tuple2(fc, right(drop_2(fb, size4(fa))));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/zipWith.mjs
var Running3 = class {
  constructor(excess) {
    this.excess = excess;
    this._tag = "Running";
  }
};
var LeftDone2 = class {
  constructor(excessL) {
    this.excessL = excessL;
    this._tag = "LeftDone";
  }
};
var RightDone2 = class {
  constructor(excessR) {
    this.excessR = excessR;
    this._tag = "RightDone";
  }
};
var End3 = class {
  constructor() {
    this._tag = "End";
  }
};
function handleSuccess(f2, leftUpd, rightUpd, excess) {
  const [leftExcess, rightExcess] = fold_2(excess, (l2) => [l2, empty4()], (r2) => [empty4(), r2]);
  const left4 = fold_(leftUpd, () => leftExcess, (upd) => concat_3(leftExcess, upd));
  const right5 = fold_(rightUpd, () => rightExcess, (upd) => concat_3(rightExcess, upd));
  const {
    tuple: [emit, newExcess]
  } = zipChunks_(left4, right5, f2);
  if (leftUpd._tag === "Some" && rightUpd._tag === "Some") {
    return succeed4(tuple2(emit, new Running3(newExcess)));
  }
  if (leftUpd._tag === "None" && rightUpd._tag === "None") {
    return fail5(none);
  }
  const newState = newExcess._tag === "Left" ? isEmpty5(newExcess.left) ? new End3() : new LeftDone2(newExcess.left) : isEmpty5(newExcess.right) ? new End3() : new RightDone2(newExcess.right);
  return succeed4(tuple2(emit, newState));
}
function zipWith_9(self, that, f2) {
  return combineChunks_(self, that, new Running3(left(empty4())), (st2, p1, p2) => {
    switch (st2._tag) {
      case "End": {
        return succeed5(fail5(none));
      }
      case "Running": {
        return catchAllCause_(zipWithPar_(optional(p1), optional(p2), (l2, r2) => handleSuccess(f2, l2, r2, st2.excess)), (e2) => succeed5(halt(map_11(e2, some))));
      }
      case "LeftDone": {
        return catchAllCause_(map_13(optional(p2), (l2) => handleSuccess(f2, none, l2, left(st2.excessL))), (e2) => succeed5(halt(map_11(e2, some))));
      }
      case "RightDone": {
        return catchAllCause_(map_13(optional(p1), (r2) => handleSuccess(f2, r2, none, right(st2.excessR))), (e2) => succeed5(halt(map_11(e2, some))));
      }
    }
  });
}
function zipWith7(that, f2) {
  return (self) => zipWith_9(self, that, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/zip.mjs
function zip_11(...[s1, s2, ...streams]) {
  const init = zipWith_9(s1, s2, tuple2);
  return reduce_(streams, init, (acc, v2) => (
    // @ts-expect-error
    zipWith_9(acc, v2, (a2, b2) => append_(a2, b2))
  ));
}
function zip10(...[s1, ...streams]) {
  return (self) => (
    // @ts-expect-error
    zip_11(self, s1, ...streams)
  );
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/zipAllWithExec.mjs
var StatusTypeId = /* @__PURE__ */ Symbol();
var RunningTypeId = /* @__PURE__ */ Symbol();
var Running4 = class {
  constructor() {
    this._statusTypeId = StatusTypeId;
    this._typeId = RunningTypeId;
  }
};
var LeftDoneTypeId2 = /* @__PURE__ */ Symbol();
var LeftDone3 = class {
  constructor() {
    this._statusTypeId = StatusTypeId;
    this._typeId = LeftDoneTypeId2;
  }
};
var RightDoneTypeId2 = /* @__PURE__ */ Symbol();
var RightDone3 = class {
  constructor() {
    this._statusTypeId = StatusTypeId;
    this._typeId = RightDoneTypeId2;
  }
};
var EndTypeId3 = /* @__PURE__ */ Symbol();
var End4 = class {
  constructor() {
    this._statusTypeId = StatusTypeId;
    this._typeId = EndTypeId3;
  }
};
function zipAllWithExec_(self, that, exec, left4, right5, both) {
  const handleSuccess2 = (maybeO, maybeA1, excess) => {
    const {
      tuple: [excessL, excessR]
    } = fold_2(excess, (l2) => tuple2(l2, empty4()), (r2) => tuple2(empty4(), r2));
    const chunkL = fold_(maybeO, () => excessL, (upd) => concat_3(excessL, upd));
    const chunkR = fold_(maybeA1, () => excessR, (upd) => concat_3(excessR, upd));
    const {
      tuple: [emit, newExcess]
    } = zipChunks_(chunkL, chunkR, both);
    const {
      tuple: [fullEmit, status]
    } = (() => {
      if (isSome(maybeO)) {
        if (isSome(maybeA1)) {
          return tuple2(emit, new Running4());
        } else {
          return tuple2(emit, new RightDone3());
        }
      } else {
        if (isSome(maybeA1)) {
          return tuple2(emit, new LeftDone3());
        } else {
          const leftover = fold_2(newExcess, map5(left4), map5(right5));
          return tuple2(concat_3(emit, leftover), new End4());
        }
      }
    })();
    return succeed4(tuple2(fullEmit, tuple2(status, newExcess)));
  };
  return combineChunks_(self, that, tuple2(new Running4(), left(empty4())), ({
    tuple: [status, excess]
  }, pullL, pullR) => {
    switch (status._typeId) {
      case RunningTypeId: {
        if (exec._tag === "Sequential") {
          return catchAllCause_(zipWith_4(unoption(pullL), unoption(pullR), (a2, b2) => handleSuccess2(a2, b2, excess)), (e2) => succeed5(failCause(map_11(e2, some))));
        } else {
          return catchAllCause_(zipWithPar(unoption(pullR), (a2, b2) => handleSuccess2(a2, b2, excess))(unoption(pullL)), (e2) => succeed5(failCause(map_11(e2, some))));
        }
      }
      case LeftDoneTypeId2:
        return catchAllCause_(map_13(unoption(pullR), (_2) => handleSuccess2(none, _2, excess)), (e2) => succeed5(failCause(map_11(e2, some))));
      case RightDoneTypeId2:
        return catchAllCause_(map_13(unoption(pullL), (_2) => handleSuccess2(_2, none, excess)), (e2) => succeed5(failCause(map_11(e2, some))));
      case EndTypeId3:
        return succeed5(fail5(none));
    }
  });
}
function zipAllWithExec(that, exec, left4, right5, both) {
  return (self) => zipAllWithExec_(self, that, exec, left4, right5, both);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/zipAllWith.mjs
function zipAllWith_2(self, that, left4, right5, both) {
  return zipAllWithExec_(self, that, parallel, left4, right5, both);
}
function zipAllWith2(that, left4, right5, both) {
  return (self) => zipAllWith_2(self, that, left4, right5, both);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/zipAll.mjs
function zipAll_2(self, that, defaultLeft, defaultRight) {
  return zipAllWith_2(self, that, (_2) => tuple2(_2, defaultRight), (_2) => tuple2(defaultLeft, _2), (a2, b2) => tuple2(a2, b2));
}
function zipAll2(that, defaultLeft, defaultRight) {
  return (self) => zipAll_2(self, that, defaultLeft, defaultRight);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/zipAllLeft.mjs
function zipAllLeft_(self, that, default_) {
  return zipAllWith_2(self, that, identity, (_2) => default_, (o2, _2) => o2);
}
function zipAllLeft(that, default_) {
  return (self) => zipAllLeft_(self, that, default_);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/zipAllRight.mjs
function zipAllRight_(self, that, default_) {
  return zipAllWith_2(self, that, (_2) => default_, identity, (_2, o2) => o2);
}
function zipAllRight(that, default_) {
  return (self) => zipAllRight_(self, that, default_);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/zipLeft.mjs
function zipLeft_3(self, that) {
  return zipWith_9(self, that, (o2, _2) => o2);
}
function zipLeft4(that) {
  return (self) => zipLeft_3(self, that);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/zipRight.mjs
function zipRight_6(self, that) {
  return zipWith_9(self, that, (_2, o2) => o2);
}
function zipRight4(that) {
  return (self) => zipRight_6(self, that);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/zipWithLatest.mjs
function zipWithLatest_(self, that, f2) {
  const pullNonEmpty = (pull) => chain_12(pull, (chunk2) => isEmpty5(chunk2) ? pullNonEmpty(pull) : succeed5(chunk2));
  return fromPull2(map_14(bind_2(chain_13(bindAll_2(do_3, () => ({
    left: map_14(toPull2(self), pullNonEmpty),
    right: map_14(toPull2(that), pullNonEmpty)
  })), ({
    left: left4,
    right: right5
  }) => fromEffect(transplant((graft) => succeed5({
    left: graft(left4),
    right: graft(right5)
  })))), "pull", ({
    left: left4,
    right: right5
  }) => toPull2(chain_16(fromEffectOption(raceWith_(left4, right5, (leftDone, rightFiber) => zipWith_4(done(leftDone), join(rightFiber), (l2, r2) => tuple2(l2, r2, true)), (rightDone, leftFiber) => zipWith_4(done(rightDone), join(leftFiber), (r2, l2) => tuple2(l2, r2, false)))), ({
    tuple: [l2, r2, leftFirst]
  }) => chain_16(fromEffect4(makeRef(tuple2(unsafeGet_2(l2, size4(l2) - 1), unsafeGet_2(r2, size4(r2) - 1)))), (latest) => concat_4(fromChunk(leftFirst ? map_8(r2, (_2) => f2(unsafeGet_2(l2, size4(l2) - 1), _2)) : map_8(l2, (_2) => f2(_2, unsafeGet_2(r2, size4(r2) - 1)))), chain_16(mapEffect_3(mergeEither_(repeatEffectOption(left4), repeatEffectOption(right5)), fold2((leftChunk) => modify_2(latest, ({
    tuple: [_2, rightLatest]
  }) => tuple2(map_8(leftChunk, (_3) => f2(_3, rightLatest)), tuple2(unsafeGet_2(leftChunk, size4(leftChunk) - 1), rightLatest))), (rightChunk) => modify_2(latest, ({
    tuple: [leftLatest, _2]
  }) => tuple2(map_8(rightChunk, (_3) => f2(leftLatest, _3)), tuple2(leftLatest, unsafeGet_2(rightChunk, size4(rightChunk) - 1)))))), fromChunk)))))), ({
    pull
  }) => pull));
}
function zipWithLatest(that, f2) {
  return (self) => zipWithLatest_(self, that, f2);
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/zipWithNext.mjs
function zipWithNext(self) {
  const process2 = (last4) => readWith((in_2) => {
    const {
      tuple: [newlast, chunk2]
    } = mapAccum_(in_2, last4, (prev, curr) => tuple2(some(curr), map_(prev, (_2) => tuple2(_2, curr))));
    const out = collect_2(chunk2, fold(() => none, ({
      tuple: [prev, curr]
    }) => some(tuple2(prev, some(curr)))));
    return zipRight_4(write(out), process2(newlast));
  }, (err) => fail10(err), (_2) => fold_(last4, () => unit5, (value) => zipRight_4(write(single(tuple2(value, none))), unit5)));
  return new Stream(self.channel[">>>"](process2(none)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/zipWithPrevious.mjs
function zipWithPrevious(self) {
  return mapAccum_2(self, emptyOf(), (prev, next2) => tuple2(some(next2), tuple2(prev, next2)));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/api/zipWithPreviousAndNext.mjs
function zipWithPreviousAndNext(self) {
  return map_20(zipWithNext(zipWithPrevious(self)), ({
    tuple: [{
      tuple: [prev, curr]
    }, next2]
  }) => tuple2(prev, curr, map_(next2, get(1))));
}

// node_modules/@effect-ts/system/_mjs/Experimental/Stream/_internal/do.mjs
function bind6(tag2, f2) {
  return (mk) => chain_16(mk, (k2) => map_20(f2(k2), (a2) => ({
    ...k2,
    [tag2]: a2
  })));
}
function let_6(tag2, f2) {
  return (mk) => map_20(mk, (k2) => ({
    ...k2,
    [tag2]: f2(k2)
  }));
}
var do_6 = /* @__PURE__ */ fromEffect4(/* @__PURE__ */ succeed5({}));

// node_modules/@contentlayer2/utils/dist/effect/Stream.js
var streamTapSkipFirst = (f2) => (stream) => pipe(stream, mapAccumEffect2(0, (x2, o2) => gen4(function* (_2) {
  if (x2 > 0) {
    yield* _2(f2(o2));
  }
  return tuple2(x2 + 1, o2);
})));
var tapSkipFirstRight = (f2) => (stream) => pipe(stream, zipWithIndex2, tap6(({ tuple: [val, index] }) => index === 0 || isLeft(val) ? succeed5(null) : f2(val.right)), map13(({ tuple: [val] }) => val));
var tapRight = (f2) => (stream) => pipe(stream, tap6((val) => isLeft(val) ? succeed5(null) : f2(val.right)));
var tapLeft = (f2) => (stream) => pipe(stream, tap6((val) => isLeft(val) ? f2(val.left) : succeed5(null)));
var tapRightEither = (f2) => (stream) => pipe(stream, tap6((val) => isLeft(val) ? succeed5(null) : f2(val.right)));
var startWith = (...values3) => (stream) => merge_(stream, fromChunk(from3(values3)));
var startWithRight = (value) => (stream) => merge_(stream, fromIterable([right(value)]));
var chainMapEitherRight = (mapRight) => (stream) => {
  return chain_16(stream, fold2((_left) => stream, (right5) => mapRight(right5)));
};
var chainSwitchMapEitherRight = (mapRight) => (stream) => {
  return chainParSwitch(fold2((_left) => stream, (right5) => mapRight(right5)), 1)(stream);
};
var mapEffectEitherRight = (mapRight) => (stream) => {
  return mapEffect_3(stream, fold2((left4) => succeed5(leftW(left4)), (right5) => mapRight(right5)));
};
var mapEitherLeft = (mapLeft2) => (stream) => {
  return map_20(stream, mapLeft(mapLeft2));
};
var mapEitherRight = (mapRight) => (stream) => {
  return map_20(stream, map2(mapRight));
};
var fromValue2 = (a2) => fromEffect4(succeed5(a2));

// node_modules/@contentlayer2/utils/dist/effect/Effect.js
var Effect_exports3 = {};
__export(Effect_exports3, {
  Access: () => Access2,
  Any: () => Any,
  Applicative: () => Applicative,
  AssociativeBoth: () => AssociativeBoth,
  AssociativeEither: () => AssociativeEither,
  AssociativeFlatten: () => AssociativeFlatten,
  Base: () => Base2,
  Category: () => Category,
  Covariant: () => Covariant,
  CustomRuntime: () => CustomRuntime,
  EffectURI: () => EffectURI,
  Fail: () => Fail3,
  ForkScopeRestore: () => ForkScopeRestore,
  GenEffect: () => GenEffect,
  ICheckInterrupt: () => ICheckInterrupt,
  ICheckTracingStatus: () => ICheckTracingStatus,
  IDescriptor: () => IDescriptor,
  IEffectAsync: () => IEffectAsync,
  IEffectPartial: () => IEffectPartial,
  IEffectTotal: () => IEffectTotal,
  IFail: () => IFail,
  IFiberRefModify: () => IFiberRefModify,
  IFiberRefNew: () => IFiberRefNew,
  IFlatMap: () => IFlatMap,
  IFold: () => IFold,
  IFork: () => IFork,
  IGetForkScope: () => IGetForkScope,
  IInterruptStatus: () => IInterruptStatus,
  IOverrideForkScope: () => IOverrideForkScope,
  IPlatform: () => IPlatform,
  IProvide: () => IProvide,
  IRaceWith: () => IRaceWith,
  IRead: () => IRead,
  ISucceed: () => ISucceed,
  ISupervise: () => ISupervise,
  ISuspend: () => ISuspend,
  ISuspendPartial: () => ISuspendPartial,
  ITrace: () => ITrace,
  ITracer: () => ITracer,
  ITracingStatus: () => ITracingStatus,
  IYield: () => IYield,
  IdentityBoth: () => IdentityBoth,
  IdentityFlatten: () => IdentityFlatten,
  InterruptStatusRestoreImpl: () => InterruptStatusRestoreImpl,
  Monad: () => Monad,
  Parallel: () => Parallel2,
  ParallelN: () => ParallelN,
  Provide: () => Provide2,
  Run: () => Run,
  Sequential: () => Sequential2,
  _A: () => _A,
  _C: () => _C,
  _E: () => _E,
  _I: () => _I,
  _L: () => _L,
  _O: () => _O,
  _R: () => _R,
  _RIn: () => _RIn,
  _ROut: () => _ROut,
  _S1: () => _S1,
  _S2: () => _S2,
  _T: () => _T,
  _U: () => _U,
  _W: () => _W,
  absolve: () => absolve,
  absorb: () => absorb,
  absorbWith: () => absorbWith,
  absorbWith_: () => absorbWith_,
  access: () => access3,
  accessM: () => accessM3,
  accessService: () => accessService2,
  accessServiceM: () => accessServiceM2,
  accessServices: () => accessServices,
  accessServicesM: () => accessServicesM,
  accessServicesT: () => accessServicesT,
  accessServicesTM: () => accessServicesTM,
  andThen: () => andThen,
  andThen_: () => andThen_,
  ap: () => ap4,
  ap_: () => ap_3,
  as: () => as2,
  asService: () => asService,
  asService_: () => asService_,
  asSome: () => asSome,
  asSomeError: () => asSomeError,
  asUnit: () => asUnit,
  as_: () => as_,
  awaitAllChildren: () => awaitAllChildren,
  bimap: () => bimap4,
  bimap_: () => bimap_3,
  bind: () => bind2,
  bindAll: () => bindAll,
  bindAllPar: () => bindAllPar,
  bindAllParN: () => bindAllParN,
  bindAllParN_: () => bindAllParN_,
  bindAllPar_: () => bindAllPar_,
  bindAll_: () => bindAll_,
  bind_: () => bind_,
  bracket: () => bracket,
  bracketExit: () => bracketExit,
  bracketExit_: () => bracketExit_,
  bracketFiber: () => bracketFiber,
  bracketFiber_: () => bracketFiber_,
  bracketOnError: () => bracketOnError,
  bracketOnError_: () => bracketOnError_,
  bracket_: () => bracket_,
  cached: () => cached,
  cachedInvalidate: () => cachedInvalidate,
  cachedInvalidate_: () => cachedInvalidate_,
  cached_: () => cached_,
  catch: () => _catch,
  catchAll: () => catchAll2,
  catchAllCause: () => catchAllCause,
  catchAllCause_: () => catchAllCause_,
  catchAllDefect: () => catchAllDefect,
  catchAllDefect_: () => catchAllDefect_,
  catchAll_: () => catchAll_2,
  catchSome: () => catchSome,
  catchSomeCause: () => catchSomeCause,
  catchSomeCause_: () => catchSomeCause_,
  catchSomeDefect: () => catchSomeDefect,
  catchSomeDefect_: () => catchSomeDefect_,
  catchSome_: () => catchSome_,
  catchTag: () => catchTag,
  catchTag_: () => catchTag_,
  catch_: () => catch_,
  cause: () => cause,
  chain: () => chain8,
  chainError: () => chainError,
  chainError_: () => chainError_,
  chainMergeObject: () => chainMergeObject,
  chain_: () => chain_12,
  checkInterruptible: () => checkInterruptible,
  checkPlatform: () => checkPlatform,
  checkTraced: () => checkTraced,
  collect: () => collect2,
  collectAll: () => collectAll2,
  collectAllPar: () => collectAllPar2,
  collectAllParN: () => collectAllParN,
  collectAllParN_: () => collectAllParN_,
  collectAllSuccesses: () => collectAllSuccesses,
  collectAllSuccessesPar: () => collectAllSuccessesPar,
  collectAllSuccessesParN: () => collectAllSuccessesParN,
  collectAllUnit: () => collectAllUnit,
  collectAllUnitPar: () => collectAllUnitPar,
  collectAllUnitParN: () => collectAllUnitParN,
  collectAllUnitParN_: () => collectAllUnitParN_,
  collectAllWith: () => collectAllWith,
  collectAllWithPar: () => collectAllWithPar,
  collectAllWithParN: () => collectAllWithParN,
  collectAllWithParN_: () => collectAllWithParN_,
  collectAllWithPar_: () => collectAllWithPar_,
  collectAllWith_: () => collectAllWith_,
  collectPar: () => collectPar,
  collectParN: () => collectParN,
  collectParN_: () => collectParN_,
  collectPar_: () => collectPar_,
  collect_: () => collect_3,
  compose: () => compose,
  compose_: () => compose_2,
  cond: () => cond,
  condM: () => condM,
  condM_: () => condM_,
  cond_: () => cond_,
  continueOrFail: () => continueOrFail,
  continueOrFailM: () => continueOrFailM,
  continueOrFailM_: () => continueOrFailM_,
  continueOrFail_: () => continueOrFail_,
  debugLogEnv: () => debugLogEnv,
  defaultEnv: () => defaultEnv,
  defaultPlatform: () => defaultPlatform,
  defaultRuntime: () => defaultRuntime,
  delay: () => delay,
  delay_: () => delay_,
  deriveAccess: () => deriveAccess,
  deriveAccessM: () => deriveAccessM,
  deriveLifted: () => deriveLifted,
  descriptor: () => descriptor2,
  descriptorWith: () => descriptorWith,
  die: () => die3,
  dieMessage: () => dieMessage,
  dieWith: () => dieWith,
  disconnect: () => disconnect,
  do: () => do_2,
  done: () => done,
  dropWhile: () => dropWhile,
  dropWhile_: () => dropWhile_,
  effectAsync: () => effectAsync,
  effectAsyncBlockingOn: () => effectAsyncBlockingOn,
  effectAsyncInterrupt: () => effectAsyncInterrupt,
  effectAsyncInterruptBlockingOn: () => effectAsyncInterruptBlockingOn,
  effectAsyncM: () => effectAsyncM,
  effectAsyncOption: () => effectAsyncOption,
  effectAsyncOptionBlockingOn: () => effectAsyncOptionBlockingOn,
  effectMaybeAsyncInterrupt: () => effectMaybeAsyncInterrupt,
  effectMaybeAsyncInterruptBlockingOn: () => effectMaybeAsyncInterruptBlockingOn,
  either: () => either2,
  eitherMap: () => eitherMap,
  ensuring: () => ensuring,
  ensuringChild: () => ensuringChild,
  ensuringChild_: () => ensuringChild_,
  ensuringChildren: () => ensuringChildren,
  ensuringChildren_: () => ensuringChildren_,
  ensuring_: () => ensuring_,
  environment: () => environment2,
  eventually: () => eventually,
  fail: () => fail6,
  failWith: () => failWith,
  fiberId: () => fiberId,
  filter: () => filter3,
  filterNot: () => filterNot,
  filterNotPar: () => filterNotPar,
  filterNotParN: () => filterNotParN,
  filterNotParN_: () => filterNotParN_,
  filterNotPar_: () => filterNotPar_,
  filterNot_: () => filterNot_,
  filterOrDie: () => filterOrDie,
  filterOrDieMessage: () => filterOrDieMessage,
  filterOrDieMessage_: () => filterOrDieMessage_,
  filterOrDie_: () => filterOrDie_,
  filterOrElse: () => filterOrElse2,
  filterOrElse_: () => filterOrElse_2,
  filterOrFail: () => filterOrFail,
  filterOrFail_: () => filterOrFail_,
  filterPar: () => filterPar,
  filterParN: () => filterParN,
  filterParN_: () => filterParN_,
  filterPar_: () => filterPar_,
  filter_: () => filter_5,
  first: () => first2,
  firstSuccessOf: () => firstSuccessOf,
  flatten: () => flatten8,
  flattenErrorOption: () => flattenErrorOption,
  flattenErrorOption_: () => flattenErrorOption_,
  flip: () => flip,
  flipWith: () => flipWith,
  flipWith_: () => flipWith_,
  fold: () => fold6,
  foldCause: () => foldCause,
  foldCauseM: () => foldCauseM,
  foldCauseM_: () => foldCauseM_,
  foldCause_: () => foldCause_,
  foldM: () => foldM2,
  foldM_: () => foldM_2,
  fold_: () => fold_5,
  forEach: () => forEach4,
  forEachExec: () => forEachExec,
  forEachExec_: () => forEachExec_,
  forEachOf: () => forEachOf,
  forEachPar: () => forEachPar,
  forEachParDict: () => forEachParDict,
  forEachParDict_: () => forEachParDict_,
  forEachParN: () => forEachParN,
  forEachParNOf: () => forEachParNOf,
  forEachParN_: () => forEachParN_,
  forEachParOf: () => forEachParOf,
  forEachParWithIndex: () => forEachParWithIndex,
  forEachParWithIndexN: () => forEachParWithIndexN,
  forEachParWithIndexN_: () => forEachParWithIndexN_,
  forEachParWithIndex_: () => forEachParWithIndex_,
  forEachPar_: () => forEachPar_,
  forEachUnit: () => forEachUnit,
  forEachUnitPar: () => forEachUnitPar,
  forEachUnitParN: () => forEachUnitParN,
  forEachUnitParN_: () => forEachUnitParN_,
  forEachUnitPar_: () => forEachUnitPar_,
  forEachUnit_: () => forEachUnit_,
  forEachWithIndex: () => forEachWithIndex2,
  forEachWithIndex_: () => forEachWithIndex_2,
  forEach_: () => forEach_5,
  forever: () => forever2,
  fork: () => fork,
  forkAll: () => forkAll,
  forkAllUnit: () => forkAllUnit,
  forkAs: () => forkAs,
  forkAs_: () => forkAs_,
  forkDaemon: () => forkDaemon,
  forkDaemonReport: () => forkDaemonReport,
  forkDaemonReport_: () => forkDaemonReport_,
  forkIn: () => forkIn,
  forkInReport: () => forkInReport,
  forkInReport_: () => forkInReport_,
  forkIn_: () => forkIn_,
  forkManaged: () => forkManaged,
  forkReport: () => forkReport,
  forkReport_: () => forkReport_,
  forkScope: () => forkScope,
  forkScopeMask: () => forkScopeMask,
  forkScopeMask_: () => forkScopeMask_,
  forkScopeWith: () => forkScopeWith,
  forkWithErrorHandler: () => forkWithErrorHandler,
  forkWithErrorHandler_: () => forkWithErrorHandler_,
  fromAsync: () => fromAsync,
  fromEither: () => fromEither2,
  fromFiber: () => fromFiber,
  fromFiberM: () => fromFiberM,
  fromIO: () => fromIO,
  fromNodeCb: () => fromNodeCb,
  fromNullable: () => fromNullable3,
  fromOption: () => fromOption3,
  fromPredicate: () => fromPredicate3,
  gen: () => gen4,
  genM: () => genM,
  get: () => get6,
  getIdentity: () => getIdentity,
  getIdentityPar: () => getIdentityPar,
  getOrFail: () => getOrFail,
  getOrFailUnit: () => getOrFailUnit,
  getValidationApplicative: () => getValidationApplicative,
  halt: () => halt2,
  haltWith: () => haltWith,
  head: () => head4,
  if: () => _if,
  ifM: () => ifM,
  ifM_: () => ifM_,
  if_: () => if_,
  ignore: () => ignore,
  in: () => _in,
  in_: () => in_,
  instruction: () => instruction,
  interrupt: () => interrupt3,
  interruptAllChildren: () => interruptAllChildren,
  interruptAs: () => interruptAs,
  interruptStatus: () => interruptStatus,
  interruptStatus_: () => interruptStatus_,
  interruptible: () => interruptible2,
  interruptibleMask: () => interruptibleMask,
  isFailure: () => isFailure,
  isSuccess: () => isSuccess,
  iterate: () => iterate,
  join: () => join2,
  joinEither: () => joinEither,
  joinEither_: () => joinEither_,
  join_: () => join_,
  left: () => left2,
  leftOrFail: () => leftOrFail,
  leftOrFailException: () => leftOrFailException,
  leftOrFail_: () => leftOrFail_,
  let: () => let__,
  let_: () => let_2,
  log: () => log2,
  loop: () => loop,
  loopUnit: () => loopUnit,
  makeCustomRuntime: () => makeCustomRuntime,
  map: () => map9,
  mapBoth: () => mapBoth,
  mapBoth_: () => mapBoth_2,
  mapError: () => mapError2,
  mapErrorCause: () => mapErrorCause2,
  mapErrorCause_: () => mapErrorCause_,
  mapError_: () => mapError_3,
  mapN: () => mapN,
  mapNPar: () => mapNPar,
  mapNParN: () => mapNParN,
  mapNParN_: () => mapNParN_,
  mapNPar_: () => mapNPar_,
  mapN_: () => mapN_,
  mapTryCatch: () => mapTryCatch,
  mapTryCatch_: () => mapTryCatch_,
  map_: () => map_13,
  match: () => match,
  matchIn: () => matchIn,
  matchMorph: () => matchMorph,
  matchTag: () => matchTag2,
  matchTagIn: () => matchTagIn,
  memoize: () => memoize,
  memoizeEq: () => memoizeEq,
  merge: () => merge2,
  mergeAll: () => mergeAll,
  mergeAllPar: () => mergeAllPar,
  mergeAllParN: () => mergeAllParN,
  mergeAllParN_: () => mergeAllParN_,
  mergeAllPar_: () => mergeAllPar_,
  mergeAll_: () => mergeAll_,
  never: () => never,
  noEnv: () => noEnv,
  none: () => none3,
  onError: () => onError,
  onError_: () => onError_,
  onExit: () => onExit2,
  onExit_: () => onExit_2,
  onFirst: () => onFirst,
  onInterrupt: () => onInterrupt,
  onInterruptExtended_: () => onInterruptExtended_,
  onInterrupt_: () => onInterrupt_,
  onLeft: () => onLeft,
  onRight: () => onRight,
  onSecond: () => onSecond,
  onTermination: () => onTermination,
  onTermination_: () => onTermination_,
  once: () => once,
  onlyDefaultEnv: () => onlyDefaultEnv,
  option: () => option,
  optional: () => optional,
  orDie: () => orDie,
  orDieKeep: () => orDieKeep,
  orDieWith: () => orDieWith,
  orDieWith_: () => orDieWith_,
  orElse: () => orElse2,
  orElseEither: () => orElseEither3,
  orElseEither_: () => orElseEither_3,
  orElseFail: () => orElseFail2,
  orElseFail_: () => orElseFail_,
  orElseOptional: () => orElseOptional,
  orElseOptional_: () => orElseOptional_,
  orElseSucceed: () => orElseSucceed,
  orElseSucceed_: () => orElseSucceed_,
  orElse_: () => orElse_2,
  overrideForkScope: () => overrideForkScope,
  overrideForkScope_: () => overrideForkScope_,
  parallel: () => parallel,
  parallelErrors: () => parallelErrors,
  parallelN: () => parallelN,
  partition: () => partition,
  partitionPar: () => partitionPar,
  partitionParN: () => partitionParN,
  partitionParN_: () => partitionParN_,
  partitionPar_: () => partitionPar_,
  partition_: () => partition_,
  prettyReporter: () => prettyReporter,
  promise: () => promise,
  provide: () => provide2,
  provideAll: () => provideAll2,
  provideAll_: () => provideAll_3,
  provideLayer: () => provideLayer,
  provideLayer_: () => provideLayer_,
  provideService: () => provideService,
  provideServiceM: () => provideServiceM,
  provideServiceM_: () => provideServiceM_,
  provideServiceManaged: () => provideServiceManaged,
  provideService_: () => provideService_,
  provideSome: () => provideSome2,
  provideSomeLayer: () => provideSomeLayer,
  provideSomeLayer_: () => provideSomeLayer_,
  provideSomeManaged: () => provideSomeManaged,
  provideSome_: () => provideSome_,
  provide_: () => provide_,
  race: () => race,
  raceAll: () => raceAll,
  raceAllWait: () => raceAllWait,
  raceAllWithStrategy: () => raceAllWithStrategy,
  raceEither: () => raceEither,
  raceEither_: () => raceEither_,
  raceFirst: () => raceFirst,
  raceFirst_: () => raceFirst_,
  raceWith: () => raceWith,
  raceWithScope: () => raceWithScope,
  raceWithScope_: () => raceWithScope_,
  raceWith_: () => raceWith_,
  race_: () => race_,
  reduce: () => reduce3,
  reduceAll: () => reduceAll,
  reduceAllPar: () => reduceAllPar,
  reduceAllParN: () => reduceAllParN,
  reduceAllParN_: () => reduceAllParN_,
  reduceAllPar_: () => reduceAllPar_,
  reduceAll_: () => reduceAll_,
  reduceRight: () => reduceRight3,
  reduceRight_: () => reduceRight_6,
  reduce_: () => reduce_6,
  refailWithTrace: () => refailWithTrace,
  refineOrDie: () => refineOrDie,
  refineOrDieWith: () => refineOrDieWith,
  refineOrDieWith_: () => refineOrDieWith_,
  refineOrDie_: () => refineOrDie_,
  reject: () => reject,
  rejectM: () => rejectM,
  rejectM_: () => rejectM_,
  reject_: () => reject_,
  repeat: () => repeat,
  repeatN: () => repeatN,
  repeatN_: () => repeatN_,
  repeatOrElse: () => repeatOrElse,
  repeatOrElseEither: () => repeatOrElseEither,
  repeatOrElseEither_: () => repeatOrElseEither_,
  repeatOrElse_: () => repeatOrElse_,
  repeatUntil: () => repeatUntil,
  repeatUntilM: () => repeatUntilM,
  repeatUntilM_: () => repeatUntilM_,
  repeatUntil_: () => repeatUntil_,
  repeatWhile: () => repeatWhile,
  repeatWhileM: () => repeatWhileM,
  repeatWhileM_: () => repeatWhileM_,
  repeatWhile_: () => repeatWhile_,
  repeat_: () => repeat_,
  replaceService: () => replaceService,
  replaceServiceM: () => replaceServiceM,
  replaceServiceM_: () => replaceServiceM_,
  replaceService_: () => replaceService_,
  replicate: () => replicate,
  replicateMUnit: () => replicateMUnit,
  replicateMUnit_: () => replicateMUnit_,
  replicate_: () => replicate_,
  require: () => _require,
  require_: () => require_,
  reserve: () => reserve2,
  reserve_: () => reserve_,
  resetForkScope: () => resetForkScope,
  result: () => result,
  resurrect: () => resurrect,
  retry: () => retry,
  retryOrElse: () => retryOrElse,
  retryOrElseEither: () => retryOrElseEither,
  retryOrElseEither_: () => retryOrElseEither_,
  retryOrElse_: () => retryOrElse_,
  retryUntil: () => retryUntil,
  retryUntilM: () => retryUntilM,
  retryUntilM_: () => retryUntilM_,
  retryUntil_: () => retryUntil_,
  retryWhile: () => retryWhile,
  retryWhileM: () => retryWhileM,
  retryWhileM_: () => retryWhileM_,
  retryWhile_: () => retryWhile_,
  retry_: () => retry_,
  right: () => right2,
  rightOrFail: () => rightOrFail2,
  run: () => run4,
  runCancel: () => runCancel,
  runFiber: () => runFiber,
  runPromise: () => runPromise,
  runPromiseExit: () => runPromiseExit,
  runtime: () => runtime,
  sandbox: () => sandbox,
  sandboxWith: () => sandboxWith,
  sandboxWith_: () => sandboxWith_,
  scopeWith: () => scopeWith,
  second: () => second,
  sequential: () => sequential,
  service: () => service,
  services: () => services,
  sleep: () => sleep2,
  some: () => some2,
  someOrElse: () => someOrElse,
  someOrElseM: () => someOrElseM,
  someOrElseM_: () => someOrElseM_,
  someOrElse_: () => someOrElse_,
  someOrFail: () => someOrFail,
  someOrFailException: () => someOrFailException,
  someOrFail_: () => someOrFail_,
  struct: () => struct,
  structPar: () => structPar,
  structParN: () => structParN,
  structParN_: () => structParN_,
  succeed: () => succeed5,
  succeedWith: () => succeedWith3,
  summarized: () => summarized,
  summarized_: () => summarized_,
  supervised: () => supervised,
  supervised_: () => supervised_,
  suspend: () => suspend4,
  swap: () => swap2,
  sync: () => sync,
  tap: () => tap4,
  tapBoth: () => tapBoth,
  tapBoth_: () => tapBoth_,
  tapCause: () => tapCause,
  tapCauseLogPretty: () => tapCauseLogPretty,
  tapCause_: () => tapCause_,
  tapEither: () => tapEither,
  tapEither_: () => tapEither_,
  tapError: () => tapError,
  tapError_: () => tapError_,
  tapExit: () => tapExit,
  tapExit_: () => tapExit_,
  tapSync: () => tapSync,
  tap_: () => tap_4,
  timed: () => timed,
  timedWith: () => timedWith,
  timedWith_: () => timedWith_,
  timeout: () => timeout,
  timeoutFail: () => timeoutFail,
  timeoutFailCause: () => timeoutFailCause,
  timeoutFailCause_: () => timeoutFailCause_,
  timeoutFail_: () => timeoutFail_,
  timeoutTo: () => timeoutTo,
  timeoutTo_: () => timeoutTo_,
  timeout_: () => timeout_,
  to: () => to,
  toLayer: () => toLayer,
  toLayerRaw: () => toLayerRaw,
  toLeft: () => toLeft,
  toLeftWith: () => toLeftWith,
  toManaged: () => toManaged,
  toManagedRelease: () => toManagedRelease,
  toManagedRelease_: () => toManagedRelease_,
  to_: () => to_,
  trace: () => trace2,
  traced: () => traced2,
  tracedMask: () => tracedMask,
  tracingStatus: () => tracingStatus,
  tracingStatus_: () => tracingStatus_,
  transplant: () => transplant,
  try: () => try_,
  tryCatch: () => tryCatch4,
  tryCatchOption: () => tryCatchOption,
  tryCatchPromise: () => tryCatchPromise,
  tryCatchSuspend: () => tryCatchSuspend,
  tryOrElse: () => tryOrElse,
  tryOrElse_: () => tryOrElse_,
  tryPromise: () => tryPromise,
  tryPromiseOrDie: () => tryPromiseOrDie,
  tuple: () => tuple3,
  tuplePar: () => tuplePar,
  tupleParN: () => tupleParN,
  uncause: () => uncause,
  unfailable: () => unfailable,
  uninterruptible: () => uninterruptible2,
  uninterruptibleMask: () => uninterruptibleMask,
  union: () => union,
  unionFn: () => unionFn,
  unit: () => unit3,
  unitTraced: () => unitTraced,
  unless: () => unless,
  unlessM: () => unlessM,
  unlessM_: () => unlessM_,
  unless_: () => unless_,
  unoption: () => unoption,
  unrefine: () => unrefine,
  unrefineWith: () => unrefineWith,
  unrefineWith_: () => unrefineWith_,
  unrefine_: () => unrefine_,
  unsandbox: () => unsandbox,
  unsome: () => unsome,
  untraced: () => untraced2,
  untracedMask: () => untracedMask,
  updateService: () => updateService,
  updateService_: () => updateService_,
  validate: () => validate,
  validateExec: () => validateExec,
  validateExec_: () => validateExec_,
  validateFirst: () => validateFirst,
  validateFirstPar: () => validateFirstPar,
  validateFirstParN: () => validateFirstParN,
  validateFirstParN_: () => validateFirstParN_,
  validateFirstPar_: () => validateFirstPar_,
  validateFirst_: () => validateFirst_,
  validatePar: () => validatePar,
  validateParN: () => validateParN,
  validateParN_: () => validateParN_,
  validatePar_: () => validatePar_,
  validate_: () => validate_,
  when: () => when,
  whenCase: () => whenCase,
  whenCase_: () => whenCase_,
  whenM: () => whenM,
  whenM_: () => whenM_,
  when_: () => when_,
  withChildren: () => withChildren,
  withRuntime: () => withRuntime,
  withRuntimeM: () => withRuntimeM,
  yieldNow: () => yieldNow,
  zip: () => zip5,
  zipLeft: () => zipLeft2,
  zipLeftPar: () => zipLeftPar,
  zipLeftPar_: () => zipLeftPar_,
  zipLeft_: () => zipLeft_,
  zipPar: () => zipPar2,
  zipPar_: () => zipPar_,
  zipRight: () => zipRight2,
  zipRightPar: () => zipRightPar,
  zipRightPar_: () => zipRightPar_,
  zipRight_: () => zipRight_2,
  zipWith: () => zipWith3,
  zipWithPar: () => zipWithPar,
  zipWithPar_: () => zipWithPar_,
  zipWith_: () => zipWith_4,
  zip_: () => zip_4
});
var log_ = Effect_exports2.deriveLifted(ConsoleService)(["log"], [], []);
var log2 = log_.log;
var rightOrFail2 = (effect2, __trace) => Effect_exports2.chain_(effect2, Either_exports2.fold((x2) => Effect_exports2.fail(x2, __trace), (x2) => Effect_exports2.succeed(x2, __trace)));
var tapCauseLogPretty = (eff) => Effect_exports2.tapCause_(eff, (err) => Effect_exports2.succeedWith(() => console.error(Cause_exports2.pretty(err))));
var debugLogEnv = (msg) => pipe(Effect_exports2.environment(), Effect_exports2.tap((env) => log2(msg ?? "debugLogEnv", env)));
var tryPromiseOrDie = (promise2) => pipe(Effect_exports2.tryPromise(promise2), Effect_exports2.orDie);
var sync = (fn) => Effect_exports2.succeedWith(fn);
var eitherMap = (mapRight) => (effect2, __trace) => Effect_exports2.map_(effect2, Either_exports2.map(mapRight));
var chainMergeObject = (effect2) => (self) => Effect_exports2.chain_(self, (a1) => pipe(effect2(a1), Effect_exports2.map((a2) => ({ ...a1, ...a2 }))));
var forEachParDict = (args) => (as6) => forEachParDict_(as6, args);
var forEachParDict_ = (as6, { mapKey, mapValue }) => pipe(as6, Effect_exports2.forEach((a2) => Effect_exports2.tuplePar(mapKey(a2), mapValue(a2))), Effect_exports2.map(Chunk_exports2.map(toNative)), Effect_exports2.map(Chunk_exports2.toArray), Effect_exports2.map(Object.fromEntries));
var tapSync = (tapFn) => (eff) => Effect_exports2.tap_(eff, (a2) => Effect_exports2.succeedWith(() => tapFn(a2)));

// node_modules/@contentlayer2/utils/dist/effect/Option.js
var Option_exports3 = {};
__export(Option_exports3, {
  Any: () => Any3,
  Applicative: () => Applicative3,
  AssociativeBoth: () => AssociativeBoth3,
  AssociativeEither: () => AssociativeEither2,
  AssociativeFlatten: () => AssociativeFlatten3,
  Compactable: () => Compactable,
  Covariant: () => Covariant3,
  Extend: () => Extend,
  Fail: () => Fail4,
  Filterable: () => Filterable,
  Foldable: () => Foldable,
  ForEach: () => ForEach,
  IdentityBoth: () => IdentityBoth3,
  IdentityFlatten: () => IdentityFlatten3,
  Monad: () => Monad3,
  None: () => None,
  OptionURI: () => OptionURI,
  PartialException: () => PartialException,
  PartialExceptionTypeId: () => PartialExceptionTypeId,
  Some: () => Some,
  Wiltable: () => Wiltable,
  Witherable: () => Witherable,
  alt: () => alt2,
  ap: () => ap,
  ap_: () => ap_,
  bind: () => bind4,
  chain: () => chain,
  chain_: () => chain_,
  compactF: () => compactF2,
  do: () => do_4,
  do_: () => do_4,
  duplicate: () => duplicate,
  elem: () => elem2,
  elem_: () => elem_2,
  emptyOf: () => emptyOf,
  exists: () => exists,
  exists_: () => exists_,
  extend: () => extend,
  extend_: () => extend_,
  filter: () => filter4,
  filterMap: () => filterMap2,
  filterMap_: () => filterMap_2,
  filter_: () => filter_7,
  flatten: () => flatten,
  fold: () => fold,
  fold_: () => fold_,
  forEachF: () => forEachF2,
  fromEither: () => fromEither,
  fromNullable: () => fromNullable,
  fromPredicate: () => fromPredicate,
  fromPredicate_: () => fromPredicate_,
  gen: () => gen5,
  getApplyAssociative: () => getApplyAssociative,
  getApplyIdentity: () => getApplyIdentity,
  getEqual: () => getEqual2,
  getFirst: () => getFirst,
  getFirstAssociative: () => getFirstAssociative,
  getFirstIdentity: () => getFirstIdentity,
  getIdentity: () => getIdentity4,
  getLast: () => getLast,
  getLastAssociative: () => getLastAssociative,
  getLastIdentity: () => getLastIdentity,
  getLeft: () => getLeft,
  getOrElse: () => getOrElse,
  getOrElseS: () => getOrElseS,
  getOrElseS_: () => getOrElseS_,
  getOrElse_: () => getOrElse_,
  getOrd: () => getOrd2,
  getRefinement: () => getRefinement,
  getRight: () => getRight,
  getShow: () => getShow2,
  getUnsafe: () => getUnsafe,
  if: () => branch,
  if_: () => branch_,
  isNone: () => isNone,
  isSome: () => isSome,
  let: () => let_4,
  let_: () => let_4,
  map: () => map,
  mapNullable: () => mapNullable,
  map_: () => map_,
  match: () => match2,
  matchIn: () => matchIn2,
  matchMorph: () => matchMorph2,
  matchTag: () => matchTag3,
  matchTagIn: () => matchTagIn2,
  none: () => none,
  partial: () => partial,
  partition: () => partition3,
  partitionMap: () => partitionMap3,
  partitionMap_: () => partitionMap_2,
  partition_: () => partition_3,
  separate: () => separate3,
  separateF: () => separateF2,
  sequence: () => sequence,
  some: () => some,
  struct: () => struct3,
  tap: () => tap,
  tap_: () => tap_,
  toNullable: () => toNullable,
  toUndefined: () => toUndefined,
  tryCatch: () => tryCatch,
  tuple: () => tuple5,
  zip: () => zip,
  zipFirst: () => zipFirst,
  zipFirst_: () => zipFirst_,
  zipSecond: () => zipSecond,
  zipSecond_: () => zipSecond_,
  zip_: () => zip_
});
var getUnsafe = (option3) => {
  if (Option_exports2.isSome(option3)) {
    return option3.value;
  }
  throw new Error("Option.getUnsafe: Option is None");
};

// node_modules/@contentlayer2/utils/dist/effect/These.js
var These_exports = {};
__export(These_exports, {
  These: () => These,
  chain: () => chain13,
  chain_: () => chain_18,
  effectTapErrorOrWarning: () => effectTapErrorOrWarning,
  effectTapSuccess: () => effectTapSuccess,
  effectThese: () => effectThese,
  effectToEither: () => effectToEither,
  effectUnwrapValue: () => effectUnwrapValue,
  errorOrWaning: () => errorOrWaning,
  fail: () => fail14,
  foldM: () => foldM5,
  foldM_: () => foldM_5,
  isNonFailure: () => isNonFailure,
  map: () => map14,
  mapError: () => mapError7,
  mapError_: () => mapError_7,
  map_: () => map_22,
  result: () => result3,
  succeed: () => succeed11,
  toEffect: () => toEffect,
  warn: () => warn,
  warnOption: () => warnOption
});
var These = class {
  constructor(either5) {
    this.either = either5;
  }
};
function succeed11(a2) {
  return new These(Either_exports2.right(tuple2(a2, Option_exports3.none)));
}
function warn(a2, e2) {
  return new These(Either_exports2.right(tuple2(a2, Option_exports3.some(e2))));
}
function warnOption(a2, e2) {
  return new These(Either_exports2.right(tuple2(a2, e2)));
}
function fail14(e2) {
  return new These(Either_exports2.left(e2));
}
var isNonFailure = (self) => Either_exports2.isRight(self.either);
function foldM_5(self, onSuccess, onBoth, onFail) {
  return new These(Either_exports2.fold_(self.either, (x2) => onFail(x2).either, ({ tuple: [result4, warnings] }) => warnings._tag === "None" ? onSuccess(result4).either : onBoth(result4, warnings.value).either));
}
function foldM5(onSuccess, onBoth, onFail) {
  return (self) => foldM_5(self, onSuccess, onBoth, onFail);
}
function map_22(self, f2) {
  return foldM_5(self, (a2) => succeed11(f2(a2)), (a2, e2) => warn(f2(a2), e2), fail14);
}
function map14(f2) {
  return (self) => map_22(self, f2);
}
function mapError_7(self, f2) {
  return foldM_5(self, (a2) => succeed11(a2), (a2, e2) => warn(a2, f2(e2)), (e2) => fail14(f2(e2)));
}
function mapError7(f2) {
  return (self) => mapError_7(self, f2);
}
function chain_18(self, f2) {
  return foldM_5(self, (a2) => f2(a2, Option_exports3.none), (a2, _2) => f2(a2, Option_exports3.some(_2)), fail14);
}
function chain13(f2) {
  return (self) => chain_18(self, f2);
}
function result3(self) {
  return self.either;
}
var errorOrWaning = (self) => {
  return Either_exports2.fold_(self.either, Option_exports3.some, (tp) => tp.get(1));
};
var toEffect = (self) => {
  return pipe(result3(self), Either_exports2.fold(Effect_exports3.fail, Effect_exports3.succeed));
};
var effectUnwrapValue = (effect2) => {
  return pipe(effect2, Effect_exports3.chain((these) => Either_exports2.fold_(these.either, Effect_exports3.fail, ({ tuple: [a2] }) => Effect_exports3.succeed(a2))));
};
var effectTapSuccess = (tapFn) => (effect2) => {
  return Effect_exports3.tap_(effect2, (these) => pipe(result3(these), Either_exports2.fold(() => Effect_exports3.unit, (tp) => tapFn(tp.get(0)))));
};
var effectTapErrorOrWarning = (tapFn) => (effect2) => {
  return Effect_exports3.tap_(effect2, (these) => pipe(errorOrWaning(these), Option_exports3.fold(() => Effect_exports3.unit, (e2) => tapFn(e2))));
};
var effectThese = (effect2) => {
  return pipe(effect2, Effect_exports3.either, Effect_exports3.map(Either_exports2.fold((e2) => fail14(e2), (t2) => t2)));
};
var effectToEither = (effect2) => pipe(effect2, Effect_exports3.map((these) => Either_exports2.fold_(these.either, (e2) => Either_exports2.left(e2), ({ tuple: [val, optE2] }) => Option_exports3.fold_(optE2, () => Either_exports2.right(val), (e2) => Either_exports2.left(e2)))));

// node_modules/@contentlayer2/utils/dist/effect/Chunk.js
var Chunk_exports3 = {};
__export(Chunk_exports3, {
  Any: () => Any4,
  AppendN: () => AppendN,
  AppendNTypeId: () => AppendNTypeId,
  Applicative: () => Applicative4,
  ApplyZip: () => ApplyZip,
  Arr: () => Arr,
  ArrTypeId: () => ArrTypeId,
  AssociativeBothZip: () => AssociativeBothZip,
  AssociativeFlatten: () => AssociativeFlatten4,
  BreadthFirstChainRec: () => BreadthFirstChainRec,
  BufferSize: () => BufferSize,
  ChunkBuilder: () => ChunkBuilder,
  ChunkInternal: () => ChunkInternal,
  ChunkTypeId: () => ChunkTypeId,
  Collection: () => Collection,
  Compact: () => Compact,
  Concat: () => Concat,
  ConcatTypeId: () => ConcatTypeId,
  Covariant: () => Covariant4,
  DepthFirstChainRec: () => DepthFirstChainRec,
  Empty: () => Empty3,
  EmptyTypeId: () => EmptyTypeId,
  Extend: () => Extend2,
  Filter: () => Filter,
  FilterMap: () => FilterMap,
  FilterMapWithIndex: () => FilterMapWithIndex,
  FilterWithIndex: () => FilterWithIndex,
  Filterable: () => Filterable2,
  FilterableWithIndex: () => FilterableWithIndex,
  FoldMap: () => FoldMap,
  FoldMapWithIndex: () => FoldMapWithIndex,
  Foldable: () => Foldable2,
  FoldableWithIndex: () => FoldableWithIndex,
  ForEach: () => ForEach2,
  ForEachWithIndex: () => ForEachWithIndex,
  Monad: () => Monad4,
  Partition: () => Partition,
  PartitionMap: () => PartitionMap,
  PartitionMapWithIndex: () => PartitionMapWithIndex,
  PartitionWithIndex: () => PartitionWithIndex,
  PlainArr: () => PlainArr,
  PrependN: () => PrependN,
  PrependNTypeId: () => PrependNTypeId,
  Reduce: () => Reduce,
  ReduceRight: () => ReduceRight,
  ReduceRightWithIndex: () => ReduceRightWithIndex,
  ReduceWithIndex: () => ReduceWithIndex,
  Separate: () => Separate,
  Singleton: () => Singleton,
  SingletonTypeId: () => SingletonTypeId,
  Slice: () => Slice,
  SliceTypeId: () => SliceTypeId,
  Uint8Arr: () => Uint8Arr,
  Wiltable: () => Wiltable2,
  WiltableWithIndex: () => WiltableWithIndex,
  Witherable: () => Witherable2,
  WitherableWithIndex: () => WitherableWithIndex,
  _Empty: () => _Empty,
  _copy: () => _copy,
  alloc: () => alloc,
  append: () => append2,
  append_: () => append_4,
  breadthFirstChainRec: () => breadthFirstChainRec,
  buckets: () => buckets,
  builder: () => builder,
  chain: () => chain4,
  chain_: () => chain_7,
  collect: () => collect,
  collectEffect: () => collectEffect,
  collectEffect_: () => collectEffect_,
  collectWhile: () => collectWhile,
  collectWhileEffect: () => collectWhileEffect,
  collectWhileEffect_: () => collectWhileEffect_,
  collectWhile_: () => collectWhile_,
  collectWithIndex: () => collectWithIndex,
  collectWithIndex_: () => collectWithIndex_,
  collect_: () => collect_2,
  compact: () => compact3,
  compactF: () => compactF,
  compactWithIndexF: () => compactWithIndexF,
  concat: () => concat2,
  concat_: () => concat_3,
  concrete: () => concrete,
  concreteId: () => concreteId,
  corresponds: () => corresponds2,
  corresponds_: () => corresponds_,
  dedupe: () => dedupe,
  depthFirstChainRec: () => depthFirstChainRec,
  difference: () => difference,
  difference_: () => difference_,
  drop: () => drop,
  dropRight: () => dropRight,
  dropRight_: () => dropRight_,
  dropWhile: () => dropWhile2,
  dropWhileEffect: () => dropWhileEffect,
  dropWhileEffect_: () => dropWhileEffect_,
  dropWhile_: () => dropWhile_2,
  drop_: () => drop_2,
  elem: () => elem,
  elem_: () => elem_,
  empty: () => empty4,
  equals: () => equals3,
  equals_: () => equals_,
  exists: () => exists4,
  exists_: () => exists_3,
  fill: () => fill,
  filter: () => filter2,
  filterEffect: () => filterEffect,
  filterEffect_: () => filterEffect_,
  filterWithIndex: () => filterWithIndex2,
  filterWithIndex_: () => filterWithIndex_2,
  filter_: () => filter_3,
  find: () => find2,
  findEffect: () => findEffect,
  findEffect_: () => findEffect_,
  findIndex: () => findIndex,
  findIndex_: () => findIndex_,
  findLast: () => findLast,
  findLastIndex: () => findLastIndex,
  findLastIndex_: () => findLastIndex_,
  findLast_: () => findLast_,
  find_: () => find_2,
  flatten: () => flatten5,
  foldMap: () => foldMap,
  foldMapWithIndex: () => foldMapWithIndex,
  foldMapWithIndex_: () => foldMapWithIndex_,
  foldMap_: () => foldMap_,
  forAll: () => forAll,
  forAll_: () => forAll_,
  forAny: () => forAny,
  forAny_: () => forAny_,
  forEach: () => forEach3,
  forEachF: () => forEachF,
  forEachF_: () => forEachF_,
  forEachWithIndexF: () => forEachWithIndexF,
  forEach_: () => forEach_4,
  from: () => from3,
  get: () => get3,
  getEqual: () => getEqual,
  getIdentity: () => getIdentity3,
  getOrd: () => getOrd,
  getShow: () => getShow,
  get_: () => get_3,
  grouped: () => grouped,
  grouped_: () => grouped_,
  head: () => head2,
  indexWhere: () => indexWhere,
  indexWhereFrom: () => indexWhereFrom,
  indexWhereFrom_: () => indexWhereFrom_,
  indexWhere_: () => indexWhere_,
  intersection: () => intersection,
  intersection_: () => intersection_2,
  isByte: () => isByte,
  isChunk: () => isChunk,
  isEmpty: () => isEmpty5,
  isNonEmpty: () => isNonEmpty2,
  join: () => join3,
  join_: () => join_2,
  last: () => last2,
  make: () => make3,
  makeBy_: () => makeBy_2,
  map: () => map5,
  mapAccum: () => mapAccum,
  mapAccumEffect: () => mapAccumEffect,
  mapAccumEffect_: () => mapAccumEffect_,
  mapAccum_: () => mapAccum_,
  mapEffect: () => mapEffect,
  mapEffectPar: () => mapEffectPar,
  mapEffectPar_: () => mapEffectPar_,
  mapEffectUnit: () => mapEffectUnit,
  mapEffectUnitPar: () => mapEffectUnitPar,
  mapEffectUnitParN: () => mapEffectUnitParN,
  mapEffectUnitParN_: () => mapEffectUnitParN_,
  mapEffectUnitPar_: () => mapEffectUnitPar_,
  mapEffectUnit_: () => mapEffectUnit_,
  mapEffect_: () => mapEffect_,
  mapMParEffect: () => mapMParEffect,
  mapMParEffect_: () => mapMParEffect_,
  mapWithIndex: () => mapWithIndex2,
  mapWithIndex_: () => mapWithIndex_2,
  map_: () => map_8,
  materialize: () => materialize,
  partition: () => partition2,
  partitionMap: () => partitionMap2,
  partitionMapWithIndex: () => partitionMapWithIndex,
  partitionMapWithIndex_: () => partitionMapWithIndex_,
  partitionMap_: () => partitionMap_,
  partitionThese: () => partitionThese,
  partitionWithIndex: () => partitionWithIndex,
  partitionWithIndex_: () => partitionWithIndex_,
  partition_: () => partition_2,
  prepend: () => prepend2,
  prepend_: () => prepend_3,
  range: () => range2,
  reduce: () => reduce5,
  reduceEffect: () => reduceEffect,
  reduceEffect_: () => reduceEffect_,
  reduceRight: () => reduceRight2,
  reduceRightEffect: () => reduceRightEffect,
  reduceRightEffect_: () => reduceRightEffect_,
  reduceRightWithIndex: () => reduceRightWithIndex2,
  reduceRightWithIndex_: () => reduceRightWithIndex_2,
  reduceRight_: () => reduceRight_5,
  reduceWhile: () => reduceWhile,
  reduceWhileEffect: () => reduceWhileEffect,
  reduceWhileEffect_: () => reduceWhileEffect_,
  reduceWhile_: () => reduceWhile_,
  reduceWithIndex: () => reduceWithIndex3,
  reduceWithIndex_: () => reduceWithIndex_4,
  reduce_: () => reduce_7,
  reverse: () => reverse3,
  reverseBuckets: () => reverseBuckets,
  separate: () => separate2,
  separateF: () => separateF,
  separateWithIndexF: () => separateWithIndexF,
  single: () => single,
  size: () => size4,
  sort: () => sort,
  sortBy: () => sortBy,
  sortBy_: () => sortBy_,
  sort_: () => sort_,
  split: () => split,
  splitAt: () => splitAt,
  splitAt_: () => splitAt_,
  splitWhere: () => splitWhere,
  splitWhere_: () => splitWhere_,
  split_: () => split_,
  tail: () => tail2,
  take: () => take,
  takeRight: () => takeRight,
  takeRight_: () => takeRight_2,
  takeWhile: () => takeWhile,
  takeWhileEffect: () => takeWhileEffect,
  takeWhileEffect_: () => takeWhileEffect_,
  takeWhile_: () => takeWhile_,
  take_: () => take_2,
  toArray: () => toArray2,
  toArrayLike: () => toArrayLike,
  toString: () => toString,
  unfold: () => unfold,
  unfoldEffect: () => unfoldEffect,
  union: () => union2,
  union_: () => union_3,
  uniq: () => uniq,
  uniq_: () => uniq_,
  unit: () => unit,
  unsafeGet: () => unsafeGet2,
  unsafeGet_: () => unsafeGet_2,
  unsafeHead: () => unsafeHead,
  unsafeLast: () => unsafeLast2,
  unsafeTail: () => unsafeTail,
  unzip: () => unzip2,
  zip: () => zip6,
  zipAll: () => zipAll,
  zipAllWith: () => zipAllWith,
  zipAllWith_: () => zipAllWith_,
  zipAll_: () => zipAll_,
  zipWith: () => zipWith4,
  zipWithIndex: () => zipWithIndex,
  zipWithIndexOffset: () => zipWithIndexOffset,
  zipWithIndexOffset_: () => zipWithIndexOffset_,
  zipWith_: () => zipWith_5,
  zip_: () => zip_5
});
var partitionThese = (chunk2) => {
  let errors = Chunk_exports2.empty();
  let values3 = Chunk_exports2.empty();
  Chunk_exports2.forEach_(chunk2, (a2) => {
    const res = These_exports.result(a2);
    if (Either_exports2.isLeft(res)) {
      errors = Chunk_exports2.append_(errors, res.left);
    } else {
      values3 = Chunk_exports2.append_(values3, res.right.tuple[0]);
      const warning = res.right.tuple[1];
      if (Option_exports3.isSome(warning)) {
        errors = Chunk_exports2.append_(errors, warning.value);
      }
    }
  });
  return Tuple_exports2.tuple(errors, values3);
};

// node_modules/@contentlayer2/utils/dist/effect/OT.js
var OT_exports = {};
__export(OT_exports, {
  LiveConsoleSimple: () => LiveConsoleSimple,
  LiveTracer: () => LiveTracer,
  SimpleProcessor: () => SimpleProcessor,
  SimpleProcessorSymbol: () => SimpleProcessorSymbol,
  SimpleProcessorTag: () => SimpleProcessorTag,
  Span: () => Span,
  SpanImpl: () => SpanImpl,
  SpanSymbol: () => SpanSymbol,
  Tracer: () => Tracer2,
  TracerProvider: () => TracerProvider,
  TracerProviderSymbol: () => TracerProviderSymbol,
  TracerSymbol: () => TracerSymbol,
  addAttribute: () => addAttribute,
  addEvent: () => addEvent,
  makeSimpleProcessor: () => makeSimpleProcessor,
  makeTracer: () => makeTracer,
  withSpan: () => withSpan,
  withStreamSpan: () => withStreamSpan,
  withTracer: () => withTracer
});

// node_modules/@effect-ts/otel/_mjs/TracerProvider/index.mjs
var TracerProviderSymbol = /* @__PURE__ */ Symbol();
var TracerProvider = /* @__PURE__ */ tag();

// node_modules/@effect-ts/otel/_mjs/Tracer/index.mjs
var TracerSymbol = /* @__PURE__ */ Symbol();
var Tracer2 = /* @__PURE__ */ tag();
var makeTracer = (name) => gen6(function* (_2) {
  const {
    tracerProvider
  } = yield* _2(TracerProvider);
  const tracer2 = yield* _2(succeedWith3(() => tracerProvider.getTracer(name)));
  return {
    [TracerSymbol]: TracerSymbol,
    tracer: tracer2
  };
});
var LiveTracer = /* @__PURE__ */ fromManaged(Tracer2)(/* @__PURE__ */ makeTracer("@effect-ts/otel/Tracer"));
var {
  tracer: withTracer
} = /* @__PURE__ */ deriveAccessM(Tracer2)(["tracer"]);

// node_modules/@effect-ts/otel/_mjs/Span/index.mjs
init_esm();
init_esm();
var _a8;
var SpanSymbol = /* @__PURE__ */ Symbol();
var SpanImpl = class {
  constructor(span) {
    this.span = span;
    this[_a8] = SpanSymbol;
  }
};
_a8 = SpanSymbol;
var Span = /* @__PURE__ */ tag();
function withSpan(name, options, ctx) {
  return (effect2) => {
    const createSpan = withTracer((tracer2) => access3((r2) => {
      const maybeSpan = Span.readOption(r2);
      if (ctx) {
        return tracer2.startSpan(name, options, ctx);
      }
      if ((options === null || options === void 0 ? void 0 : options.root) !== true && isSome(maybeSpan)) {
        const ctx2 = trace.setSpan(context.active(), maybeSpan.value.span);
        return tracer2.startSpan(name, options, ctx2);
      }
      return tracer2.startSpan(name, {
        ...options,
        root: true
      });
    }));
    return bracketExit_(createSpan, (s2) => provideService(Span)(new SpanImpl(s2))(effect2), (s2, e2) => succeedWith3(() => {
      if (e2._tag === "Failure") {
        s2.setAttribute("error.type", "Fiber Failure");
        s2.setAttribute("error.message", "An Effect Has A Failure");
        s2.setAttribute("error.stack", pretty(e2.cause));
        s2.setStatus({
          code: SpanStatusCode.ERROR
        });
      } else {
        s2.setStatus({
          code: SpanStatusCode.OK
        });
      }
      s2.end();
    }));
  };
}
function addAttribute(name, value) {
  return accessServiceM2(Span)((_2) => succeedWith3(() => {
    _2.span.setAttribute(name, value);
  }));
}
function addEvent(name, attributesOrStartTime, startTime) {
  return accessServiceM2(Span)((_2) => succeedWith3(() => {
    _2.span.addEvent(name, attributesOrStartTime, startTime);
  }));
}

// node_modules/@effect-ts/otel/_mjs/Processor/Simple/index.mjs
var import_sdk_trace_base = __toESM(require_src3(), 1);
var SimpleProcessorSymbol = /* @__PURE__ */ Symbol();
var makeSimpleProcessor = (exporter) => gen6(function* (_2) {
  const {
    tracerProvider
  } = yield* _2(TracerProvider);
  const spanExporter = yield* _2(exporter);
  const spanProcessor = yield* _2(succeedWith3(() => new import_sdk_trace_base.SimpleSpanProcessor(spanExporter)));
  yield* _2(succeedWith3(() => tracerProvider.addSpanProcessor(spanProcessor)));
  return {
    [SimpleProcessorSymbol]: SimpleProcessorSymbol,
    spanExporter,
    spanProcessor
  };
});
var SimpleProcessorTag = /* @__PURE__ */ tag(SimpleProcessorSymbol);
function SimpleProcessor(exporter) {
  return fromManaged(SimpleProcessorTag)(makeSimpleProcessor(exporter));
}
var LiveConsoleSimple = /* @__PURE__ */ SimpleProcessor(/* @__PURE__ */ succeedWith4(() => new import_sdk_trace_base.ConsoleSpanExporter()));

// node_modules/@contentlayer2/utils/dist/effect/OT.js
init_esm();
var withStreamSpan = (name, options, ctx) => (stream) => pipe(
  // NOTE we're using this weird `S.access` + `S.chain` here since `T.access` seems to be buggy
  // TODO fix this with Effect 2 
  access5((r2) => r2),
  chain12((r2) => pipe(Managed_exports.gen(function* ($2) {
    const span = yield* $2(Managed_exports.makeExit_(pipe(Effect_exports2.succeedWith(() => {
      const { tracer: tracer2 } = Tracer2.read(r2);
      const maybeSpan = Span.readOption(r2);
      if (ctx) {
        return tracer2.startSpan(name, options, ctx);
      }
      if (options?.root !== true && Option_exports2.isSome(maybeSpan)) {
        const ctx2 = trace.setSpan(context.active(), maybeSpan.value.span);
        return tracer2.startSpan(name, options, ctx2);
      }
      return tracer2.startSpan(name, { ...options, root: true });
    })), (s2, e2) => Effect_exports2.succeedWith(() => {
      if (e2._tag === "Failure") {
        s2.setAttribute("error.type", "Fiber Failure");
        s2.setAttribute("error.message", "An Effect Has A Failure");
        s2.setAttribute("error.stack", pretty(e2.cause));
        s2.setStatus({ code: SpanStatusCode.ERROR });
      } else {
        s2.setStatus({ code: SpanStatusCode.OK });
      }
      s2.end();
    })));
    return pipe(stream, provideAll4({ ...r2, ...Span.has(new SpanImpl(span)) }));
  }), unwrapManaged2))
);

// node_modules/@contentlayer2/utils/dist/hash.js
var HashError = class extends Tagged("HashError") {
};

// node_modules/@contentlayer2/utils/dist/file-paths.js
import * as path from "node:path";
var absolutePosixFilePath = (path_) => {
  if (!isPosixFilePathString(path_)) {
    throw new Error(`Expected a Posix file path, got ${path_}`);
  }
  if (!path.isAbsolute(path_)) {
    throw new Error(`Expected an absolute path (i.e. starting with '/' or '\\'), got ${path_}`);
  }
  return Branded_exports.makeBranded(path_);
};
var relativePosixFilePath = (path_) => {
  if (!isPosixFilePathString(path_)) {
    throw new Error(`Expected a Posix file path, got ${path_}`);
  }
  if (path.isAbsolute(path_)) {
    throw new Error(`Expected a relative path (i.e. not starting with '/' or '\\'), got ${path_}`);
  }
  return Branded_exports.makeBranded(path_);
};
var isPosixFilePathString = (path_) => !path_.includes(path.win32.sep);
var unknownToRelativePosixFilePath = (path_, cwd) => {
  if (path.isAbsolute(path_)) {
    if (cwd === void 0) {
      throw new Error(`Expected a relative path, got ${path_}`);
    }
    return relative2(cwd, path_);
  }
  if (isPosixFilePathString(path_)) {
    return relativePosixFilePath(path_);
  }
  return relativePosixFilePath(path_.split(path.win32.sep).join(path.posix.sep));
};
var unknownToAbsolutePosixFilePath = (path_, cwd) => {
  if (!path.isAbsolute(path_)) {
    if (cwd === void 0) {
      throw new Error(`Expected an absolute path (i.e. starting with '/' or '\\'), got ${path_}`);
    }
    return filePathJoin(cwd, path_);
  }
  if (isPosixFilePathString(path_)) {
    return absolutePosixFilePath(path_);
  }
  return absolutePosixFilePath(path_.split(path.win32.sep).join(path.posix.sep));
};
var unknownFilePath = (path_) => Branded_exports.makeBranded(path_);
function filePathJoin(...paths) {
  if (paths.length > 0 && path.isAbsolute(paths[0])) {
    if (paths.slice(1).some(path.isAbsolute)) {
      throw new Error(`All path segments except the first are expected to be relative, got ${paths}`);
    }
    return unknownToAbsolutePosixFilePath(path.join(...paths));
  }
  return unknownToRelativePosixFilePath(path.join(...paths));
}
function dirname2(path_) {
  return path.dirname(path_);
}
function relative2(from4, to2) {
  return unknownToRelativePosixFilePath(path.relative(from4, to2));
}

// node_modules/@contentlayer2/utils/dist/base64.js
var base64_exports = {};
__export(base64_exports, {
  decode: () => decode,
  encode: () => encode
});
var base64abc = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "+",
  "/"
];
var encode = (data) => {
  const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
  let result4 = "", i2;
  const l2 = uint8.length;
  for (i2 = 2; i2 < l2; i2 += 3) {
    result4 += base64abc[uint8[i2 - 2] >> 2];
    result4 += base64abc[(uint8[i2 - 2] & 3) << 4 | uint8[i2 - 1] >> 4];
    result4 += base64abc[(uint8[i2 - 1] & 15) << 2 | uint8[i2] >> 6];
    result4 += base64abc[uint8[i2] & 63];
  }
  if (i2 === l2 + 1) {
    result4 += base64abc[uint8[i2 - 2] >> 2];
    result4 += base64abc[(uint8[i2 - 2] & 3) << 4];
    result4 += "==";
  }
  if (i2 === l2) {
    result4 += base64abc[uint8[i2 - 2] >> 2];
    result4 += base64abc[(uint8[i2 - 2] & 3) << 4 | uint8[i2 - 1] >> 4];
    result4 += base64abc[(uint8[i2 - 1] & 15) << 2];
    result4 += "=";
  }
  return result4;
};
var decode = (b64) => {
  const binString = atob(b64);
  const size7 = binString.length;
  const bytes = new Uint8Array(size7);
  for (let i2 = 0; i2 < size7; i2++) {
    bytes[i2] = binString.charCodeAt(i2);
  }
  return bytes;
};

// node_modules/@contentlayer2/utils/dist/tracing-effect/otel-exporter-trace-otlp-grpc.js
var import_exporter_trace_otlp_grpc = __toESM(require_src21(), 1);
var _a9;
var OTLPTraceExporterConfigSymbol = Symbol();
var OTLPTraceExporterConfig = class {
  constructor(config) {
    this.config = config;
    this[_a9] = OTLPTraceExporterConfigSymbol;
  }
};
_a9 = OTLPTraceExporterConfigSymbol;
var OTLPTraceExporterConfigTag = tag(OTLPTraceExporterConfigSymbol);
var makeOTLPTraceExporterConfigLayer = (config) => fromEffect2(OTLPTraceExporterConfigTag)(succeedWith3(() => new OTLPTraceExporterConfig(config))).setKey(OTLPTraceExporterConfigTag.key);
var makeTracingSpanExporter = gen6(function* (_2) {
  const { config } = yield* _2(OTLPTraceExporterConfigTag);
  const spanExporter = yield* _2(pipe(
    succeedWith3(() => new import_exporter_trace_otlp_grpc.OTLPTraceExporter(config)),
    // NOTE Unfortunately this workaround/"hack" is currently needed since Otel doesn't yet provide a graceful
    // way to shutdown.
    //
    // Related issue: https://github.com/open-telemetry/opentelemetry-js/issues/987
    make5((p2) => gen4(function* (_3) {
      while (1) {
        yield* _3(sleep2(0));
        const promises = p2["_sendingPromises"];
        if (promises.length > 0) {
          yield* _3(result(promise(() => Promise.all(promises))));
        } else {
          break;
        }
      }
    }))
  ));
  return spanExporter;
});
var LiveSimpleProcessor = SimpleProcessor(makeTracingSpanExporter);

// node_modules/@contentlayer2/utils/dist/tracing-effect/index.js
var CollectorConfig = makeOTLPTraceExporterConfigLayer({});
var dummyProps = {};
var DummyTracing = Tracer2.has({
  [TracerSymbol]: TracerSymbol,
  tracer: {
    startSpan: () => ({
      setAttribute: () => null,
      setStatus: () => null,
      end: () => null
    }),
    ...dummyProps
  }
});
var provideDummyTracing = provide2(DummyTracing);

// node_modules/@contentlayer2/utils/dist/fs_.js
var fs_exports = {};
__export(fs_exports, {
  FileNotFoundError: () => FileNotFoundError,
  FileOrDirNotFoundError: () => FileOrDirNotFoundError,
  FsTag: () => FsTag,
  JsonParseError: () => JsonParseError,
  JsonStringifyError: () => JsonStringifyError,
  MkdirError: () => MkdirError,
  ReadFileError: () => ReadFileError,
  RmError: () => RmError,
  StatError: () => StatError,
  SymlinkError: () => SymlinkError,
  UnknownFSError: () => UnknownFSError,
  WriteFileError: () => WriteFileError,
  fileOrDirExists: () => fileOrDirExists,
  mkdirp: () => mkdirp,
  readFile: () => readFile,
  readFileBuffer: () => readFileBuffer,
  readFileJson: () => readFileJson,
  readFileJsonIfExists: () => readFileJsonIfExists,
  rm: () => rm,
  stat: () => stat,
  symlink: () => symlink,
  symlinkExists: () => symlinkExists,
  writeFile: () => writeFile,
  writeFileJson: () => writeFileJson
});
var FsTag = tag(Symbol("contentlayer:Fs"));
var { fileOrDirExists, symlinkExists, stat, readFile, readFileBuffer, writeFile, writeFileJson, mkdirp, symlink } = Effect_exports3.deriveLifted(FsTag)([
  "fileOrDirExists",
  "symlinkExists",
  "stat",
  "readFile",
  "readFileBuffer",
  "writeFile",
  "writeFileJson",
  "mkdirp",
  "symlink"
], [], []);
var readFileJson = (filePath) => Effect_exports3.accessServiceM(FsTag)((_2) => _2.readFileJson(filePath));
var readFileJsonIfExists = (filePath) => Effect_exports3.accessServiceM(FsTag)((_2) => _2.readFileJsonIfExists(filePath));
function rm(path9, params = {}) {
  return pipe(Effect_exports3.accessServiceM(FsTag)((_2) => _2.rm(path9, params)));
}
var FileNotFoundError = class extends Tagged("fs.FileNotFoundError") {
};
var FileOrDirNotFoundError = class extends Tagged("fs.FileOrDirNotFoundError") {
};
var ReadFileError = class extends Tagged("fs.ReadFileError") {
};
var StatError = class extends Tagged("fs.StatError") {
};
var WriteFileError = class extends Tagged("fs.WriteFileError") {
};
var MkdirError = class extends Tagged("fs.MkdirError") {
};
var RmError = class extends Tagged("fs.RmError") {
};
var SymlinkError = class extends Tagged("fs.SymlinkError") {
};
var UnknownFSError = class extends Tagged("fs.UnknownFSError") {
  constructor() {
    super(...arguments);
    this.toString = () => `UnknownFSError: ${errorToString(this.error)} ${this.error.stack}`;
  }
};
var JsonParseError = class extends Tagged("fs.JsonParseError") {
};
var JsonStringifyError = class extends Tagged("fs.JsonStringifyError") {
};

// node_modules/@contentlayer2/utils/dist/fs-in-memory.js
import { fs } from "memfs";
var fileOrDirExists2 = (pathLike) => {
  return pipe(stat2(pathLike), Effect_exports3.map((stat_) => stat_.isFile() || stat_.isDirectory()), Effect_exports3.catchTag("fs.FileNotFoundError", () => Effect_exports3.succeed(false)), Effect_exports3.tap((exists5) => OT_exports.addAttribute("exists", exists5)), OT_exports.withSpan("fileOrDirExists", { attributes: { pathLike } }));
};
var symlinkExists2 = (pathLike) => {
  return pipe(stat2(pathLike), Effect_exports3.map((stat_) => stat_.isSymbolicLink()), Effect_exports3.catchTag("fs.FileNotFoundError", () => Effect_exports3.succeed(false)));
};
var stat2 = (filePath) => {
  return Effect_exports3.tryCatch(() => fs.statSync(filePath), (error) => {
    if (error.code === "ENOENT") {
      return new FileNotFoundError({ filePath });
    } else {
      return new StatError({ filePath, error });
    }
  });
};
var readFile2 = (filePath) => OT_exports.withSpan("readFile", { attributes: { filePath } })(Effect_exports3.tryCatch(() => fs.readFileSync(filePath, "utf8"), (error) => {
  if (error.code === "ENOENT") {
    return new FileNotFoundError({ filePath });
  } else {
    return new ReadFileError({ filePath, error });
  }
}));
var readFileBuffer2 = (filePath) => OT_exports.withSpan("readFileBuffer", { attributes: { filePath } })(Effect_exports3.tryCatch(() => fs.readFileSync(filePath, { encoding: "buffer" }), (error) => {
  if (error.code === "ENOENT") {
    return new FileNotFoundError({ filePath });
  } else {
    return new ReadFileError({ filePath, error });
  }
}));
var readFileJson2 = (filePath) => pipe(readFile2(filePath), Effect_exports3.chain((str) => Effect_exports3.tryCatch(() => JSON.parse(str), (error) => new JsonParseError({ str, error }))));
var readFileJsonIfExists2 = (filePath) => pipe(fileOrDirExists2(filePath), Effect_exports3.chain((exists5) => exists5 ? readFileJson2(filePath) : Effect_exports3.succeed(void 0)), Effect_exports3.catchTag("fs.FileNotFoundError", (e2) => Effect_exports3.die(e2)));
var writeFile2 = (filePath, content) => OT_exports.withSpan("writeFile", { attributes: { filePath } })(Effect_exports3.tryCatch(() => fs.writeFileSync(filePath, content, { encoding: "utf8" }), (error) => new WriteFileError({ filePath, error })));
var writeFileJson2 = ({ filePath, content }) => pipe(Effect_exports3.tryCatch(() => JSON.stringify(content, null, 2) + "\n", (error) => new JsonStringifyError({ error })), Effect_exports3.chain((contentStr) => writeFile2(filePath, contentStr)));
var mkdirp2 = (dirPath) => OT_exports.withSpan("mkdirp", { attributes: { dirPath } })(Effect_exports3.tryCatch(() => fs.mkdirSync(dirPath, { recursive: true }), (error) => new MkdirError({ dirPath, error })));
function rm2(path9, params = {}) {
  const { force = false, recursive = true } = params;
  return OT_exports.withSpan("rm", { attributes: { path: path9 } })(Effect_exports3.tryCatch(() => fs.rmSync(path9, { recursive, force }), (error) => {
    if (error.code === "ENOENT") {
      return new FileOrDirNotFoundError({ path: path9 });
    } else {
      return new RmError({ path: path9, error });
    }
  }));
}
var symlink2 = ({ targetPath, symlinkPath, type }) => OT_exports.withSpan("symlink", { attributes: { targetPath, symlinkPath, type } })(Effect_exports3.tryCatch(() => fs.symlinkSync(targetPath, symlinkPath, type), (error) => new SymlinkError({ targetPath, symlinkPath, type, error })));
var InMemoryFsLive = Layer_exports2.fromValue(FsTag)({
  fileOrDirExists: fileOrDirExists2,
  symlinkExists: symlinkExists2,
  stat: stat2,
  readFile: readFile2,
  readFileBuffer: readFileBuffer2,
  readFileJson: readFileJson2,
  readFileJsonIfExists: readFileJsonIfExists2,
  writeFile: writeFile2,
  writeFileJson: writeFileJson2,
  mkdirp: mkdirp2,
  rm: rm2,
  symlink: symlink2
});

// node_modules/@contentlayer2/utils/dist/index.js
import { AsciiTree } from "oo-ascii-tree";
import * as pattern2 from "ts-pattern";
import * as inflection from "inflection";
Date.prototype.toTemporalInstant = toTemporalInstant;
var errorToString = (error) => {
  const stack = process.env.CL_DEBUG ? error.stack : void 0;
  const str = error.toString();
  const stackStr = stack ? `
${stack}` : "";
  if (str !== "[object Object]")
    return str + stackStr;
  return JSON.stringify({ ...error, stack }, null, 2);
};
function casesHandled(x2) {
  throw new Error(`A case was not handled for value: ${JSON.stringify(x2)}`);
}
var RawError = class extends Tagged("RawError") {
};
var isReadonlyArray = (_2) => Array.isArray(_2);
function assertNever(_2) {
  throw new Error(`assertNever: This should never happen ${JSON.stringify(_2)}`);
}
var asMutableArray = (arr) => arr.slice();

// node_modules/@contentlayer2/utils/dist/node/version.js
import * as path2 from "node:path";
import { fileURLToPath } from "node:url";
var __dirname2 = path2.dirname(fileURLToPath(import.meta.url));
var getContentlayerVersion = () => {
  const packageJsonFilePath = path2.join(__dirname2, "..", "..", "package.json");
  return pipe(fs_exports.readFileJson(packageJsonFilePath), Effect_exports3.map((pkg) => pkg.version), Effect_exports3.catchTag("fs.FileNotFoundError", (e2) => Effect_exports3.die(e2)));
};

// node_modules/@contentlayer2/utils/dist/node/fs.js
import { promises as fs2 } from "node:fs";
var fileOrDirExists3 = (pathLike) => {
  return pipe(stat3(pathLike), Effect_exports3.map((stat_) => stat_.isFile() || stat_.isDirectory()), Effect_exports3.catchTag("fs.FileNotFoundError", () => Effect_exports3.succeed(false)), Effect_exports3.tap((exists5) => addAttribute("exists", exists5)), withSpan("fileOrDirExists", { attributes: { pathLike } }));
};
var symlinkExists3 = (pathLike) => {
  return pipe(stat3(pathLike), Effect_exports3.map((stat_) => stat_.isSymbolicLink()), Effect_exports3.catchTag("fs.FileNotFoundError", () => Effect_exports3.succeed(false)));
};
var stat3 = (filePath) => {
  return Effect_exports3.tryCatchPromise(async () => fs2.stat(filePath), (error) => {
    if (error.code === "ENOENT") {
      return new FileNotFoundError({ filePath });
    } else {
      return new StatError({ filePath, error });
    }
  });
};
var readFile3 = (filePath) => withSpan("readFile", { attributes: { filePath } })(Effect_exports3.tryCatchPromise(() => fs2.readFile(filePath, "utf8"), (error) => {
  if (error.code === "ENOENT") {
    return new FileNotFoundError({ filePath });
  } else {
    return new ReadFileError({ filePath, error });
  }
}));
var readFileBuffer3 = (filePath) => withSpan("readFileBuffer", { attributes: { filePath } })(Effect_exports3.tryCatchPromise(() => fs2.readFile(filePath), (error) => {
  if (error.code === "ENOENT") {
    return new FileNotFoundError({ filePath });
  } else {
    return new ReadFileError({ filePath, error });
  }
}));
var readFileJson3 = (filePath) => pipe(readFile3(filePath), Effect_exports3.chain((str) => Effect_exports3.tryCatch(() => JSON.parse(str), (error) => new JsonParseError({ str, error }))));
var readFileJsonIfExists3 = (filePath) => pipe(fileOrDirExists3(filePath), Effect_exports3.chain((exists5) => exists5 ? readFileJson3(filePath) : Effect_exports3.succeed(void 0)), Effect_exports3.catchTag("fs.FileNotFoundError", (e2) => Effect_exports3.die(e2)));
var writeFile3 = (filePath, content) => withSpan("writeFile", { attributes: { filePath } })(Effect_exports3.tryCatchPromise(() => fs2.writeFile(filePath, content, "utf8"), (error) => new WriteFileError({ filePath, error })));
var writeFileJson3 = ({ filePath, content }) => pipe(Effect_exports3.tryCatch(() => JSON.stringify(content, null, 2) + "\n", (error) => new JsonStringifyError({ error })), Effect_exports3.chain((contentStr) => writeFile3(filePath, contentStr)));
var mkdirp3 = (dirPath) => withSpan("mkdirp", { attributes: { dirPath } })(Effect_exports3.tryCatchPromise(() => fs2.mkdir(dirPath, { recursive: true }), (error) => new MkdirError({ dirPath, error })));
function rm3(path9, params = {}) {
  const { force = false, recursive = true } = params;
  return withSpan("rm", { attributes: { path: path9 } })(Effect_exports3.tryCatchPromise(() => fs2.rm(path9, { recursive, force }), (error) => {
    if (error.code === "ENOENT") {
      return new FileOrDirNotFoundError({ path: path9 });
    } else {
      return new RmError({ path: path9, error });
    }
  }));
}
var symlink3 = ({ targetPath, symlinkPath, type }) => withSpan("symlink", { attributes: { targetPath, symlinkPath, type } })(Effect_exports3.tryCatchPromise(() => fs2.symlink(targetPath, symlinkPath, type), (error) => new SymlinkError({ targetPath, symlinkPath, type, error })));
var NodeFsLive = Layer_exports2.fromValue(FsTag)({
  fileOrDirExists: fileOrDirExists3,
  symlinkExists: symlinkExists3,
  stat: stat3,
  readFile: readFile3,
  readFileBuffer: readFileBuffer3,
  readFileJson: readFileJson3,
  readFileJsonIfExists: readFileJsonIfExists3,
  writeFile: writeFile3,
  writeFileJson: writeFileJson3,
  mkdirp: mkdirp3,
  rm: rm3,
  symlink: symlink3
});

// node_modules/@contentlayer2/utils/dist/node/fs-watcher.js
var fs_watcher_exports = {};
__export(fs_watcher_exports, {
  DirectoryAdded: () => DirectoryAdded,
  DirectoryRemoved: () => DirectoryRemoved,
  FileAdded: () => FileAdded,
  FileChanged: () => FileChanged,
  FileRemoved: () => FileRemoved,
  FileWatcher: () => FileWatcher,
  FileWatcherError: () => FileWatcherError,
  FileWatcherTypeId: () => FileWatcherTypeId,
  WatchErrorTypeId: () => WatchErrorTypeId,
  add: () => add2,
  add_: () => add_3,
  make: () => make12,
  makeAndSubscribe: () => makeAndSubscribe,
  makeUnsafe: () => makeUnsafe,
  remove: () => remove3,
  remove_: () => remove_4,
  shutdown: () => shutdown3,
  subscribe: () => subscribe2
});
import * as Chokidar from "chokidar";
var _a10;
var _b3;
var _c3;
var _d3;
var FileAdded = class {
  constructor(path9, stats) {
    this.path = path9;
    this.stats = stats;
    this._tag = "FileAdded";
  }
};
var FileRemoved = class {
  constructor(path9, stats) {
    this.path = path9;
    this.stats = stats;
    this._tag = "FileRemoved";
  }
};
var FileChanged = class {
  constructor(path9, stats) {
    this.path = path9;
    this.stats = stats;
    this._tag = "FileChanged";
  }
};
var DirectoryAdded = class {
  constructor(path9, stats) {
    this.path = path9;
    this.stats = stats;
    this._tag = "DirectoryAdded";
  }
};
var DirectoryRemoved = class {
  constructor(path9, stats) {
    this.path = path9;
    this.stats = stats;
    this._tag = "DirectoryRemoved";
  }
};
var FileWatcherTypeId = Symbol();
var FileWatcher = class {
  constructor() {
    this[_a10] = FileWatcherTypeId;
  }
};
_a10 = FileWatcherTypeId;
var FileWatcherInternal = class extends FileWatcher {
  constructor() {
    super(...arguments);
    this[_b3] = FileWatcherTypeId;
  }
};
_b3 = FileWatcherTypeId;
var WatchErrorTypeId = Symbol();
var FileWatcherError = class extends Tagged("FileWatcherError") {
  constructor() {
    super(...arguments);
    this[_c3] = WatchErrorTypeId;
  }
};
_c3 = WatchErrorTypeId;
var ConcreteFileWatcher = class extends FileWatcherInternal {
  constructor(instance, fsEventsHub, paths, options) {
    super();
    this.instance = instance;
    this.fsEventsHub = fsEventsHub;
    this.paths = paths;
    this.options = options;
    this[_d3] = FileWatcherTypeId;
  }
  shutdown() {
    return pipe(this.instance, get4, chain8((_2) => tryPromise(() => _2.close())), catchAll2((_2) => unit3));
  }
  add(paths) {
    return pipe(this.instance, get4, chain8((_2) => succeedWith3(() => {
      _2.add(paths);
    })));
  }
  remove(paths) {
    return pipe(this.instance, get4, chain8((_2) => succeedWith3(() => {
      _2.unwatch(paths);
    })));
  }
  subscribeToEvents() {
    return pipe(this.instance, get4, chain8((_2) => succeedWith3(() => {
      _2.on("error", (error) => {
        run4(publish_(this.fsEventsHub, succeed4(left(new FileWatcherError({ origin: some(error) })))));
      });
      _2.on("all", (eventName, path9, stats) => {
        switch (eventName) {
          case "add":
            run4(publish_(this.fsEventsHub, succeed4(right(new FileAdded(unknownFilePath(path9), fromNullable(stats))))));
            break;
          case "unlink":
            run4(publish_(this.fsEventsHub, succeed4(right(new FileRemoved(unknownFilePath(path9), fromNullable(stats))))));
            break;
          case "change":
            run4(publish_(this.fsEventsHub, succeed4(right(new FileChanged(unknownFilePath(path9), fromNullable(stats))))));
            break;
          case "addDir":
            run4(publish_(this.fsEventsHub, succeed4(right(new DirectoryAdded(unknownFilePath(path9), fromNullable(stats))))));
            break;
          case "unlinkDir":
            run4(publish_(this.fsEventsHub, succeed4(right(new DirectoryRemoved(unknownFilePath(path9), fromNullable(stats))))));
            break;
        }
      });
    })));
  }
  subscribe() {
    return pipe(subscribe(this.fsEventsHub), chain9((_2) => ensuringFirst_(succeed7(fromQueue()(_2)), shutdown(_2))), map10(flattenExit));
  }
};
_d3 = FileWatcherTypeId;
function concrete6(fileWatcher) {
}
function makeUnsafe(paths, options) {
  const instance = unsafeMakeRef(Chokidar.watch(paths, options));
  const hub = unsafeMakeUnbounded();
  return new ConcreteFileWatcher(instance, hub, paths, options);
}
function make12(paths, options) {
  return pipe(
    succeedWith3(() => Chokidar.watch(paths, options)),
    // T.tap(() => T.succeedWith(() => console.log('start make'))),
    chain8((_2) => makeRef(_2)),
    zip5(makeUnbounded3()),
    // T.tap(() => T.fail(new Error('test'))),
    chain8(({ tuple: [instance, hub] }) => succeedWith3(() => new ConcreteFileWatcher(instance, hub, paths, options))),
    tap4((_2) => _2.subscribeToEvents())
  );
}
var makeAndSubscribe = (paths, options) => pipe(make_(make12(paths, options), shutdown3), chain9(subscribe2), unwrapManaged2);
function subscribe2(self) {
  concrete6(self);
  return self.subscribe();
}
function add_3(self, paths) {
  concrete6(self);
  return self.add(paths);
}
function add2(paths) {
  return (self) => add_3(self, paths);
}
function remove_4(self, paths) {
  concrete6(self);
  return self.remove(paths);
}
function remove3(paths) {
  return (self) => remove_4(self, paths);
}
function shutdown3(self) {
  concrete6(self);
  return self.shutdown();
}

// node_modules/@contentlayer2/core/dist/generation/generate-dotpkg.js
import { camelCase } from "camel-case";
import * as URL2 from "url";

// node_modules/@contentlayer2/core/dist/_ArtifactsDir.js
var ArtifactsDir_exports = {};
__export(ArtifactsDir_exports, {
  getCacheDirPath: () => getCacheDirPath,
  getDirPath: () => getDirPath,
  mkdir: () => mkdir,
  mkdirCache: () => mkdirCache
});

// node_modules/@contentlayer2/core/dist/cwd.js
var makeCwd = Effect_exports3.gen(function* (_2) {
  const cwd = yield* _2(Effect_exports3.succeedWith(() => {
    const cwdValue = process.env.PWD ?? process.cwd();
    return unknownToAbsolutePosixFilePath(cwdValue);
  }));
  return { cwd };
});
var Cwd = tag(Symbol("contentlayer:Cwd"));
var provideCwd = Effect_exports3.provideServiceM(Cwd)(makeCwd);
var getCwd = Effect_exports3.accessService(Cwd)((_2) => _2.cwd);

// node_modules/@contentlayer2/core/dist/_ArtifactsDir.js
var getDirPath = ({ cwd }) => filePathJoin(cwd, ".contentlayer");
var mkdir = Effect_exports3.gen(function* ($2) {
  const cwd = yield* $2(getCwd);
  const dirPath = getDirPath({ cwd });
  yield* $2(fs_exports.mkdirp(dirPath));
  return dirPath;
});
var getCacheDirPath = pipe(Effect_exports3.struct({
  contentlayerVersion: getContentlayerVersion(),
  cwd: getCwd
}), Effect_exports3.map(({ contentlayerVersion, cwd }) => filePathJoin(getDirPath({ cwd }), ".cache", `v${contentlayerVersion}`)));
var mkdirCache = pipe(getCacheDirPath, Effect_exports3.tap((_2) => fs_exports.mkdirp(_2)));

// node_modules/@contentlayer2/core/dist/errors.js
var NoConfigFoundError = class extends Tagged("NoConfigFoundError") {
  constructor() {
    super(...arguments);
    this.toString = () => this.configPath ? `Couldn't find ${this.configPath}` : `Could not find contentlayer.config.ts or contentlayer.config.js in ${this.cwd}`;
  }
};
var ConfigReadError = class extends Tagged("ConfigReadError") {
  constructor() {
    super(...arguments);
    this.toString = () => `ConfigReadError (${this.configPath}): ${errorToString(this.error)}`;
  }
};
var ConfigNoDefaultExportError = class extends Tagged("ConfigNoDefaultExportError") {
};
var SourceFetchDataError = class extends Tagged("SourceFetchDataError") {
  constructor() {
    super(...arguments);
    this.toString = () => `SourceFetchDataError: ${errorToString(this.error)}`;
    this.toJSON = () => ({ _tag: this._tag, error: errorToString(this.error), alreadyHandled: this.alreadyHandled });
  }
};
SourceFetchDataError.fromJSON = (json) => new SourceFetchDataError({ error: json.error, alreadyHandled: json.alreadyHandled });
var SourceProvideSchemaError = class extends Tagged("SourceProvideSchemaError") {
  constructor() {
    super(...arguments);
    this.toString = () => `SourceProvideSchemaError: ${errorToString(this.error)}`;
    this.toJSON = () => ({ _tag: this._tag, error: errorToString(this.error) });
  }
};
SourceProvideSchemaError.fromJSON = (json) => new SourceProvideSchemaError({ error: json.error });
var HandledFetchDataError = class extends Tagged("HandledFetchDataError") {
};
var EsbuildBinNotFoundError = class extends Tagged("EsbuildBinNotFoundError") {
};
var SuccessCallbackError = class extends Tagged("SuccessCallbackError") {
  constructor() {
    super(...arguments);
    this.toString = () => `SuccessCallbackError: ${errorToString(this.error)}`;
  }
};

// node_modules/@contentlayer2/core/dist/getConfig/esbuild.js
import * as esbuild from "esbuild";
var _a11;
var _b4;
var EsbuildWatcherTypeId = Symbol();
_a11 = EsbuildWatcherTypeId;
var UnknownEsbuildError = class extends Tagged("UnknownEsbuildError") {
  constructor() {
    super(...arguments);
    this.toString = () => `UnknownEsbuildError: ${errorToString(this.error)}`;
  }
};
var KnownEsbuildError = class extends Tagged("KnownEsbuildError") {
  constructor() {
    super(...arguments);
    this.toString = () => `KnownEsbuildError: ${JSON.stringify(this.error, null, 2)}`;
  }
};
_b4 = EsbuildWatcherTypeId;

// node_modules/@contentlayer2/core/dist/DataCache.js
import * as path3 from "node:path";
var DataCache;
(function(DataCache2) {
  DataCache2.loadPreviousCacheFromDisk = ({ schemaHash }) => pipe(Effect_exports3.gen(function* ($2) {
    const cacheDirPath = yield* $2(ArtifactsDir_exports.getCacheDirPath);
    const filePath = path3.join(cacheDirPath, dataCacheFileName(schemaHash));
    yield* $2(OT_exports.addAttribute("filePath", filePath));
    const cache = yield* $2(fs_exports.readFileJsonIfExists(filePath));
    return cache;
  }), OT_exports.withSpan("@contentlayer2/core/cache:loadPreviousCacheFromDisk", { attributes: { schemaHash } }));
  DataCache2.writeCacheToDisk = ({ cache, schemaHash }) => pipe(Effect_exports3.gen(function* ($2) {
    const cacheDirPath = yield* $2(ArtifactsDir_exports.mkdirCache);
    const filePath = path3.join(cacheDirPath, dataCacheFileName(schemaHash));
    yield* $2(OT_exports.addAttribute("filePath", filePath));
    yield* $2(fs_exports.writeFileJson({ filePath, content: cache }));
  }), Effect_exports3.either, OT_exports.withSpan("@contentlayer2/core/cache:writeCacheToDisk", { attributes: { schemaHash } }));
  const dataCacheFileName = (schemaHash) => `data-${schemaHash}.json`;
})(DataCache || (DataCache = {}));

// node_modules/@contentlayer2/core/dist/getConfig/index.js
import * as path4 from "node:path";
var makeTmpDirAndResolveEntryPoint = pipe(ArtifactsDir_exports.mkdirCache, Effect_exports3.map((cacheDir) => path4.join(cacheDir, "compiled-contentlayer-config.mjs")));

// node_modules/@contentlayer2/core/dist/runMain.js
import * as os from "node:os";

// node_modules/@contentlayer2/core/dist/markdown/markdown.js
import rehypeStringify from "rehype-stringify";
import remarkFrontmatter from "remark-frontmatter";
import remarkParse from "remark-parse";
import remark2rehype from "remark-rehype";
import { unified } from "unified";

// node_modules/@contentlayer2/core/dist/markdown/unified.js
var addRawDocumentToVFile = (rawDocumentData) => () => (_2, vfile) => {
  Object.assign(vfile.data, { rawDocumentData });
};

// node_modules/@contentlayer2/core/dist/markdown/markdown.js
var markdownToHtml = ({ mdString, options, rawDocumentData }) => pipe(Effect_exports3.gen(function* ($2) {
  if (process.env["CL_FAST_MARKDOWN"]) {
    return yield* $2(Effect_exports3.tryPromise(async () => {
      const { parse: parseWasm } = await import("markdown-wasm/dist/markdown.node.js");
      return parseWasm(mdString);
    }));
  }
  const builder2 = unified();
  builder2.use(addRawDocumentToVFile(rawDocumentData));
  if (typeof options === "function") {
    options(builder2);
  } else {
    builder2.use(remarkFrontmatter);
    builder2.use(remarkParse);
    if (options?.remarkPlugins) {
      builder2.use(options.remarkPlugins);
    }
    builder2.use(remark2rehype);
    if (options?.rehypePlugins) {
      builder2.use(options.rehypePlugins);
    }
    builder2.use(rehypeStringify);
  }
  const res = yield* $2(Effect_exports3.tryPromise(() => builder2.process(mdString)));
  return res.toString();
}), Effect_exports3.catchAllDefect(Effect_exports3.fail), Effect_exports3.mapError((error) => new UnexpectedMarkdownError({ error })), OT_exports.withSpan("@contentlayer2/core/markdown:markdownToHtml"));
var UnexpectedMarkdownError = class extends Tagged("UnexpectedMarkdownError") {
  constructor() {
    super(...arguments);
    this.toString = () => `UnexpectedMarkdownError: ${errorToString(this.error)}`;
  }
};

// node_modules/@contentlayer2/core/dist/markdown/mdx.js
import * as path5 from "node:path";
import * as mdxBundler from "mdx-bundler";
var bundleMDX2 = ({ mdxString, options, contentDirPath, rawDocumentData }) => pipe(Effect_exports3.gen(function* ($2) {
  if (mdxString.length === 0) {
    return "";
  }
  const { rehypePlugins, remarkPlugins, resolveCwd, cwd: cwd_, mdxOptions: mapMdxOptions, esbuildOptions: mapEsbuildOptions, ...restOptions } = options ?? {};
  const getCwdFromContentDirPath = () => (
    // TODO don't use `process.cwd()` but instead `HasCwd`
    path5.isAbsolute(contentDirPath) ? contentDirPath : path5.join(process.cwd(), contentDirPath)
  );
  const getRelativeCwd = () => path5.join(getCwdFromContentDirPath(), path5.dirname(rawDocumentData.flattenedPath));
  const getCwd2 = () => resolveCwd === "contentDirPath" ? getCwdFromContentDirPath() : getRelativeCwd();
  if (process.env.NODE_ENV === void 0) {
    process.env.NODE_ENV = "development";
  }
  const mdxOptions = {
    mdxOptions: (opts) => {
      opts.rehypePlugins = [...opts.rehypePlugins ?? [], ...rehypePlugins ?? []];
      opts.remarkPlugins = [
        addRawDocumentToVFile(rawDocumentData),
        ...opts.remarkPlugins ?? [],
        ...remarkPlugins ?? []
      ];
      return mapMdxOptions ? mapMdxOptions(opts) : opts;
    },
    // User-provided cwd trumps resolution
    cwd: cwd_ ?? getCwd2(),
    esbuildOptions: (opts, frontmatter) => {
      opts.target = "es2020";
      return mapEsbuildOptions ? mapEsbuildOptions(opts, frontmatter) : opts;
    },
    // NOTE `restOptions` should be spread at the end to allow for user overrides
    ...restOptions
  };
  const res = yield* $2(Effect_exports3.tryPromise(() => mdxBundler.bundleMDX({ source: mdxString, ...mdxOptions })));
  if (res.errors.length > 0) {
    return yield* $2(Effect_exports3.fail(res.errors));
  }
  return res.code;
}), Effect_exports3.mapError((error) => new UnexpectedMDXError({ error })), Effect_exports3.tapError(() => OT_exports.addAttribute("mdxString", mdxString)), OT_exports.withSpan("@contentlayer2/core/markdown:bundleMDX"));
var UnexpectedMDXError = class extends Tagged("UnexpectedMDXError") {
  constructor() {
    super(...arguments);
    this.toString = () => `UnexpectedMDXError: ${errorToString(this.error)}`;
  }
};

// node_modules/@contentlayer2/core/dist/plugin.js
var defaultFieldOptions = {
  bodyFieldName: "body",
  typeFieldName: "type"
};
var processArgs = async (argsOrArgsThunk, sourceKey) => {
  const { extensions, fieldOptions, markdown, mdx, date, disableImportAliasWarning, experimental, onSuccess, ...restArgs } = typeof argsOrArgsThunk === "function" ? await argsOrArgsThunk(sourceKey) : argsOrArgsThunk;
  const options = {
    markdown,
    mdx,
    date,
    fieldOptions: {
      bodyFieldName: fieldOptions?.bodyFieldName ?? defaultFieldOptions.bodyFieldName,
      typeFieldName: fieldOptions?.typeFieldName ?? defaultFieldOptions.typeFieldName
    },
    disableImportAliasWarning: disableImportAliasWarning ?? false,
    experimental: {
      enableDynamicBuild: experimental?.enableDynamicBuild ?? false
    },
    onSuccess
  };
  return { extensions: extensions ?? {}, options, restArgs };
};

// node_modules/@contentlayer2/core/dist/schema/field.js
var isListFieldDef = (_2) => _2.type === "list";
var ListFieldDefItem;
(function(ListFieldDefItem3) {
  ListFieldDefItem3.isDefItemNested = (_2) => _2.type === "nested";
  ListFieldDefItem3.isDefItemReference = (_2) => _2.type === "reference";
})(ListFieldDefItem || (ListFieldDefItem = {}));
var isReferenceField = (_2) => _2.type === "reference";

// node_modules/@contentlayer2/core/dist/schema/validate.js
var validateSchema = (schema) => {
  Object.values(schema.documentTypeDefMap).forEach((def) => validateDocumentOrObjectDef({ def }));
  Object.values(schema.nestedTypeDefMap).forEach((def) => validateDocumentOrObjectDef({ def }));
};
var validateDocumentOrObjectDef = ({ def }) => {
  const stackbitExt = def.extensions.stackbit;
  if (stackbitExt?.labelField) {
    const noFieldFoundForLabelField = !def.fieldDefs.some((_2) => _2.name === stackbitExt.labelField);
    if (noFieldFoundForLabelField) {
      throw new Error(`There is no field with the name "${stackbitExt.labelField}" as specified for "labelField" in ${def._tag} with the name "${def.name}"`);
    }
  }
};

// node_modules/@contentlayer2/core/dist/validate-tsconfig.js
import path6 from "node:path";
import { parse as parseJsonc } from "comment-json";
var validateTsconfig = pipe(Effect_exports3.gen(function* ($2) {
  const cwd = yield* $2(getCwd);
  const possibleFileNames = ["tsconfig.json", "jsconfig.json"].map((_2) => filePathJoin(cwd, _2));
  const tsconfigOption = yield* $2(pipe(possibleFileNames, Effect_exports3.forEachPar(tryParseFile), Effect_exports3.map(Chunk_exports3.toArray), Effect_exports3.map((_2) => Option_exports3.getFirst(..._2))));
  const warningMessage = (msg) => Effect_exports3.log(`Contentlayer (Warning): Importing from \`contentlayer/generated\` might not work.
${msg}

For more information see https://www.contentlayer.dev/docs/getting-started
To disable this warning you can set \`disableImportAliasWarning: true\` in your Contentlayer config.
`);
  if (Option_exports3.isNone(tsconfigOption)) {
    yield* $2(warningMessage(`No tsconfig.json or jsconfig.json file found`));
    return;
  }
  const { config, fileName } = tsconfigOption.value;
  if (config.compilerOptions?.baseUrl === void 0) {
    yield* $2(warningMessage(`Config option \`compilerOptions.baseUrl\` not found in "${fileName}".`));
    return;
  }
  if (config.compilerOptions?.paths === void 0) {
    yield* $2(warningMessage(`Config option \`compilerOptions.paths\` not found in "${fileName}".`));
    return;
  }
  const paths = Object.values(config.compilerOptions.paths).flat();
  if (!paths.some((_2) => _2.includes("./.contentlayer/generated"))) {
    yield* $2(warningMessage(`No path alias found for "contentlayer/generated" via \`compilerOptions.paths\` in "${fileName}".`));
  }
}), OT_exports.withSpan("validateTsconfig"));
var tryParseFile = (filePath) => pipe(fs_exports.readFile(filePath), Effect_exports3.chain((contents) => Effect_exports3.tryCatch(() => parseJsonc(contents, void 0, true), (error) => new InvalidTsconfigError({ error }))), Effect_exports3.map((config) => ({ fileName: path6.basename(filePath), config })), Effect_exports3.tapError((error) => Effect_exports3.succeedWith(() => {
  if (error._tag === "InvalidTsconfigError" || error._tag === "fs.ReadFileError") {
    console.log(`Contentlayer: Invalid jsconfig/tsconfig file found: ${filePath}`);
  }
})), Effect_exports3.option);
var InvalidTsconfigError = class extends Tagged("InvalidTsconfigError") {
};

// node_modules/@contentlayer2/source-files/dist/fetchData/DocumentContext.js
import * as path7 from "node:path";

// node_modules/@contentlayer2/source-files/dist/fetchData/mapping/field-date.js
var makeDateField = ({ dateString, fieldName, options }) => pipe(Effect_exports3.try(() => {
  const dateHasExplitcitTimezone = () => {
    try {
      Pt.TimeZone.from(dateString);
      return true;
    } catch {
      return false;
    }
  };
  if (options.date?.timezone !== void 0 && dateHasExplitcitTimezone() === false) {
    const instant2 = new Date(dateString).toTemporalInstant();
    const desiredTimezone = Pt.TimeZone.from(options.date.timezone);
    const offsetNs = desiredTimezone.getOffsetNanosecondsFor(instant2);
    return instant2.subtract({ nanoseconds: offsetNs }).toString();
  } else {
    return new Date(dateString).toISOString();
  }
}), Effect_exports3.catchAll(() => FetchDataError.IncompatibleFieldDataError.fail({ incompatibleFieldData: [[fieldName, dateString]] })));

// node_modules/@contentlayer2/source-files/dist/fetchData/mapping/field-image.js
var makeImageField = ({ imageData, documentFilePath, contentDirPath, fieldDef }) => Effect_exports3.gen(function* ($2) {
  const imageFieldData = yield* $2(getImageFieldData({
    imagePath: imageData.src,
    documentFilePath,
    contentDirPath,
    fieldDef
  }));
  return identity({ ...imageFieldData, alt: imageData.alt });
});
var getImageFieldData = ({ documentFilePath, contentDirPath, fieldDef, imagePath: imagePath_ }) => pipe(Effect_exports3.gen(function* ($2) {
  const cwd = yield* $2(getCwd);
  const imagePath = unknownToRelativePosixFilePath(imagePath_, cwd);
  const documentDirPath = dirname2(documentFilePath);
  const filePath = filePathJoin(documentDirPath, imagePath);
  const absoluteFilePath = filePathJoin(contentDirPath, documentDirPath, imagePath);
  const relativeFilePath = relative2(filePathJoin(contentDirPath, documentDirPath), absoluteFilePath);
  const fileBuffer = yield* $2(fs_exports.readFileBuffer(absoluteFilePath));
  const { resizedData, height, width, format: format3 } = yield* $2(processImage(fileBuffer));
  const aspectRatio = width / height;
  const dataB64 = base64_exports.encode(resizedData);
  const blurhashDataUrl = `data:image/${format3};base64,${dataB64}`;
  return identity({
    filePath,
    relativeFilePath,
    format: format3,
    height,
    width,
    aspectRatio,
    blurhashDataUrl
  });
}), Effect_exports3.catchAll((error) => pipe(getFromDocumentContext("documentTypeDef"), Effect_exports3.chain((documentTypeDef) => Effect_exports3.fail(new FetchDataError.ImageError({
  error,
  documentFilePath,
  fieldDef,
  imagePath: imagePath_,
  documentTypeDef
}))))), OT_exports.withSpan("getImageFieldData", { attributes: { imagePath: imagePath_ } }));
var SharpModule = void 0;
var ImageScriptModule = void 0;
var processImage = (fileBuffer) => Effect_exports3.gen(function* ($2) {
  if (SharpModule === void 0 && ImageScriptModule === void 0) {
    yield* $2(pipe(
      Effect_exports3.tryPromise(() => import("sharp")),
      // NOTE `sharp` is still a CJS module, so default import is needed
      Effect_exports3.tap((_2) => Effect_exports3.succeedWith(() => SharpModule = _2.default)),
      Effect_exports3.catchAll(() => pipe(Effect_exports3.tryPromise(() => import("imagescript")), Effect_exports3.tap((_2) => Effect_exports3.succeedWith(() => ImageScriptModule = _2)))),
      OT_exports.withSpan("importSharpOrImageScript")
    ));
  }
  if (SharpModule) {
    return yield* $2(processImageWithSharp(fileBuffer));
  } else {
    return yield* $2(processImageWithImageScript(fileBuffer));
  }
});
var processImageWithImageScript = (fileBuffer) => pipe(Effect_exports3.gen(function* ($2) {
  const format3 = ImageScriptModule.ImageType.getType(fileBuffer);
  if (format3 === null) {
    return yield* $2(Effect_exports3.fail(new Error("Could not determine image type")));
  }
  const image = yield* $2(pipe(Effect_exports3.tryPromise(() => ImageScriptModule.decode(fileBuffer)), OT_exports.withSpan("decodeImage")));
  const { width, height } = image;
  image.resize(8, 8);
  const resizedData = yield* $2(pipe(Effect_exports3.tryPromise(() => image.encode(70)), OT_exports.withSpan("resizeImage")));
  return { resizedData, width, height, format: format3 };
}), OT_exports.withSpan("processImageWithImageScript"));
var processImageWithSharp = (fileBuffer) => pipe(Effect_exports3.gen(function* ($2) {
  const sharpImage = SharpModule(fileBuffer);
  const metadata = yield* $2(Effect_exports3.tryPromise(() => sharpImage.metadata()));
  if (metadata.width === void 0 || metadata.height === void 0 || metadata.format === void 0) {
    return yield* $2(Effect_exports3.fail(new Error("Could not determine image dimensions")));
  }
  const { width, height, format: format3 } = metadata;
  const resizedInfo = yield* $2(pipe(Effect_exports3.tryPromise(() => {
    const quality = 70;
    switch (format3) {
      case "jpeg":
        sharpImage.jpeg({ quality });
        break;
      case "webp":
        sharpImage.webp({ quality });
        break;
      case "png":
        sharpImage.png({ quality });
        break;
      case "avif":
        sharpImage.avif({ quality });
        break;
    }
    return sharpImage.resize(8, 8).toBuffer({ resolveWithObject: true });
  }), OT_exports.withSpan("resizeImage", { attributes: { width, height, format: format3 } })));
  return { resizedData: resizedInfo.data, width, height, format: format3 };
}), OT_exports.withSpan("processImageWithSharp"));

// node_modules/@contentlayer2/source-files/dist/fetchData/mapping/field-markdown.js
var makeMarkdownField = ({ mdString, options, isDocumentBodyField }) => Effect_exports3.gen(function* ($2) {
  const rawDocumentData = yield* $2(getFromDocumentContext("rawDocumentData"));
  if (isDocumentBodyField) {
    const rawContent = yield* $2(getFromDocumentContext("rawContent"));
    if (rawContent.kind !== "markdown" && rawContent.kind !== "mdx")
      return assertNever(rawContent);
    const html = yield* $2(markdownToHtml({
      mdString: rawContent.rawDocumentContent,
      options: options?.markdown,
      rawDocumentData
    }));
    return { raw: mdString, html };
  } else {
    const html = yield* $2(markdownToHtml({ mdString, options: options?.markdown, rawDocumentData }));
    return { raw: mdString, html };
  }
});

// node_modules/@contentlayer2/source-files/dist/fetchData/mapping/field-mdx.js
var makeMdxField = ({ mdxString, options, contentDirPath, isDocumentBodyField }) => Effect_exports3.gen(function* ($2) {
  const rawDocumentData = yield* $2(getFromDocumentContext("rawDocumentData"));
  if (isDocumentBodyField) {
    const rawContent = yield* $2(getFromDocumentContext("rawContent"));
    if (rawContent.kind !== "mdx" && rawContent.kind !== "markdown")
      return assertNever(rawContent);
    const code = yield* $2(bundleMDX2({
      mdxString: rawContent.rawDocumentContent,
      options: options?.mdx,
      contentDirPath,
      rawDocumentData
    }));
    return { raw: mdxString, code };
  } else {
    const code = yield* $2(bundleMDX2({ mdxString, options: options?.mdx, contentDirPath, rawDocumentData }));
    return { raw: mdxString, code };
  }
});

// node_modules/@contentlayer2/source-files/dist/fetchData/mapping/parseFieldData.js
import * as zod from "zod";
var ParsedImageData = zod.object({
  src: zod.string(),
  alt: zod.string().optional()
});
var ImageData = zod.union([zod.string(), ParsedImageData]).transform((_2) => {
  if (typeof _2 === "string") {
    return { src: _2 };
  }
  return _2;
});
var codecMap = {
  boolean: zod.boolean(),
  number: zod.number(),
  string: zod.string(),
  date: zod.string(),
  // NOTE date parsing is handled in `field-date.ts`
  enum: zod.string(),
  // TODO
  image: ImageData,
  json: zod.any(),
  list: zod.array(zod.any()),
  list_polymorphic: zod.array(zod.any()),
  markdown: zod.string(),
  mdx: zod.string(),
  nested: zod.record(zod.any()),
  nested_polymorphic: zod.record(zod.any()),
  nested_unnamed: zod.record(zod.any()),
  reference: zod.string(),
  reference_polymorphic: zod.string()
};
var parseFieldData = ({ rawData, fieldType, fieldName }) => {
  const result4 = codecMap[fieldType].safeParse(rawData);
  if (result4.success) {
    return Effect_exports3.succeed(result4.data);
  } else {
    return FetchDataError.IncompatibleFieldDataError.fail({ incompatibleFieldData: [[fieldName, rawData]] });
  }
};

// node_modules/@contentlayer2/source-files/dist/fetchData/mapping/index.js
var makeDocument = ({ rawContent, documentTypeDef, coreSchemaDef, relativeFilePath, contentDirPath, options }) => pipe(Effect_exports3.gen(function* ($2) {
  const { bodyFieldName, typeFieldName } = options.fieldOptions;
  const body = pattern2.match(rawContent).when(rawContentHasBody, (_2) => _2.body).otherwise(() => void 0);
  const rawData = { ...rawContent.fields, [bodyFieldName]: body };
  const docValues = yield* $2(Effect_exports3.forEachParDict_(documentTypeDef.fieldDefs, {
    mapValue: (fieldDef) => getDataForFieldDef({
      fieldDef,
      rawFieldData: rawData[fieldDef.name],
      isRootDocument: true,
      coreSchemaDef,
      options,
      documentFilePath: relativeFilePath,
      contentDirPath
    }),
    mapKey: (fieldDef) => Effect_exports3.succeed(fieldDef.name)
  }));
  const _raw = yield* $2(getFromDocumentContext("rawDocumentData"));
  const doc = identity({
    ...docValues,
    _id: relativeFilePath,
    _raw,
    [typeFieldName]: documentTypeDef.name
  });
  return doc;
}), Effect_exports3.mapError((error) => error._tag === "NoSuchNestedDocumentTypeError" || error._tag === "IncompatibleFieldDataError" || error._tag === "ImageError" ? error : new FetchDataError.UnexpectedError({ error, documentFilePath: relativeFilePath })));
var rawContentHasBody = (_2) => "body" in _2 && _2.body !== void 0;
var getFlattenedPath = (relativeFilePath) => relativeFilePath.split(".").slice(0, -1).join(".").replace(/^index$/, "").replace(/\/index$/, "");
var makeNestedDocument = ({ rawObjectData, fieldDefs, nestedTypeName, coreSchemaDef, options, documentFilePath, contentDirPath }) => Effect_exports3.gen(function* ($2) {
  const objValues = yield* $2(Effect_exports3.forEachParDict_(fieldDefs, {
    mapValue: (fieldDef) => getDataForFieldDef({
      fieldDef,
      rawFieldData: rawObjectData[fieldDef.name],
      isRootDocument: false,
      coreSchemaDef,
      options,
      documentFilePath,
      contentDirPath
    }),
    mapKey: (fieldDef) => Effect_exports3.succeed(fieldDef.name)
  }));
  const typeNameField = options.fieldOptions.typeFieldName;
  const obj = { ...objValues, [typeNameField]: nestedTypeName, _raw: {} };
  return obj;
});
var getDataForFieldDef = ({ fieldDef, rawFieldData, isRootDocument, coreSchemaDef, options, documentFilePath, contentDirPath }) => Effect_exports3.gen(function* ($2) {
  if ((rawFieldData === void 0 || rawFieldData === null) && fieldDef.default !== void 0) {
    rawFieldData = fieldDef.default;
  }
  if (rawFieldData === void 0 || rawFieldData === null) {
    const documentTypeDef = yield* $2(getFromDocumentContext("documentTypeDef"));
    console.assert(fieldDef.isRequired === false || fieldDef.isSystemField === true, `Inconsistent data found: ${rawFieldData} ${JSON.stringify({
      fieldDef,
      documentFilePath,
      rootDocTypeName: documentTypeDef.name,
      isRootDocument
    }, null, 2)}`);
    return rawFieldData;
  }
  const parseFieldDataEff = (fieldType) => parseFieldData({
    rawData: rawFieldData,
    fieldType,
    fieldName: fieldDef.name
  });
  switch (fieldDef.type) {
    case "nested": {
      const nestedTypeDef = coreSchemaDef.nestedTypeDefMap[fieldDef.nestedTypeName];
      const rawObjectData2 = yield* $2(parseFieldDataEff("nested"));
      return yield* $2(makeNestedDocument({
        rawObjectData: rawObjectData2,
        fieldDefs: nestedTypeDef.fieldDefs,
        nestedTypeName: nestedTypeDef.name,
        coreSchemaDef,
        options,
        documentFilePath,
        contentDirPath
      }));
    }
    case "nested_unnamed":
      const rawObjectData = yield* $2(parseFieldDataEff("nested_unnamed"));
      return yield* $2(makeNestedDocument({
        rawObjectData,
        fieldDefs: fieldDef.typeDef.fieldDefs,
        nestedTypeName: "__UNNAMED__",
        coreSchemaDef,
        options,
        documentFilePath,
        contentDirPath
      }));
    case "nested_polymorphic": {
      const rawObjectData2 = yield* $2(parseFieldDataEff("nested_polymorphic"));
      const nestedTypeName = rawObjectData2[fieldDef.typeField];
      if (!fieldDef.nestedTypeNames.includes(nestedTypeName)) {
        const documentTypeDef = yield* $2(getFromDocumentContext("documentTypeDef"));
        return yield* $2(Effect_exports3.fail(new FetchDataError.NoSuchNestedDocumentTypeError({
          nestedTypeName,
          documentFilePath,
          fieldName: fieldDef.name,
          validNestedTypeNames: fieldDef.nestedTypeNames,
          documentTypeDef
        })));
      }
      const nestedTypeDef = coreSchemaDef.nestedTypeDefMap[nestedTypeName];
      return yield* $2(makeNestedDocument({
        rawObjectData: rawObjectData2,
        fieldDefs: nestedTypeDef.fieldDefs,
        nestedTypeName: nestedTypeDef.name,
        coreSchemaDef,
        options,
        documentFilePath,
        contentDirPath
      }));
    }
    case "reference":
    case "reference_polymorphic":
      return yield* $2(parseFieldDataEff(fieldDef.type));
    case "list_polymorphic":
    case "list":
      const rawListData = yield* $2(parseFieldDataEff("list"));
      return yield* $2(Effect_exports3.forEachPar_(rawListData, (rawItemData) => getDataForListItem({
        rawItemData,
        fieldDef,
        coreSchemaDef,
        options,
        documentFilePath,
        contentDirPath
      })));
    case "date":
      const dateString = yield* $2(parseFieldDataEff("date"));
      return yield* $2(makeDateField({ dateString, fieldName: fieldDef.name, options }));
    case "markdown": {
      const mdString = yield* $2(parseFieldDataEff("markdown"));
      const isDocumentBodyField = isRootDocument && fieldDef.name === options.fieldOptions.bodyFieldName;
      return yield* $2(makeMarkdownField({ mdString, options, isDocumentBodyField }));
    }
    case "mdx": {
      const mdxString = yield* $2(parseFieldDataEff("mdx"));
      const isDocumentBodyField = isRootDocument && fieldDef.name === options.fieldOptions.bodyFieldName;
      return yield* $2(makeMdxField({ mdxString, contentDirPath, options, isDocumentBodyField }));
    }
    case "image":
      const imageData = yield* $2(parseFieldDataEff("image"));
      return yield* $2(makeImageField({ imageData, documentFilePath, contentDirPath, fieldDef }));
    case "boolean":
    case "string":
    case "number":
    case "json":
    case "enum":
      return yield* $2(parseFieldDataEff(fieldDef.type));
    default:
      casesHandled(fieldDef);
  }
});
var getDataForListItem = ({ rawItemData, fieldDef, coreSchemaDef, options, documentFilePath, contentDirPath }) => Effect_exports3.gen(function* ($2) {
  const parseFieldDataEff = (fieldType) => parseFieldData({
    rawData: rawItemData,
    fieldType,
    fieldName: fieldDef.name
  });
  if (fieldDef.type === "list_polymorphic") {
    const rawObjectData = yield* $2(parseFieldDataEff("nested"));
    const nestedTypeName = rawObjectData[fieldDef.typeField];
    const nestedTypeDef = coreSchemaDef.nestedTypeDefMap[nestedTypeName];
    if (nestedTypeDef === void 0) {
      const validNestedTypeNames = fieldDef.of.filter((_2) => _2.type === "nested").map((_2) => _2.nestedTypeName);
      const documentTypeDef = yield* $2(getFromDocumentContext("documentTypeDef"));
      return yield* $2(Effect_exports3.fail(new FetchDataError.NoSuchNestedDocumentTypeError({
        nestedTypeName,
        documentFilePath,
        fieldName: fieldDef.name,
        validNestedTypeNames,
        documentTypeDef
      })));
    }
    return yield* $2(makeNestedDocument({
      rawObjectData: rawItemData,
      fieldDefs: nestedTypeDef.fieldDefs,
      nestedTypeName: nestedTypeDef.name,
      coreSchemaDef,
      options,
      documentFilePath,
      contentDirPath
    }));
  }
  switch (fieldDef.of.type) {
    case "nested": {
      const nestedTypeDef = coreSchemaDef.nestedTypeDefMap[fieldDef.of.nestedTypeName];
      const rawObjectData = yield* $2(parseFieldDataEff("nested"));
      return yield* $2(makeNestedDocument({
        rawObjectData,
        fieldDefs: nestedTypeDef.fieldDefs,
        nestedTypeName: nestedTypeDef.name,
        coreSchemaDef,
        options,
        documentFilePath,
        contentDirPath
      }));
    }
    case "nested_unnamed": {
      const rawObjectData = yield* $2(parseFieldDataEff("nested_unnamed"));
      return yield* $2(makeNestedDocument({
        rawObjectData,
        fieldDefs: fieldDef.of.typeDef.fieldDefs,
        nestedTypeName: "__UNNAMED__",
        coreSchemaDef,
        options,
        documentFilePath,
        contentDirPath
      }));
    }
    case "date":
      const dateString = yield* $2(parseFieldDataEff("date"));
      return yield* $2(makeDateField({ dateString, fieldName: fieldDef.name, options }));
    case "markdown": {
      const mdString = yield* $2(parseFieldDataEff("markdown"));
      return yield* $2(makeMarkdownField({ mdString, options, isDocumentBodyField: false }));
    }
    case "mdx": {
      const mdxString = yield* $2(parseFieldDataEff("mdx"));
      return yield* $2(makeMdxField({ mdxString, contentDirPath, options, isDocumentBodyField: false }));
    }
    case "image":
      const imageData = yield* $2(parseFieldDataEff("image"));
      return yield* $2(makeImageField({ imageData, documentFilePath, contentDirPath, fieldDef }));
    case "enum":
    case "reference":
    case "string":
    case "boolean":
    case "number":
    case "json":
      return rawItemData;
    default:
      return casesHandled(fieldDef.of);
  }
});

// node_modules/@contentlayer2/source-files/dist/fetchData/DocumentContext.js
var DocumentContext = tag(Symbol.for("@contentlayer2/source-files/DocumentContext"));
var provideDocumentContext = (_2) => Effect_exports3.provideService(DocumentContext)(_2);
var makeAndProvideDocumentContext = ({ rawContent, relativeFilePath, documentTypeDef }) => {
  const contentType = pattern2.match(rawContent.kind).with("markdown", () => "markdown").with("mdx", () => "mdx").otherwise(() => "data");
  const rawDocumentData = {
    sourceFilePath: relativeFilePath,
    sourceFileName: path7.basename(relativeFilePath),
    sourceFileDir: path7.dirname(relativeFilePath),
    contentType,
    flattenedPath: getFlattenedPath(relativeFilePath)
  };
  return provideDocumentContext({ rawContent, rawDocumentData, relativeFilePath, documentTypeDef });
};
var getFromDocumentContext = (key) => Effect_exports3.accessService(DocumentContext)((_2) => _2[key]);
var getDocumentContext = Effect_exports3.accessService(DocumentContext)((_2) => _2);

// node_modules/@contentlayer2/source-files/dist/errors/aggregate.js
var handleFetchDataErrors = ({ errors, documentCount, options, flags, schemaDef, contentDirPath, verbose }) => Effect_exports3.gen(function* ($2) {
  const filteredErrors = filterIgnoredErrorsByFlags({ errors, flags });
  if (filteredErrors.length === 0)
    return;
  const shouldFail = failOrSkip({ errors: filteredErrors, flags }) === "fail";
  const errorMessage = aggregateFetchDataErrors({
    documentCount,
    errors: filteredErrors,
    options,
    flags,
    shouldFail,
    schemaDef,
    contentDirPath,
    verbose
  });
  yield* $2(Effect_exports3.log(errorMessage));
  if (shouldFail) {
    yield* $2(Effect_exports3.fail(new HandledFetchDataError()));
  }
});
var aggregateFetchDataErrors = ({ errors, documentCount, options, flags, shouldFail, schemaDef, contentDirPath, verbose }) => {
  const keyMessage = `Found ${errors.length} problems in ${documentCount} documents.`;
  const topMessage = shouldFail ? `Error: ${keyMessage}` : `Warning: ${keyMessage}`;
  const asciiTree = new AsciiTree(topMessage + "\n");
  const uniqueErrorTags = Array.from(new Set(errors.map((e2) => e2._tag)));
  for (const tag2 of uniqueErrorTags) {
    const taggedErrors = errors.filter((e2) => e2._tag === tag2);
    let str = "";
    const errorPrintLimit = verbose ? taggedErrors.length : 20;
    const remainingErrorCount = Math.max(taggedErrors.length - errorPrintLimit, 0);
    const skippingMessage = shouldPrintSkipMessage({ flags, error: taggedErrors[0] }) ? " (Skipping documents)" : "";
    str += taggedErrors[0].renderHeadline({
      errorCount: taggedErrors.length,
      skippingMessage,
      options,
      schemaDef,
      contentDirPath
    });
    str += "\n\n";
    str += taggedErrors.splice(0, errorPrintLimit).map((_2) => `\u2022 ${_2.renderLine()}`).join("\n");
    if (remainingErrorCount > 0) {
      str += "\n";
      str += `\u2022 ... ${remainingErrorCount} more documents (Use the --verbose CLI option to show all documents)`;
    }
    str += "\n";
    asciiTree.add(new AsciiTree(str));
  }
  return asciiTree.toString();
};
var shouldPrintSkipMessage = ({ error, flags }) => {
  if (error.category === "MissingOrIncompatibleData" && flags.onMissingOrIncompatibleData === "skip-warn" && error.documentTypeDef?.isSingleton !== true) {
    return true;
  }
  if (error.category === "UnknownDocument" && flags.onUnknownDocuments === "skip-warn") {
    return true;
  }
  return false;
};
var failOrSkip = ({ errors, flags }) => {
  if (errors.some((_2) => _2.category === "ExtraFieldData") && flags.onExtraFieldData === "fail") {
    return "fail";
  }
  if (errors.some((_2) => _2.category === "UnknownDocument") && flags.onUnknownDocuments === "fail") {
    return "fail";
  }
  if (errors.some((_2) => _2.category === "MissingOrIncompatibleData") && flags.onMissingOrIncompatibleData === "fail") {
    return "fail";
  }
  if (errors.some((_2) => _2.category === "SingletonDocumentNotFound")) {
    return "fail";
  }
  if (errors.some((_2) => _2.category === "Unexpected")) {
    return "fail";
  }
  if (errors.some((_2) => _2.documentTypeDef?.isSingleton)) {
    return "fail";
  }
  return "skip";
};
var filterIgnoredErrorsByFlags = ({ errors, flags }) => errors.filter((e2) => {
  if (e2.category === "ExtraFieldData" && flags.onExtraFieldData === "ignore")
    return false;
  if (e2.category === "UnknownDocument" && flags.onUnknownDocuments === "skip-ignore")
    return false;
  if (e2.category === "MissingOrIncompatibleData" && flags.onMissingOrIncompatibleData === "skip-ignore")
    return false;
  return true;
});

// node_modules/@contentlayer2/source-files/dist/errors/index.js
var FetchDataError;
(function(FetchDataError2) {
  FetchDataError2.handleErrors = handleFetchDataErrors;
  class InvalidFrontmatterError extends Tagged("InvalidFrontmatterError") {
    constructor() {
      super(...arguments);
      this.category = "MissingOrIncompatibleData";
      this.documentTypeDef = void 0;
      this.renderHeadline = ({ errorCount, skippingMessage }) => `Invalid frontmatter data found for ${errorCount} documents.${skippingMessage}`;
      this.renderLine = () => `"${this.documentFilePath}" failed with ${errorToString(this.error)}`;
    }
  }
  FetchDataError2.InvalidFrontmatterError = InvalidFrontmatterError;
  class InvalidMarkdownFileError extends Tagged("InvalidMarkdownFileError") {
    constructor() {
      super(...arguments);
      this.category = "MissingOrIncompatibleData";
      this.documentTypeDef = void 0;
      this.renderHeadline = ({ errorCount, skippingMessage }) => `Invalid markdown in ${errorCount} documents.${skippingMessage}`;
      this.renderLine = () => `"${this.documentFilePath}" failed with ${errorToString(this.error)}`;
    }
  }
  FetchDataError2.InvalidMarkdownFileError = InvalidMarkdownFileError;
  class InvalidYamlFileError extends Tagged("InvalidYamlFileError") {
    constructor() {
      super(...arguments);
      this.category = "MissingOrIncompatibleData";
      this.documentTypeDef = void 0;
      this.renderHeadline = ({ errorCount, skippingMessage }) => `Invalid YAML data in ${errorCount} documents.${skippingMessage}`;
      this.renderLine = () => `"${this.documentFilePath}" failed with ${errorToString(this.error)}`;
    }
  }
  FetchDataError2.InvalidYamlFileError = InvalidYamlFileError;
  class InvalidJsonFileError extends Tagged("InvalidJsonFileError") {
    constructor() {
      super(...arguments);
      this.category = "MissingOrIncompatibleData";
      this.documentTypeDef = void 0;
      this.renderHeadline = ({ errorCount, skippingMessage }) => `Invalid JSON data in ${errorCount} documents.${skippingMessage}`;
      this.renderLine = () => `"${this.documentFilePath}" failed with ${errorToString(this.error)}`;
    }
  }
  FetchDataError2.InvalidJsonFileError = InvalidJsonFileError;
  class ImageError extends Tagged("ImageError") {
    constructor() {
      super(...arguments);
      this.category = "MissingOrIncompatibleData";
      this.renderHeadline = ({ errorCount, skippingMessage }) => `Error for ${errorCount} image fields.${skippingMessage}`;
      this.renderLine = () => `"${this.documentFilePath}" with field "${this.fieldDef.name}: ${this.imagePath}" failed with ${errorToString(this.error)}`;
    }
  }
  FetchDataError2.ImageError = ImageError;
  class ComputedValueError extends Tagged("ComputedValueError") {
    constructor() {
      super(...arguments);
      this.category = "MissingOrIncompatibleData";
      this.renderHeadline = ({ errorCount, skippingMessage }) => `Error during computed field exection for ${errorCount} documents.${skippingMessage}`;
      this.renderLine = () => `"${this.documentFilePath}" failed with ${errorToString(this.error)}`;
    }
  }
  FetchDataError2.ComputedValueError = ComputedValueError;
  class UnsupportedFileExtension extends Tagged("UnsupportedFileExtension") {
    constructor() {
      super(...arguments);
      this.category = "MissingOrIncompatibleData";
      this.documentTypeDef = void 0;
      this.renderHeadline = ({ errorCount, skippingMessage }) => `Found unsupported file extensions for ${errorCount} documents.${skippingMessage}`;
      this.renderLine = () => `"${this.filePath}" uses "${this.extension}"`;
    }
  }
  FetchDataError2.UnsupportedFileExtension = UnsupportedFileExtension;
  class FileExtensionMismatch extends Tagged("FileExtensionMismatch") {
    constructor() {
      super(...arguments);
      this.category = "MissingOrIncompatibleData";
      this.documentTypeDef = void 0;
      this.renderHeadline = ({ errorCount, skippingMessage }) => `File extension not compatible with \`contentType\` for ${errorCount} documents.${skippingMessage}`;
      this.renderLine = () => {
        const expectedFileExtensions = pattern2.match(this.contentType).with("markdown", () => ["md", "mdx"]).with("mdx", () => ["mdx", "mdx"]).with("data", () => ["json", "yaml", "yml"]).exhaustive();
        return `"${this.filePath}" ends with "${this.extension}" but expected to be one of "${expectedFileExtensions.join(", ")}" as defined \`contentType\` is "${this.contentType}"`;
      };
    }
  }
  FetchDataError2.FileExtensionMismatch = FileExtensionMismatch;
  class CouldNotDetermineDocumentTypeError extends Tagged("CouldNotDetermineDocumentTypeError") {
    constructor() {
      super(...arguments);
      this.category = "UnknownDocument";
      this.documentTypeDef = void 0;
      this.renderHeadline = ({ errorCount, options, schemaDef, skippingMessage }) => {
        const validTypeNames = Object.keys(schemaDef.documentTypeDefMap).join(", ");
        return `Couldn't determine the document type for ${errorCount} documents.${skippingMessage}

Please either define a filePathPattern for the given document type definition or provide a valid value for the type field (i.e. the field "${options.fieldOptions.typeFieldName}" needs to be one of the following document type names: ${validTypeNames}).`;
      };
      this.renderLine = () => `${this.documentFilePath}`;
    }
  }
  FetchDataError2.CouldNotDetermineDocumentTypeError = CouldNotDetermineDocumentTypeError;
  class NoSuchDocumentTypeError extends Tagged("NoSuchDocumentTypeError") {
    constructor() {
      super(...arguments);
      this.category = "MissingOrIncompatibleData";
      this.documentTypeDef = void 0;
      this.renderHeadline = ({ errorCount, schemaDef, skippingMessage }) => {
        const validTypeNames = Object.keys(schemaDef.documentTypeDefMap).join(", ");
        return `Couldn't find document type definitions provided by name for ${errorCount} documents.${skippingMessage}

Please use one of the following document type names: ${validTypeNames}.`;
      };
      this.renderLine = () => `${this.documentFilePath} (Used type name: "${this.documentTypeName}")`;
    }
  }
  FetchDataError2.NoSuchDocumentTypeError = NoSuchDocumentTypeError;
  class NoSuchNestedDocumentTypeError extends Tagged("NoSuchNestedDocumentTypeError") {
    constructor() {
      super(...arguments);
      this.category = "MissingOrIncompatibleData";
      this.renderHeadline = ({ errorCount, skippingMessage }) => {
        return `Couldn't find nested document type definitions provided by name for ${errorCount} documents.${skippingMessage}`;
      };
      this.renderLine = () => {
        const validTypeNames = this.validNestedTypeNames.join(", ");
        return `${this.documentFilePath} (Used type name "${this.nestedTypeName}" for field "${this.fieldName}". Please use one of the following nested document type names: ${validTypeNames}`;
      };
    }
  }
  FetchDataError2.NoSuchNestedDocumentTypeError = NoSuchNestedDocumentTypeError;
  class MissingRequiredFieldsError extends Tagged("MissingRequiredFieldsError") {
    constructor() {
      super(...arguments);
      this.category = "MissingOrIncompatibleData";
      this.renderHeadline = ({ errorCount, skippingMessage }) => `Missing required fields for ${errorCount} documents.${skippingMessage}`;
      this.renderLine = () => {
        const misingRequiredFieldsStr = this.fieldDefsWithMissingData.map((fieldDef) => `  \u2022 ${fieldDef.name}: ${fieldDef.type}`).join("\n");
        return `"${this.documentFilePath}" (of type "${this.documentTypeDef.name}") is missing the following required fields:
${misingRequiredFieldsStr}`;
      };
    }
  }
  FetchDataError2.MissingRequiredFieldsError = MissingRequiredFieldsError;
  class ExtraFieldDataError extends Tagged("ExtraFieldDataError") {
    constructor() {
      super(...arguments);
      this.category = "ExtraFieldData";
      this.renderHeadline = ({ errorCount, skippingMessage }) => `  ${errorCount} documents contain field data which isn't defined in the document type definition.${skippingMessage}`;
      this.renderLine = () => {
        const extraFields = this.extraFieldEntries.map(([key, value]) => `  \u2022 ${key}: ${JSON.stringify(value)}`).join("\n");
        return `"${this.documentFilePath}" of type "${this.documentTypeDef.name}" has the following extra fields:
${extraFields} `;
      };
    }
  }
  FetchDataError2.ExtraFieldDataError = ExtraFieldDataError;
  class ReferencedFileDoesNotExistError extends Tagged("ReferencedFileDoesNotExistError") {
    constructor() {
      super(...arguments);
      this.category = "MissingOrIncompatibleData";
      this.renderHeadline = ({ errorCount, contentDirPath, skippingMessage }) => `${errorCount} documents contain file references which don't exist.${skippingMessage}

File paths have to be relative to \`contentDirPath\`: "${contentDirPath}")`;
      this.renderLine = () => {
        return `"${this.documentFilePath}" of type "${this.documentTypeDef.name}" with field "${this.fieldName}" references the file "${this.referencedFilePath}" which doesn't exist.`;
      };
    }
  }
  FetchDataError2.ReferencedFileDoesNotExistError = ReferencedFileDoesNotExistError;
  class IncompatibleFieldDataError extends Tagged("IncompatibleFieldDataError") {
    constructor() {
      super(...arguments);
      this.category = "MissingOrIncompatibleData";
      this.renderHeadline = ({ errorCount, skippingMessage }) => `${errorCount} documents contain field data which didn't match the structure defined in the document type definition.${skippingMessage}`;
      this.renderLine = () => {
        const incompatibleFields = this.incompatibleFieldData.map(([key, value]) => `  \u2022 ${key}: ${JSON.stringify(value)}`).join("\n");
        return `"${this.documentFilePath}" of type "${this.documentTypeDef.name}" has the following incompatible fields:
${incompatibleFields} `;
      };
    }
  }
  IncompatibleFieldDataError.fail = ({ incompatibleFieldData }) => pipe(getDocumentContext, Effect_exports3.chain((documentContext) => Effect_exports3.fail(new FetchDataError2.IncompatibleFieldDataError({
    documentFilePath: documentContext.relativeFilePath,
    documentTypeDef: documentContext.documentTypeDef,
    incompatibleFieldData
  }))));
  FetchDataError2.IncompatibleFieldDataError = IncompatibleFieldDataError;
  class SingletonDocumentNotFoundError extends Tagged("SingletonDocumentNotFoundError") {
    constructor() {
      super(...arguments);
      this.category = "SingletonDocumentNotFound";
      this.renderHeadline = ({ errorCount }) => `Couldn't find a document for ${errorCount} singleton document types`;
      this.renderLine = () => {
        const filePathInfo = this.filePath ? ` at provided file path "${this.filePath}"` : ``;
        return `Couldn't find a document for document type "${this.documentTypeDef.name}"${filePathInfo}`;
      };
    }
  }
  FetchDataError2.SingletonDocumentNotFoundError = SingletonDocumentNotFoundError;
  class UnexpectedError extends Tagged("UnexpectedError") {
    constructor() {
      super(...arguments);
      this.category = "Unexpected";
      this.documentTypeDef = void 0;
      this.renderHeadline = ({ errorCount }) => `Encountered unexpected errors while processing of ${errorCount} documents. This is possibly a bug in Contentlayer. Please open an issue.`;
      this.renderLine = () => `"${this.documentFilePath}": ${errorToString(this.error)}`;
    }
  }
  FetchDataError2.UnexpectedError = UnexpectedError;
})(FetchDataError || (FetchDataError = {}));
var DuplicateBodyFieldError = class extends Tagged("DuplicateBodyFieldError") {
  constructor() {
    super(...arguments);
    this.toString = () => `You cannot override the "${this.bodyFieldName}" field in a document definition.`;
  }
};

// node_modules/@contentlayer2/source-files/dist/fetchData/DocumentTypeMap.js
var DocumentTypeMap = class _DocumentTypeMap extends Tagged("@local/DocumentTypeMap") {
  constructor() {
    super(...arguments);
    this.add = (documentTypeName, filePath) => {
      const oldPaths = pipe(HashMap_exports2.get_(this.map, documentTypeName), Option_exports3.getOrElse(() => []));
      return new _DocumentTypeMap({
        map: HashMap_exports2.set_(this.map, documentTypeName, [...oldPaths, filePath])
      });
    };
    this.getFilePaths = (documentTypeName) => HashMap_exports2.get_(this.map, documentTypeName);
  }
};
DocumentTypeMap.init = () => new DocumentTypeMap({ map: HashMap_exports2.make() });
var DocumentTypeMapState = State_exports.State(DocumentTypeMap._tag);
var provideDocumentTypeMapState = Effect_exports3.provideSomeLayer(DocumentTypeMapState.Live(DocumentTypeMap.init()));

// node_modules/@contentlayer2/source-files/dist/fetchData/fetchAllDocuments.js
import * as os2 from "node:os";
import glob from "fast-glob";

// node_modules/@contentlayer2/source-files/dist/fetchData/makeCacheItemFromFilePath.js
import matter from "gray-matter";
import yaml from "yaml";

// node_modules/@contentlayer2/source-files/dist/fetchData/validateDocumentData.js
import micromatch from "micromatch";
var validateDocumentData = ({ coreSchemaDef, rawContent, relativeFilePath, filePathPatternMap, options, contentDirPath, contentTypeMap }) => pipe(Effect_exports3.gen(function* ($2) {
  const documentDefName = getDocumentDefName({ rawContent, filePathPatternMap, relativeFilePath, options });
  yield* $2(OT_exports.addAttribute("documentDefName", documentDefName));
  if (documentDefName === void 0) {
    const typeFieldName = options.fieldOptions.typeFieldName;
    return These_exports.fail(new FetchDataError.CouldNotDetermineDocumentTypeError({ documentFilePath: relativeFilePath, typeFieldName }));
  }
  const documentTypeDef = coreSchemaDef.documentTypeDefMap[documentDefName];
  if (documentTypeDef === void 0) {
    return These_exports.fail(new FetchDataError.NoSuchDocumentTypeError({
      documentTypeName: documentDefName,
      documentFilePath: relativeFilePath
    }));
  }
  const contentType = contentTypeMap[documentTypeDef.name];
  const mismatchError = validateContentTypeMatchesFileExtension({ contentType, relativeFilePath });
  if (mismatchError)
    return These_exports.fail(mismatchError);
  yield* $2(DocumentTypeMapState.update((_2) => _2.add(documentDefName, relativeFilePath)));
  const requiredFieldError = validateRequiredFieldValues({
    rawFieldValues: rawContent.fields,
    documentFilePath: relativeFilePath,
    documentTypeDef,
    fieldDefs: documentTypeDef.fieldDefs
  });
  if (Option_exports3.isSome(requiredFieldError)) {
    return These_exports.fail(requiredFieldError.value);
  }
  const warningOption = validateExtraFieldValues({
    fieldDefs: documentTypeDef.fieldDefs,
    rawFieldValues: rawContent.fields,
    options,
    documentTypeDef,
    documentFilePath: relativeFilePath
  });
  for (const fieldDef of documentTypeDef.fieldDefs) {
    const fieldValidOption = yield* $2(validateFieldData({
      documentFilePath: relativeFilePath,
      documentTypeDef,
      fieldDef,
      coreSchemaDef,
      rawFieldData: rawContent.fields[fieldDef.name],
      contentDirPath
    }));
    if (Option_exports3.isSome(fieldValidOption)) {
      return These_exports.fail(fieldValidOption.value);
    }
  }
  return These_exports.warnOption({ documentTypeDef }, warningOption);
}), OT_exports.withSpan("validateDocumentData", { attributes: { relativeFilePath } }));
var getDocumentDefName = ({ rawContent, relativeFilePath, filePathPatternMap, options }) => {
  const typeFieldName = options.fieldOptions.typeFieldName;
  const typeFieldValue = rawContent.fields[typeFieldName];
  if (typeFieldValue !== void 0) {
    return typeFieldValue;
  }
  return getDocumentDefNameByFilePathPattern({ filePathPatternMap, relativeFilePath });
};
var getDocumentDefNameByFilePathPattern = ({ relativeFilePath, filePathPatternMap }) => {
  const matchingFilePathPattern = Object.keys(filePathPatternMap).find((filePathPattern) => micromatch.isMatch(relativeFilePath, filePathPattern, {}));
  if (matchingFilePathPattern) {
    return filePathPatternMap[matchingFilePathPattern];
  }
  return void 0;
};
var validateFieldData = ({ fieldDef, rawFieldData, documentFilePath, coreSchemaDef, documentTypeDef, contentDirPath }) => Effect_exports3.gen(function* ($2) {
  const dataIsNil = rawFieldData === void 0 || rawFieldData === null;
  if (dataIsNil && fieldDef.isRequired === false) {
    return Option_exports3.none;
  }
  switch (fieldDef.type) {
    case "list":
      return Array.isArray(rawFieldData) ? Option_exports3.none : Option_exports3.some(new FetchDataError.IncompatibleFieldDataError({
        incompatibleFieldData: [[fieldDef.name, rawFieldData]],
        documentFilePath,
        documentTypeDef
      }));
    case "reference":
      if (typeof rawFieldData === "string") {
        const fullFilePath = filePathJoin(contentDirPath, rawFieldData);
        const fileExists = yield* $2(fs_exports.fileOrDirExists(fullFilePath));
        if (!fileExists) {
          return Option_exports3.some(new FetchDataError.ReferencedFileDoesNotExistError({
            referencedFilePath: rawFieldData,
            fieldName: fieldDef.name,
            documentFilePath,
            documentTypeDef
          }));
        }
      }
      return Option_exports3.none;
    case "nested_unnamed":
    case "nested": {
      const nestedFieldDefs = fieldDef.type === "nested_unnamed" ? fieldDef.typeDef.fieldDefs : coreSchemaDef.nestedTypeDefMap[fieldDef.nestedTypeName].fieldDefs;
      const nestedFieldError = validateRequiredFieldValues({
        documentFilePath,
        documentTypeDef,
        fieldDefs: nestedFieldDefs,
        rawFieldValues: rawFieldData
      });
      if (Option_exports3.isSome(nestedFieldError))
        return nestedFieldError;
      for (const fieldDef2 of nestedFieldDefs) {
        const fieldValidOption = yield* $2(validateFieldData({
          documentFilePath,
          documentTypeDef,
          coreSchemaDef,
          fieldDef: fieldDef2,
          rawFieldData: rawFieldData[fieldDef2.name],
          contentDirPath
        }));
        if (Option_exports3.isSome(fieldValidOption)) {
          return fieldValidOption;
        }
      }
      return Option_exports3.none;
    }
    case "nested_polymorphic":
    default:
      return Option_exports3.none;
  }
})["|>"](Effect_exports3.orDie);
var validateRequiredFieldValues = ({ rawFieldValues, fieldDefs, documentTypeDef, documentFilePath }) => {
  const existingDataFieldKeys = Object.keys(rawFieldValues);
  const requiredFieldsWithoutDefaultValue = fieldDefs.filter((_2) => _2.isRequired && _2.default === void 0 && _2.isSystemField === false);
  const misingRequiredFieldDefs = requiredFieldsWithoutDefaultValue.filter((fieldDef) => !existingDataFieldKeys.includes(fieldDef.name));
  if (misingRequiredFieldDefs.length > 0) {
    return Option_exports3.some(new FetchDataError.MissingRequiredFieldsError({
      documentFilePath,
      documentTypeDef,
      fieldDefsWithMissingData: misingRequiredFieldDefs
    }));
  }
  return Option_exports3.none;
};
var validateExtraFieldValues = ({ rawFieldValues, fieldDefs, options, documentTypeDef, documentFilePath }) => {
  const existingDataFieldKeys = Object.keys(rawFieldValues);
  const typeFieldName = options.fieldOptions.typeFieldName;
  const schemaFieldNames = fieldDefs.map((_2) => _2.name).concat([typeFieldName]);
  const extraFieldEntries = existingDataFieldKeys.filter((fieldKey) => !schemaFieldNames.includes(fieldKey)).map((fieldKey) => [fieldKey, rawFieldValues[fieldKey]]);
  if (extraFieldEntries.length > 0) {
    return Option_exports3.some(new FetchDataError.ExtraFieldDataError({
      documentFilePath,
      extraFieldEntries,
      documentTypeDef
    }));
  }
  return Option_exports3.none;
};
var validateContentTypeMatchesFileExtension = ({ contentType, relativeFilePath }) => {
  const extension = relativeFilePath.toLowerCase().split(".").pop();
  const validMarkdownExtensions = ["md", "mdx"];
  const isInvalidMarkdownOrMdx = (contentType === "markdown" || contentType === "mdx") && validMarkdownExtensions.includes(extension) === false;
  const validDataExtensions = ["json", "yaml", "yml"];
  const isInvalidData = contentType === "data" && validDataExtensions.includes(extension) === false;
  if (isInvalidMarkdownOrMdx || isInvalidData) {
    return new FetchDataError.FileExtensionMismatch({ contentType, extension, filePath: relativeFilePath });
  }
  return void 0;
};

// node_modules/@contentlayer2/source-files/dist/fetchData/makeCacheItemFromFilePath.js
var makeCacheItemFromFilePath = ({ relativeFilePath, filePathPatternMap, coreSchemaDef, contentDirPath, options, previousCache, contentTypeMap }) => pipe(Effect_exports3.gen(function* ($2) {
  const fullFilePath = filePathJoin(contentDirPath, relativeFilePath);
  const documentHash = yield* $2(pipe(fs_exports.stat(fullFilePath), Effect_exports3.map((_2) => _2.mtime.getTime().toString())));
  if (previousCache && previousCache.cacheItemsMap[relativeFilePath] && previousCache.cacheItemsMap[relativeFilePath].documentHash === documentHash && previousCache.cacheItemsMap[relativeFilePath].hasWarnings === false) {
    const cacheItem = previousCache.cacheItemsMap[relativeFilePath];
    yield* $2(DocumentTypeMapState.update((_2) => _2.add(cacheItem.documentTypeName, relativeFilePath)));
    return These_exports.succeed(cacheItem);
  }
  const rawContent = yield* $2(processRawContent({ fullFilePath, relativeFilePath }));
  const [{ documentTypeDef }, warnings] = yield* $2(pipe(validateDocumentData({
    rawContent,
    relativeFilePath,
    coreSchemaDef,
    filePathPatternMap,
    options,
    contentDirPath,
    contentTypeMap
  }), Effect_exports3.chain(These_exports.toEffect), Effect_exports3.map((_2) => _2.tuple)));
  const document = yield* $2(pipe(makeDocument({
    documentTypeDef,
    rawContent,
    coreSchemaDef,
    relativeFilePath,
    contentDirPath,
    options
  }), makeAndProvideDocumentContext({ rawContent, relativeFilePath, documentTypeDef })));
  const computedValues = yield* $2(getComputedValues({ documentTypeDef, document, documentFilePath: relativeFilePath }));
  if (computedValues) {
    Object.entries(computedValues).forEach(([fieldName, value]) => {
      document[fieldName] = value;
    });
  }
  return These_exports.warnOption({ document, documentHash, hasWarnings: Option_exports3.isSome(warnings), documentTypeName: documentTypeDef.name }, warnings);
}), OT_exports.withSpan("@contentlayer2/source-local/fetchData:makeCacheItemFromFilePath", {
  attributes: { relativeFilePath }
}), Effect_exports3.mapError((error) => {
  switch (error._tag) {
    case "fs.StatError":
    case "fs.ReadFileError":
    case "fs.FileNotFoundError":
      return new FetchDataError.UnexpectedError({ error, documentFilePath: relativeFilePath });
    default:
      return error;
  }
}), These_exports.effectThese);
var processRawContent = ({ fullFilePath, relativeFilePath }) => pipe(Effect_exports3.gen(function* ($2) {
  const fileContent = yield* $2(fs_exports.readFile(fullFilePath));
  const filePathExtension = relativeFilePath.toLowerCase().split(".").pop();
  switch (filePathExtension) {
    case "md": {
      const markdown = yield* $2(parseMarkdown({ markdownString: fileContent, documentFilePath: relativeFilePath }));
      return identity({
        kind: "markdown",
        fields: markdown.data,
        body: markdown.content,
        rawDocumentContent: fileContent
      });
    }
    case "mdx": {
      const markdown = yield* $2(parseMarkdown({ markdownString: fileContent, documentFilePath: relativeFilePath }));
      return identity({
        kind: "mdx",
        fields: markdown.data,
        body: markdown.content,
        rawDocumentContent: fileContent
      });
    }
    case "json": {
      const fields = yield* $2(parseJson({ jsonString: fileContent, documentFilePath: relativeFilePath }));
      return identity({ kind: "json", fields });
    }
    case "yaml":
    case "yml": {
      const fields = yield* $2(parseYaml({ yamlString: fileContent, documentFilePath: relativeFilePath }));
      return identity({ kind: "yaml", fields });
    }
    default:
      return yield* $2(Effect_exports3.fail(new FetchDataError.UnsupportedFileExtension({ extension: filePathExtension, filePath: relativeFilePath })));
  }
}), OT_exports.withSpan("@contentlayer2/source-local/fetchData:getRawContent"));
var getComputedValues = ({ document, documentTypeDef, documentFilePath }) => {
  if (documentTypeDef.computedFields === void 0) {
    return Effect_exports3.succeed(void 0);
  }
  return pipe(documentTypeDef.computedFields, Effect_exports3.forEachParDict({
    mapKey: (field) => Effect_exports3.succeed(field.name),
    mapValue: (field) => Effect_exports3.tryCatchPromise(async () => field.resolve(document), (error) => new FetchDataError.ComputedValueError({ error, documentFilePath, documentTypeDef }))
  }));
};
var parseMarkdown = ({ markdownString, documentFilePath }) => Effect_exports3.tryCatch(() => matter(markdownString, {
  engines: {
    // Provide custom YAML engine to avoid parsing of date values https://github.com/jonschlinkert/gray-matter/issues/62)
    yaml: (str) => yaml.parse(str)
  }
}), (error) => {
  if (error.name === "YAMLException") {
    return new FetchDataError.InvalidFrontmatterError({ error, documentFilePath });
  } else {
    return new FetchDataError.InvalidMarkdownFileError({ error, documentFilePath });
  }
});
var parseJson = ({ jsonString, documentFilePath }) => Effect_exports3.tryCatch(() => JSON.parse(jsonString), (error) => new FetchDataError.InvalidJsonFileError({ error, documentFilePath }));
var parseYaml = ({ yamlString, documentFilePath }) => Effect_exports3.tryCatch(() => yaml.parse(yamlString) ?? {}, (error) => new FetchDataError.InvalidYamlFileError({ error, documentFilePath }));

// node_modules/@contentlayer2/source-files/dist/fetchData/fetchAllDocuments.js
var fetchAllDocuments = ({ coreSchemaDef, filePathPatternMap, contentDirPath, contentDirInclude, contentDirExclude, contentTypeMap, flags, options, previousCache, verbose }) => pipe(Effect_exports3.gen(function* ($2) {
  const allRelativeFilePaths = yield* $2(getAllRelativeFilePaths({ contentDirPath, contentDirInclude, contentDirExclude }));
  const concurrencyLimit = os2.cpus().length;
  const { dataErrors, documents } = yield* $2(pipe(allRelativeFilePaths, Effect_exports3.forEachParN(concurrencyLimit, (relativeFilePath) => makeCacheItemFromFilePath({
    relativeFilePath,
    filePathPatternMap,
    coreSchemaDef,
    contentDirPath,
    options,
    previousCache,
    contentTypeMap
  })), Effect_exports3.map(Chunk_exports3.partitionThese), Effect_exports3.map(({ tuple: [errors, docs] }) => ({ dataErrors: Chunk_exports3.toArray(errors), documents: Chunk_exports3.toArray(docs) }))));
  const singletonDataErrors = yield* $2(validateSingletonDocuments({ coreSchemaDef, filePathPatternMap }));
  yield* $2(FetchDataError.handleErrors({
    errors: [...dataErrors, ...singletonDataErrors],
    documentCount: allRelativeFilePaths.length,
    flags,
    options,
    schemaDef: coreSchemaDef,
    contentDirPath,
    verbose
  }));
  const cacheItemsMap = Object.fromEntries(documents.map((_2) => [_2.document._id, _2]));
  return { cacheItemsMap };
}), provideDocumentTypeMapState, OT_exports.withSpan("@contentlayer2/source-local/fetchData:fetchAllDocuments", { attributes: { contentDirPath } }));
var getAllRelativeFilePaths = ({ contentDirPath, contentDirInclude, contentDirExclude }) => {
  const getPatternPrefix = (paths_) => {
    const paths = paths_.map((_2) => _2.trim()).filter((_2) => _2 !== "." && _2 !== "./").map((_2) => _2.endsWith("/") ? _2 : `${_2}/`);
    if (paths.length === 0)
      return "";
    if (paths.length === 1)
      return paths[0];
    return `{${paths.join(",")}}`;
  };
  const filePathPattern = "{,**/}*.{md,mdx,json,yaml,yml}";
  const pattern3 = `${getPatternPrefix(contentDirInclude)}${filePathPattern}`;
  return pipe(Effect_exports3.tryCatchPromise(() => glob(pattern3, { cwd: contentDirPath, ignore: asMutableArray(contentDirExclude) }), (error) => new fs_exports.UnknownFSError({ error })), Effect_exports3.map((_2) => _2.map(relativePosixFilePath)), OT_exports.withSpan("@contentlayer2/source-local/fetchData:getAllRelativeFilePaths"));
};
var validateSingletonDocuments = ({ coreSchemaDef, filePathPatternMap }) => Effect_exports3.gen(function* ($2) {
  const singletonDocumentDefs = Object.values(coreSchemaDef.documentTypeDefMap).filter((documentTypeDef) => documentTypeDef.isSingleton);
  const documentTypeMap = yield* $2(DocumentTypeMapState.get);
  const invertedFilePathPattnernMap = invertRecord(filePathPatternMap);
  return singletonDocumentDefs.filter((documentTypeDef) => pipe(documentTypeMap.getFilePaths(documentTypeDef.name), Option_exports3.map((_2) => _2.length), Option_exports3.getOrElse(() => 0)) !== 1).map((documentTypeDef) => new FetchDataError.SingletonDocumentNotFoundError({
    documentTypeDef,
    filePath: invertedFilePathPattnernMap[documentTypeDef.name]
  }));
});
var invertRecord = (record2) => pipe(Object.entries(record2), (entries) => entries.map(([key, value]) => [value, key]), Object.fromEntries);

// node_modules/@contentlayer2/source-files/dist/fetchData/index.js
var fetchData = ({ coreSchemaDef, documentTypeDefs, flags, options, contentDirPath, contentDirInclude, contentDirExclude, skipCachePersistence = false, verbose }) => {
  const filePathPatternMap = makefilePathPatternMap(documentTypeDefs);
  const contentTypeMap = makeContentTypeMap(documentTypeDefs);
  const initEvent = { _tag: "init" };
  const watchPaths = contentDirInclude.length > 0 ? contentDirInclude : ["."];
  const fileUpdatesStream = pipe(fs_watcher_exports.makeAndSubscribe(watchPaths, {
    cwd: contentDirPath,
    ignoreInitial: true,
    ignored: contentDirExclude,
    // NOTE type cast needed because of readonly array
    // Unfortunately needed in order to avoid race conditions
    awaitWriteFinish: { stabilityThreshold: 50, pollInterval: 10 }
  }), Stream_exports.mapEitherRight(chokidarAllEventToCustomUpdateEvent));
  const resolveParams = pipe(skipCachePersistence ? Effect_exports3.succeed(void 0) : DataCache.loadPreviousCacheFromDisk({ schemaHash: coreSchemaDef.hash }), Effect_exports3.either);
  return pipe(Stream_exports.fromEffect(resolveParams), Stream_exports.chainSwitchMapEitherRight((cache) => pipe(
    fileUpdatesStream,
    Stream_exports.tapRight((e2) => Effect_exports3.succeedWith(() => (e2._tag === "updated" || e2._tag === "deleted") && console.log(`
File ${e2._tag}: ${e2.relativeFilePath}`))),
    Stream_exports.startWithRight(initEvent),
    Stream_exports.mapEffectEitherRight((event) => pipe(event, Effect_exports3.matchTag({
      init: () => fetchAllDocuments({
        coreSchemaDef,
        filePathPatternMap,
        contentDirPath,
        contentDirInclude,
        contentDirExclude,
        flags,
        options,
        previousCache: cache,
        verbose,
        contentTypeMap
      }),
      deleted: (event2) => Effect_exports3.succeedWith(() => {
        delete cache.cacheItemsMap[event2.relativeFilePath];
        return cache;
      }),
      updated: (event2) => updateCacheEntry({
        contentDirPath,
        filePathPatternMap,
        cache,
        event: event2,
        flags,
        coreSchemaDef,
        options,
        contentTypeMap
      })
    }), Effect_exports3.either)),
    // update local and persisted cache
    Stream_exports.tapRight((cache_) => Effect_exports3.succeedWith(() => cache = cache_)),
    Stream_exports.tapRightEither((cache_) => skipCachePersistence ? Effect_exports3.unit : DataCache.writeCacheToDisk({ cache: cache_, schemaHash: coreSchemaDef.hash }))
  )), Stream_exports.mapEitherRight((cache) => embedReferences({ cache, coreSchemaDef })), Stream_exports.mapEitherLeft((error) => new SourceFetchDataError({ error, alreadyHandled: error._tag === "HandledFetchDataError" })));
};
var makefilePathPatternMap = (documentTypeDefs) => Object.fromEntries(documentTypeDefs.filter((_2) => _2.filePathPattern).map((documentDef) => [documentDef.filePathPattern, documentDef.name]));
var makeContentTypeMap = (documentTypeDefs) => Object.fromEntries(documentTypeDefs.filter((_2) => _2.filePathPattern).map((documentDef) => [documentDef.name, documentDef.contentType]));
var updateCacheEntry = ({ contentDirPath, filePathPatternMap, cache, event, flags, coreSchemaDef, options, contentTypeMap }) => Effect_exports3.gen(function* ($2) {
  yield* $2(pipe(
    makeCacheItemFromFilePath({
      relativeFilePath: event.relativeFilePath,
      contentDirPath,
      filePathPatternMap,
      coreSchemaDef,
      options,
      previousCache: cache,
      contentTypeMap
    }),
    // NOTE in this code path the DocumentTypeMapState is not used
    provideDocumentTypeMapState,
    These_exports.effectTapSuccess((cacheItem) => Effect_exports3.succeedWith(() => {
      cache.cacheItemsMap[event.relativeFilePath] = cacheItem;
    })),
    These_exports.effectTapErrorOrWarning((errorOrWarning) => FetchDataError.handleErrors({
      errors: [errorOrWarning],
      documentCount: 1,
      flags,
      options,
      schemaDef: coreSchemaDef,
      verbose: false,
      contentDirPath
    }))
  ));
  return cache;
});
var chokidarAllEventToCustomUpdateEvent = (event) => {
  switch (event._tag) {
    case "FileAdded":
    case "FileChanged":
      return { _tag: "updated", relativeFilePath: unknownToRelativePosixFilePath(event.path) };
    case "FileRemoved":
      return { _tag: "deleted", relativeFilePath: unknownToRelativePosixFilePath(event.path) };
    case "DirectoryRemoved":
    case "DirectoryAdded":
      return { _tag: "init" };
    default:
      casesHandled(event);
  }
};
var embedReferences = ({ cache, coreSchemaDef }) => {
  const documentDefs = Object.values(coreSchemaDef.documentTypeDefMap);
  const nestedDefs = Object.values(coreSchemaDef.nestedTypeDefMap);
  const defs = [...documentDefs, ...nestedDefs];
  const defsWithEmbeddedRefs = defs.filter((_2) => _2.fieldDefs.some((_3) => isReferenceField(_3) && _3.embedDocument));
  const defsWithEmbeddedListRefs = defs.filter((_2) => _2.fieldDefs.some((_3) => isListFieldDef(_3) && _3.of.type === "reference" && _3.of.embedDocument));
  const defNameSetWithEmbeddedRefs = /* @__PURE__ */ new Set([
    ...defsWithEmbeddedRefs.map((_2) => _2.name),
    ...defsWithEmbeddedListRefs.map((_2) => _2.name)
  ]);
  if (defsWithEmbeddedRefs.length > 0) {
    for (const cacheItem of Object.values(cache.cacheItemsMap)) {
      if (!defNameSetWithEmbeddedRefs.has(cacheItem.documentTypeName))
        continue;
      const documentDef = coreSchemaDef.documentTypeDefMap[cacheItem.documentTypeName];
      const fieldDefsWithEmbeddedRefs = documentDef.fieldDefs.filter((_2) => isReferenceField(_2) && _2.embedDocument);
      for (const fieldDef of fieldDefsWithEmbeddedRefs) {
        const referenceId = cacheItem.document[fieldDef.name];
        if (referenceId === void 0 || referenceId === null)
          continue;
        const referenceAlreadyEmbedded = typeof referenceId !== "string";
        if (referenceAlreadyEmbedded)
          continue;
        const referencedDocument = cache.cacheItemsMap[referenceId].document;
        cacheItem.document[fieldDef.name] = referencedDocument;
      }
      const listFieldDefs = documentDef.fieldDefs.filter(isListFieldDef);
      for (const listFieldDef of listFieldDefs) {
        if (ListFieldDefItem.isDefItemReference(listFieldDef.of) && listFieldDef.of.embedDocument) {
          const listValues = cacheItem.document[listFieldDef.name];
          if (listValues === void 0 || listValues === null || !Array.isArray(listValues))
            continue;
          for (const [index, listValue] of listValues.entries()) {
            const referenceAlreadyEmbedded = typeof listValue !== "string";
            if (referenceAlreadyEmbedded)
              continue;
            const referencedDocument = cache.cacheItemsMap[listValue].document;
            cacheItem.document[listFieldDef.name][index] = referencedDocument;
          }
        }
      }
    }
  }
  return cache;
};

// node_modules/@contentlayer2/source-files/dist/schema/defs/field.js
var isListPolymorphicFieldDef = (_2) => _2.type === "list" && Array.isArray(_2.of);
var ListFieldDefItem2;
(function(ListFieldDefItem3) {
  ListFieldDefItem3.isDefItemNested = (_2) => _2.type === "nested";
})(ListFieldDefItem2 || (ListFieldDefItem2 = {}));
var isNestedPolymorphicFieldDef = (_2) => _2.type === "nested" && Array.isArray(_2.of);
var isReferencePolymorphicFieldDef = (_2) => _2.type === "reference" && Array.isArray(_2.of);

// node_modules/@contentlayer2/source-files/dist/schema/defs/index.js
var isNestedTypeDef = (_2) => _2.hasOwnProperty("name");
var isNestedUnnamedTypeDef = (_2) => !_2.hasOwnProperty("name");
var defineDocumentType = (def) => ({
  type: "document",
  def
});

// node_modules/@contentlayer2/source-files/dist/schema/provideSchema.js
var makeCoreSchema = ({ documentTypeDefs, options, esbuildHash }) => Effect_exports3.gen(function* ($2) {
  const coreDocumentTypeDefMap = {};
  const coreNestedTypeDefMap = {};
  for (const documentDef of documentTypeDefs) {
    validateDefName({ defName: documentDef.name });
    const fieldDefs = getFieldDefEntries(documentDef.fields ?? []).map((_2) => fieldDefEntryToCoreFieldDef(_2, options.fieldOptions));
    if (fieldDefs.some((_2) => _2.name === options.fieldOptions.bodyFieldName)) {
      yield* $2(Effect_exports3.fail(new DuplicateBodyFieldError({ bodyFieldName: options.fieldOptions.bodyFieldName })));
    }
    if (documentDef.contentType === void 0 || documentDef.contentType === "markdown") {
      fieldDefs.push({
        type: "markdown",
        name: options.fieldOptions.bodyFieldName,
        description: "Markdown file body",
        default: void 0,
        isRequired: true,
        isSystemField: true
      });
    }
    if (documentDef.contentType === "mdx") {
      fieldDefs.push({
        type: "mdx",
        name: options.fieldOptions.bodyFieldName,
        description: "MDX file body",
        default: void 0,
        isRequired: true,
        isSystemField: true
      });
    }
    const computedFields = Object.entries(documentDef.computedFields ?? {}).map(([name, computedField]) => ({
      ...pick(computedField, ["description", "type"], false),
      name,
      // NOTE we need to flip the variance here (casting a core.Document to a LocalDocument)
      resolve: computedField.resolve
    }));
    const coreDocumentDef = {
      _tag: "DocumentTypeDef",
      ...pick(documentDef, ["name", "description"], false),
      isSingleton: documentDef.isSingleton ?? false,
      fieldDefs,
      computedFields,
      extensions: documentDef.extensions ?? {}
    };
    coreDocumentTypeDefMap[documentDef.name] = coreDocumentDef;
  }
  const nestedDefs = collectNestedDefs(documentTypeDefs);
  for (const nestedDef of nestedDefs) {
    validateDefName({ defName: nestedDef.name });
    const coreNestedTypeDef = {
      _tag: "NestedTypeDef",
      ...pick(nestedDef, ["description"], false),
      name: nestedDef.name,
      fieldDefs: getFieldDefEntries(nestedDef.fields ?? []).map((_2) => fieldDefEntryToCoreFieldDef(_2, options.fieldOptions)),
      extensions: nestedDef.extensions ?? {}
    };
    coreNestedTypeDefMap[coreNestedTypeDef.name] = coreNestedTypeDef;
  }
  const coreSchemaDef = {
    documentTypeDefMap: coreDocumentTypeDefMap,
    nestedTypeDefMap: coreNestedTypeDefMap,
    hash: esbuildHash
  };
  validateSchema(coreSchemaDef);
  return coreSchemaDef;
});
var validateDefName = ({ defName }) => {
  const firstChar = defName.charAt(0);
  if (firstChar.toLowerCase() === firstChar) {
    const improvedDefName = uppercaseFirstChar(defName);
    console.warn(`Warning: A document or nested definition name should start with a uppercase letter.
You've provided the name "${defName}" - please consider using "${improvedDefName}" instead.
`);
  }
};
var getFieldDefEntries = (fieldDefs) => {
  if (Array.isArray(fieldDefs)) {
    return fieldDefs.map((fieldDef) => [fieldDef.name, fieldDef]);
  } else {
    return Object.entries(fieldDefs);
  }
};
var getFieldDefValues = (fieldDefs) => {
  if (Array.isArray(fieldDefs)) {
    return fieldDefs;
  } else {
    return Object.values(fieldDefs);
  }
};
var fieldDefEntryToCoreFieldDef = ([name, fieldDef], fieldOptions) => {
  const baseFields = {
    ...pick(fieldDef, ["type", "default", "description"], false),
    name,
    isRequired: fieldDef.required ?? false,
    isSystemField: false
  };
  switch (fieldDef.type) {
    case "list":
      if (isListPolymorphicFieldDef(fieldDef)) {
        return identity({
          ...baseFields,
          type: "list_polymorphic",
          default: fieldDef.default,
          typeField: fieldDef.typeField ?? fieldOptions.typeFieldName,
          of: fieldDef.of.map((_2) => fieldListItemsToCoreFieldListDefItems(_2, fieldOptions))
        });
      }
      return identity({
        ...baseFields,
        type: "list",
        default: fieldDef.default,
        of: fieldListItemsToCoreFieldListDefItems(fieldDef.of, fieldOptions)
      });
    case "nested":
      if (isNestedPolymorphicFieldDef(fieldDef)) {
        const nestedTypeDefs = fieldDef.of.map((_2) => _2.def());
        const containsUnnamedTypeDef = nestedTypeDefs.some(isNestedUnnamedTypeDef);
        if (containsUnnamedTypeDef) {
          throw new Error(`Nested unnamed polymorphic type definitions are not yet supported.`);
        }
        const nestedTypeNames = nestedTypeDefs.map((_2) => _2.name);
        return identity({
          ...baseFields,
          type: "nested_polymorphic",
          default: fieldDef.default,
          nestedTypeNames,
          typeField: fieldDef.typeField ?? fieldOptions.typeFieldName
        });
      }
      const nestedTypeDef = fieldDef.of.def();
      if (isNestedTypeDef(nestedTypeDef)) {
        return identity({
          ...baseFields,
          type: "nested",
          default: fieldDef.default,
          nestedTypeName: nestedTypeDef.name
        });
      }
      const fieldDefs = getFieldDefEntries(nestedTypeDef.fields ?? []).map((_2) => fieldDefEntryToCoreFieldDef(_2, fieldOptions));
      const extensions = nestedTypeDef.extensions ?? {};
      const typeDef = { _tag: "NestedUnnamedTypeDef", fieldDefs, extensions };
      return identity({
        ...baseFields,
        type: "nested_unnamed",
        default: fieldDef.default,
        typeDef
      });
    case "reference":
      if (isReferencePolymorphicFieldDef(fieldDef)) {
        const documentTypeNames = fieldDef.of.map((_2) => _2.def().name);
        return identity({
          ...baseFields,
          type: "reference_polymorphic",
          default: fieldDef.default,
          documentTypeNames,
          typeField: fieldDef.typeField ?? fieldOptions.typeFieldName
        });
      }
      return identity({
        ...baseFields,
        type: "reference",
        default: fieldDef.default,
        documentTypeName: fieldDef.of.def().name,
        embedDocument: fieldDef.embedDocument ?? false
      });
    case "enum":
      return identity({
        ...baseFields,
        type: "enum",
        default: fieldDef.default,
        options: fieldDef.options
      });
    case "boolean":
    case "date":
    case "image":
    case "json":
    case "markdown":
    case "mdx":
    case "number":
    case "string":
      return {
        // needs to pick again since fieldDef.type has been
        ...pick(fieldDef, ["type", "default", "description"], false),
        isRequired: fieldDef.required ?? false,
        name,
        isSystemField: false
      };
    default:
      casesHandled(fieldDef);
  }
};
var fieldListItemsToCoreFieldListDefItems = (listFieldDefItem, fieldOptions) => {
  switch (listFieldDefItem.type) {
    case "boolean":
    case "string":
    case "number":
    case "date":
    case "json":
    case "markdown":
    case "mdx":
    case "image":
      return pick(listFieldDefItem, ["type"], false);
    case "enum":
      return {
        type: "enum",
        options: listFieldDefItem.options
      };
    case "nested":
      const nestedTypeDef = listFieldDefItem.def();
      if (isNestedTypeDef(nestedTypeDef)) {
        return { type: "nested", nestedTypeName: nestedTypeDef.name };
      }
      const fieldDefs = getFieldDefEntries(nestedTypeDef.fields ?? []).map((_2) => fieldDefEntryToCoreFieldDef(_2, fieldOptions));
      const extensions = nestedTypeDef.extensions ?? {};
      const typeDef = { _tag: "NestedUnnamedTypeDef", fieldDefs, extensions };
      return { type: "nested_unnamed", typeDef };
    case "document":
      return {
        type: "reference",
        documentTypeName: listFieldDefItem.def().name,
        embedDocument: listFieldDefItem.embedDocument ?? false
      };
    default:
      casesHandled(listFieldDefItem);
  }
};
var collectNestedDefs = (documentDefs) => {
  const objectDefMap = {};
  const traverseNestedDef = (objectDef) => {
    if (objectDef.name in objectDefMap) {
      return;
    }
    objectDefMap[objectDef.name] = objectDef;
    getFieldDefValues(objectDef.fields ?? []).forEach(traverseField);
  };
  const traverseField = (fieldDef) => {
    switch (fieldDef.type) {
      case "nested":
        if (isReadonlyArray(fieldDef.of)) {
          const nestedTypeDefs = fieldDef.of.map((_2) => _2.def());
          return nestedTypeDefs.forEach((nestedTypeDef2) => {
            if (isNestedTypeDef(nestedTypeDef2)) {
              return traverseNestedDef(nestedTypeDef2);
            }
            return getFieldDefValues(nestedTypeDef2.fields ?? []).forEach(traverseField);
          });
        }
        const nestedTypeDef = fieldDef.of.def();
        if (isNestedTypeDef(nestedTypeDef)) {
          return traverseNestedDef(nestedTypeDef);
        }
        return getFieldDefValues(nestedTypeDef.fields ?? []).forEach(traverseField);
      case "list":
        if (isListPolymorphicFieldDef(fieldDef)) {
          return fieldDef.of.forEach(traverseListFieldItem);
        }
        return traverseListFieldItem(fieldDef.of);
      case "image":
      case "boolean":
      case "date":
      case "enum":
      case "json":
      case "markdown":
      case "mdx":
      case "number":
      case "string":
      case "reference":
        return;
      default:
        casesHandled(fieldDef);
    }
  };
  const traverseListFieldItem = (listFieldDefItem) => {
    switch (listFieldDefItem.type) {
      case "nested":
        const nestedTypeDef = listFieldDefItem.def();
        if (isNestedUnnamedTypeDef(nestedTypeDef)) {
          return getFieldDefValues(nestedTypeDef.fields ?? []).forEach(traverseField);
        }
        return traverseNestedDef(nestedTypeDef);
    }
  };
  documentDefs.flatMap((_2) => getFieldDefValues(_2.fields ?? [])).forEach(traverseField);
  return Object.values(objectDefMap);
};

// node_modules/@contentlayer2/source-files/dist/index.js
var makeSource = (args) => async (sourceKey) => {
  const { options, extensions, restArgs: { documentTypes, contentDirPath: contentDirPath_, contentDirInclude: contentDirInclude_, contentDirExclude: contentDirExclude_, onUnknownDocuments = "skip-warn", onMissingOrIncompatibleData = "skip-warn", onExtraFieldData = "warn" } } = await processArgs(args, sourceKey);
  const flags = { onUnknownDocuments, onExtraFieldData, onMissingOrIncompatibleData };
  const documentTypeDefs = (Array.isArray(documentTypes) ? documentTypes : Object.values(documentTypes)).map((_2) => _2.def());
  return {
    type: "local",
    extensions: extensions ?? {},
    options,
    provideSchema: (esbuildHash) => pipe(makeCoreSchema({ documentTypeDefs, options, esbuildHash }), Effect_exports3.mapError((error) => new SourceProvideSchemaError({ error }))),
    fetchData: ({ schemaDef, verbose, skipCachePersistence }) => pipe(Stream_exports.fromEffect(getCwd), Stream_exports.chain((cwd) => {
      const contentDirPath = unknownToAbsolutePosixFilePath(contentDirPath_, cwd);
      const contentDirExclude = (contentDirExclude_ ?? contentDirExcludeDefault).map((_2) => unknownToRelativePosixFilePath(_2, contentDirPath));
      const contentDirInclude = (contentDirInclude_ ?? []).map((_2) => unknownToRelativePosixFilePath(_2, contentDirPath));
      return fetchData({
        coreSchemaDef: schemaDef,
        documentTypeDefs,
        flags,
        options,
        contentDirPath,
        contentDirExclude,
        contentDirInclude,
        verbose,
        skipCachePersistence
      });
    }))
  };
};
var contentDirExcludeDefault = ["node_modules", ".git", ".yarn", ".cache", ".next", ".contentlayer"];

// contentlayer.config.ts
import rehypePrettyCode from "rehype-pretty-code";
import rehypeSlug from "rehype-slug";
import { codeImport } from "remark-code-import";
import { visit } from "unist-util-visit";
var rehypePrettyCodeOptions = {
  // Use one of Shiki's packaged themes
  theme: "one-dark-pro",
  // Keep the background or use a custom background color
  keepBackground: false,
  // Prevent collapsing of single-line blocks
  grid: true,
  onVisitHighlightedLine(element) {
    element.properties.className?.push("highlighted");
  },
  onVisitHighlightedChars(element) {
    element.properties.className = ["word"];
  }
};
var Post = defineDocumentType(() => ({
  name: "Post",
  filePathPattern: "./articles/*.mdx",
  contentType: "mdx",
  fields: {
    title: {
      type: "string",
      description: "The title of the post",
      required: true
    },
    date: {
      type: "date",
      description: "The date of the post",
      required: true
    },
    excerpt: {
      type: "string",
      description: "The excerpt of the post",
      required: false
    }
  },
  computedFields: {
    url: {
      type: "string",
      resolve: (post) => `/${post._raw.flattenedPath}`
    },
    slug: {
      type: "string",
      resolve: (post) => post._raw.flattenedPath.replace("articles/", "")
    }
  }
}));
var Static = defineDocumentType(() => ({
  name: "Static",
  filePathPattern: "./data/*.mdx",
  contentType: "mdx",
  fields: {
    title: {
      type: "string",
      description: "The title of the post",
      required: true
    }
  },
  computedFields: {
    slug: {
      type: "string",
      resolve: (post) => post._raw.flattenedPath.replace("data/", "")
    }
  }
}));
var GENERATED_FILE_PATH = path8.resolve(".contentlayer/generated/index.mjs");
var contentlayer_config_default = makeSource({
  contentDirPath: "content",
  documentTypes: [Post, Static],
  mdx: {
    remarkPlugins: [codeImport],
    rehypePlugins: [
      () => (tree) => {
        visit(tree, (node) => {
          if (node?.type === "element" && node?.tagName === "pre") {
            const [codeEl] = node.children;
            if (codeEl.tagName !== "code") {
              return;
            }
            node.__rawString__ = codeEl.children?.[0].value;
            node.__src__ = node.properties?.__src__;
          }
        });
      },
      [rehypePrettyCode, rehypePrettyCodeOptions],
      () => (tree) => {
        visit(tree, (node) => {
          if (node?.type === "element" && node?.tagName === "figure") {
            if (!("data-rehype-pretty-code-figure" in node.properties)) {
              return;
            }
            const preElement = node.children.at(-1);
            if (preElement.tagName !== "pre") {
              return;
            }
            preElement.properties.__rawString__ = node.__rawString__;
            if (node.__src__) {
              preElement.properties.__src__ = node.__src__;
            }
          }
        });
      },
      rehypeSlug
    ]
  }
});
export {
  Post,
  Static,
  contentlayer_config_default as default
};
/*! Bundled license information:

@grpc/proto-loader/build/src/util.js:
  (**
   * @license
   * Copyright 2018 gRPC authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   *)

@grpc/proto-loader/build/src/index.js:
  (**
   * @license
   * Copyright 2018 gRPC authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   *)
*/
//# sourceMappingURL=compiled-contentlayer-config-U6VHCBKH.mjs.map
